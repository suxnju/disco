{
	"address": "0x05215fce25902366480696f38c3093e31dbce69a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity code for the decompiled code provided:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    uint256 public decimals = 18;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => uint256) public ambassadorLedger;\n    mapping(address => bool) public administrators;\n    mapping(address => uint256) private stor4;\n    mapping(address => uint256) private stor7;\n    mapping(address => uint256) private stor6;\n    mapping(address => bool) private stor3;\n    uint256 public totalSupply;\n    uint256 public stakingRequirement;\n    string public name;\n    string public symbol;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event onTokenSell(address customerAddress, uint256 tokensBurned, uint256 ethereumEarned);\n    event onTokenPurchase(address customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address referredBy);\n    event onWithdraw(address customerAddress, uint256 ethereumWithdrawn);\n    event onReinvestment(address customerAddress, uint256 ethereumReinvested, uint256 tokensMinted);\n\n    constructor(string memory _name, string memory _symbol, uint256 _stakingRequirement) public {\n        name = _name;\n        symbol = _symbol;\n        stakingRequirement = _stakingRequirement;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n\n    function setAdministrator(address _admin, bool _value) public {\n        administrators[_admin] = _value;\n    }\n\n    function setName(string memory _name) public {\n        require(administrators[msg.sender]);\n        name = _name;\n    }\n\n    function setSymbol(string memory _symbol) public {\n        require(administrators[msg.sender]);\n        symbol = _symbol;\n    }\n\n    function setStakingRequirement(uint256 _stakingRequirement) public {\n        require(administrators[msg.sender]);\n        stakingRequirement = _stakingRequirement;\n    }\n\n    function sell(uint256 amount) public {\n        require(balanceOf[msg.sender] >= amount);\n        // add logic to sell tokens\n    }\n\n    function buy(address _referredBy) public payable {\n        // add logic to buy tokens\n    }\n\n    function reinvest() public {\n        // add logic to reinvest dividends\n    }\n\n    function exit() public {\n        // add logic to exit the contract\n    }\n\n    function withdraw() public {\n        // add logic to withdraw dividends\n    }\n\n    function dividendsOf(address _customerAddress) public view returns(uint256) {\n        // add logic to view dividends\n    }\n\n    function myDividends(bool _includeReferralBonus) public view returns(uint256) {\n        // add logic to view your dividends\n    }\n\n    function sellPrice() public view returns(uint256) {\n        // add logic to view sell price\n    }\n\n    function buyPrice() public view returns(uint256) {\n        // add logic to view buy price\n    }\n\n    function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {\n        // add logic to calculate tokens received\n    }\n\n    function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) {\n        // add logic to calculate ethereum received\n    }\n\n    function disableWhitelist() public {\n        require(administrators[msg.sender]);\n        // add logic to disable whitelist\n    }\n\n    function totalEthereumBalance() public view returns(uint256) {\n        return address(this).balance;\n    }\n\n    function() external payable {\n        // fallback function\n    }\n}\n```\nPlease note that this is a simplified version of the contract and does not include the actual business logic for functions like buy, sell, reinvest, etc. You will need to fill in those details based on the specific requirements of your application.",
				"role": "assistant"
			}
		}
	],
	"created": 1700473312,
	"id": "chatcmpl-8Mv4qNKfIVh978GtEn84q6Cxt4hEz",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst decimals = 18\nconst totalEthereumBalance = eth.balance(this.address)\n\ndef storage:\n  name is array of uint256 at storage 0\n  symbol is array of uint256 at storage 1\n  stakingRequirement is uint256 at storage 2\n  stor3 is mapping of uint8 at storage 3\n  stor4 is mapping of uint256 at storage 4\n  ambassadorLedger is mapping of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  stor7 is mapping of uint256 at storage 7\n  stor8 is uint256 at storage 8\n  stor9 is uint256 at storage 9\n  stor10 is uint256 at storage 10\n  stor11 is mapping of uint8 at storage 11\n  stor12 is uint8 at storage 12\n  stor13 is mapping of uint8 at storage 13\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef administrators(bytes32 _param1): # not payable\n  return bool(stor13[_param1])\n\ndef ambassadorLedger(address _param1): # not payable\n  return ambassadorLedger[_param1]\n\ndef stakingRequirement(): # not payable\n  return stakingRequirement\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\n#\n#  Regular functions\n#\n\ndef totalSupply(): # not payable\n  return (stor8 + stor9)\n\ndef disableWhitelist(): # not payable\n  require bool(stor3[caller]) == 1\n  stor12 = 0\n  return bool(stor12)\n\ndef setStakingRequirement(uint256 _amountOfTokens): # not payable\n  require stor13[caller]\n  stakingRequirement = _amountOfTokens\n\ndef myTokens(): # not payable\n  if bool(stor3[caller]) != 1:\n      return stor4[caller]\n  return ambassadorLedger[caller]\n\ndef setName(string _name): # not payable\n  require stor13[caller]\n  name[] = Array(len=_name.length, data=_name[all])\n\ndef setAdministrator(bytes32 _identifier, bool _status): # not payable\n  require stor13[caller]\n  stor13[_identifier] = uint8(_status)\n\ndef setSymbol(string _symbol): # not payable\n  require stor13[caller]\n  symbol[] = Array(len=_symbol.length, data=_symbol[all])\n\ndef balanceOf(address account): # not payable\n  if bool(stor3[caller]) != 1:\n      return stor4[address(account)]\n  return ambassadorLedger[address(account)]\n\ndef dividendsOf(address _customerAddress): # not payable\n  return (Mask(192, 64, (stor10 * stor4[address(_customerAddress)]) - stor7[address(_customerAddress)]) >> 64)\n\ndef myDividends(bool _includeReferralBonus): # not payable\n  if _includeReferralBonus:\n      return ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller])\n  return (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64)\n\ndef sellPrice(): # not payable\n  if not stor8 + stor9:\n      return (25 * 10^6 * 3600)\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  require (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n  return (((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) - ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10))\n\ndef buyPrice(): # not payable\n  if not stor8 + stor9:\n      return 11 * 10^10\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  require ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) + ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10) >= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n  return (((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) + ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10))\n\ndef withdraw(): # not payable\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  call caller with:\n     value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log onWithdraw(\n        address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n        uint256 ethereumWithdrawn=caller)\n\ndef calculateEthereumReceived(uint256 _tokensToSell): # not payable\n  require _tokensToSell <= stor8\n  require 10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell)\n  require (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18\n  return (((25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18 / 10))\n\ndef calculateTokensReceived(uint256 _ethereumToSpend): # not payable\n  require _ethereumToSpend / 10 <= _ethereumToSpend\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  if 100000000000 * 10^18 <= t:\n      return ((t - 100000000000 * 10^18 / 10^10) - stor8 - stor9)\n  revert\n\ndef transfer(address recipient, uint256 amount): # not payable\n  if bool(stor3[caller]) != 1:\n      require stor4[caller] > 0\n  else:\n      require ambassadorLedger[caller] > 0\n  require not stor3[caller]\n  require not stor3[address(recipient)]\n  require amount <= stor4[caller]\n  if (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0:\n      require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n      stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n      stor6[caller] = 0\n      call caller with:\n         value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n            uint256 ethereumWithdrawn=caller)\n  require amount <= stor4[caller]\n  stor4[caller] -= amount\n  require stor4[address(recipient)] + amount >= stor4[address(recipient)]\n  stor4[address(recipient)] += amount\n  stor7[caller] += -1 * stor10 * amount\n  stor7[address(recipient)] += stor10 * amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef sell(uint256 amount): # not payable\n  if bool(stor3[caller]) != 1:\n      require stor4[caller] > 0\n  else:\n      require ambassadorLedger[caller] > 0\n  require not stor3[caller]\n  require amount <= stor4[caller]\n  require 10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount)\n  require (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18\n  require amount <= stor8\n  stor8 -= amount\n  require amount <= stor4[caller]\n  stor4[caller] -= amount\n  stor7[caller] = stor7[caller] - (stor10 * amount) - (((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10) << 64)\n  if stor8 > 0:\n      require stor8\n      require stor10 + ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8) >= stor10\n      stor10 += (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8\n  log onTokenSell(\n        address customerAddress=amount,\n        uint256 tokensBurned=((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10),\n        uint256 ethereumEarned=caller)\n\ndef buy(address _referredBy) payable: \n  if call.value < eth.balance(this.address):\n      if eth.balance(this.address) - call.value >= 7 * 10^18:\n          stor12 = 0\n  if not stor11[caller]:\n      require bool(stor12) != 1\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require call.value / 10 / 3 <= call.value / 10\n  require call.value / 10 <= call.value\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  if 100000000000 * 10^18 <= t:\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n      if 0 >= -stor8:\n          require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n          if not _referredBy:\n              require call.value / 10 >= (call.value / 10) - (call.value / 10 / 3)\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if _referredBy == caller:\n              if call.value / 10 >= (call.value / 10) - (call.value / 10 / 3):\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if stor4[address(_referredBy)] < stakingRequirement:\n                  if call.value / 10 >= (call.value / 10) - (call.value / 10 / 3):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if stor6[address(_referredBy)] + (call.value / 10 / 3) >= stor6[address(_referredBy)]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef exit(): # not payable\n  if stor4[caller] > 0:\n      if bool(stor3[caller]) != 1:\n          require stor4[caller] > 0\n      else:\n          require ambassadorLedger[caller] > 0\n      require not stor3[caller]\n      require stor4[caller] <= stor4[caller]\n      require 10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller])\n      require (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18\n      require stor4[caller] <= stor8\n      stor8 -= stor4[caller]\n      require stor4[caller] <= stor4[caller]\n      stor4[caller] = 0\n      stor7[caller] = stor7[caller] - (stor10 * stor4[caller]) - (((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10) << 64)\n      if stor8 > 0:\n          require stor8\n          require stor10 + ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8) >= stor10\n          stor10 += (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8\n      log onTokenSell(\n            address customerAddress=stor4[caller],\n            uint256 tokensBurned=((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10),\n            uint256 ethereumEarned=caller)\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  call caller with:\n     value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log onWithdraw(\n        address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n        uint256 ethereumWithdrawn=caller)\n\ndef _fallback(?) payable: # default function\n  if call.value < eth.balance(this.address):\n      if eth.balance(this.address) - call.value >= 7 * 10^18:\n          stor12 = 0\n  if not stor11[caller]:\n      require bool(stor12) != 1\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require call.value / 10 / 3 <= call.value / 10\n  require call.value / 10 <= call.value\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  require 100000000000 * 10^18 <= t\n  require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n  require 0 >= -stor8\n  require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n  require call.value / 10 >= (call.value / 10) - (call.value / 10 / 3)\n  if stor8 <= 0:\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (call.value / 10 << 64)\n  else:\n      require (t - 100000000000 * 10^18 / 10^10) - stor9 >= stor8\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor9\n      require stor8\n      stor10 += call.value / 10 << 64 / stor8\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (t - 100000000000 * 10^18 / 10^10 * call.value / 10 << 64 / stor8) + (stor8 * call.value / 10 << 64 / stor8) + (stor9 * call.value / 10 << 64 / stor8)\n  log onTokenPurchase(\n        address customerAddress=call.value,\n        uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller,\n        address referredBy=0)\n  if bool(stor3[caller]) == 1:\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 <= stor8\n      stor8 = (2 * stor8) - (t - 100000000000 * 10^18 / 10^10) + stor9\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 <= stor4[caller]\n      stor4[caller] = stor4[caller] - (t - 100000000000 * 10^18 / 10^10) + stor8 + stor9\n      require ambassadorLedger[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= ambassadorLedger[caller]\n      ambassadorLedger[caller] = ambassadorLedger[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 >= stor9\n      stor9 = (t - 100000000000 * 10^18 / 10^10) - stor8\n\ndef reinvest(): # not payable\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  require not stor3[caller]\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 / 3 <= (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 <= (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  require 100000000000 * 10^18 <= t\n  require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n  require 0 >= -stor8\n  require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 >= ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) - ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 / 3)\n  if stor8 <= 0:\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64)\n  else:\n      require (t - 100000000000 * 10^18 / 10^10) - stor9 >= stor8\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor9\n      require stor8\n      stor10 += (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (t - 100000000000 * 10^18 / 10^10 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8) + (stor8 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8) + (stor9 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8)\n  log onTokenPurchase(\n        address customerAddress=(Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller],\n        uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller,\n        address referredBy=0)\n  log onReinvestment(\n        address customerAddress=(Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller],\n        uint256 ethereumReinvested=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 18\nconst totalEthereumBalance = eth.balance(this.address)\n\ndef storage:\n  name is array of uint256 at storage 0\n  symbol is array of uint256 at storage 1\n  stakingRequirement is uint256 at storage 2\n  stor3 is mapping of uint8 at storage 3\n  stor4 is mapping of uint256 at storage 4\n  ambassadorLedger is mapping of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  stor7 is mapping of uint256 at storage 7\n  stor8 is uint256 at storage 8\n  stor9 is uint256 at storage 9\n  stor10 is uint256 at storage 10\n  stor11 is mapping of uint8 at storage 11\n  stor12 is uint8 at storage 12\n  stor13 is mapping of uint8 at storage 13\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef administrators(bytes32 _param1): # not payable\n  return bool(stor13[_param1])\n\ndef ambassadorLedger(address _param1): # not payable\n  return ambassadorLedger[_param1]\n\ndef stakingRequirement(): # not payable\n  return stakingRequirement\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\n#\n#  Regular functions\n#\n\ndef totalSupply(): # not payable\n  return (stor8 + stor9)\n\ndef disableWhitelist(): # not payable\n  require bool(stor3[caller]) == 1\n  stor12 = 0\n  return bool(stor12)\n\ndef setStakingRequirement(uint256 _amountOfTokens): # not payable\n  require stor13[caller]\n  stakingRequirement = _amountOfTokens\n\ndef myTokens(): # not payable\n  if bool(stor3[caller]) != 1:\n      return stor4[caller]\n  return ambassadorLedger[caller]\n\ndef setName(string _name): # not payable\n  require stor13[caller]\n  name[] = Array(len=_name.length, data=_name[all])\n\ndef setAdministrator(bytes32 _identifier, bool _status): # not payable\n  require stor13[caller]\n  stor13[_identifier] = uint8(_status)\n\ndef setSymbol(string _symbol): # not payable\n  require stor13[caller]\n  symbol[] = Array(len=_symbol.length, data=_symbol[all])\n\ndef balanceOf(address account): # not payable\n  if bool(stor3[caller]) != 1:\n      return stor4[address(account)]\n  return ambassadorLedger[address(account)]\n\ndef dividendsOf(address _customerAddress): # not payable\n  return (Mask(192, 64, (stor10 * stor4[address(_customerAddress)]) - stor7[address(_customerAddress)]) >> 64)\n\ndef myDividends(bool _includeReferralBonus): # not payable\n  if _includeReferralBonus:\n      return ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller])\n  return (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64)\n\ndef sellPrice(): # not payable\n  if not stor8 + stor9:\n      return (25 * 10^6 * 3600)\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  require (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n  return (((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) - ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10))\n\ndef buyPrice(): # not payable\n  if not stor8 + stor9:\n      return 11 * 10^10\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  require ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) + ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10) >= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n  return (((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) + ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10))\n\ndef withdraw(): # not payable\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  call caller with:\n     value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log onWithdraw(\n        address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n        uint256 ethereumWithdrawn=caller)\n\ndef calculateEthereumReceived(uint256 _tokensToSell): # not payable\n  require _tokensToSell <= stor8\n  require 10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell)\n  require (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18\n  return (((25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18 / 10))\n\ndef calculateTokensReceived(uint256 _ethereumToSpend): # not payable\n  require _ethereumToSpend / 10 <= _ethereumToSpend\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  if 100000000000 * 10^18 <= t:\n      return ((t - 100000000000 * 10^18 / 10^10) - stor8 - stor9)\n  revert\n\ndef transfer(address recipient, uint256 amount): # not payable\n  if bool(stor3[caller]) != 1:\n      require stor4[caller] > 0\n  else:\n      require ambassadorLedger[caller] > 0\n  require not stor3[caller]\n  require not stor3[address(recipient)]\n  require amount <= stor4[caller]\n  if (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0:\n      require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n      stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n      stor6[caller] = 0\n      call caller with:\n         value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n            uint256 ethereumWithdrawn=caller)\n  require amount <= stor4[caller]\n  stor4[caller] -= amount\n  require stor4[address(recipient)] + amount >= stor4[address(recipient)]\n  stor4[address(recipient)] += amount\n  stor7[caller] += -1 * stor10 * amount\n  stor7[address(recipient)] += stor10 * amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef sell(uint256 amount): # not payable\n  if bool(stor3[caller]) != 1:\n      require stor4[caller] > 0\n  else:\n      require ambassadorLedger[caller] > 0\n  require not stor3[caller]\n  require amount <= stor4[caller]\n  require 10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount)\n  require (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18\n  require amount <= stor8\n  stor8 -= amount\n  require amount <= stor4[caller]\n  stor4[caller] -= amount\n  stor7[caller] = stor7[caller] - (stor10 * amount) - (((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10) << 64)\n  if stor8 > 0:\n      require stor8\n      require stor10 + ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8) >= stor10\n      stor10 += (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8\n  log onTokenSell(\n        address customerAddress=amount,\n        uint256 tokensBurned=((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10),\n        uint256 ethereumEarned=caller)\n\ndef buy(address _referredBy) payable: \n  if call.value < eth.balance(this.address):\n      if eth.balance(this.address) - call.value >= 7 * 10^18:\n          stor12 = 0\n  if not stor11[caller]:\n      require bool(stor12) != 1\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require call.value / 10 / 3 <= call.value / 10\n  require call.value / 10 <= call.value\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  if 100000000000 * 10^18 <= t:\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n      if 0 >= -stor8:\n          require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n          if not _referredBy:\n              require call.value / 10 >= (call.value / 10) - (call.value / 10 / 3)\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if _referredBy == caller:\n              if call.value / 10 >= (call.value / 10) - (call.value / 10 / 3):\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if stor4[address(_referredBy)] < stakingRequirement:\n                  if call.value / 10 >= (call.value / 10) - (call.value / 10 / 3):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if stor6[address(_referredBy)] + (call.value / 10 / 3) >= stor6[address(_referredBy)]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef exit(): # not payable\n  if stor4[caller] > 0:\n      if bool(stor3[caller]) != 1:\n          require stor4[caller] > 0\n      else:\n          require ambassadorLedger[caller] > 0\n      require not stor3[caller]\n      require stor4[caller] <= stor4[caller]\n      require 10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller])\n      require (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18\n      require stor4[caller] <= stor8\n      stor8 -= stor4[caller]\n      require stor4[caller] <= stor4[caller]\n      stor4[caller] = 0\n      stor7[caller] = stor7[caller] - (stor10 * stor4[caller]) - (((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10) << 64)\n      if stor8 > 0:\n          require stor8\n          require stor10 + ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8) >= stor10\n          stor10 += (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8\n      log onTokenSell(\n            address customerAddress=stor4[caller],\n            uint256 tokensBurned=((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10),\n            uint256 ethereumEarned=caller)\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  call caller with:\n     value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log onWithdraw(\n        address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n        uint256 ethereumWithdrawn=caller)\n\ndef _fallback(?) payable: # default function\n  if call.value < eth.balance(this.address):\n      if eth.balance(this.address) - call.value >= 7 * 10^18:\n          stor12 = 0\n  if not stor11[caller]:\n      require bool(stor12) != 1\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require call.value / 10 / 3 <= call.value / 10\n  require call.value / 10 <= call.value\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  require 100000000000 * 10^18 <= t\n  require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n  require 0 >= -stor8\n  require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n  require call.value / 10 >= (call.value / 10) - (call.value / 10 / 3)\n  if stor8 <= 0:\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (call.value / 10 << 64)\n  else:\n      require (t - 100000000000 * 10^18 / 10^10) - stor9 >= stor8\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor9\n      require stor8\n      stor10 += call.value / 10 << 64 / stor8\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (t - 100000000000 * 10^18 / 10^10 * call.value / 10 << 64 / stor8) + (stor8 * call.value / 10 << 64 / stor8) + (stor9 * call.value / 10 << 64 / stor8)\n  log onTokenPurchase(\n        address customerAddress=call.value,\n        uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller,\n        address referredBy=0)\n  if bool(stor3[caller]) == 1:\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 <= stor8\n      stor8 = (2 * stor8) - (t - 100000000000 * 10^18 / 10^10) + stor9\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 <= stor4[caller]\n      stor4[caller] = stor4[caller] - (t - 100000000000 * 10^18 / 10^10) + stor8 + stor9\n      require ambassadorLedger[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= ambassadorLedger[caller]\n      ambassadorLedger[caller] = ambassadorLedger[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 >= stor9\n      stor9 = (t - 100000000000 * 10^18 / 10^10) - stor8\n\ndef reinvest(): # not payable\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  require not stor3[caller]\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 / 3 <= (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 <= (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  require 100000000000 * 10^18 <= t\n  require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n  require 0 >= -stor8\n  require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 >= ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) - ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 / 3)\n  if stor8 <= 0:\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64)\n  else:\n      require (t - 100000000000 * 10^18 / 10^10) - stor9 >= stor8\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor9\n      require stor8\n      stor10 += (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (t - 100000000000 * 10^18 / 10^10 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8) + (stor8 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8) + (stor9 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8)\n  log onTokenPurchase(\n        address customerAddress=(Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller],\n        uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller,\n        address referredBy=0)\n  log onReinvestment(\n        address customerAddress=(Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller],\n        uint256 ethereumReinvested=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 18\nconst totalEthereumBalance = eth.balance(this.address)\n\ndef storage:\n  name is array of uint256 at storage 0\n  symbol is array of uint256 at storage 1\n  stakingRequirement is uint256 at storage 2\n  stor3 is mapping of uint8 at storage 3\n  stor4 is mapping of uint256 at storage 4\n  ambassadorLedger is mapping of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  stor7 is mapping of uint256 at storage 7\n  stor8 is uint256 at storage 8\n  stor9 is uint256 at storage 9\n  stor10 is uint256 at storage 10\n  stor11 is mapping of uint8 at storage 11\n  stor12 is uint8 at storage 12\n  stor13 is mapping of uint8 at storage 13\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef administrators(bytes32 _param1): # not payable\n  return bool(stor13[_param1])\n\ndef ambassadorLedger(address _param1): # not payable\n  return ambassadorLedger[_param1]\n\ndef stakingRequirement(): # not payable\n  return stakingRequirement\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\n#\n#  Regular functions\n#\n\ndef totalSupply(): # not payable\n  return (stor8 + stor9)\n\ndef disableWhitelist(): # not payable\n  require bool(stor3[caller]) == 1\n  stor12 = 0\n  return bool(stor12)\n\ndef setStakingRequirement(uint256 _amountOfTokens): # not payable\n  require stor13[caller]\n  stakingRequirement = _amountOfTokens\n\ndef myTokens(): # not payable\n  if bool(stor3[caller]) != 1:\n      return stor4[caller]\n  return ambassadorLedger[caller]\n\ndef setName(string _name): # not payable\n  require stor13[caller]\n  name[] = Array(len=_name.length, data=_name[all])\n\ndef setAdministrator(bytes32 _identifier, bool _status): # not payable\n  require stor13[caller]\n  stor13[_identifier] = uint8(_status)\n\ndef setSymbol(string _symbol): # not payable\n  require stor13[caller]\n  symbol[] = Array(len=_symbol.length, data=_symbol[all])\n\ndef balanceOf(address account): # not payable\n  if bool(stor3[caller]) != 1:\n      return stor4[address(account)]\n  return ambassadorLedger[address(account)]\n\ndef dividendsOf(address _customerAddress): # not payable\n  return (Mask(192, 64, (stor10 * stor4[address(_customerAddress)]) - stor7[address(_customerAddress)]) >> 64)\n\ndef myDividends(bool _includeReferralBonus): # not payable\n  if _includeReferralBonus:\n      return ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller])\n  return (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64)\n\ndef sellPrice(): # not payable\n  if not stor8 + stor9:\n      return (25 * 10^6 * 3600)\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  require (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n  return (((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) - ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10))\n\ndef buyPrice(): # not payable\n  if not stor8 + stor9:\n      return 11 * 10^10\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  require ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) + ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10) >= (10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n  return (((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) + ((10000000000 * 10^18 * stor8 + stor9 + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 10))\n\ndef withdraw(): # not payable\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  call caller with:\n     value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log onWithdraw(\n        address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n        uint256 ethereumWithdrawn=caller)\n\ndef calculateEthereumReceived(uint256 _tokensToSell): # not payable\n  require _tokensToSell <= stor8\n  require 10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell)\n  require (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18\n  return (((25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * _tokensToSell) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18 / 10))\n\ndef calculateTokensReceived(uint256 _ethereumToSpend): # not payable\n  require _ethereumToSpend / 10 <= _ethereumToSpend\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * _ethereumToSpend / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  if 100000000000 * 10^18 <= t:\n      return ((t - 100000000000 * 10^18 / 10^10) - stor8 - stor9)\n  revert\n\ndef transfer(address recipient, uint256 amount): # not payable\n  if bool(stor3[caller]) != 1:\n      require stor4[caller] > 0\n  else:\n      require ambassadorLedger[caller] > 0\n  require not stor3[caller]\n  require not stor3[address(recipient)]\n  require amount <= stor4[caller]\n  if (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0:\n      require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n      stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n      stor6[caller] = 0\n      call caller with:\n         value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n            uint256 ethereumWithdrawn=caller)\n  require amount <= stor4[caller]\n  stor4[caller] -= amount\n  require stor4[address(recipient)] + amount >= stor4[address(recipient)]\n  stor4[address(recipient)] += amount\n  stor7[caller] += -1 * stor10 * amount\n  stor7[address(recipient)] += stor10 * amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef sell(uint256 amount): # not payable\n  if bool(stor3[caller]) != 1:\n      require stor4[caller] > 0\n  else:\n      require ambassadorLedger[caller] > 0\n  require not stor3[caller]\n  require amount <= stor4[caller]\n  require 10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount)\n  require (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18\n  require amount <= stor8\n  stor8 -= amount\n  require amount <= stor4[caller]\n  stor4[caller] -= amount\n  stor7[caller] = stor7[caller] - (stor10 * amount) - (((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10) << 64)\n  if stor8 > 0:\n      require stor8\n      require stor10 + ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8) >= stor10\n      stor10 += (25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8\n  log onTokenSell(\n        address customerAddress=amount,\n        uint256 tokensBurned=((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * amount) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 / 10),\n        uint256 ethereumEarned=caller)\n\ndef buy(address _referredBy) payable: \n  if call.value < eth.balance(this.address):\n      if eth.balance(this.address) - call.value >= 7 * 10^18:\n          stor12 = 0\n  if not stor11[caller]:\n      require bool(stor12) != 1\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require call.value / 10 / 3 <= call.value / 10\n  require call.value / 10 <= call.value\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  if 100000000000 * 10^18 <= t:\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n      if 0 >= -stor8:\n          require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n          if not _referredBy:\n              require call.value / 10 >= (call.value / 10) - (call.value / 10 / 3)\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if _referredBy == caller:\n              if call.value / 10 >= (call.value / 10) - (call.value / 10 / 3):\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if stor4[address(_referredBy)] < stakingRequirement:\n                  if call.value / 10 >= (call.value / 10) - (call.value / 10 / 3):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              else:\n                  if stor6[address(_referredBy)] + (call.value / 10 / 3) >= stor6[address(_referredBy)]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef exit(): # not payable\n  if stor4[caller] > 0:\n      if bool(stor3[caller]) != 1:\n          require stor4[caller] > 0\n      else:\n          require ambassadorLedger[caller] > 0\n      require not stor3[caller]\n      require stor4[caller] <= stor4[caller]\n      require 10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller])\n      require (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 <= (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18\n      require stor4[caller] <= stor8\n      stor8 -= stor4[caller]\n      require stor4[caller] <= stor4[caller]\n      stor4[caller] = 0\n      stor7[caller] = stor7[caller] - (stor10 * stor4[caller]) - (((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10) << 64)\n      if stor8 > 0:\n          require stor8\n          require stor10 + ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8) >= stor10\n          stor10 += (25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10 << 64 / stor8\n      log onTokenSell(\n            address customerAddress=stor4[caller],\n            uint256 tokensBurned=((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18) - ((25 * 10^6 * 3600 * stor4[caller]) + (10^10 * stor8 + stor9 + 10^18 / 10^18 * stor4[caller]) - (10^10 * (stor4[caller] + 10^18)^2 + -stor4[caller] - 10^18 / 10^18 / 2) / 10^18 / 10),\n            uint256 ethereumEarned=caller)\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  call caller with:\n     value (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log onWithdraw(\n        address customerAddress=((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]),\n        uint256 ethereumWithdrawn=caller)\n\ndef _fallback(?) payable: # default function\n  if call.value < eth.balance(this.address):\n      if eth.balance(this.address) - call.value >= 7 * 10^18:\n          stor12 = 0\n  if not stor11[caller]:\n      require bool(stor12) != 1\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require call.value / 10 / 3 <= call.value / 10\n  require call.value / 10 <= call.value\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * call.value) + (-20000000000000000000000000000 * 10^18 * call.value / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  require 100000000000 * 10^18 <= t\n  require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n  require 0 >= -stor8\n  require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n  require call.value / 10 >= (call.value / 10) - (call.value / 10 / 3)\n  if stor8 <= 0:\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (call.value / 10 << 64)\n  else:\n      require (t - 100000000000 * 10^18 / 10^10) - stor9 >= stor8\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor9\n      require stor8\n      stor10 += call.value / 10 << 64 / stor8\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (t - 100000000000 * 10^18 / 10^10 * call.value / 10 << 64 / stor8) + (stor8 * call.value / 10 << 64 / stor8) + (stor9 * call.value / 10 << 64 / stor8)\n  log onTokenPurchase(\n        address customerAddress=call.value,\n        uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller,\n        address referredBy=0)\n  if bool(stor3[caller]) == 1:\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 <= stor8\n      stor8 = (2 * stor8) - (t - 100000000000 * 10^18 / 10^10) + stor9\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 <= stor4[caller]\n      stor4[caller] = stor4[caller] - (t - 100000000000 * 10^18 / 10^10) + stor8 + stor9\n      require ambassadorLedger[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= ambassadorLedger[caller]\n      ambassadorLedger[caller] = ambassadorLedger[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require (t - 100000000000 * 10^18 / 10^10) - stor8 >= stor9\n      stor9 = (t - 100000000000 * 10^18 / 10^10) - stor8\n\ndef reinvest(): # not payable\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] > 0\n  require not stor3[caller]\n  stor7[caller] += Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller])\n  stor6[caller] = 0\n  if call.value > 10^18:\n      require eth.balance(this.address) < 10 * 10^18\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 / 3 <= (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 <= (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller]\n  s = (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n  t = (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n  while s < t:\n      require s\n      s = ((0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor6[caller]) + (-20000000000000000000000000000 * 10^18 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) + (100 * 10^18 * (stor8 + stor9)^2) + (2000000000000000000000 * 10^18 * stor8) + (2000000000000000000000 * 10^18 * stor9) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n      t = s\n      continue \n  require 100000000000 * 10^18 <= t\n  require (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 > 0\n  require 0 >= -stor8\n  require (t - 100000000000 * 10^18 / 10^10) - stor9 > stor8\n  require (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 >= ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10) - ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 / 3)\n  if stor8 <= 0:\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - ((Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64)\n  else:\n      require (t - 100000000000 * 10^18 / 10^10) - stor9 >= stor8\n      stor8 = (t - 100000000000 * 10^18 / 10^10) - stor9\n      require stor8\n      stor10 += (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8\n      require stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9 >= stor4[caller]\n      stor4[caller] = stor4[caller] + (t - 100000000000 * 10^18 / 10^10) - stor8 - stor9\n      stor7[caller] = stor7[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (stor8 * stor10) - (stor9 * stor10) - (t - 100000000000 * 10^18 / 10^10 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8) + (stor8 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8) + (stor9 * (Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller] / 10 << 64 / stor8)\n  log onTokenPurchase(\n        address customerAddress=(Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller],\n        uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller,\n        address referredBy=0)\n  log onReinvestment(\n        address customerAddress=(Mask(192, 64, (stor10 * stor4[caller]) - stor7[caller]) >> 64) + stor6[caller],\n        uint256 ethereumReinvested=(t - 100000000000 * 10^18 / 10^10) - stor8 - stor9,\n        uint256 tokensMinted=caller)\n\n.",
	"status": "1",
	"time_cost": 55.59452533721924,
	"usage": {
		"completion_tokens": 831,
		"prompt_tokens": 9463,
		"total_tokens": 10294
	}
}