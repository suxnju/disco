{
	"address": "0xc6038f9ff35a3f2b00f9747b483bced7b024015e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity smart contract code that mirrors the provided decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _userDepositedWei;\n    mapping (address => uint256) private _userWithdrewWei;\n    mapping (address => uint256) private _userReferralsWei;\n    mapping (address => uint256) private _userDividendsWei;\n    uint256 private _totalDepositedWei;\n    uint256 private _totalWithdrewWei;\n    address private marketingAddress = 0x2db7088799a5594a152c8dcf05976508e4eaa3e4;\n\n    function userDividendsWei(address user) public view returns (uint256) {\n        uint256 v0 = helperFunction(4, _userDividendsWei[user]);\n        uint256 v1 = helperFunction(block.number - _userDividendsWei[user], v0 / 100);\n        return v1 / 5900;\n    }\n\n    function totalWithdrewWei() public view returns (uint256) {\n        return _totalWithdrewWei;\n    }\n\n    function userDepositedWei(address user) public view returns (uint256) {\n        return _userDepositedWei[user];\n    }\n\n    function totalDepositedWei() public view returns (uint256) {\n        return _totalDepositedWei;\n    }\n\n    function userReferralsWei(address user) public view returns (uint256) {\n        return _userReferralsWei[user];\n    }\n\n    function userWithdrewWei(address user) public view returns (uint256) {\n        return _userWithdrewWei[user];\n    }\n\n    function helperFunction(uint256 a, uint256 b) private pure returns (uint256) {\n        if (b != 0) {\n            uint256 result = a * b;\n            assert(b == 0 || result / b == a);\n            return result;\n        } else {\n            return 0;\n        }\n    }\n\n    function() external payable {\n        uint256 v0 = helperFunction(15, msg.value);\n        address(marketingAddress).call.value(v0 / 100).gas(!(v0 / 100) * 2300);\n\n        if (_userDepositedWei[msg.sender] != 0) {\n            uint256 v2 = helperFunction(4, _userDividendsWei[msg.sender]);\n            uint256 v3 = helperFunction(block.number - _userDividendsWei[msg.sender], v2 / 100);\n            msg.sender.call.value(v3 / 5900).gas(!(v3 / 5900) * 2300);\n            _userWithdrewWei[msg.sender] += v3 / 5900;\n            _totalWithdrewWei += v3 / 5900;\n        }\n\n        if (msg.data.length > 0 && msg.sender != address(this)) {\n            uint256 v6 = helperFunction(4, msg.value);\n            msg.sender.call.value(v6 / 100).gas(!(v6 / 100) * 2300);\n            _userReferralsWei[msg.sender] += v6 / 100;\n        }\n\n        _userDividendsWei[msg.sender] = block.number;\n        _userDepositedWei[msg.sender] += msg.value;\n        _totalDepositedWei += msg.value;\n    }\n}\n```\n\nPlease note that the given decompiled code is quite complex and might contain some inaccuracies. The compiled EVM bytecode and original Solidity source code are needed to guarantee an accurate decompilation. Additionally, the provided decompiled code seems to include some error checking and gas optimization, which might be specific to the original contract's requirements and might not be necessary in all cases.",
				"role": "assistant"
			}
		}
	],
	"created": 1701467007,
	"id": "chatcmpl-8R5aBt1WcPpOxodVldZ5Rp3JEwIQj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 18:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _userDepositedWei; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _userWithdrewWei; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _userReferralsWei; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userDividendsWei; // STORAGE[0x3]\nuint256 _totalDepositedWei; // STORAGE[0x4]\nuint256 _totalWithdrewWei; // STORAGE[0x5]\n\n\nfunction userDividendsWei(address varg0) public nonPayable { \n    v0 = 0x6e6(4, _userDividendsWei[varg0]);\n    assert(100);\n    v1 = 0x6e6(block.number - _userDividendsWei[varg0], v0 / 100);\n    assert(5900);\n    return v1 / 5900;\n}\n\nfunction marketingAddress() public nonPayable { \n    return 0x2db7088799a5594a152c8dcf05976508e4eaa3e4;\n}\n\nfunction totalWithdrewWei() public nonPayable { \n    return _totalWithdrewWei;\n}\n\nfunction userDepositedWei(address varg0) public nonPayable { \n    return _userDepositedWei[varg0];\n}\n\nfunction totalDepositedWei() public nonPayable { \n    return _totalDepositedWei;\n}\n\nfunction userReferralsWei(address varg0) public nonPayable { \n    return _userReferralsWei[varg0];\n}\n\nfunction userWithdrewWei(address varg0) public nonPayable { \n    return _userWithdrewWei[varg0];\n}\n\nfunction 0x6e6(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x6e6(15, msg.value);\n    assert(100);\n    v1 = 0x2db7088799a5594a152c8dcf05976508e4eaa3e4.call().value(v0 / 100).gas(!(v0 / 100) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    if (_userDepositedWei[msg.sender] != 0) {\n        v2 = 0x6e6(4, _userDividendsWei[msg.sender]);\n        assert(100);\n        v3 = 0x6e6(block.number - _userDividendsWei[msg.sender], v2 / 100);\n        assert(5900);\n        v4 = msg.sender.call().value(v3 / 5900).gas(!(v3 / 5900) * 2300);\n        require(v4); // checks call status, propagates error data on error\n        _userWithdrewWei[msg.sender] = _userWithdrewWei[msg.sender] + v3 / 5900;\n        assert(_totalWithdrewWei + v3 / 5900 >= _totalWithdrewWei);\n        _totalWithdrewWei = _totalWithdrewWei + v3 / 5900;\n    }\n    v5 = new bytes[](msg.data.length);\n    CALLDATACOPY(v5.data, 0, msg.data.length);\n    v6 = 0x6e6(4, msg.value);\n    assert(100);\n    v7 = v8 = address(MEM[v5 + 20]) > 0;\n    if (v8) {\n        v7 = v9 = address(MEM[v5 + 20]) != msg.sender;\n    }\n    if (v7) {\n        v10 = address(MEM[v5 + 20]).call().value(v6 / 100).gas(!(v6 / 100) * 2300);\n        require(v10); // checks call status, propagates error data on error\n        _userReferralsWei[address(MEM[v5 + 20])] = _userReferralsWei[address(MEM[v5 + 20])] + v6 / 100;\n    }\n    _userDividendsWei[msg.sender] = block.number;\n    _userDividendsWei[msg.sender] = _userDividendsWei[msg.sender] + msg.value;\n    assert(_totalDepositedWei + msg.value >= _totalDepositedWei);\n    _totalDepositedWei = _totalDepositedWei + msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1b68adff == function_selector) {\n            userDividendsWei(address);\n        } else if (0xa5ece941 == function_selector) {\n            marketingAddress();\n        } else if (0xb781e47d == function_selector) {\n            totalWithdrewWei();\n        } else if (0xc8d1c6cf == function_selector) {\n            userDepositedWei(address);\n        } else if (0xee12d4f2 == function_selector) {\n            totalDepositedWei();\n        } else if (0xee1596e5 == function_selector) {\n            userReferralsWei(address);\n        } else if (0xfc4fcc5a == function_selector) {\n            userWithdrewWei(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 18:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _userDepositedWei; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _userWithdrewWei; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _userReferralsWei; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userDividendsWei; // STORAGE[0x3]\nuint256 _totalDepositedWei; // STORAGE[0x4]\nuint256 _totalWithdrewWei; // STORAGE[0x5]\n\n\nfunction userDividendsWei(address varg0) public nonPayable { \n    v0 = 0x6e6(4, _userDividendsWei[varg0]);\n    assert(100);\n    v1 = 0x6e6(block.number - _userDividendsWei[varg0], v0 / 100);\n    assert(5900);\n    return v1 / 5900;\n}\n\nfunction marketingAddress() public nonPayable { \n    return 0x2db7088799a5594a152c8dcf05976508e4eaa3e4;\n}\n\nfunction totalWithdrewWei() public nonPayable { \n    return _totalWithdrewWei;\n}\n\nfunction userDepositedWei(address varg0) public nonPayable { \n    return _userDepositedWei[varg0];\n}\n\nfunction totalDepositedWei() public nonPayable { \n    return _totalDepositedWei;\n}\n\nfunction userReferralsWei(address varg0) public nonPayable { \n    return _userReferralsWei[varg0];\n}\n\nfunction userWithdrewWei(address varg0) public nonPayable { \n    return _userWithdrewWei[varg0];\n}\n\nfunction 0x6e6(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x6e6(15, msg.value);\n    assert(100);\n    v1 = 0x2db7088799a5594a152c8dcf05976508e4eaa3e4.call().value(v0 / 100).gas(!(v0 / 100) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    if (_userDepositedWei[msg.sender] != 0) {\n        v2 = 0x6e6(4, _userDividendsWei[msg.sender]);\n        assert(100);\n        v3 = 0x6e6(block.number - _userDividendsWei[msg.sender], v2 / 100);\n        assert(5900);\n        v4 = msg.sender.call().value(v3 / 5900).gas(!(v3 / 5900) * 2300);\n        require(v4); // checks call status, propagates error data on error\n        _userWithdrewWei[msg.sender] = _userWithdrewWei[msg.sender] + v3 / 5900;\n        assert(_totalWithdrewWei + v3 / 5900 >= _totalWithdrewWei);\n        _totalWithdrewWei = _totalWithdrewWei + v3 / 5900;\n    }\n    v5 = new bytes[](msg.data.length);\n    CALLDATACOPY(v5.data, 0, msg.data.length);\n    v6 = 0x6e6(4, msg.value);\n    assert(100);\n    v7 = v8 = address(MEM[v5 + 20]) > 0;\n    if (v8) {\n        v7 = v9 = address(MEM[v5 + 20]) != msg.sender;\n    }\n    if (v7) {\n        v10 = address(MEM[v5 + 20]).call().value(v6 / 100).gas(!(v6 / 100) * 2300);\n        require(v10); // checks call status, propagates error data on error\n        _userReferralsWei[address(MEM[v5 + 20])] = _userReferralsWei[address(MEM[v5 + 20])] + v6 / 100;\n    }\n    _userDividendsWei[msg.sender] = block.number;\n    _userDividendsWei[msg.sender] = _userDividendsWei[msg.sender] + msg.value;\n    assert(_totalDepositedWei + msg.value >= _totalDepositedWei);\n    _totalDepositedWei = _totalDepositedWei + msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1b68adff == function_selector) {\n            userDividendsWei(address);\n        } else if (0xa5ece941 == function_selector) {\n            marketingAddress();\n        } else if (0xb781e47d == function_selector) {\n            totalWithdrewWei();\n        } else if (0xc8d1c6cf == function_selector) {\n            userDepositedWei(address);\n        } else if (0xee12d4f2 == function_selector) {\n            totalDepositedWei();\n        } else if (0xee1596e5 == function_selector) {\n            userReferralsWei(address);\n        } else if (0xfc4fcc5a == function_selector) {\n            userWithdrewWei(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 18:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _userDepositedWei; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _userWithdrewWei; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _userReferralsWei; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _userDividendsWei; // STORAGE[0x3]\nuint256 _totalDepositedWei; // STORAGE[0x4]\nuint256 _totalWithdrewWei; // STORAGE[0x5]\n\n\nfunction userDividendsWei(address varg0) public nonPayable { \n    v0 = 0x6e6(4, _userDividendsWei[varg0]);\n    assert(100);\n    v1 = 0x6e6(block.number - _userDividendsWei[varg0], v0 / 100);\n    assert(5900);\n    return v1 / 5900;\n}\n\nfunction marketingAddress() public nonPayable { \n    return 0x2db7088799a5594a152c8dcf05976508e4eaa3e4;\n}\n\nfunction totalWithdrewWei() public nonPayable { \n    return _totalWithdrewWei;\n}\n\nfunction userDepositedWei(address varg0) public nonPayable { \n    return _userDepositedWei[varg0];\n}\n\nfunction totalDepositedWei() public nonPayable { \n    return _totalDepositedWei;\n}\n\nfunction userReferralsWei(address varg0) public nonPayable { \n    return _userReferralsWei[varg0];\n}\n\nfunction userWithdrewWei(address varg0) public nonPayable { \n    return _userWithdrewWei[varg0];\n}\n\nfunction 0x6e6(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x6e6(15, msg.value);\n    assert(100);\n    v1 = 0x2db7088799a5594a152c8dcf05976508e4eaa3e4.call().value(v0 / 100).gas(!(v0 / 100) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    if (_userDepositedWei[msg.sender] != 0) {\n        v2 = 0x6e6(4, _userDividendsWei[msg.sender]);\n        assert(100);\n        v3 = 0x6e6(block.number - _userDividendsWei[msg.sender], v2 / 100);\n        assert(5900);\n        v4 = msg.sender.call().value(v3 / 5900).gas(!(v3 / 5900) * 2300);\n        require(v4); // checks call status, propagates error data on error\n        _userWithdrewWei[msg.sender] = _userWithdrewWei[msg.sender] + v3 / 5900;\n        assert(_totalWithdrewWei + v3 / 5900 >= _totalWithdrewWei);\n        _totalWithdrewWei = _totalWithdrewWei + v3 / 5900;\n    }\n    v5 = new bytes[](msg.data.length);\n    CALLDATACOPY(v5.data, 0, msg.data.length);\n    v6 = 0x6e6(4, msg.value);\n    assert(100);\n    v7 = v8 = address(MEM[v5 + 20]) > 0;\n    if (v8) {\n        v7 = v9 = address(MEM[v5 + 20]) != msg.sender;\n    }\n    if (v7) {\n        v10 = address(MEM[v5 + 20]).call().value(v6 / 100).gas(!(v6 / 100) * 2300);\n        require(v10); // checks call status, propagates error data on error\n        _userReferralsWei[address(MEM[v5 + 20])] = _userReferralsWei[address(MEM[v5 + 20])] + v6 / 100;\n    }\n    _userDividendsWei[msg.sender] = block.number;\n    _userDividendsWei[msg.sender] = _userDividendsWei[msg.sender] + msg.value;\n    assert(_totalDepositedWei + msg.value >= _totalDepositedWei);\n    _totalDepositedWei = _totalDepositedWei + msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1b68adff == function_selector) {\n            userDividendsWei(address);\n        } else if (0xa5ece941 == function_selector) {\n            marketingAddress();\n        } else if (0xb781e47d == function_selector) {\n            totalWithdrewWei();\n        } else if (0xc8d1c6cf == function_selector) {\n            userDepositedWei(address);\n        } else if (0xee12d4f2 == function_selector) {\n            totalDepositedWei();\n        } else if (0xee1596e5 == function_selector) {\n            userReferralsWei(address);\n        } else if (0xfc4fcc5a == function_selector) {\n            userWithdrewWei(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 34.61358976364136,
	"usage": {
		"completion_tokens": 797,
		"prompt_tokens": 1367,
		"total_tokens": 2164
	}
}