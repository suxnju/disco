{
	"address": "0xf165c0df0b759e93e6166aecb667c7ec2a300525",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a basic smart contract that captures some of the key functionality from the decompiled code. Please note that the decompiled code is very complex, so this contract does not capture every aspect of it, but it should give you a good starting point.\n\n```solidity\npragma solidity ^0.8.2;\n\ncontract MyContract {\n    uint256 public totalContribution;\n    uint256 public totalBonusTokensIssued;\n    uint256 public totalSupply;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping(address => uint256)) public allowance;\n    address public ethFoundDeposit;\n    bool public purchasingAllowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {\n        totalContribution = 0;\n        totalBonusTokensIssued = 0;\n        totalSupply = 0;\n        ethFoundDeposit = msg.sender;\n        purchasingAllowed = false;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function enablePurchasing() public {\n        require(msg.sender == ethFoundDeposit, \"Only the contract owner can enable purchasing.\");\n        purchasingAllowed = true;\n    }\n\n    function disablePurchasing() public {\n        require(msg.sender == ethFoundDeposit, \"Only the contract owner can disable purchasing.\");\n        purchasingAllowed = false;\n    }\n}\n```\n\nThis contract includes a basic ERC20 token with `approve()`, `transfer()`, and `transferFrom()` functions. It also includes a constructor that sets initial values for the contract's state variables. The `enablePurchasing()` and `disablePurchasing()` functions can be called by the contract owner to allow or disallow token purchasing.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461212,
	"id": "chatcmpl-8R44ipZg5iWG3NY9ZQ3os4a0HEL8u",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 20:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalContribution; // STORAGE[0x0]\nuint256 _totalBonusTokensIssued; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _deadline; // STORAGE[0x9]\nuint256 _startline; // STORAGE[0xa]\nuint256 _refundDeadLine; // STORAGE[0xb]\nuint256 _transactionCounter; // STORAGE[0xc]\nuint256 _etherReceived; // STORAGE[0xd]\naddress _enablePurchasing; // STORAGE[0x6] bytes 0 to 19\naddress _ethFoundDeposit; // STORAGE[0x7] bytes 0 to 19\nuint160 _gatFoundDeposit; // STORAGE[0x8] bytes 0 to 19\nuint8 _purchasingAllowed; // STORAGE[0x6] bytes 20 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nLogTransaction(address, uint256);\n\nfunction name() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & 'General Advertising Token';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 != 0;\n    if (v1) {\n        v0 = _allowance[varg0] != 0;\n    }\n    if (!v0) {\n        _allowance[varg0] = varg1;\n        emit Approval(msg.sender, varg0, varg1);\n        v2 = v3 = 1;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction totalContribution() public nonPayable { \n    return _totalContribution;\n}\n\nfunction transactionCounter() public nonPayable { \n    return _transactionCounter;\n}\n\nfunction withdrawEtherHomeLocal(address varg0) public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    v0 = varg0.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction startline() public nonPayable { \n    return _startline;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 >= 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n        goto 0x1050B0x50c;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction etherReceived() public nonPayable { \n    return _etherReceived;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction gatFund() public nonPayable { \n    return 0xcecb8f27f4200f3a000000;\n}\n\nfunction tokenExchangeRate() public nonPayable { \n    return 9000;\n}\n\nfunction refund() public nonPayable { \n    require(!_purchasingAllowed);\n    require(block.timestamp < _refundDeadLine);\n    require(_totalSupply - _totalBonusTokensIssued < 0xe0fe3d8bb9bc7b1000000);\n    require(msg.sender != _ethFoundDeposit);\n    require(_balanceOf[msg.sender] > 0);\n    emit LogTransaction(msg.sender, owner_4[msg.sender]);\n    v0 = msg.sender.call().value(owner_4[msg.sender]).gas(!owner_4[msg.sender] * 2300);\n    require(v0);\n    _totalContribution = _totalContribution - owner_4[msg.sender];\n    owner_4[msg.sender] = owner_4[msg.sender] - owner_4[msg.sender];\n}\n\nfunction disablePurchasing() public nonPayable { \n    require(msg.sender == _enablePurchasing);\n    require(_purchasingAllowed);\n    _purchasingAllowed = 0;\n}\n\nfunction tokenCreationCap() public nonPayable { \n    return 0x33b2e3c9fd0803ce8000000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ethFoundDeposit() public nonPayable { \n    return _ethFoundDeposit;\n}\n\nfunction enablePurchasing() public nonPayable { \n    require(msg.sender == _enablePurchasing);\n    require(!_purchasingAllowed);\n    _purchasingAllowed = 1;\n}\n\nfunction symbol() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & 0x4741540000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction totalBonusTokensIssued() public nonPayable { \n    return _totalBonusTokensIssued;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 >= 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x1610B0x814;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction tokenSellCap() public nonPayable { \n    return 0x26c62ad77dc602dae000000;\n}\n\nfunction gatFoundDeposit() public nonPayable { \n    return _gatFoundDeposit;\n}\n\nfunction refundDeadLine() public nonPayable { \n    return _refundDeadLine;\n}\n\nfunction getStats() public nonPayable { \n    return _totalContribution, _totalSupply, _totalBonusTokensIssued, _purchasingAllowed;\n}\n\nfunction sendSurplusTokens() public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    require(0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000) > 0);\n    _balanceOf[_gatFoundDeposit] = _balanceOf[_gatFoundDeposit] + (0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000));\n    emit Transfer(address(this), _gatFoundDeposit, 0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000));\n}\n\nfunction tokenSaleMin() public nonPayable { \n    return 0xe0fe3d8bb9bc7b1000000;\n}\n\nfunction purchasingAllowed() public nonPayable { \n    return _purchasingAllowed;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction withdrawEtherHomeExternal() public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    v0 = _ethFoundDeposit.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xdcf4b8f == function_selector) {\n            totalContribution();\n        } else if (0x14e887e8 == function_selector) {\n            transactionCounter();\n        } else if (0x16f36d74 == function_selector) {\n            withdrawEtherHomeLocal(address);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1ffe4cca == function_selector) {\n            startline();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x30adce0e == function_selector) {\n            etherReceived();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3facdfb6 == function_selector) {\n            gatFund();\n        } else if (0x4172d080 == function_selector) {\n            tokenExchangeRate();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x64acdb77 == function_selector) {\n            disablePurchasing();\n        } else if (0x6f7920fd == function_selector) {\n            tokenCreationCap();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7bb26a1b == function_selector) {\n            ethFoundDeposit();\n        } else if (0x8f580996 == function_selector) {\n            enablePurchasing();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x98b01fe3 == function_selector) {\n            totalBonusTokensIssued();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xadddbacb == function_selector) {\n            tokenSellCap();\n        } else if (0xb6712a4f == function_selector) {\n            gatFoundDeposit();\n        } else if (0xbff7df7c == function_selector) {\n            refundDeadLine();\n        } else if (0xc59d4847 == function_selector) {\n            getStats();\n        } else if (0xd4d37883 == function_selector) {\n            sendSurplusTokens();\n        } else if (0xd873f0d6 == function_selector) {\n            tokenSaleMin();\n        } else if (0xda040c0f == function_selector) {\n            purchasingAllowed();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xfc77060d == function_selector) {\n            withdrawEtherHomeExternal();\n        }\n    }\n    require(_purchasingAllowed);\n    require(0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000) > 0);\n    if (msg.value != 0) {\n        _transactionCounter = _transactionCounter + 1;\n        _totalContribution = _totalContribution + msg.value;\n        v0 = v1 = 0;\n        v2 = v3 = _transactionCounter > 0;\n        if (v3) {\n            v2 = _transactionCounter <= 1000;\n        }\n        if (!v2) {\n            v4 = v5 = _transactionCounter > 1000;\n            if (v5) {\n                v4 = _transactionCounter <= 2000;\n            }\n            if (!v4) {\n                v6 = v7 = _transactionCounter > 2000;\n                if (v7) {\n                    v6 = _transactionCounter <= 3000;\n                }\n                if (!v6) {\n                    v8 = v9 = _transactionCounter > 3000;\n                    if (v9) {\n                        v8 = _transactionCounter <= 5000;\n                    }\n                    if (v8) {\n                        v0 = msg.value / 20;\n                    }\n                } else {\n                    v0 = v10 = msg.value / 10;\n                }\n            } else {\n                v0 = v11 = msg.value / 5;\n            }\n        } else {\n            v0 = v12 = msg.value >> 1;\n        }\n        _totalBonusTokensIssued = _totalBonusTokensIssued + v0;\n        _totalSupply = _totalSupply + (msg.value * 9000 + v0 * 9000);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + (msg.value * 9000 + v0 * 9000);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n        emit Transfer(address(this), msg.sender, msg.value * 9000 + v0 * 9000);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 20:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalContribution; // STORAGE[0x0]\nuint256 _totalBonusTokensIssued; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _deadline; // STORAGE[0x9]\nuint256 _startline; // STORAGE[0xa]\nuint256 _refundDeadLine; // STORAGE[0xb]\nuint256 _transactionCounter; // STORAGE[0xc]\nuint256 _etherReceived; // STORAGE[0xd]\naddress _enablePurchasing; // STORAGE[0x6] bytes 0 to 19\naddress _ethFoundDeposit; // STORAGE[0x7] bytes 0 to 19\nuint160 _gatFoundDeposit; // STORAGE[0x8] bytes 0 to 19\nuint8 _purchasingAllowed; // STORAGE[0x6] bytes 20 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nLogTransaction(address, uint256);\n\nfunction name() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & 'General Advertising Token';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 != 0;\n    if (v1) {\n        v0 = _allowance[varg0] != 0;\n    }\n    if (!v0) {\n        _allowance[varg0] = varg1;\n        emit Approval(msg.sender, varg0, varg1);\n        v2 = v3 = 1;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction totalContribution() public nonPayable { \n    return _totalContribution;\n}\n\nfunction transactionCounter() public nonPayable { \n    return _transactionCounter;\n}\n\nfunction withdrawEtherHomeLocal(address varg0) public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    v0 = varg0.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction startline() public nonPayable { \n    return _startline;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 >= 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n        goto 0x1050B0x50c;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction etherReceived() public nonPayable { \n    return _etherReceived;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction gatFund() public nonPayable { \n    return 0xcecb8f27f4200f3a000000;\n}\n\nfunction tokenExchangeRate() public nonPayable { \n    return 9000;\n}\n\nfunction refund() public nonPayable { \n    require(!_purchasingAllowed);\n    require(block.timestamp < _refundDeadLine);\n    require(_totalSupply - _totalBonusTokensIssued < 0xe0fe3d8bb9bc7b1000000);\n    require(msg.sender != _ethFoundDeposit);\n    require(_balanceOf[msg.sender] > 0);\n    emit LogTransaction(msg.sender, owner_4[msg.sender]);\n    v0 = msg.sender.call().value(owner_4[msg.sender]).gas(!owner_4[msg.sender] * 2300);\n    require(v0);\n    _totalContribution = _totalContribution - owner_4[msg.sender];\n    owner_4[msg.sender] = owner_4[msg.sender] - owner_4[msg.sender];\n}\n\nfunction disablePurchasing() public nonPayable { \n    require(msg.sender == _enablePurchasing);\n    require(_purchasingAllowed);\n    _purchasingAllowed = 0;\n}\n\nfunction tokenCreationCap() public nonPayable { \n    return 0x33b2e3c9fd0803ce8000000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ethFoundDeposit() public nonPayable { \n    return _ethFoundDeposit;\n}\n\nfunction enablePurchasing() public nonPayable { \n    require(msg.sender == _enablePurchasing);\n    require(!_purchasingAllowed);\n    _purchasingAllowed = 1;\n}\n\nfunction symbol() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & 0x4741540000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction totalBonusTokensIssued() public nonPayable { \n    return _totalBonusTokensIssued;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 >= 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x1610B0x814;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction tokenSellCap() public nonPayable { \n    return 0x26c62ad77dc602dae000000;\n}\n\nfunction gatFoundDeposit() public nonPayable { \n    return _gatFoundDeposit;\n}\n\nfunction refundDeadLine() public nonPayable { \n    return _refundDeadLine;\n}\n\nfunction getStats() public nonPayable { \n    return _totalContribution, _totalSupply, _totalBonusTokensIssued, _purchasingAllowed;\n}\n\nfunction sendSurplusTokens() public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    require(0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000) > 0);\n    _balanceOf[_gatFoundDeposit] = _balanceOf[_gatFoundDeposit] + (0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000));\n    emit Transfer(address(this), _gatFoundDeposit, 0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000));\n}\n\nfunction tokenSaleMin() public nonPayable { \n    return 0xe0fe3d8bb9bc7b1000000;\n}\n\nfunction purchasingAllowed() public nonPayable { \n    return _purchasingAllowed;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction withdrawEtherHomeExternal() public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    v0 = _ethFoundDeposit.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xdcf4b8f == function_selector) {\n            totalContribution();\n        } else if (0x14e887e8 == function_selector) {\n            transactionCounter();\n        } else if (0x16f36d74 == function_selector) {\n            withdrawEtherHomeLocal(address);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1ffe4cca == function_selector) {\n            startline();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x30adce0e == function_selector) {\n            etherReceived();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3facdfb6 == function_selector) {\n            gatFund();\n        } else if (0x4172d080 == function_selector) {\n            tokenExchangeRate();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x64acdb77 == function_selector) {\n            disablePurchasing();\n        } else if (0x6f7920fd == function_selector) {\n            tokenCreationCap();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7bb26a1b == function_selector) {\n            ethFoundDeposit();\n        } else if (0x8f580996 == function_selector) {\n            enablePurchasing();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x98b01fe3 == function_selector) {\n            totalBonusTokensIssued();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xadddbacb == function_selector) {\n            tokenSellCap();\n        } else if (0xb6712a4f == function_selector) {\n            gatFoundDeposit();\n        } else if (0xbff7df7c == function_selector) {\n            refundDeadLine();\n        } else if (0xc59d4847 == function_selector) {\n            getStats();\n        } else if (0xd4d37883 == function_selector) {\n            sendSurplusTokens();\n        } else if (0xd873f0d6 == function_selector) {\n            tokenSaleMin();\n        } else if (0xda040c0f == function_selector) {\n            purchasingAllowed();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xfc77060d == function_selector) {\n            withdrawEtherHomeExternal();\n        }\n    }\n    require(_purchasingAllowed);\n    require(0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000) > 0);\n    if (msg.value != 0) {\n        _transactionCounter = _transactionCounter + 1;\n        _totalContribution = _totalContribution + msg.value;\n        v0 = v1 = 0;\n        v2 = v3 = _transactionCounter > 0;\n        if (v3) {\n            v2 = _transactionCounter <= 1000;\n        }\n        if (!v2) {\n            v4 = v5 = _transactionCounter > 1000;\n            if (v5) {\n                v4 = _transactionCounter <= 2000;\n            }\n            if (!v4) {\n                v6 = v7 = _transactionCounter > 2000;\n                if (v7) {\n                    v6 = _transactionCounter <= 3000;\n                }\n                if (!v6) {\n                    v8 = v9 = _transactionCounter > 3000;\n                    if (v9) {\n                        v8 = _transactionCounter <= 5000;\n                    }\n                    if (v8) {\n                        v0 = msg.value / 20;\n                    }\n                } else {\n                    v0 = v10 = msg.value / 10;\n                }\n            } else {\n                v0 = v11 = msg.value / 5;\n            }\n        } else {\n            v0 = v12 = msg.value >> 1;\n        }\n        _totalBonusTokensIssued = _totalBonusTokensIssued + v0;\n        _totalSupply = _totalSupply + (msg.value * 9000 + v0 * 9000);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + (msg.value * 9000 + v0 * 9000);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n        emit Transfer(address(this), msg.sender, msg.value * 9000 + v0 * 9000);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 20:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalContribution; // STORAGE[0x0]\nuint256 _totalBonusTokensIssued; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _deadline; // STORAGE[0x9]\nuint256 _startline; // STORAGE[0xa]\nuint256 _refundDeadLine; // STORAGE[0xb]\nuint256 _transactionCounter; // STORAGE[0xc]\nuint256 _etherReceived; // STORAGE[0xd]\naddress _enablePurchasing; // STORAGE[0x6] bytes 0 to 19\naddress _ethFoundDeposit; // STORAGE[0x7] bytes 0 to 19\nuint160 _gatFoundDeposit; // STORAGE[0x8] bytes 0 to 19\nuint8 _purchasingAllowed; // STORAGE[0x6] bytes 20 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nLogTransaction(address, uint256);\n\nfunction name() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & 'General Advertising Token';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 != 0;\n    if (v1) {\n        v0 = _allowance[varg0] != 0;\n    }\n    if (!v0) {\n        _allowance[varg0] = varg1;\n        emit Approval(msg.sender, varg0, varg1);\n        v2 = v3 = 1;\n    } else {\n        v2 = v4 = 0;\n    }\n    return v2;\n}\n\nfunction totalContribution() public nonPayable { \n    return _totalContribution;\n}\n\nfunction transactionCounter() public nonPayable { \n    return _transactionCounter;\n}\n\nfunction withdrawEtherHomeLocal(address varg0) public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    v0 = varg0.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction startline() public nonPayable { \n    return _startline;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 >= 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n        goto 0x1050B0x50c;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction etherReceived() public nonPayable { \n    return _etherReceived;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction gatFund() public nonPayable { \n    return 0xcecb8f27f4200f3a000000;\n}\n\nfunction tokenExchangeRate() public nonPayable { \n    return 9000;\n}\n\nfunction refund() public nonPayable { \n    require(!_purchasingAllowed);\n    require(block.timestamp < _refundDeadLine);\n    require(_totalSupply - _totalBonusTokensIssued < 0xe0fe3d8bb9bc7b1000000);\n    require(msg.sender != _ethFoundDeposit);\n    require(_balanceOf[msg.sender] > 0);\n    emit LogTransaction(msg.sender, owner_4[msg.sender]);\n    v0 = msg.sender.call().value(owner_4[msg.sender]).gas(!owner_4[msg.sender] * 2300);\n    require(v0);\n    _totalContribution = _totalContribution - owner_4[msg.sender];\n    owner_4[msg.sender] = owner_4[msg.sender] - owner_4[msg.sender];\n}\n\nfunction disablePurchasing() public nonPayable { \n    require(msg.sender == _enablePurchasing);\n    require(_purchasingAllowed);\n    _purchasingAllowed = 0;\n}\n\nfunction tokenCreationCap() public nonPayable { \n    return 0x33b2e3c9fd0803ce8000000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction ethFoundDeposit() public nonPayable { \n    return _ethFoundDeposit;\n}\n\nfunction enablePurchasing() public nonPayable { \n    require(msg.sender == _enablePurchasing);\n    require(!_purchasingAllowed);\n    _purchasingAllowed = 1;\n}\n\nfunction symbol() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & 0x4741540000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction totalBonusTokensIssued() public nonPayable { \n    return _totalBonusTokensIssued;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 >= 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x1610B0x814;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction tokenSellCap() public nonPayable { \n    return 0x26c62ad77dc602dae000000;\n}\n\nfunction gatFoundDeposit() public nonPayable { \n    return _gatFoundDeposit;\n}\n\nfunction refundDeadLine() public nonPayable { \n    return _refundDeadLine;\n}\n\nfunction getStats() public nonPayable { \n    return _totalContribution, _totalSupply, _totalBonusTokensIssued, _purchasingAllowed;\n}\n\nfunction sendSurplusTokens() public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    require(0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000) > 0);\n    _balanceOf[_gatFoundDeposit] = _balanceOf[_gatFoundDeposit] + (0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000));\n    emit Transfer(address(this), _gatFoundDeposit, 0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000));\n}\n\nfunction tokenSaleMin() public nonPayable { \n    return 0xe0fe3d8bb9bc7b1000000;\n}\n\nfunction purchasingAllowed() public nonPayable { \n    return _purchasingAllowed;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction withdrawEtherHomeExternal() public nonPayable { \n    require(!_purchasingAllowed);\n    require(msg.sender == _enablePurchasing);\n    v0 = _ethFoundDeposit.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xdcf4b8f == function_selector) {\n            totalContribution();\n        } else if (0x14e887e8 == function_selector) {\n            transactionCounter();\n        } else if (0x16f36d74 == function_selector) {\n            withdrawEtherHomeLocal(address);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1ffe4cca == function_selector) {\n            startline();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x30adce0e == function_selector) {\n            etherReceived();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3facdfb6 == function_selector) {\n            gatFund();\n        } else if (0x4172d080 == function_selector) {\n            tokenExchangeRate();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x64acdb77 == function_selector) {\n            disablePurchasing();\n        } else if (0x6f7920fd == function_selector) {\n            tokenCreationCap();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7bb26a1b == function_selector) {\n            ethFoundDeposit();\n        } else if (0x8f580996 == function_selector) {\n            enablePurchasing();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x98b01fe3 == function_selector) {\n            totalBonusTokensIssued();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xadddbacb == function_selector) {\n            tokenSellCap();\n        } else if (0xb6712a4f == function_selector) {\n            gatFoundDeposit();\n        } else if (0xbff7df7c == function_selector) {\n            refundDeadLine();\n        } else if (0xc59d4847 == function_selector) {\n            getStats();\n        } else if (0xd4d37883 == function_selector) {\n            sendSurplusTokens();\n        } else if (0xd873f0d6 == function_selector) {\n            tokenSaleMin();\n        } else if (0xda040c0f == function_selector) {\n            purchasingAllowed();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xfc77060d == function_selector) {\n            withdrawEtherHomeExternal();\n        }\n    }\n    require(_purchasingAllowed);\n    require(0x33b2e3c9fd0803ce8000000 - (_totalSupply + 0xcecb8f27f4200f3a000000) > 0);\n    if (msg.value != 0) {\n        _transactionCounter = _transactionCounter + 1;\n        _totalContribution = _totalContribution + msg.value;\n        v0 = v1 = 0;\n        v2 = v3 = _transactionCounter > 0;\n        if (v3) {\n            v2 = _transactionCounter <= 1000;\n        }\n        if (!v2) {\n            v4 = v5 = _transactionCounter > 1000;\n            if (v5) {\n                v4 = _transactionCounter <= 2000;\n            }\n            if (!v4) {\n                v6 = v7 = _transactionCounter > 2000;\n                if (v7) {\n                    v6 = _transactionCounter <= 3000;\n                }\n                if (!v6) {\n                    v8 = v9 = _transactionCounter > 3000;\n                    if (v9) {\n                        v8 = _transactionCounter <= 5000;\n                    }\n                    if (v8) {\n                        v0 = msg.value / 20;\n                    }\n                } else {\n                    v0 = v10 = msg.value / 10;\n                }\n            } else {\n                v0 = v11 = msg.value / 5;\n            }\n        } else {\n            v0 = v12 = msg.value >> 1;\n        }\n        _totalBonusTokensIssued = _totalBonusTokensIssued + v0;\n        _totalSupply = _totalSupply + (msg.value * 9000 + v0 * 9000);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + (msg.value * 9000 + v0 * 9000);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n        emit Transfer(address(this), msg.sender, msg.value * 9000 + v0 * 9000);\n    }\n}\n.",
	"status": "1",
	"time_cost": 45.66794228553772,
	"usage": {
		"completion_tokens": 562,
		"prompt_tokens": 3358,
		"total_tokens": 3920
	}
}