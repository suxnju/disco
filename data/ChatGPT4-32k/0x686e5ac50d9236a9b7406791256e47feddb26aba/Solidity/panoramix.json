{
	"address": "0x686e5ac50d9236a9b7406791256e47feddb26aba",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given that the decompiled code is quite complex and incomplete in certain places, this is a simplified version of a Solidity contract that reflects the main functionalities described in the decompiled code:\n\n```solidity\npragma solidity ^0.5.17;\n\ncontract MyContract {\n    address public owner;\n    address public newOwner;\n    address public smartTokenAddress;\n    address public reserveTokenAddress;\n    address public auctionsAddress;\n    bool public initialized = false;\n\n    event OwnershipChanged(address indexed prevOwner, address indexed newOwner);\n    event LogFundsIn(address indexed from, uint256 value);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function changeOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != owner);\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipChanged(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function init(address _reserveToken, address _smartToken, address _auctions) public onlyOwner {\n        require(!initialized);\n        reserveTokenAddress = _reserveToken;\n        smartTokenAddress = _smartToken;\n        auctionsAddress = _auctions;\n        initialized = true;\n    }\n\n    function handleFund() payable public {\n        require(msg.sender == auctionsAddress);\n        emit LogFundsIn(msg.sender, msg.value);\n    }\n\n    // Other functions related to converting Eth to Met, Met to Eth, and getting results for both conversions are omitted for brevity\n}\n```\nPlease note that the decompiled code contains several complex computations and calls to external contracts which are not specified. The omitted functions related to converting Eth to Met, Met to Eth, and getting results for both conversions would require further information on the specific logic and interfaces of the external contracts involved.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472516,
	"id": "chatcmpl-8Mus0ItvduqEaTwQq88XsHeEVgbrX",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst getEthBalance = eth.balance(this.address)\n\ndef storage:\n  owner is address at storage 0\n  newOwner is address at storage 1\n  smartTokenAddress is address at storage 2\n  reserveTokenAddress is address at storage 3\n  stor4 is uint8 at storage 4 offset 160\n  auctionsAddress is address at storage 4\n\ndef auctions(): # not payable\n  return auctionsAddress\n\ndef owner(): # not payable\n  return owner\n\ndef smartToken(): # not payable\n  return smartTokenAddress\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef reserveToken(): # not payable\n  return reserveTokenAddress\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef changeOwnership(address _newOwner): # not payable\n  require owner == caller\n  require owner != _newOwner\n  newOwner = _newOwner\n  return 1\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnershipChanged(\n        address prevOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n  return 1\n\ndef getMetBalance(): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  return ext_call.return_data[0]\n\ndef init(address _uniPool, address _extPool, address _sfToken) payable: \n  require owner == caller\n  require not stor4\n  reserveTokenAddress = _uniPool\n  smartTokenAddress = _extPool\n  auctionsAddress = _sfToken\n  stor4 = 1\n\ndef handleFund() payable: \n  require ext_code.size(auctionsAddress)\n  call auctionsAddress.proceeds() with:\n       gas gas_remaining wei\n  require ext_call.success\n  require caller == ext_call.return_data[12 len 20]\n  log LogFundsIn(\n        address from=call.value,\n        uint256 value=caller)\n\ndef convertEthToMet(uint256 _mintReturn) payable: \n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not call.value:\n      if eth.balance(this.address):\n          if (0 / eth.balance(this.address)) + 10^18 >= 10^18:\n              if (0 / eth.balance(this.address)) + 10^18:\n                  require (2 * 10^18 * 0 / eth.balance(this.address)) + (0 / eth.balance(this.address) * 0 / eth.balance(this.address)) + 1000000000000000000 * 10^18 / (0 / eth.balance(this.address)) + 10^18 == (0 / eth.balance(this.address)) + 10^18\n                  if var73001 <= (0 / eth.balance(this.address)) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * call.value / call.value == 10^18:\n          if eth.balance(this.address):\n              if (10^18 * call.value / eth.balance(this.address)) + 10^18 >= 10^18:\n                  if (10^18 * call.value / eth.balance(this.address)) + 10^18:\n                      require (2 * 10^18 * 10^18 * call.value / eth.balance(this.address)) + (10^18 * call.value / eth.balance(this.address) * 10^18 * call.value / eth.balance(this.address)) + 1000000000000000000 * 10^18 / (10^18 * call.value / eth.balance(this.address)) + 10^18 == (10^18 * call.value / eth.balance(this.address)) + 10^18\n                      if var75001 <= (10^18 * call.value / eth.balance(this.address)) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef convertMetToEth(uint256 _amount, uint256 _mintReturn): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args caller, address(this.address), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  if not _amount:\n      if ext_call.return_data[0]:\n          if (0 / ext_call.return_data[0]) + 10^18 >= 10^18:\n              if (0 / ext_call.return_data[0]) + 10^18:\n                  require (2 * 10^18 * 0 / ext_call.return_data[0]) + (0 / ext_call.return_data[0] * 0 / ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (0 / ext_call.return_data[0]) + 10^18 == (0 / ext_call.return_data[0]) + 10^18\n                  if var81001 <= (0 / ext_call.return_data[0]) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _amount / _amount == 10^18:\n          if ext_call.return_data[0]:\n              if (10^18 * _amount / ext_call.return_data[0]) + 10^18 >= 10^18:\n                  if (10^18 * _amount / ext_call.return_data[0]) + 10^18:\n                      require (2 * 10^18 * 10^18 * _amount / ext_call.return_data[0]) + (10^18 * _amount / ext_call.return_data[0] * 10^18 * _amount / ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (10^18 * _amount / ext_call.return_data[0]) + 10^18 == (10^18 * _amount / ext_call.return_data[0]) + 10^18\n                      if var83001 <= (10^18 * _amount / ext_call.return_data[0]) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef getMetForEthResult(uint256 _depositAmount): # not payable\n  require _depositAmount + eth.balance(this.address) >= eth.balance(this.address)\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not _depositAmount:\n      if _depositAmount + eth.balance(this.address):\n          if (0 / _depositAmount + eth.balance(this.address)) + 10^18 >= 10^18:\n              if (0 / _depositAmount + eth.balance(this.address)) + 10^18:\n                  require (2 * 10^18 * 0 / _depositAmount + eth.balance(this.address)) + (0 / _depositAmount + eth.balance(this.address) * 0 / _depositAmount + eth.balance(this.address)) + 1000000000000000000 * 10^18 / (0 / _depositAmount + eth.balance(this.address)) + 10^18 == (0 / _depositAmount + eth.balance(this.address)) + 10^18\n                  if var75001 <= (0 / _depositAmount + eth.balance(this.address)) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _depositAmount / _depositAmount == 10^18:\n          if _depositAmount + eth.balance(this.address):\n              if (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18 >= 10^18:\n                  if (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18:\n                      require (2 * 10^18 * 10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + (10^18 * _depositAmount / _depositAmount + eth.balance(this.address) * 10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 1000000000000000000 * 10^18 / (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18 == (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18\n                      if var77001 <= (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef getEthForMetResult(uint256 _depositAmount): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  require _depositAmount + ext_call.return_data[0] >= ext_call.return_data[0]\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not _depositAmount:\n      if _depositAmount + ext_call.return_data[0]:\n          if (0 / _depositAmount + ext_call.return_data[0]) + 10^18 >= 10^18:\n              if (0 / _depositAmount + ext_call.return_data[0]) + 10^18:\n                  require (2 * 10^18 * 0 / _depositAmount + ext_call.return_data[0]) + (0 / _depositAmount + ext_call.return_data[0] * 0 / _depositAmount + ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (0 / _depositAmount + ext_call.return_data[0]) + 10^18 == (0 / _depositAmount + ext_call.return_data[0]) + 10^18\n                  if var80001 <= (0 / _depositAmount + ext_call.return_data[0]) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _depositAmount / _depositAmount == 10^18:\n          if _depositAmount + ext_call.return_data[0]:\n              if (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18 >= 10^18:\n                  if (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18:\n                      require (2 * 10^18 * 10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0] * 10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18 == (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18\n                      if var82001 <= (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst getEthBalance = eth.balance(this.address)\n\ndef storage:\n  owner is address at storage 0\n  newOwner is address at storage 1\n  smartTokenAddress is address at storage 2\n  reserveTokenAddress is address at storage 3\n  stor4 is uint8 at storage 4 offset 160\n  auctionsAddress is address at storage 4\n\ndef auctions(): # not payable\n  return auctionsAddress\n\ndef owner(): # not payable\n  return owner\n\ndef smartToken(): # not payable\n  return smartTokenAddress\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef reserveToken(): # not payable\n  return reserveTokenAddress\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef changeOwnership(address _newOwner): # not payable\n  require owner == caller\n  require owner != _newOwner\n  newOwner = _newOwner\n  return 1\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnershipChanged(\n        address prevOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n  return 1\n\ndef getMetBalance(): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  return ext_call.return_data[0]\n\ndef init(address _uniPool, address _extPool, address _sfToken) payable: \n  require owner == caller\n  require not stor4\n  reserveTokenAddress = _uniPool\n  smartTokenAddress = _extPool\n  auctionsAddress = _sfToken\n  stor4 = 1\n\ndef handleFund() payable: \n  require ext_code.size(auctionsAddress)\n  call auctionsAddress.proceeds() with:\n       gas gas_remaining wei\n  require ext_call.success\n  require caller == ext_call.return_data[12 len 20]\n  log LogFundsIn(\n        address from=call.value,\n        uint256 value=caller)\n\ndef convertEthToMet(uint256 _mintReturn) payable: \n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not call.value:\n      if eth.balance(this.address):\n          if (0 / eth.balance(this.address)) + 10^18 >= 10^18:\n              if (0 / eth.balance(this.address)) + 10^18:\n                  require (2 * 10^18 * 0 / eth.balance(this.address)) + (0 / eth.balance(this.address) * 0 / eth.balance(this.address)) + 1000000000000000000 * 10^18 / (0 / eth.balance(this.address)) + 10^18 == (0 / eth.balance(this.address)) + 10^18\n                  if var73001 <= (0 / eth.balance(this.address)) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * call.value / call.value == 10^18:\n          if eth.balance(this.address):\n              if (10^18 * call.value / eth.balance(this.address)) + 10^18 >= 10^18:\n                  if (10^18 * call.value / eth.balance(this.address)) + 10^18:\n                      require (2 * 10^18 * 10^18 * call.value / eth.balance(this.address)) + (10^18 * call.value / eth.balance(this.address) * 10^18 * call.value / eth.balance(this.address)) + 1000000000000000000 * 10^18 / (10^18 * call.value / eth.balance(this.address)) + 10^18 == (10^18 * call.value / eth.balance(this.address)) + 10^18\n                      if var75001 <= (10^18 * call.value / eth.balance(this.address)) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef convertMetToEth(uint256 _amount, uint256 _mintReturn): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args caller, address(this.address), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  if not _amount:\n      if ext_call.return_data[0]:\n          if (0 / ext_call.return_data[0]) + 10^18 >= 10^18:\n              if (0 / ext_call.return_data[0]) + 10^18:\n                  require (2 * 10^18 * 0 / ext_call.return_data[0]) + (0 / ext_call.return_data[0] * 0 / ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (0 / ext_call.return_data[0]) + 10^18 == (0 / ext_call.return_data[0]) + 10^18\n                  if var81001 <= (0 / ext_call.return_data[0]) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _amount / _amount == 10^18:\n          if ext_call.return_data[0]:\n              if (10^18 * _amount / ext_call.return_data[0]) + 10^18 >= 10^18:\n                  if (10^18 * _amount / ext_call.return_data[0]) + 10^18:\n                      require (2 * 10^18 * 10^18 * _amount / ext_call.return_data[0]) + (10^18 * _amount / ext_call.return_data[0] * 10^18 * _amount / ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (10^18 * _amount / ext_call.return_data[0]) + 10^18 == (10^18 * _amount / ext_call.return_data[0]) + 10^18\n                      if var83001 <= (10^18 * _amount / ext_call.return_data[0]) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef getMetForEthResult(uint256 _depositAmount): # not payable\n  require _depositAmount + eth.balance(this.address) >= eth.balance(this.address)\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not _depositAmount:\n      if _depositAmount + eth.balance(this.address):\n          if (0 / _depositAmount + eth.balance(this.address)) + 10^18 >= 10^18:\n              if (0 / _depositAmount + eth.balance(this.address)) + 10^18:\n                  require (2 * 10^18 * 0 / _depositAmount + eth.balance(this.address)) + (0 / _depositAmount + eth.balance(this.address) * 0 / _depositAmount + eth.balance(this.address)) + 1000000000000000000 * 10^18 / (0 / _depositAmount + eth.balance(this.address)) + 10^18 == (0 / _depositAmount + eth.balance(this.address)) + 10^18\n                  if var75001 <= (0 / _depositAmount + eth.balance(this.address)) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _depositAmount / _depositAmount == 10^18:\n          if _depositAmount + eth.balance(this.address):\n              if (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18 >= 10^18:\n                  if (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18:\n                      require (2 * 10^18 * 10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + (10^18 * _depositAmount / _depositAmount + eth.balance(this.address) * 10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 1000000000000000000 * 10^18 / (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18 == (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18\n                      if var77001 <= (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef getEthForMetResult(uint256 _depositAmount): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  require _depositAmount + ext_call.return_data[0] >= ext_call.return_data[0]\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not _depositAmount:\n      if _depositAmount + ext_call.return_data[0]:\n          if (0 / _depositAmount + ext_call.return_data[0]) + 10^18 >= 10^18:\n              if (0 / _depositAmount + ext_call.return_data[0]) + 10^18:\n                  require (2 * 10^18 * 0 / _depositAmount + ext_call.return_data[0]) + (0 / _depositAmount + ext_call.return_data[0] * 0 / _depositAmount + ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (0 / _depositAmount + ext_call.return_data[0]) + 10^18 == (0 / _depositAmount + ext_call.return_data[0]) + 10^18\n                  if var80001 <= (0 / _depositAmount + ext_call.return_data[0]) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _depositAmount / _depositAmount == 10^18:\n          if _depositAmount + ext_call.return_data[0]:\n              if (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18 >= 10^18:\n                  if (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18:\n                      require (2 * 10^18 * 10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0] * 10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18 == (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18\n                      if var82001 <= (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst getEthBalance = eth.balance(this.address)\n\ndef storage:\n  owner is address at storage 0\n  newOwner is address at storage 1\n  smartTokenAddress is address at storage 2\n  reserveTokenAddress is address at storage 3\n  stor4 is uint8 at storage 4 offset 160\n  auctionsAddress is address at storage 4\n\ndef auctions(): # not payable\n  return auctionsAddress\n\ndef owner(): # not payable\n  return owner\n\ndef smartToken(): # not payable\n  return smartTokenAddress\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef reserveToken(): # not payable\n  return reserveTokenAddress\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef changeOwnership(address _newOwner): # not payable\n  require owner == caller\n  require owner != _newOwner\n  newOwner = _newOwner\n  return 1\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnershipChanged(\n        address prevOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n  return 1\n\ndef getMetBalance(): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  return ext_call.return_data[0]\n\ndef init(address _uniPool, address _extPool, address _sfToken) payable: \n  require owner == caller\n  require not stor4\n  reserveTokenAddress = _uniPool\n  smartTokenAddress = _extPool\n  auctionsAddress = _sfToken\n  stor4 = 1\n\ndef handleFund() payable: \n  require ext_code.size(auctionsAddress)\n  call auctionsAddress.proceeds() with:\n       gas gas_remaining wei\n  require ext_call.success\n  require caller == ext_call.return_data[12 len 20]\n  log LogFundsIn(\n        address from=call.value,\n        uint256 value=caller)\n\ndef convertEthToMet(uint256 _mintReturn) payable: \n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not call.value:\n      if eth.balance(this.address):\n          if (0 / eth.balance(this.address)) + 10^18 >= 10^18:\n              if (0 / eth.balance(this.address)) + 10^18:\n                  require (2 * 10^18 * 0 / eth.balance(this.address)) + (0 / eth.balance(this.address) * 0 / eth.balance(this.address)) + 1000000000000000000 * 10^18 / (0 / eth.balance(this.address)) + 10^18 == (0 / eth.balance(this.address)) + 10^18\n                  if var73001 <= (0 / eth.balance(this.address)) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * call.value / call.value == 10^18:\n          if eth.balance(this.address):\n              if (10^18 * call.value / eth.balance(this.address)) + 10^18 >= 10^18:\n                  if (10^18 * call.value / eth.balance(this.address)) + 10^18:\n                      require (2 * 10^18 * 10^18 * call.value / eth.balance(this.address)) + (10^18 * call.value / eth.balance(this.address) * 10^18 * call.value / eth.balance(this.address)) + 1000000000000000000 * 10^18 / (10^18 * call.value / eth.balance(this.address)) + 10^18 == (10^18 * call.value / eth.balance(this.address)) + 10^18\n                      if var75001 <= (10^18 * call.value / eth.balance(this.address)) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef convertMetToEth(uint256 _amount, uint256 _mintReturn): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args caller, address(this.address), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  if not _amount:\n      if ext_call.return_data[0]:\n          if (0 / ext_call.return_data[0]) + 10^18 >= 10^18:\n              if (0 / ext_call.return_data[0]) + 10^18:\n                  require (2 * 10^18 * 0 / ext_call.return_data[0]) + (0 / ext_call.return_data[0] * 0 / ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (0 / ext_call.return_data[0]) + 10^18 == (0 / ext_call.return_data[0]) + 10^18\n                  if var81001 <= (0 / ext_call.return_data[0]) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _amount / _amount == 10^18:\n          if ext_call.return_data[0]:\n              if (10^18 * _amount / ext_call.return_data[0]) + 10^18 >= 10^18:\n                  if (10^18 * _amount / ext_call.return_data[0]) + 10^18:\n                      require (2 * 10^18 * 10^18 * _amount / ext_call.return_data[0]) + (10^18 * _amount / ext_call.return_data[0] * 10^18 * _amount / ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (10^18 * _amount / ext_call.return_data[0]) + 10^18 == (10^18 * _amount / ext_call.return_data[0]) + 10^18\n                      if var83001 <= (10^18 * _amount / ext_call.return_data[0]) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef getMetForEthResult(uint256 _depositAmount): # not payable\n  require _depositAmount + eth.balance(this.address) >= eth.balance(this.address)\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not _depositAmount:\n      if _depositAmount + eth.balance(this.address):\n          if (0 / _depositAmount + eth.balance(this.address)) + 10^18 >= 10^18:\n              if (0 / _depositAmount + eth.balance(this.address)) + 10^18:\n                  require (2 * 10^18 * 0 / _depositAmount + eth.balance(this.address)) + (0 / _depositAmount + eth.balance(this.address) * 0 / _depositAmount + eth.balance(this.address)) + 1000000000000000000 * 10^18 / (0 / _depositAmount + eth.balance(this.address)) + 10^18 == (0 / _depositAmount + eth.balance(this.address)) + 10^18\n                  if var75001 <= (0 / _depositAmount + eth.balance(this.address)) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _depositAmount / _depositAmount == 10^18:\n          if _depositAmount + eth.balance(this.address):\n              if (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18 >= 10^18:\n                  if (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18:\n                      require (2 * 10^18 * 10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + (10^18 * _depositAmount / _depositAmount + eth.balance(this.address) * 10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 1000000000000000000 * 10^18 / (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18 == (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 10^18\n                      if var77001 <= (10^18 * _depositAmount / _depositAmount + eth.balance(this.address)) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\ndef getEthForMetResult(uint256 _depositAmount): # not payable\n  require ext_code.size(reserveTokenAddress)\n  call reserveTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  require ext_call.success\n  require _depositAmount + ext_call.return_data[0] >= ext_call.return_data[0]\n  require ext_code.size(smartTokenAddress)\n  call smartTokenAddress.totalSupply() with:\n       gas gas_remaining wei\n  require ext_call.success\n  if not _depositAmount:\n      if _depositAmount + ext_call.return_data[0]:\n          if (0 / _depositAmount + ext_call.return_data[0]) + 10^18 >= 10^18:\n              if (0 / _depositAmount + ext_call.return_data[0]) + 10^18:\n                  require (2 * 10^18 * 0 / _depositAmount + ext_call.return_data[0]) + (0 / _depositAmount + ext_call.return_data[0] * 0 / _depositAmount + ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (0 / _depositAmount + ext_call.return_data[0]) + 10^18 == (0 / _depositAmount + ext_call.return_data[0]) + 10^18\n                  if var80001 <= (0 / _depositAmount + ext_call.return_data[0]) + 2 * 10^18:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  else:\n      if 10^18 * _depositAmount / _depositAmount == 10^18:\n          if _depositAmount + ext_call.return_data[0]:\n              if (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18 >= 10^18:\n                  if (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18:\n                      require (2 * 10^18 * 10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0] * 10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 1000000000000000000 * 10^18 / (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18 == (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 10^18\n                      if var82001 <= (10^18 * _depositAmount / _depositAmount + ext_call.return_data[0]) + 2 * 10^18:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  revert\n\n.",
	"status": "1",
	"time_cost": 35.792468786239624,
	"usage": {
		"completion_tokens": 391,
		"prompt_tokens": 2714,
		"total_tokens": 3105
	}
}