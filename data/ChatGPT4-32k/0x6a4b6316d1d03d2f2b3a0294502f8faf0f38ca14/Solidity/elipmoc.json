{
	"address": "0x6a4b6316d1d03d2f2b3a0294502f8faf0f38ca14",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "From the decompiled code, it looks like the contract is a token contract with functions for transferring tokens, approving spenders, purchasing tokens, converting between WEI and tokens, and others. Here is a simplified Solidity version of the contract:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Token {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    uint256 private _currentSupply;\n    uint256 private _weiDeposited;\n    address private _owner;\n    uint8 private _decimals;\n    string private _name;\n    string private _symbol;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_, uint256 totalSupply_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        _totalSupply = totalSupply_;\n        _owner = msg.sender;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(_balances[msg.sender] >= amount, \"Insufficient balance\");\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_balances[sender] >= amount, \"Insufficient balance\");\n        require(_allowances[sender][msg.sender] >= amount, \"Insufficient allowance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // Additional functions for purchasing tokens, converting between WEI and tokens, etc.\n}\n```\n\nRemember, the provided decompiled code has been greatly simplified, and does not include all functionality present in the original contract. For example, it omits the logic for handling the token's symbol, name, and decimals, as well as functionality for purchasing tokens, converting between WEI and tokens, and others. Additionally, the contract in the original decompiled code uses low-level operations and does not follow the ERC20 standard.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459695,
	"id": "chatcmpl-8R3gFx0dbgUROaOapD7wPrARix9u9",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 21:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x1]\nuint256[] _name; // STORAGE[0x2]\nuint256 __totalSupply; // STORAGE[0x5]\nuint256 __currentSupply; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x9]\nuint256 _weiDeposited; // STORAGE[0xa]\nuint160 _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction 0x1764(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg2);\n    _balanceOf[v1] = _balanceOf[v0] - varg0;\n    v2 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v3 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    if (address(varg1) == 0) {\n        if (address(varg1) == 0) {\n            require(varg0 <= __currentSupply);\n            __currentSupply = __currentSupply - varg0;\n        }\n    } else {\n        v4 = address(varg1);\n        v5 = _balanceOf[v4] + varg0;\n        require(v5 >= _balanceOf[v4]);\n        v6 = address(varg1);\n        _balanceOf[v6] = v5;\n    }\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction 0x1ae1(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    if (address(varg1) == 0) {\n        if (address(varg1) == 0) {\n            require(varg0 <= __currentSupply);\n            __currentSupply = __currentSupply - varg0;\n        }\n    } else {\n        v0 = address(varg1);\n        v1 = _balanceOf[v0] + varg0;\n        require(v1 >= _balanceOf[v0]);\n        v2 = address(varg1);\n        _balanceOf[v2] = v1;\n    }\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    require(v0, 'Zero transfer or not enough (allowed) funds');\n    require(varg1 != 0, 'No burning allowed');\n    require(varg0 != 0, \"You can't mint this token, purchase it instead\");\n    v4 = _SafeDiv(50, varg2);\n    require(v4 <= varg2);\n    v5 = 0x1764(varg2 - v4, varg1, varg0);\n    v6 = 0x1764(v4, 0, varg0);\n    return 0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction purchaseTokens() public payable { \n    require(msg.value > 0);\n    v0 = v1 = msg.value;\n    v2 = v3 = __currentSupply == 0;\n    if (v3) {\n        v2 = v4 = _weiDeposited == 0;\n    }\n    if (!v2) {\n        v5 = v6 = _weiDeposited == 0;\n        if (_weiDeposited != 0) {\n            v5 = v7 = __currentSupply == 0;\n        }\n        if (!v5) {\n            v5 = v8 = v1 == 0;\n        }\n        if (!v5) {\n            v9 = _SafeMul(__currentSupply, v1);\n            v0 = v10 = _SafeDiv(_weiDeposited, v9);\n        } else {\n            v0 = v11 = 0;\n        }\n    }\n    require(__currentSupply + v0 >= __currentSupply);\n    require(__currentSupply + v0 <= __totalSupply, 'We have reached our contract limit');\n    require(v0 > 0);\n    emit Transfer(0, msg.sender, v0);\n    require(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    require(__currentSupply + v0 >= __currentSupply);\n    __currentSupply = __currentSupply + v0;\n    require(_weiDeposited + msg.value >= _weiDeposited);\n    _weiDeposited = _weiDeposited + msg.value;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction weiToTokens(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = __currentSupply == 0;\n    if (v1) {\n        v0 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v2 = v3 = _weiDeposited == 0;\n        if (_weiDeposited != 0) {\n            v2 = v4 = __currentSupply == 0;\n        }\n        if (!v2) {\n            v2 = varg0 == 0;\n        }\n        if (!v2) {\n            v5 = _SafeMul(__currentSupply, varg0);\n            v6 = v7 = _SafeDiv(_weiDeposited, v5);\n        } else {\n            v6 = v8 = 0;\n        }\n    }\n    return v6;\n}\n\nfunction weiDeposited() public nonPayable { \n    return _weiDeposited;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction tokensToWei(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = v2 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v0 = __currentSupply == 0;\n    }\n    if (!v0) {\n        v3 = _SafeMul(varg0, _weiDeposited);\n        v4 = _SafeDiv(__currentSupply, v3);\n        v5 = _SafeDiv(50, v4);\n        require(v5 <= v4);\n        v6 = v4 - v5;\n    } else {\n        v6 = v7 = 0;\n    }\n    return v6;\n}\n\nfunction purchaseEth(uint256 tokens) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(tokens > 0);\n    v0 = 0xf03(tokens);\n    require(v0 > 0);\n    emit Transfer(msg.sender, 0, tokens);\n    require(tokens <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - tokens;\n    require(tokens <= __currentSupply);\n    __currentSupply = __currentSupply - tokens;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(v0 <= _weiDeposited);\n    _weiDeposited = _weiDeposited - v0;\n}\n\nfunction currentSupply() public nonPayable { \n    return __currentSupply;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _currentSupply() public nonPayable { \n    return __currentSupply;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 > 0;\n    }\n    require(v0, 'Zero transfer or not enough funds');\n    require(varg0 != 0, 'No burning allowed');\n    require(msg.sender != 0, \"You can't mint this token, purchase it instead\");\n    v3 = _SafeDiv(50, varg1);\n    require(v3 <= varg1);\n    v4 = 0x1ae1(varg1 - v3, varg0);\n    v5 = 0x1ae1(v3, 0);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sellAllTokens() public nonPayable { \n    require(_balanceOf[msg.sender] > 0);\n    v0 = 0xf03(_balanceOf[msg.sender]);\n    require(v0 > 0);\n    emit Transfer(msg.sender, 0, _balanceOf[msg.sender]);\n    require(_balanceOf[msg.sender] <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - _balanceOf[msg.sender];\n    require(_balanceOf[msg.sender] <= __currentSupply);\n    __currentSupply = __currentSupply - _balanceOf[msg.sender];\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(v0 <= _weiDeposited);\n    _weiDeposited = _weiDeposited - v0;\n}\n\nfunction 0xf03(uint256 varg0) private { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = v2 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v0 = __currentSupply == 0;\n    }\n    if (!v0) {\n        v3 = _SafeMul(varg0, _weiDeposited);\n        v4 = _SafeDiv(__currentSupply, v3);\n        v5 = _SafeDiv(50, v4);\n        require(v5 <= v4);\n        v6 = v4 - v5;\n    } else {\n        v6 = v7 = 0;\n    }\n    return v6;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x7346ec57 > function_selector >> 224) {\n            if (0x3290ce29 > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector >> 224) {\n                    transferFrom(address,address,uint256);\n                } else if (0x313ce567 == function_selector >> 224) {\n                    decimals();\n                }\n            } else if (0x3290ce29 == function_selector >> 224) {\n                purchaseTokens();\n            } else if (0x3eaaf86b == function_selector >> 224) {\n                _totalSupply();\n            } else if (0x53aaef7d == function_selector >> 224) {\n                weiToTokens(uint256);\n            } else if (0x65302f68 == function_selector >> 224) {\n                weiDeposited();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xa4fefad6 > function_selector >> 224) {\n            if (0x7346ec57 == function_selector >> 224) {\n                tokensToWei(uint256);\n            } else if (0x7439011e == function_selector >> 224) {\n                0x7439011e();\n            } else if (0x771282f6 == function_selector >> 224) {\n                currentSupply();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            }\n        } else if (0xa4fefad6 == function_selector >> 224) {\n            _currentSupply();\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector >> 224) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe867a136 == function_selector >> 224) {\n            sellAllTokens();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 21:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x1]\nuint256[] _name; // STORAGE[0x2]\nuint256 __totalSupply; // STORAGE[0x5]\nuint256 __currentSupply; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x9]\nuint256 _weiDeposited; // STORAGE[0xa]\nuint160 _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction 0x1764(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg2);\n    _balanceOf[v1] = _balanceOf[v0] - varg0;\n    v2 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v3 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    if (address(varg1) == 0) {\n        if (address(varg1) == 0) {\n            require(varg0 <= __currentSupply);\n            __currentSupply = __currentSupply - varg0;\n        }\n    } else {\n        v4 = address(varg1);\n        v5 = _balanceOf[v4] + varg0;\n        require(v5 >= _balanceOf[v4]);\n        v6 = address(varg1);\n        _balanceOf[v6] = v5;\n    }\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction 0x1ae1(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    if (address(varg1) == 0) {\n        if (address(varg1) == 0) {\n            require(varg0 <= __currentSupply);\n            __currentSupply = __currentSupply - varg0;\n        }\n    } else {\n        v0 = address(varg1);\n        v1 = _balanceOf[v0] + varg0;\n        require(v1 >= _balanceOf[v0]);\n        v2 = address(varg1);\n        _balanceOf[v2] = v1;\n    }\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    require(v0, 'Zero transfer or not enough (allowed) funds');\n    require(varg1 != 0, 'No burning allowed');\n    require(varg0 != 0, \"You can't mint this token, purchase it instead\");\n    v4 = _SafeDiv(50, varg2);\n    require(v4 <= varg2);\n    v5 = 0x1764(varg2 - v4, varg1, varg0);\n    v6 = 0x1764(v4, 0, varg0);\n    return 0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction purchaseTokens() public payable { \n    require(msg.value > 0);\n    v0 = v1 = msg.value;\n    v2 = v3 = __currentSupply == 0;\n    if (v3) {\n        v2 = v4 = _weiDeposited == 0;\n    }\n    if (!v2) {\n        v5 = v6 = _weiDeposited == 0;\n        if (_weiDeposited != 0) {\n            v5 = v7 = __currentSupply == 0;\n        }\n        if (!v5) {\n            v5 = v8 = v1 == 0;\n        }\n        if (!v5) {\n            v9 = _SafeMul(__currentSupply, v1);\n            v0 = v10 = _SafeDiv(_weiDeposited, v9);\n        } else {\n            v0 = v11 = 0;\n        }\n    }\n    require(__currentSupply + v0 >= __currentSupply);\n    require(__currentSupply + v0 <= __totalSupply, 'We have reached our contract limit');\n    require(v0 > 0);\n    emit Transfer(0, msg.sender, v0);\n    require(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    require(__currentSupply + v0 >= __currentSupply);\n    __currentSupply = __currentSupply + v0;\n    require(_weiDeposited + msg.value >= _weiDeposited);\n    _weiDeposited = _weiDeposited + msg.value;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction weiToTokens(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = __currentSupply == 0;\n    if (v1) {\n        v0 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v2 = v3 = _weiDeposited == 0;\n        if (_weiDeposited != 0) {\n            v2 = v4 = __currentSupply == 0;\n        }\n        if (!v2) {\n            v2 = varg0 == 0;\n        }\n        if (!v2) {\n            v5 = _SafeMul(__currentSupply, varg0);\n            v6 = v7 = _SafeDiv(_weiDeposited, v5);\n        } else {\n            v6 = v8 = 0;\n        }\n    }\n    return v6;\n}\n\nfunction weiDeposited() public nonPayable { \n    return _weiDeposited;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction tokensToWei(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = v2 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v0 = __currentSupply == 0;\n    }\n    if (!v0) {\n        v3 = _SafeMul(varg0, _weiDeposited);\n        v4 = _SafeDiv(__currentSupply, v3);\n        v5 = _SafeDiv(50, v4);\n        require(v5 <= v4);\n        v6 = v4 - v5;\n    } else {\n        v6 = v7 = 0;\n    }\n    return v6;\n}\n\nfunction purchaseEth(uint256 tokens) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(tokens > 0);\n    v0 = 0xf03(tokens);\n    require(v0 > 0);\n    emit Transfer(msg.sender, 0, tokens);\n    require(tokens <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - tokens;\n    require(tokens <= __currentSupply);\n    __currentSupply = __currentSupply - tokens;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(v0 <= _weiDeposited);\n    _weiDeposited = _weiDeposited - v0;\n}\n\nfunction currentSupply() public nonPayable { \n    return __currentSupply;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _currentSupply() public nonPayable { \n    return __currentSupply;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 > 0;\n    }\n    require(v0, 'Zero transfer or not enough funds');\n    require(varg0 != 0, 'No burning allowed');\n    require(msg.sender != 0, \"You can't mint this token, purchase it instead\");\n    v3 = _SafeDiv(50, varg1);\n    require(v3 <= varg1);\n    v4 = 0x1ae1(varg1 - v3, varg0);\n    v5 = 0x1ae1(v3, 0);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sellAllTokens() public nonPayable { \n    require(_balanceOf[msg.sender] > 0);\n    v0 = 0xf03(_balanceOf[msg.sender]);\n    require(v0 > 0);\n    emit Transfer(msg.sender, 0, _balanceOf[msg.sender]);\n    require(_balanceOf[msg.sender] <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - _balanceOf[msg.sender];\n    require(_balanceOf[msg.sender] <= __currentSupply);\n    __currentSupply = __currentSupply - _balanceOf[msg.sender];\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(v0 <= _weiDeposited);\n    _weiDeposited = _weiDeposited - v0;\n}\n\nfunction 0xf03(uint256 varg0) private { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = v2 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v0 = __currentSupply == 0;\n    }\n    if (!v0) {\n        v3 = _SafeMul(varg0, _weiDeposited);\n        v4 = _SafeDiv(__currentSupply, v3);\n        v5 = _SafeDiv(50, v4);\n        require(v5 <= v4);\n        v6 = v4 - v5;\n    } else {\n        v6 = v7 = 0;\n    }\n    return v6;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x7346ec57 > function_selector >> 224) {\n            if (0x3290ce29 > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector >> 224) {\n                    transferFrom(address,address,uint256);\n                } else if (0x313ce567 == function_selector >> 224) {\n                    decimals();\n                }\n            } else if (0x3290ce29 == function_selector >> 224) {\n                purchaseTokens();\n            } else if (0x3eaaf86b == function_selector >> 224) {\n                _totalSupply();\n            } else if (0x53aaef7d == function_selector >> 224) {\n                weiToTokens(uint256);\n            } else if (0x65302f68 == function_selector >> 224) {\n                weiDeposited();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xa4fefad6 > function_selector >> 224) {\n            if (0x7346ec57 == function_selector >> 224) {\n                tokensToWei(uint256);\n            } else if (0x7439011e == function_selector >> 224) {\n                0x7439011e();\n            } else if (0x771282f6 == function_selector >> 224) {\n                currentSupply();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            }\n        } else if (0xa4fefad6 == function_selector >> 224) {\n            _currentSupply();\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector >> 224) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe867a136 == function_selector >> 224) {\n            sellAllTokens();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 21:37 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x1]\nuint256[] _name; // STORAGE[0x2]\nuint256 __totalSupply; // STORAGE[0x5]\nuint256 __currentSupply; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x9]\nuint256 _weiDeposited; // STORAGE[0xa]\nuint160 _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction 0x1764(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg2);\n    _balanceOf[v1] = _balanceOf[v0] - varg0;\n    v2 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v3 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    if (address(varg1) == 0) {\n        if (address(varg1) == 0) {\n            require(varg0 <= __currentSupply);\n            __currentSupply = __currentSupply - varg0;\n        }\n    } else {\n        v4 = address(varg1);\n        v5 = _balanceOf[v4] + varg0;\n        require(v5 >= _balanceOf[v4]);\n        v6 = address(varg1);\n        _balanceOf[v6] = v5;\n    }\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return 1;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction 0x1ae1(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    if (address(varg1) == 0) {\n        if (address(varg1) == 0) {\n            require(varg0 <= __currentSupply);\n            __currentSupply = __currentSupply - varg0;\n        }\n    } else {\n        v0 = address(varg1);\n        v1 = _balanceOf[v0] + varg0;\n        require(v1 >= _balanceOf[v0]);\n        v2 = address(varg1);\n        _balanceOf[v2] = v1;\n    }\n    emit Transfer(msg.sender, address(varg1), varg0);\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    require(v0, 'Zero transfer or not enough (allowed) funds');\n    require(varg1 != 0, 'No burning allowed');\n    require(varg0 != 0, \"You can't mint this token, purchase it instead\");\n    v4 = _SafeDiv(50, varg2);\n    require(v4 <= varg2);\n    v5 = 0x1764(varg2 - v4, varg1, varg0);\n    v6 = 0x1764(v4, 0, varg0);\n    return 0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction purchaseTokens() public payable { \n    require(msg.value > 0);\n    v0 = v1 = msg.value;\n    v2 = v3 = __currentSupply == 0;\n    if (v3) {\n        v2 = v4 = _weiDeposited == 0;\n    }\n    if (!v2) {\n        v5 = v6 = _weiDeposited == 0;\n        if (_weiDeposited != 0) {\n            v5 = v7 = __currentSupply == 0;\n        }\n        if (!v5) {\n            v5 = v8 = v1 == 0;\n        }\n        if (!v5) {\n            v9 = _SafeMul(__currentSupply, v1);\n            v0 = v10 = _SafeDiv(_weiDeposited, v9);\n        } else {\n            v0 = v11 = 0;\n        }\n    }\n    require(__currentSupply + v0 >= __currentSupply);\n    require(__currentSupply + v0 <= __totalSupply, 'We have reached our contract limit');\n    require(v0 > 0);\n    emit Transfer(0, msg.sender, v0);\n    require(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    require(__currentSupply + v0 >= __currentSupply);\n    __currentSupply = __currentSupply + v0;\n    require(_weiDeposited + msg.value >= _weiDeposited);\n    _weiDeposited = _weiDeposited + msg.value;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction weiToTokens(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = __currentSupply == 0;\n    if (v1) {\n        v0 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v2 = v3 = _weiDeposited == 0;\n        if (_weiDeposited != 0) {\n            v2 = v4 = __currentSupply == 0;\n        }\n        if (!v2) {\n            v2 = varg0 == 0;\n        }\n        if (!v2) {\n            v5 = _SafeMul(__currentSupply, varg0);\n            v6 = v7 = _SafeDiv(_weiDeposited, v5);\n        } else {\n            v6 = v8 = 0;\n        }\n    }\n    return v6;\n}\n\nfunction weiDeposited() public nonPayable { \n    return _weiDeposited;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction tokensToWei(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = v2 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v0 = __currentSupply == 0;\n    }\n    if (!v0) {\n        v3 = _SafeMul(varg0, _weiDeposited);\n        v4 = _SafeDiv(__currentSupply, v3);\n        v5 = _SafeDiv(50, v4);\n        require(v5 <= v4);\n        v6 = v4 - v5;\n    } else {\n        v6 = v7 = 0;\n    }\n    return v6;\n}\n\nfunction purchaseEth(uint256 tokens) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(tokens > 0);\n    v0 = 0xf03(tokens);\n    require(v0 > 0);\n    emit Transfer(msg.sender, 0, tokens);\n    require(tokens <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - tokens;\n    require(tokens <= __currentSupply);\n    __currentSupply = __currentSupply - tokens;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(v0 <= _weiDeposited);\n    _weiDeposited = _weiDeposited - v0;\n}\n\nfunction currentSupply() public nonPayable { \n    return __currentSupply;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _currentSupply() public nonPayable { \n    return __currentSupply;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 > 0;\n    }\n    require(v0, 'Zero transfer or not enough funds');\n    require(varg0 != 0, 'No burning allowed');\n    require(msg.sender != 0, \"You can't mint this token, purchase it instead\");\n    v3 = _SafeDiv(50, varg1);\n    require(v3 <= varg1);\n    v4 = 0x1ae1(varg1 - v3, varg0);\n    v5 = 0x1ae1(v3, 0);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = new array[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v1.data + v2] = MEM[v0.data + v2];\n        v2 = v2 + 32;\n    }\n    v4 = v5 = v0.length + v1.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    require(varg0.code.size);\n    v6 = varg0.receiveApproval(msg.sender, varg1, address(this), v1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sellAllTokens() public nonPayable { \n    require(_balanceOf[msg.sender] > 0);\n    v0 = 0xf03(_balanceOf[msg.sender]);\n    require(v0 > 0);\n    emit Transfer(msg.sender, 0, _balanceOf[msg.sender]);\n    require(_balanceOf[msg.sender] <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - _balanceOf[msg.sender];\n    require(_balanceOf[msg.sender] <= __currentSupply);\n    __currentSupply = __currentSupply - _balanceOf[msg.sender];\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(v0 <= _weiDeposited);\n    _weiDeposited = _weiDeposited - v0;\n}\n\nfunction 0xf03(uint256 varg0) private { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = v2 = _weiDeposited == 0;\n    }\n    if (!v0) {\n        v0 = __currentSupply == 0;\n    }\n    if (!v0) {\n        v3 = _SafeMul(varg0, _weiDeposited);\n        v4 = _SafeDiv(__currentSupply, v3);\n        v5 = _SafeDiv(50, v4);\n        require(v5 <= v4);\n        v6 = v4 - v5;\n    } else {\n        v6 = v7 = 0;\n    }\n    return v6;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x7346ec57 > function_selector >> 224) {\n            if (0x3290ce29 > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector >> 224) {\n                    transferFrom(address,address,uint256);\n                } else if (0x313ce567 == function_selector >> 224) {\n                    decimals();\n                }\n            } else if (0x3290ce29 == function_selector >> 224) {\n                purchaseTokens();\n            } else if (0x3eaaf86b == function_selector >> 224) {\n                _totalSupply();\n            } else if (0x53aaef7d == function_selector >> 224) {\n                weiToTokens(uint256);\n            } else if (0x65302f68 == function_selector >> 224) {\n                weiDeposited();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xa4fefad6 > function_selector >> 224) {\n            if (0x7346ec57 == function_selector >> 224) {\n                tokensToWei(uint256);\n            } else if (0x7439011e == function_selector >> 224) {\n                0x7439011e();\n            } else if (0x771282f6 == function_selector >> 224) {\n                currentSupply();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            }\n        } else if (0xa4fefad6 == function_selector >> 224) {\n            _currentSupply();\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector >> 224) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe867a136 == function_selector >> 224) {\n            sellAllTokens();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 49.626858711242676,
	"usage": {
		"completion_tokens": 678,
		"prompt_tokens": 4305,
		"total_tokens": 4983
	}
}