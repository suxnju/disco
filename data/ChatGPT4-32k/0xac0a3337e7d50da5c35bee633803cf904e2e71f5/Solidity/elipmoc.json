{
	"address": "0xac0a3337e7d50da5c35bee633803cf904e2e71f5",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity contract code that represents the decompiled code:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    uint256[] private _name;\n    uint256[] private _symbol;\n    uint256 private _decimals;\n    uint256 private _getSaleStart;\n    uint256 private _getSaleEnd;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    address private _withdraw;\n\n    event BuyToken(address indexed buyer, uint256 value, uint256 amount);\n    event Refund();\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(block.timestamp > _getSaleEnd);\n        require(_balanceOf[from] >= value);\n        require(_allowance[from][msg.sender] >= value);\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from][msg.sender] -= value;\n        return true;\n    }\n\n    function softCapReached() public view returns (bool) {\n        return address(this).balance > 1 ether;\n    }\n\n    function decimals() public view returns (uint256) {\n        return _decimals;\n    }\n\n    function inSalePeriod() public view returns (bool) {\n        return (block.timestamp > _getSaleStart && block.timestamp < _getSaleEnd);\n    }\n\n    function withdraw() public {\n        require(msg.sender == _withdraw);\n        require(address(this).balance > 1 ether);\n        require(block.timestamp > _getSaleEnd);\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function getSaleEnd() public view returns (uint256) {\n        return _getSaleEnd;\n    }\n\n    function refund() public {\n        require(address(this).balance <= 1 ether);\n        require(block.timestamp > _getSaleEnd);\n        uint256 amount = _balanceOf[msg.sender];\n        _balanceOf[msg.sender] = 0;\n        msg.sender.transfer(amount);\n        emit Refund();\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function symbol() public view returns (string memory) {\n        return string(abi.encodePacked(_symbol));\n    }\n\n    function getSaleStart() public view returns (uint256) {\n        return _getSaleStart;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(amount <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= amount;\n        _balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function buyTokens() public payable {\n        require(msg.value > 0);\n        require(inSalePeriod());\n        uint256 amount = msg.value;\n        _balanceOf[msg.sender] += amount;\n        emit BuyToken(msg.sender, msg.value, amount);\n    }\n\n    function name() public view returns (string memory) {\n        return string(abi.encodePacked(_name));\n    }\n}\n```\nPlease note that the above contract is a simplified version and may not cover all the cases of the original contract. Some parts (like symbol and name) are not entirely clear in the decompiled code, so I've made assumptions.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459782,
	"id": "chatcmpl-8R3hecpEOtsaQfK5Qf2AZ4ASv0FJs",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 21:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 _getSaleStart; // STORAGE[0x3]\nuint256 _getSaleEnd; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _withdraw; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nBuyToken(address, uint256, uint256);\nRefund();\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(block.timestamp > 0x127500 + _getSaleEnd);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    if (!v0) {\n        v4 = v5 = 0;\n    } else {\n        v6 = _SafeSub(varg2, _balanceOf[varg0]);\n        _balanceOf[varg0] = v6;\n        v7 = _SafeSub(varg2, _allowance[msg.sender]);\n        _allowance[msg.sender] = v7;\n        v8 = _SafeAdd(varg2, _allowance[varg1]);\n        _balanceOf[varg1] = v8;\n        v4 = v9 = 1;\n        goto 0x704B0x1bb;\n    }\n    return v4;\n}\n\nfunction softCapReached() public nonPayable { \n    return (address(this)).balance > 0x1b1ae4d6e2ef500000;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction inSalePeriod() public nonPayable { \n    v0 = 0x72c();\n    return v0;\n}\n\nfunction withdraw() public nonPayable { \n    require(_withdraw == msg.sender);\n    v0 = v1 = 1 == (address(this)).balance > 0x1b1ae4d6e2ef500000;\n    if (v1) {\n        v0 = block.timestamp > _getSaleEnd;\n    }\n    if (v0) {\n        v2 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v2);\n    }\n}\n\nfunction getSaleEnd() public nonPayable { \n    return _getSaleEnd;\n}\n\nfunction refund() public nonPayable { \n    v0 = v1 = (address(this)).balance <= 0x1b1ae4d6e2ef500000;\n    if (v1) {\n        v0 = block.timestamp > _getSaleEnd;\n    }\n    if (v0) {\n        assert(0xde0b6b3a7640000);\n        v2 = msg.sender.call().value(_balanceOf[msg.sender] / 0xde0b6b3a7640000).gas(2300 * !(_balanceOf[msg.sender] / 0xde0b6b3a7640000));\n        require(v2);\n        emit Refund();\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getSaleStart() public nonPayable { \n    return _getSaleStart;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x932(varg1, varg0);\n    return v0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction getCurrentPrice() public nonPayable { \n    return 0x1b1ae4d6e2ef500000;\n}\n\nfunction 0x72c() private { \n    v0 = v1 = block.timestamp > _getSaleStart;\n    if (v1) {\n        v0 = v2 = block.timestamp < _getSaleEnd;\n    }\n    return v0;\n}\n\nfunction 0x932(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = address(varg1);\n    v2 = _SafeAdd(varg0, _balanceOf[v1]);\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(msg.sender, v3, varg0);\n    return 1;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= varg1);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction buyTokens() public payable { \n    require(msg.value > 0);\n    v0 = 0x72c();\n    require(v0);\n    v1 = 0x932(0x1b1ae4d6e2ef500000 * msg.value / 0xde0b6b3a7640000, msg.sender);\n    emit BuyToken(msg.sender, msg.value, 0);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (function_selector == 0x6fdde03) {\n        name();\n    } else if (0x95ea7b3 == function_selector) {\n        approve(address,uint256);\n    } else if (0x23b872dd == function_selector) {\n        transferFrom(address,address,uint256);\n    } else if (0x2b9edee9 == function_selector) {\n        softCapReached();\n    } else if (0x313ce567 == function_selector) {\n        decimals();\n    } else if (0x32c862ed == function_selector) {\n        inSalePeriod();\n    } else if (0x3ccfd60b == function_selector) {\n        withdraw();\n    } else if (0x4cc22f9d == function_selector) {\n        getSaleEnd();\n    } else if (0x590e1ae3 == function_selector) {\n        refund();\n    } else if (0x70a08231 == function_selector) {\n        balanceOf(address);\n    } else if (0x95d89b41 == function_selector) {\n        symbol();\n    } else if (0x969235a4 == function_selector) {\n        getSaleStart();\n    } else if (0xa9059cbb == function_selector) {\n        transfer(address,uint256);\n    } else {\n        if (0xd0febe4c != function_selector) {\n            if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xeb91d37e == function_selector) {\n                getCurrentPrice();\n            }\n        }\n        buyTokens();\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 21:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 _getSaleStart; // STORAGE[0x3]\nuint256 _getSaleEnd; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _withdraw; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nBuyToken(address, uint256, uint256);\nRefund();\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(block.timestamp > 0x127500 + _getSaleEnd);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    if (!v0) {\n        v4 = v5 = 0;\n    } else {\n        v6 = _SafeSub(varg2, _balanceOf[varg0]);\n        _balanceOf[varg0] = v6;\n        v7 = _SafeSub(varg2, _allowance[msg.sender]);\n        _allowance[msg.sender] = v7;\n        v8 = _SafeAdd(varg2, _allowance[varg1]);\n        _balanceOf[varg1] = v8;\n        v4 = v9 = 1;\n        goto 0x704B0x1bb;\n    }\n    return v4;\n}\n\nfunction softCapReached() public nonPayable { \n    return (address(this)).balance > 0x1b1ae4d6e2ef500000;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction inSalePeriod() public nonPayable { \n    v0 = 0x72c();\n    return v0;\n}\n\nfunction withdraw() public nonPayable { \n    require(_withdraw == msg.sender);\n    v0 = v1 = 1 == (address(this)).balance > 0x1b1ae4d6e2ef500000;\n    if (v1) {\n        v0 = block.timestamp > _getSaleEnd;\n    }\n    if (v0) {\n        v2 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v2);\n    }\n}\n\nfunction getSaleEnd() public nonPayable { \n    return _getSaleEnd;\n}\n\nfunction refund() public nonPayable { \n    v0 = v1 = (address(this)).balance <= 0x1b1ae4d6e2ef500000;\n    if (v1) {\n        v0 = block.timestamp > _getSaleEnd;\n    }\n    if (v0) {\n        assert(0xde0b6b3a7640000);\n        v2 = msg.sender.call().value(_balanceOf[msg.sender] / 0xde0b6b3a7640000).gas(2300 * !(_balanceOf[msg.sender] / 0xde0b6b3a7640000));\n        require(v2);\n        emit Refund();\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getSaleStart() public nonPayable { \n    return _getSaleStart;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x932(varg1, varg0);\n    return v0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction getCurrentPrice() public nonPayable { \n    return 0x1b1ae4d6e2ef500000;\n}\n\nfunction 0x72c() private { \n    v0 = v1 = block.timestamp > _getSaleStart;\n    if (v1) {\n        v0 = v2 = block.timestamp < _getSaleEnd;\n    }\n    return v0;\n}\n\nfunction 0x932(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = address(varg1);\n    v2 = _SafeAdd(varg0, _balanceOf[v1]);\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(msg.sender, v3, varg0);\n    return 1;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= varg1);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction buyTokens() public payable { \n    require(msg.value > 0);\n    v0 = 0x72c();\n    require(v0);\n    v1 = 0x932(0x1b1ae4d6e2ef500000 * msg.value / 0xde0b6b3a7640000, msg.sender);\n    emit BuyToken(msg.sender, msg.value, 0);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (function_selector == 0x6fdde03) {\n        name();\n    } else if (0x95ea7b3 == function_selector) {\n        approve(address,uint256);\n    } else if (0x23b872dd == function_selector) {\n        transferFrom(address,address,uint256);\n    } else if (0x2b9edee9 == function_selector) {\n        softCapReached();\n    } else if (0x313ce567 == function_selector) {\n        decimals();\n    } else if (0x32c862ed == function_selector) {\n        inSalePeriod();\n    } else if (0x3ccfd60b == function_selector) {\n        withdraw();\n    } else if (0x4cc22f9d == function_selector) {\n        getSaleEnd();\n    } else if (0x590e1ae3 == function_selector) {\n        refund();\n    } else if (0x70a08231 == function_selector) {\n        balanceOf(address);\n    } else if (0x95d89b41 == function_selector) {\n        symbol();\n    } else if (0x969235a4 == function_selector) {\n        getSaleStart();\n    } else if (0xa9059cbb == function_selector) {\n        transfer(address,uint256);\n    } else {\n        if (0xd0febe4c != function_selector) {\n            if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xeb91d37e == function_selector) {\n                getCurrentPrice();\n            }\n        }\n        buyTokens();\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 21:02 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _decimals; // STORAGE[0x2]\nuint256 _getSaleStart; // STORAGE[0x3]\nuint256 _getSaleEnd; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _withdraw; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nBuyToken(address, uint256, uint256);\nRefund();\nTransfer(address, address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(block.timestamp > 0x127500 + _getSaleEnd);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (_balanceOf[varg0] >= varg2) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 > 0;\n    }\n    if (v0) {\n        v0 = _balanceOf[varg1] + varg2 > _balanceOf[varg1];\n    }\n    if (!v0) {\n        v4 = v5 = 0;\n    } else {\n        v6 = _SafeSub(varg2, _balanceOf[varg0]);\n        _balanceOf[varg0] = v6;\n        v7 = _SafeSub(varg2, _allowance[msg.sender]);\n        _allowance[msg.sender] = v7;\n        v8 = _SafeAdd(varg2, _allowance[varg1]);\n        _balanceOf[varg1] = v8;\n        v4 = v9 = 1;\n        goto 0x704B0x1bb;\n    }\n    return v4;\n}\n\nfunction softCapReached() public nonPayable { \n    return (address(this)).balance > 0x1b1ae4d6e2ef500000;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction inSalePeriod() public nonPayable { \n    v0 = 0x72c();\n    return v0;\n}\n\nfunction withdraw() public nonPayable { \n    require(_withdraw == msg.sender);\n    v0 = v1 = 1 == (address(this)).balance > 0x1b1ae4d6e2ef500000;\n    if (v1) {\n        v0 = block.timestamp > _getSaleEnd;\n    }\n    if (v0) {\n        v2 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v2);\n    }\n}\n\nfunction getSaleEnd() public nonPayable { \n    return _getSaleEnd;\n}\n\nfunction refund() public nonPayable { \n    v0 = v1 = (address(this)).balance <= 0x1b1ae4d6e2ef500000;\n    if (v1) {\n        v0 = block.timestamp > _getSaleEnd;\n    }\n    if (v0) {\n        assert(0xde0b6b3a7640000);\n        v2 = msg.sender.call().value(_balanceOf[msg.sender] / 0xde0b6b3a7640000).gas(2300 * !(_balanceOf[msg.sender] / 0xde0b6b3a7640000));\n        require(v2);\n        emit Refund();\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getSaleStart() public nonPayable { \n    return _getSaleStart;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x932(varg1, varg0);\n    return v0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction getCurrentPrice() public nonPayable { \n    return 0x1b1ae4d6e2ef500000;\n}\n\nfunction 0x72c() private { \n    v0 = v1 = block.timestamp > _getSaleStart;\n    if (v1) {\n        v0 = v2 = block.timestamp < _getSaleEnd;\n    }\n    return v0;\n}\n\nfunction 0x932(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = address(varg1);\n    v2 = _SafeAdd(varg0, _balanceOf[v1]);\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(msg.sender, v3, varg0);\n    return 1;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= varg1);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction buyTokens() public payable { \n    require(msg.value > 0);\n    v0 = 0x72c();\n    require(v0);\n    v1 = 0x932(0x1b1ae4d6e2ef500000 * msg.value / 0xde0b6b3a7640000, msg.sender);\n    emit BuyToken(msg.sender, msg.value, 0);\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (function_selector == 0x6fdde03) {\n        name();\n    } else if (0x95ea7b3 == function_selector) {\n        approve(address,uint256);\n    } else if (0x23b872dd == function_selector) {\n        transferFrom(address,address,uint256);\n    } else if (0x2b9edee9 == function_selector) {\n        softCapReached();\n    } else if (0x313ce567 == function_selector) {\n        decimals();\n    } else if (0x32c862ed == function_selector) {\n        inSalePeriod();\n    } else if (0x3ccfd60b == function_selector) {\n        withdraw();\n    } else if (0x4cc22f9d == function_selector) {\n        getSaleEnd();\n    } else if (0x590e1ae3 == function_selector) {\n        refund();\n    } else if (0x70a08231 == function_selector) {\n        balanceOf(address);\n    } else if (0x95d89b41 == function_selector) {\n        symbol();\n    } else if (0x969235a4 == function_selector) {\n        getSaleStart();\n    } else if (0xa9059cbb == function_selector) {\n        transfer(address,uint256);\n    } else {\n        if (0xd0febe4c != function_selector) {\n            if (0xdd62ed3e == function_selector) {\n                allowance(address,address);\n            } else if (0xeb91d37e == function_selector) {\n                getCurrentPrice();\n            }\n        }\n        buyTokens();\n    }\n}\n.",
	"status": "1",
	"time_cost": 67.81063199043274,
	"usage": {
		"completion_tokens": 771,
		"prompt_tokens": 2324,
		"total_tokens": 3095
	}
}