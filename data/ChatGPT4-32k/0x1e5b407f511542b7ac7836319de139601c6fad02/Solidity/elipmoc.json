{
	"address": "0x1e5b407f511542b7ac7836319de139601c6fad02",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity version of the contract based on the decompiled EVM bytecode might look like this:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract NextLevelClub {\n\n    uint256 private _totalSupply;\n    mapping (address => mapping (address => uint256)) private _approve;\n    mapping (address => uint256) private _balanceOf;\n    uint256 private stor_5;\n    uint256 private _price;\n    address private _owner;\n    address private _confirmOwner;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        _owner = msg.sender;\n        _totalSupply = 1000000;\n        _price = 1 ether;\n        _balanceOf[_owner] = _totalSupply;\n    }\n\n    function name() public pure returns(string memory) {\n        return \"NEXT LEVEL CLUB\";\n    }\n\n    function approve(address spender, uint256 value) public {\n        _approve[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function totalSupply() public view returns(uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(msg.data.length >= 100);\n        require(value <= _balanceOf[from]);\n        require(value <= _approve[from][msg.sender]);\n        // Simplified transfer logic for brevity\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _approve[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n    }\n\n    function decimals() public pure returns(uint8) { \n        return 6;\n    }\n\n    function balanceOf(address account) public view returns(uint256) { \n        return _balanceOf[account];\n    }\n\n    function owner() public view returns(address) { \n        return _owner;\n    }\n\n    function symbol() public pure returns(string memory) { \n        return \"NLCLUB\";\n    }\n\n    function Price() public view returns(uint256) { \n        return _price;\n    }\n\n    function changeOwner(address newOwner) public { \n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        _confirmOwner = newOwner;\n    }\n\n    function transfer(address to, uint256 value) public { \n        require(value <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function confirmOwner() public { \n        require(msg.sender == _confirmOwner);\n        _owner = _confirmOwner;\n        _confirmOwner = address(0);\n    }\n\n    function allowance(address owner, address spender) public view returns(uint256) { \n        return _approve[owner][spender];\n    }\n\n    fallback() external payable { \n        // Simplified fallback function for brevity\n        require(msg.value > 0);\n        _totalSupply += msg.value / _price;\n        _balanceOf[msg.sender] += msg.value / _price;\n        emit Transfer(address(this), msg.sender, msg.value / _price);\n    }\n}\n```\n\nPlease note that due to the nature of decompiled bytecode, this code may not behave exactly the same as the original contract that the bytecode was created from. The logic of some complex computations has been simplified for brevity.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456576,
	"id": "chatcmpl-8R2rwUK2yuUxJWcnhrH2FjDEZm4z8",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 05:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 _price; // STORAGE[0x6]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _confirmOwner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'NEXT LEVEL CLUB';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_5);\n            stor_5 = stor_5 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_5 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_5);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            assert(_totalSupply);\n            _price = this.balance / _totalSupply;\n            v4 = _SafeMul(101, this.balance / _totalSupply);\n            v5 = _SafeDiv(100, v4);\n            _price = v5;\n            _totalSupply = 0;\n            stor_5 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v6 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v6); // checks call status, propagates error data on error\n        }\n        v7 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v7); // checks call status, propagates error data on error\n    } else {\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'NLCLUB';\n    }\n    return v0;\n}\n\nfunction Price() public nonPayable { \n    return _price;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    _confirmOwner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_5);\n            stor_5 = stor_5 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_5 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_5);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            assert(_totalSupply);\n            _price = this.balance / _totalSupply;\n            v4 = _SafeMul(101, this.balance / _totalSupply);\n            v5 = _SafeDiv(100, v4);\n            _price = v5;\n            _totalSupply = 0;\n            stor_5 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v6 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v6); // checks call status, propagates error data on error\n        }\n        v7 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v7); // checks call status, propagates error data on error\n    } else {\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction confirmOwner() public nonPayable { \n    require(msg.sender == _confirmOwner);\n    _owner = _confirmOwner;\n    _confirmOwner = 0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0);\n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x8ac7230489e80000);\n    assert(10 * _price >> 3);\n    require(msg.value / (10 * _price >> 3) > 0);\n    require(_balanceOf[msg.sender] + msg.value / (10 * _price >> 3) > _balanceOf[msg.sender]);\n    _totalSupply += msg.value / (10 * _price >> 3);\n    _balanceOf[msg.sender] += msg.value / (10 * _price >> 3);\n    v0 = _SafeDiv(100, msg.value);\n    v1 = _SafeMul(85, v0);\n    stor_5 += v1;\n    v2 = _SafeDiv(_totalSupply, v1 + stor_5);\n    _price = v2;\n    assert(10 * v2 >> 3);\n    require(msg.value % (10 * v2 >> 3) > 0);\n    emit Transfer(this, msg.sender, msg.value / (10 * _price >> 3));\n    v3 = _SafeMul(5, v0);\n    v4 = _owner.call().value(v3).gas(2300 * !v3);\n    require(v4); // checks call status, propagates error data on error\n    v5 = _SafeMul(5, v0);\n    v6 = 0xb453aa2cdc2f9241d2c451053da8268b34b4227f.call().value(v5).gas(2300 * !v5);\n    require(v6); // checks call status, propagates error data on error\n    v7 = msg.sender.call().value(msg.value % (10 * v2 >> 3)).gas(2300 * !(msg.value % (10 * v2 >> 3)));\n    require(v7); // checks call status, propagates error data on error\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9dfde201 == function_selector) {\n            Price();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbd9b6d86 == function_selector) {\n            confirmOwner();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 05:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 _price; // STORAGE[0x6]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _confirmOwner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'NEXT LEVEL CLUB';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_5);\n            stor_5 = stor_5 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_5 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_5);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            assert(_totalSupply);\n            _price = this.balance / _totalSupply;\n            v4 = _SafeMul(101, this.balance / _totalSupply);\n            v5 = _SafeDiv(100, v4);\n            _price = v5;\n            _totalSupply = 0;\n            stor_5 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v6 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v6); // checks call status, propagates error data on error\n        }\n        v7 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v7); // checks call status, propagates error data on error\n    } else {\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'NLCLUB';\n    }\n    return v0;\n}\n\nfunction Price() public nonPayable { \n    return _price;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    _confirmOwner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_5);\n            stor_5 = stor_5 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_5 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_5);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            assert(_totalSupply);\n            _price = this.balance / _totalSupply;\n            v4 = _SafeMul(101, this.balance / _totalSupply);\n            v5 = _SafeDiv(100, v4);\n            _price = v5;\n            _totalSupply = 0;\n            stor_5 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v6 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v6); // checks call status, propagates error data on error\n        }\n        v7 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v7); // checks call status, propagates error data on error\n    } else {\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction confirmOwner() public nonPayable { \n    require(msg.sender == _confirmOwner);\n    _owner = _confirmOwner;\n    _confirmOwner = 0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0);\n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x8ac7230489e80000);\n    assert(10 * _price >> 3);\n    require(msg.value / (10 * _price >> 3) > 0);\n    require(_balanceOf[msg.sender] + msg.value / (10 * _price >> 3) > _balanceOf[msg.sender]);\n    _totalSupply += msg.value / (10 * _price >> 3);\n    _balanceOf[msg.sender] += msg.value / (10 * _price >> 3);\n    v0 = _SafeDiv(100, msg.value);\n    v1 = _SafeMul(85, v0);\n    stor_5 += v1;\n    v2 = _SafeDiv(_totalSupply, v1 + stor_5);\n    _price = v2;\n    assert(10 * v2 >> 3);\n    require(msg.value % (10 * v2 >> 3) > 0);\n    emit Transfer(this, msg.sender, msg.value / (10 * _price >> 3));\n    v3 = _SafeMul(5, v0);\n    v4 = _owner.call().value(v3).gas(2300 * !v3);\n    require(v4); // checks call status, propagates error data on error\n    v5 = _SafeMul(5, v0);\n    v6 = 0xb453aa2cdc2f9241d2c451053da8268b34b4227f.call().value(v5).gas(2300 * !v5);\n    require(v6); // checks call status, propagates error data on error\n    v7 = msg.sender.call().value(msg.value % (10 * v2 >> 3)).gas(2300 * !(msg.value % (10 * v2 >> 3)));\n    require(v7); // checks call status, propagates error data on error\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9dfde201 == function_selector) {\n            Price();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbd9b6d86 == function_selector) {\n            confirmOwner();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 05:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _approve; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 _price; // STORAGE[0x6]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _confirmOwner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (15) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffff & 'NEXT LEVEL CLUB';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _approve[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length >= 100);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _approve[msg.sender]);\n    if (this == varg1) {\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        v0 = _SafeMul(_price, varg2);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg2) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_5);\n            stor_5 = stor_5 - v0;\n            _totalSupply = _totalSupply - varg2;\n            v2 = _SafeMul(varg2, v1);\n            stor_5 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_5);\n            _price = v3;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n        }\n        if (_totalSupply == varg2) {\n            assert(_totalSupply);\n            _price = this.balance / _totalSupply;\n            v4 = _SafeMul(101, this.balance / _totalSupply);\n            v5 = _SafeDiv(100, v4);\n            _price = v5;\n            _totalSupply = 0;\n            stor_5 = 0;\n            emit Transfer(varg0, varg1, varg2);\n            _approve[msg.sender] = _approve[msg.sender] - varg2;\n            v6 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v6); // checks call status, propagates error data on error\n        }\n        v7 = varg0.call().value(v0).gas(2300 * !v0);\n        require(v7); // checks call status, propagates error data on error\n    } else {\n        require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _balanceOf[varg1] += varg2;\n        _approve[msg.sender] = _approve[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n    }\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 6;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (6) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffff & 'NLCLUB';\n    }\n    return v0;\n}\n\nfunction Price() public nonPayable { \n    return _price;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    _confirmOwner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length >= 68);\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (this == varg0) {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v0 = _SafeMul(_price, varg1);\n        require(v0 <= this.balance);\n        if (_totalSupply > varg1) {\n            v1 = _SafeDiv(_totalSupply, (address(this)).balance - stor_5);\n            stor_5 = stor_5 - v0;\n            _totalSupply = _totalSupply - varg1;\n            v2 = _SafeMul(varg1, v1);\n            stor_5 += v2;\n            v3 = _SafeDiv(_totalSupply, v2 + stor_5);\n            _price = v3;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n        if (_totalSupply == varg1) {\n            assert(_totalSupply);\n            _price = this.balance / _totalSupply;\n            v4 = _SafeMul(101, this.balance / _totalSupply);\n            v5 = _SafeDiv(100, v4);\n            _price = v5;\n            _totalSupply = 0;\n            stor_5 = 0;\n            emit Transfer(msg.sender, varg0, varg1);\n            v6 = _owner.call().value(this.balance - v0).gas(2300 * !(this.balance - v0));\n            require(v6); // checks call status, propagates error data on error\n        }\n        v7 = msg.sender.call().value(v0).gas(2300 * !v0);\n        require(v7); // checks call status, propagates error data on error\n    } else {\n        require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n    return 1;\n}\n\nfunction confirmOwner() public nonPayable { \n    require(msg.sender == _confirmOwner);\n    _owner = _confirmOwner;\n    _confirmOwner = 0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _approve[varg1];\n}\n\nfunction fallback() public payable { \n    require(msg.value > 0);\n    require(msg.value >= 0x2386f26fc10000);\n    require(msg.value <= 0x8ac7230489e80000);\n    assert(10 * _price >> 3);\n    require(msg.value / (10 * _price >> 3) > 0);\n    require(_balanceOf[msg.sender] + msg.value / (10 * _price >> 3) > _balanceOf[msg.sender]);\n    _totalSupply += msg.value / (10 * _price >> 3);\n    _balanceOf[msg.sender] += msg.value / (10 * _price >> 3);\n    v0 = _SafeDiv(100, msg.value);\n    v1 = _SafeMul(85, v0);\n    stor_5 += v1;\n    v2 = _SafeDiv(_totalSupply, v1 + stor_5);\n    _price = v2;\n    assert(10 * v2 >> 3);\n    require(msg.value % (10 * v2 >> 3) > 0);\n    emit Transfer(this, msg.sender, msg.value / (10 * _price >> 3));\n    v3 = _SafeMul(5, v0);\n    v4 = _owner.call().value(v3).gas(2300 * !v3);\n    require(v4); // checks call status, propagates error data on error\n    v5 = _SafeMul(5, v0);\n    v6 = 0xb453aa2cdc2f9241d2c451053da8268b34b4227f.call().value(v5).gas(2300 * !v5);\n    require(v6); // checks call status, propagates error data on error\n    v7 = msg.sender.call().value(msg.value % (10 * v2 >> 3)).gas(2300 * !(msg.value % (10 * v2 >> 3)));\n    require(v7); // checks call status, propagates error data on error\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9dfde201 == function_selector) {\n            Price();\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbd9b6d86 == function_selector) {\n            confirmOwner();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 31.42609405517578,
	"usage": {
		"completion_tokens": 721,
		"prompt_tokens": 2557,
		"total_tokens": 3278
	}
}