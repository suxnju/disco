{
	"address": "0x7675de10fe92ec4661438d0b502bcf280898c043",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity contract code that corresponds to the given decompiled code could look something like this:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (bytes32 => uint256) private _getUInt;\n    mapping (bytes32 => string) private _stringStorage;\n    mapping (bytes32 => address) private _addressStorage;\n    mapping (bytes32 => bytes) private _bytesStorage;\n    mapping (bytes32 => bytes32) private _bytes32Storage;\n    mapping (bytes32 => bool) private _booleanStorage;\n    mapping (bytes32 => int256) private _intStorage;\n    \n    address private _owner;\n    address private _fallback;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Caller is not the owner\");\n        _;\n    }\n\n    modifier onlyFallback() {\n        require(_fallback == msg.sender, \"Caller is not the fallback address\");\n        _;\n    }\n\n    constructor(address owner_, address fallback_) {\n        _owner = owner_;\n        _fallback = fallback_;\n    }\n\n    function fallback() public payable onlyFallback {}\n\n    function bytes32Storage(bytes32 key) public view returns (bytes32) {\n        return _bytes32Storage[key];\n    }\n\n    function addressStorage(bytes32 key) public view returns (address) {\n        return _addressStorage[key];\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function acceptableAddress() public view returns (address) {\n        return _fallback;\n    }\n\n    function booleanStorage(bytes32 key) public view returns (bool) {\n        return _booleanStorage[key];\n    }\n\n    function setBytes(bytes32 key, bytes memory value) public onlyFallback {\n        _bytesStorage[key] = value;\n    }\n\n    function stringStorage(bytes32 key) public view returns (string memory) {\n        return _stringStorage[key];\n    }\n\n    function setInt(bytes32 key, int256 value) public onlyFallback {\n        _intStorage[key] = value;\n    }\n\n    function bytesStorage(bytes32 key) public view returns (bytes memory) {\n        return _bytesStorage[key];\n    }\n\n    function setBytes32(bytes32 key, bytes32 value) public onlyFallback {\n        _bytes32Storage[key] = value;\n    }\n\n    function withdraw(address to) public onlyFallback {\n        payable(to).transfer(address(this).balance);\n    }\n\n    function getUInt(bytes32 key) public view returns (uint256) {\n        return _getUInt[key];\n    }\n\n    function setUInt(bytes32 key, uint256 value) public onlyFallback {\n        _getUInt[key] = value;\n    }\n\n    function setString(bytes32 key, string memory value) public onlyFallback {\n        _stringStorage[key] = value;\n    }\n\n    function intStorage(bytes32 key) public view returns (int256) {\n        return _intStorage[key];\n    }\n\n    function getBool(bytes32 key) public view returns (bool) {\n        return _booleanStorage[key];\n    }\n\n    function setAdd(bytes32 key, address value) public onlyFallback {\n        _addressStorage[key] = value;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function getString(bytes32 key) public view returns (string memory) {\n        return _stringStorage[key];\n    }\n\n    function getAdd(bytes32 key) public view returns (address) {\n        return _addressStorage[key];\n    }\n\n    function getBytes32(bytes32 key) public view returns (bytes32) {\n        return _bytes32Storage[key];\n    }\n\n    function uintStorage(bytes32 key) public view returns (uint256) {\n        return _getUInt[key];\n    }\n\n    function setBool(bytes32 key, bool value) public onlyFallback {\n        _booleanStorage[key] = value;\n    }\n\n    function transferAcceptable(address newFallback) public onlyOwner {\n        emit OwnershipTransferred(_fallback, newFallback);\n        _fallback = newFallback;\n    }\n\n    function getBytes(bytes32 key) public view returns (bytes memory) {\n        return _bytesStorage[key];\n    }\n\n    function getInt(bytes32 key) public view returns (int256) {\n        return _intStorage[key];\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n```\n\nPlease note that this code is an approximation of the decompiled code and it may not be fully correct. It is always recommended to have the original source code for accurate representation.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459137,
	"id": "chatcmpl-8R3XFVrXa139snrtOs1LGKrbgFtJj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.13 02:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getUInt; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _stringStorage; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addressStorage; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _bytesStorage; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _bytes32Storage; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _booleanStorage; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _intStorage; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _fallback; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    v0 = v1 = _fallback == msg.sender;\n    if (_fallback != msg.sender) {\n        v0 = v2 = _owner == msg.sender;\n    }\n    require(v0);\n}\n\nfunction bytes32Storage(bytes32 varg0) public nonPayable { \n    return _bytes32Storage[varg0];\n}\n\nfunction addressStorage(bytes32 varg0) public nonPayable { \n    return address(_addressStorage[varg0]);\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction acceptableAddress() public nonPayable { \n    return _fallback;\n}\n\nfunction booleanStorage(bytes32 varg0) public nonPayable { \n    return 0xff & _booleanStorage[varg0];\n}\n\nfunction setBytes(bytes32 varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    require(_fallback == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _bytesStorage[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _bytesStorage[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction stringStorage(bytes32 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _stringStorage[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setInt(bytes32 varg0, int256 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _intStorage[varg0] = varg1;\n}\n\nfunction bytesStorage(bytes32 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _bytesStorage[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setBytes32(bytes32 varg0, bytes32 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _bytes32Storage[varg0] = varg1;\n}\n\nfunction withdraw(address varg0) public nonPayable { \n    require(_fallback == msg.sender);\n    require(_fallback == msg.sender);\n    _getUInt[keccak256(varg0, 'balance')] = 0;\n    v0 = varg0.call().value(_getUInt[keccak256(varg0, 'balance')]).gas(2300 * !_getUInt[keccak256(varg0, 'balance')]);\n    require(v0);\n}\n\nfunction getUInt(bytes32 varg0) public nonPayable { \n    return _getUInt[varg0];\n}\n\nfunction setUInt(bytes32 varg0, uint256 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _getUInt[varg0] = varg1;\n}\n\nfunction setString(bytes32 varg0, string varg1) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    require(_fallback == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _stringStorage[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _stringStorage[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction intStorage(bytes32 varg0) public nonPayable { \n    return _intStorage[varg0];\n}\n\nfunction getBool(bytes32 varg0) public nonPayable { \n    return 0xff & _booleanStorage[varg0];\n}\n\nfunction setAdd(bytes32 varg0, address varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _addressStorage[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _addressStorage[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction getString(bytes32 varg0) public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new bytes[](((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n        if (31 < ((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n            v3 = v2 + (((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n            do {\n                MEM[v1] = STORAGE[v4];\n                v4 += 1;\n                v1 += 32;\n            } while (v3 <= v1);\n        } else {\n            MEM[v2] = _stringStorage[~0x0 & (~0x0 & varg0)] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v0.data + v6];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction getAdd(bytes32 varg0) public nonPayable { \n    return address(_addressStorage[varg0]);\n}\n\nfunction getBytes32(bytes32 varg0) public nonPayable { \n    return _bytes32Storage[varg0];\n}\n\nfunction uintStorage(bytes32 varg0) public nonPayable { \n    return _getUInt[varg0];\n}\n\nfunction setBool(bytes32 varg0, bool varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _booleanStorage[varg0] = varg1 | ~0xff & _booleanStorage[varg0];\n}\n\nfunction transferAcceptable(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_fallback, varg0);\n    _fallback = varg0;\n}\n\nfunction getBytes(bytes32 varg0) public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new bytes[](((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n        if (31 < ((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _bytesStorage[~0x0 & (~0x0 & varg0)] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getInt(bytes32 varg0) public nonPayable { \n    return _intStorage[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x31578af) {\n            bytes32Storage(bytes32);\n        } else if (0x4f49a3a == function_selector) {\n            addressStorage(bytes32);\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x1da5f94d == function_selector) {\n            acceptableAddress();\n        } else if (0x1f994137 == function_selector) {\n            booleanStorage(bytes32);\n        } else if (0x2e28d084 == function_selector) {\n            setBytes(bytes32,bytes);\n        } else if (0x35f7ff63 == function_selector) {\n            stringStorage(bytes32);\n        } else if (0x3e49bed0 == function_selector) {\n            setInt(bytes32,int256);\n        } else if (0x4a3270d7 == function_selector) {\n            bytesStorage(bytes32);\n        } else if (0x4e91db08 == function_selector) {\n            setBytes32(bytes32,bytes32);\n        } else if (0x51cff8d9 == function_selector) {\n            withdraw(address);\n        } else if (0x5aec6259 == function_selector) {\n            getUInt(bytes32);\n        } else if (0x6ca402aa == function_selector) {\n            setUInt(bytes32,uint256);\n        } else if (0x6e899550 == function_selector) {\n            setString(bytes32,string);\n        } else if (0x789c617c == function_selector) {\n            intStorage(bytes32);\n        } else if (0x7ae1cfca == function_selector) {\n            getBool(bytes32);\n        } else if (0x7c0712ae == function_selector) {\n            setAdd(bytes32,address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x986e791a == function_selector) {\n            getString(bytes32);\n        } else if (0xa02e98df == function_selector) {\n            getAdd(bytes32);\n        } else if (0xa6ed563e == function_selector) {\n            getBytes32(bytes32);\n        } else if (0xa855d4ce == function_selector) {\n            uintStorage(bytes32);\n        } else if (0xabfdcced == function_selector) {\n            setBool(bytes32,bool);\n        } else if (0xaf769b54 == function_selector) {\n            transferAcceptable(address);\n        } else if (0xc031a180 == function_selector) {\n            getBytes(bytes32);\n        } else if (0xdc97d962 == function_selector) {\n            getInt(bytes32);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 02:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getUInt; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _stringStorage; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addressStorage; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _bytesStorage; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _bytes32Storage; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _booleanStorage; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _intStorage; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _fallback; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    v0 = v1 = _fallback == msg.sender;\n    if (_fallback != msg.sender) {\n        v0 = v2 = _owner == msg.sender;\n    }\n    require(v0);\n}\n\nfunction bytes32Storage(bytes32 varg0) public nonPayable { \n    return _bytes32Storage[varg0];\n}\n\nfunction addressStorage(bytes32 varg0) public nonPayable { \n    return address(_addressStorage[varg0]);\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction acceptableAddress() public nonPayable { \n    return _fallback;\n}\n\nfunction booleanStorage(bytes32 varg0) public nonPayable { \n    return 0xff & _booleanStorage[varg0];\n}\n\nfunction setBytes(bytes32 varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    require(_fallback == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _bytesStorage[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _bytesStorage[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction stringStorage(bytes32 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _stringStorage[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setInt(bytes32 varg0, int256 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _intStorage[varg0] = varg1;\n}\n\nfunction bytesStorage(bytes32 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _bytesStorage[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setBytes32(bytes32 varg0, bytes32 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _bytes32Storage[varg0] = varg1;\n}\n\nfunction withdraw(address varg0) public nonPayable { \n    require(_fallback == msg.sender);\n    require(_fallback == msg.sender);\n    _getUInt[keccak256(varg0, 'balance')] = 0;\n    v0 = varg0.call().value(_getUInt[keccak256(varg0, 'balance')]).gas(2300 * !_getUInt[keccak256(varg0, 'balance')]);\n    require(v0);\n}\n\nfunction getUInt(bytes32 varg0) public nonPayable { \n    return _getUInt[varg0];\n}\n\nfunction setUInt(bytes32 varg0, uint256 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _getUInt[varg0] = varg1;\n}\n\nfunction setString(bytes32 varg0, string varg1) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    require(_fallback == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _stringStorage[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _stringStorage[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction intStorage(bytes32 varg0) public nonPayable { \n    return _intStorage[varg0];\n}\n\nfunction getBool(bytes32 varg0) public nonPayable { \n    return 0xff & _booleanStorage[varg0];\n}\n\nfunction setAdd(bytes32 varg0, address varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _addressStorage[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _addressStorage[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction getString(bytes32 varg0) public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new bytes[](((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n        if (31 < ((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n            v3 = v2 + (((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n            do {\n                MEM[v1] = STORAGE[v4];\n                v4 += 1;\n                v1 += 32;\n            } while (v3 <= v1);\n        } else {\n            MEM[v2] = _stringStorage[~0x0 & (~0x0 & varg0)] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v0.data + v6];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction getAdd(bytes32 varg0) public nonPayable { \n    return address(_addressStorage[varg0]);\n}\n\nfunction getBytes32(bytes32 varg0) public nonPayable { \n    return _bytes32Storage[varg0];\n}\n\nfunction uintStorage(bytes32 varg0) public nonPayable { \n    return _getUInt[varg0];\n}\n\nfunction setBool(bytes32 varg0, bool varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _booleanStorage[varg0] = varg1 | ~0xff & _booleanStorage[varg0];\n}\n\nfunction transferAcceptable(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_fallback, varg0);\n    _fallback = varg0;\n}\n\nfunction getBytes(bytes32 varg0) public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new bytes[](((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n        if (31 < ((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _bytesStorage[~0x0 & (~0x0 & varg0)] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getInt(bytes32 varg0) public nonPayable { \n    return _intStorage[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x31578af) {\n            bytes32Storage(bytes32);\n        } else if (0x4f49a3a == function_selector) {\n            addressStorage(bytes32);\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x1da5f94d == function_selector) {\n            acceptableAddress();\n        } else if (0x1f994137 == function_selector) {\n            booleanStorage(bytes32);\n        } else if (0x2e28d084 == function_selector) {\n            setBytes(bytes32,bytes);\n        } else if (0x35f7ff63 == function_selector) {\n            stringStorage(bytes32);\n        } else if (0x3e49bed0 == function_selector) {\n            setInt(bytes32,int256);\n        } else if (0x4a3270d7 == function_selector) {\n            bytesStorage(bytes32);\n        } else if (0x4e91db08 == function_selector) {\n            setBytes32(bytes32,bytes32);\n        } else if (0x51cff8d9 == function_selector) {\n            withdraw(address);\n        } else if (0x5aec6259 == function_selector) {\n            getUInt(bytes32);\n        } else if (0x6ca402aa == function_selector) {\n            setUInt(bytes32,uint256);\n        } else if (0x6e899550 == function_selector) {\n            setString(bytes32,string);\n        } else if (0x789c617c == function_selector) {\n            intStorage(bytes32);\n        } else if (0x7ae1cfca == function_selector) {\n            getBool(bytes32);\n        } else if (0x7c0712ae == function_selector) {\n            setAdd(bytes32,address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x986e791a == function_selector) {\n            getString(bytes32);\n        } else if (0xa02e98df == function_selector) {\n            getAdd(bytes32);\n        } else if (0xa6ed563e == function_selector) {\n            getBytes32(bytes32);\n        } else if (0xa855d4ce == function_selector) {\n            uintStorage(bytes32);\n        } else if (0xabfdcced == function_selector) {\n            setBool(bytes32,bool);\n        } else if (0xaf769b54 == function_selector) {\n            transferAcceptable(address);\n        } else if (0xc031a180 == function_selector) {\n            getBytes(bytes32);\n        } else if (0xdc97d962 == function_selector) {\n            getInt(bytes32);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 02:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getUInt; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _stringStorage; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addressStorage; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _bytesStorage; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _bytes32Storage; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _booleanStorage; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _intStorage; // STORAGE[0x8]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _fallback; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    v0 = v1 = _fallback == msg.sender;\n    if (_fallback != msg.sender) {\n        v0 = v2 = _owner == msg.sender;\n    }\n    require(v0);\n}\n\nfunction bytes32Storage(bytes32 varg0) public nonPayable { \n    return _bytes32Storage[varg0];\n}\n\nfunction addressStorage(bytes32 varg0) public nonPayable { \n    return address(_addressStorage[varg0]);\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction acceptableAddress() public nonPayable { \n    return _fallback;\n}\n\nfunction booleanStorage(bytes32 varg0) public nonPayable { \n    return 0xff & _booleanStorage[varg0];\n}\n\nfunction setBytes(bytes32 varg0, bytes varg1) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    require(_fallback == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _bytesStorage[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _bytesStorage[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction stringStorage(bytes32 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _stringStorage[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setInt(bytes32 varg0, int256 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _intStorage[varg0] = varg1;\n}\n\nfunction bytesStorage(bytes32 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _bytesStorage[varg0]) << 8) - 1 & _bytesStorage[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _bytesStorage[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setBytes32(bytes32 varg0, bytes32 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _bytes32Storage[varg0] = varg1;\n}\n\nfunction withdraw(address varg0) public nonPayable { \n    require(_fallback == msg.sender);\n    require(_fallback == msg.sender);\n    _getUInt[keccak256(varg0, 'balance')] = 0;\n    v0 = varg0.call().value(_getUInt[keccak256(varg0, 'balance')]).gas(2300 * !_getUInt[keccak256(varg0, 'balance')]);\n    require(v0);\n}\n\nfunction getUInt(bytes32 varg0) public nonPayable { \n    return _getUInt[varg0];\n}\n\nfunction setUInt(bytes32 varg0, uint256 varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _getUInt[varg0] = varg1;\n}\n\nfunction setString(bytes32 varg0, string varg1) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    require(_fallback == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _stringStorage[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _stringStorage[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _stringStorage[varg0]) << 8) - 1 & _stringStorage[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction intStorage(bytes32 varg0) public nonPayable { \n    return _intStorage[varg0];\n}\n\nfunction getBool(bytes32 varg0) public nonPayable { \n    return 0xff & _booleanStorage[varg0];\n}\n\nfunction setAdd(bytes32 varg0, address varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _addressStorage[varg0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _addressStorage[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction getString(bytes32 varg0) public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new bytes[](((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n        if (31 < ((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n            v3 = v2 + (((!(0x1 & _stringStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _stringStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n            do {\n                MEM[v1] = STORAGE[v4];\n                v4 += 1;\n                v1 += 32;\n            } while (v3 <= v1);\n        } else {\n            MEM[v2] = _stringStorage[~0x0 & (~0x0 & varg0)] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v0.data + v6];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction getAdd(bytes32 varg0) public nonPayable { \n    return address(_addressStorage[varg0]);\n}\n\nfunction getBytes32(bytes32 varg0) public nonPayable { \n    return _bytes32Storage[varg0];\n}\n\nfunction uintStorage(bytes32 varg0) public nonPayable { \n    return _getUInt[varg0];\n}\n\nfunction setBool(bytes32 varg0, bool varg1) public nonPayable { \n    require(_fallback == msg.sender);\n    _booleanStorage[varg0] = varg1 | ~0xff & _booleanStorage[varg0];\n}\n\nfunction transferAcceptable(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_fallback, varg0);\n    _fallback = varg0;\n}\n\nfunction getBytes(bytes32 varg0) public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new bytes[](((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n        if (31 < ((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) << 8) - 1 & _bytesStorage[~0x0 & (~0x0 & varg0)]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _bytesStorage[~0x0 & (~0x0 & varg0)] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getInt(bytes32 varg0) public nonPayable { \n    return _intStorage[varg0];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x31578af) {\n            bytes32Storage(bytes32);\n        } else if (0x4f49a3a == function_selector) {\n            addressStorage(bytes32);\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x1da5f94d == function_selector) {\n            acceptableAddress();\n        } else if (0x1f994137 == function_selector) {\n            booleanStorage(bytes32);\n        } else if (0x2e28d084 == function_selector) {\n            setBytes(bytes32,bytes);\n        } else if (0x35f7ff63 == function_selector) {\n            stringStorage(bytes32);\n        } else if (0x3e49bed0 == function_selector) {\n            setInt(bytes32,int256);\n        } else if (0x4a3270d7 == function_selector) {\n            bytesStorage(bytes32);\n        } else if (0x4e91db08 == function_selector) {\n            setBytes32(bytes32,bytes32);\n        } else if (0x51cff8d9 == function_selector) {\n            withdraw(address);\n        } else if (0x5aec6259 == function_selector) {\n            getUInt(bytes32);\n        } else if (0x6ca402aa == function_selector) {\n            setUInt(bytes32,uint256);\n        } else if (0x6e899550 == function_selector) {\n            setString(bytes32,string);\n        } else if (0x789c617c == function_selector) {\n            intStorage(bytes32);\n        } else if (0x7ae1cfca == function_selector) {\n            getBool(bytes32);\n        } else if (0x7c0712ae == function_selector) {\n            setAdd(bytes32,address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x986e791a == function_selector) {\n            getString(bytes32);\n        } else if (0xa02e98df == function_selector) {\n            getAdd(bytes32);\n        } else if (0xa6ed563e == function_selector) {\n            getBytes32(bytes32);\n        } else if (0xa855d4ce == function_selector) {\n            uintStorage(bytes32);\n        } else if (0xabfdcced == function_selector) {\n            setBool(bytes32,bool);\n        } else if (0xaf769b54 == function_selector) {\n            transferAcceptable(address);\n        } else if (0xc031a180 == function_selector) {\n            getBytes(bytes32);\n        } else if (0xdc97d962 == function_selector) {\n            getInt(bytes32);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 46.65738248825073,
	"usage": {
		"completion_tokens": 972,
		"prompt_tokens": 4009,
		"total_tokens": 4981
	}
}