{
	"address": "0x1e4f97b9f9f913c46f1632781732927b9019c68b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity contract based on the decompiled code you provided. Please note that the decompiled code seems to use some pseudo-assembly code, which is not a standard Solidity feature. Therefore, I made some assumptions to convert it into a standard Solidity contract.\n\n```solidity\npragma solidity >=0.5.0 <0.8.0;\n\ncontract MyContract {\n    bool private _toggleContractActive;\n    address private _owner;\n    address private _uniSwapFactoryAddress;\n    address private _oneSplitInterfaceAddress;\n    address private _nEWDAI_TOKEN_ADDRESS;\n    address private _cOMPOUND_TOKEN_ADDRESS;\n\n    event ERC20TokenHoldingsOnConversionDaiChai(uint256 amount);\n    event LiquidityTokens(uint256 amount);\n\n    modifier onlyOwner {\n        require(msg.sender == _owner, \"you are not authorised to call this function\");\n        _;\n    }\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function set_OneSplitInterfaceAddress(address newAddress) public onlyOwner {\n        _oneSplitInterfaceAddress = newAddress;\n    }\n\n    function set_new_DAI_TOKEN_ADDRESS(address newAddress) public onlyOwner {\n        _nEWDAI_TOKEN_ADDRESS = newAddress;\n    }\n\n    function toggleContractActive() public onlyOwner {\n        _toggleContractActive = !_toggleContractActive;\n    }\n\n    function redeem(address tokenAddress, uint256 amount) public {\n        require(!_toggleContractActive, \"Contract is currently inactive\");\n        // Code for redeem functionality goes here\n    }\n\n    function destruct() public onlyOwner {\n        selfdestruct(msg.sender);\n    }\n\n    function withdraw() public onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function inCaseTokengetsStuck(address tokenAddress) public onlyOwner {\n        // Code for transferring stuck tokens goes here\n    }\n\n    function set_new_cDAI_TokenContractAddress(address newAddress) public onlyOwner {\n        _cOMPOUND_TOKEN_ADDRESS = newAddress;\n    }\n\n    function letsInvest(address to, uint256 amount) public payable {\n        require(!_toggleContractActive, \"Contract is currently inactive\");\n        // Code for investment functionality goes here\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _owner = newOwner;\n    }\n}\n```\nPlease note that the actual implementation of most functions is not provided in the decompiled code, so I left comments where the code should go. You should replace these comments with your own implementation. The provided Solidity contract is a rough approximation based on the information from the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701464406,
	"id": "chatcmpl-8R4uETzOCTIxkbkpNwblNv5Fv2s9U",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 13:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint8 _initialize; // STORAGE[0x0] bytes 1 to 1\nuint8 _toggleContractActive; // STORAGE[0x33] bytes 0 to 0\naddress _owner; // STORAGE[0x33] bytes 1 to 20\naddress _uniSwapFactoryAddress; // STORAGE[0x34] bytes 0 to 19\naddress _oneSplitInterfaceAddress; // STORAGE[0x35] bytes 0 to 19\naddress _nEWDAI_TOKEN_ADDRESS; // STORAGE[0x36] bytes 0 to 19\naddress _cOMPOUND_TOKEN_ADDRESS; // STORAGE[0x37] bytes 0 to 19\nuint160 _dAI_TOKEN_ADDRESS; // STORAGE[0x38] bytes 0 to 19\nuint160 _eTH_TOKEN_ADDRESS; // STORAGE[0x39] bytes 0 to 19\nuint160 _oNESPLIT_ADDRESS; // STORAGE[0x3a] bytes 0 to 19\n\n// Events\nERC20TokenHoldingsOnConversionDaiChai(uint256);\nLiquidityTokens(uint256);\n\nfunction fallback() public payable { \n    if (msg.sender != _owner) {\n        v0 = v1 = 0;\n        if (!_toggleContractActive) {\n            require(_uniSwapFactoryAddress.code.size);\n            v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n            require(v2); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v4 = 0x3717(505, msg.value);\n            v5 = _SafeDiv(1000, v4);\n            v6 = _SafeSub(v5, msg.value);\n            if (v1 == 0) {\n                require(_oneSplitInterfaceAddress.code.size);\n                v7, v8 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, 1, 0).gas(msg.gas);\n                require(v7); // checks call status, propagates error data on error\n                RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());\n                require(RETURNDATASIZE() >= 64);\n                v0 = MEM[MEM[64]];\n                require(MEM[32 + MEM[64]] <= 0x100000000);\n                require(MEM[32 + MEM[64]] + MEM[64] + 32 <= MEM[64] + RETURNDATASIZE());\n                require(!((MEM[MEM[32 + MEM[64]] + MEM[64]] > 0x100000000) | (MEM[32 + MEM[64]] + MEM[64] + 32 + (MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) > MEM[64] + RETURNDATASIZE())));\n                MEM[MEM[64]] = MEM[MEM[32 + MEM[64]] + MEM[64]];\n                v9 = 0;\n                while (v9 < MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) {\n                    MEM[MEM[64] + 32 + v9] = MEM[32 + (MEM[32 + MEM[64]] + MEM[64]) + v9];\n                    v9 = v9 + 32;\n                }\n            }\n            require(_oneSplitInterfaceAddress.code.size);\n            v10 = _oneSplitInterfaceAddress.goodSwap(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, v0, 1, 0).value(v5).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v11, v12 = _nEWDAI_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', v13, v13, v0);\n            v14 = 0x3717(3, MEM[MEM[64]]);\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v15, v16 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n            require(v15); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]]);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v17, v18 = _cOMPOUND_TOKEN_ADDRESS.mint(MEM[MEM[64]]).gas(msg.gas);\n            require(v17); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v19, v20 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v19); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', 40, v0, v0);\n            emit ERC20TokenHoldingsOnConversionDaiChai(MEM[MEM[64]], MEM[MEM[64]]);\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v21, v22 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS, 0).gas(msg.gas);\n            require(v21); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v23, v24 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), MEM[MEM[64]]).gas(msg.gas);\n            require(v23); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v25 = _SafeSub(v6, (address(MEM[MEM[0x40]])).balance);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v26, v27 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(MEM[MEM[0x40]])).gas(msg.gas);\n            require(v26); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v28 = 0x3717(MEM[MEM[64]], v6);\n            v29 = _SafeDiv(v25, v28);\n            require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n            require((address(MEM[MEM[0x40]])).code.size);\n            v30, v31 = address(MEM[MEM[0x40]]).addLiquidity(1, v29 + 1, block.timestamp + 1800).value(v6).gas(msg.gas);\n            require(v30); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v32, v33 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), 0).gas(msg.gas);\n            require(v32); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(MEM[MEM[0x40]])).code.size);\n            v34, v35 = address(MEM[MEM[0x40]]).balanceOf(address(this)).gas(msg.gas);\n            require(v34); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            emit LiquidityTokens(v35);\n            require((address(MEM[MEM[0x40]])).code.size);\n            v36, v37 = address(MEM[MEM[0x40]]).transfer(msg.sender, v35).gas(msg.gas);\n            require(v36); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v38, v39 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v38); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v40, v41 = _cOMPOUND_TOKEN_ADDRESS.transfer(msg.sender, MEM[MEM[64]]).gas(msg.gas);\n            require(v40); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        }\n    }\n}\n\nfunction set_OneSplitInterfaceAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _oneSplitInterfaceAddress = varg0;\n    _oNESPLIT_ADDRESS = varg0;\n}\n\nfunction set_new_DAI_TOKEN_ADDRESS(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _nEWDAI_TOKEN_ADDRESS = varg0;\n    _dAI_TOKEN_ADDRESS = varg0;\n}\n\nfunction toggleContractActive() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _toggleContractActive = !_toggleContractActive;\n}\n\nfunction ETH_TOKEN_ADDRESS() public nonPayable { \n    return _eTH_TOKEN_ADDRESS;\n}\n\nfunction getReturn(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1.code.size);\n    v0, v1 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = 0x3717(varg0.balance, varg2);\n    v5 = _SafeDiv(MEM[MEM[64]], v4);\n    v6 = 0x3717(MEM[MEM[64]], varg2);\n    v7 = _SafeDiv(MEM[MEM[64]], v6);\n    require(varg0.code.size);\n    v8, v9 = varg0.getTokenToEthInputPrice(v7).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]] + v5 >= MEM[MEM[64]], 'SafeMath: addition overflow');\n    return MEM[MEM[64]] + v5, v5, v7;\n}\n\nfunction 0x3717(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (26) {\n            MEM[v0.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n        }\n        revert(v0);\n    }\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction Redeem(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = 0;\n    if (!_toggleContractActive) {\n        require(_uniSwapFactoryAddress.code.size);\n        v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v3)).code.size);\n        v4, v5 = address(v3).transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v6, v7 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(v3)).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v3)).code.size);\n        v8, v9 = address(v3).totalSupply().gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v10 = 0x3717((address(v3)).balance, varg1);\n        v11 = _SafeDiv(MEM[MEM[64]], v10);\n        v12 = 0x3717(MEM[MEM[64]], varg1);\n        v13 = _SafeDiv(MEM[MEM[64]], v12);\n        require((address(v3)).code.size);\n        v14, v15 = address(v3).getTokenToEthInputPrice(v13).gas(msg.gas);\n        require(v14); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] + v11 >= MEM[MEM[64]], 'SafeMath: addition overflow');\n        require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n        require((address(v3)).code.size);\n        v16, v17, v18 = address(v3).removeLiquidity(varg1, v19, v13, block.timestamp + 1800).gas(msg.gas);\n        require(v16); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 64);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v20, v21 = _cOMPOUND_TOKEN_ADDRESS.approve(_oNESPLIT_ADDRESS, v18).gas(msg.gas);\n        require(v20); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_oneSplitInterfaceAddress.code.size);\n        v22, v23 = _oneSplitInterfaceAddress.getExpectedReturn(_cOMPOUND_TOKEN_ADDRESS, _eTH_TOKEN_ADDRESS, v18, 1, 0).gas(msg.gas);\n        require(v22); // checks call status, propagates error data on error\n        RETURNDATACOPY(v23, 0, RETURNDATASIZE());\n        require(RETURNDATASIZE() >= 64);\n        require(MEM[32 + v23] <= 0x100000000);\n        require(MEM[32 + v23] + v23 + 32 <= v23 + RETURNDATASIZE());\n        require(!((MEM[MEM[32 + v23] + v23] > 0x100000000) | (MEM[32 + v23] + v23 + 32 + (MEM[MEM[32 + v23] + v23] << 5) > v23 + RETURNDATASIZE())));\n        MEM[MEM[64]] = MEM[MEM[32 + v23] + v23];\n        v24 = v25 = 0;\n        while (v24 < MEM[MEM[32 + v23] + v23] << 5) {\n            MEM[MEM[64] + 32 + v24] = MEM[32 + (MEM[32 + v23] + v23) + v24];\n            v24 = v24 + 32;\n        }\n        require(_oneSplitInterfaceAddress.code.size);\n        v26 = _oneSplitInterfaceAddress.goodSwap(_cOMPOUND_TOKEN_ADDRESS, _eTH_TOKEN_ADDRESS, v18, MEM[v23], 1, 0).gas(msg.gas);\n        require(v26); // checks call status, propagates error data on error\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v27, v28 = _cOMPOUND_TOKEN_ADDRESS.approve(_oNESPLIT_ADDRESS, 0).gas(msg.gas);\n        require(v27); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v0 = v17 + MEM[v23];\n        require(v0 >= v17, 'SafeMath: addition overflow');\n        v29, v30 = varg0.call().value(v0).gas(50000);\n        if (RETURNDATASIZE() != 0) {\n            v31 = new bytes[](RETURNDATASIZE());\n            v30 = v31.data;\n            RETURNDATACOPY(v30, 0, RETURNDATASIZE());\n        }\n        require(v29, 'transfer of ETH failed');\n    }\n    return v0;\n}\n\nfunction destruct() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    selfdestruct(_owner);\n}\n\nfunction OneSplitInterfaceAddress() public nonPayable { \n    return _oneSplitInterfaceAddress;\n}\n\nfunction COMPOUND_TOKEN_ADDRESS() public nonPayable { \n    return _cOMPOUND_TOKEN_ADDRESS;\n}\n\nfunction ONESPLIT_ADDRESS() public nonPayable { \n    return _oNESPLIT_ADDRESS;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction getEthBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return varg0.balance;\n}\n\nfunction UniSwapFactoryAddress() public nonPayable { \n    return _uniSwapFactoryAddress;\n}\n\nfunction inCaseTokengetsStuck(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction set_new_cDAI_TokenContractAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _cOMPOUND_TOKEN_ADDRESS = varg0;\n}\n\nfunction DAI_TOKEN_ADDRESS() public nonPayable { \n    return _dAI_TOKEN_ADDRESS;\n}\n\nfunction initialize() public nonPayable { \n    v0 = v1 = _initialize;\n    if (!v1) {\n        v0 = v2 = this.code.size == 0;\n    }\n    if (!v0) {\n        v0 = !stor_0_0_0;\n    }\n    require(v0, 'Contract instance has already been initialized');\n    if (!_initialize) {\n        _initialize = 1;\n        stor_0_0_0 = 1;\n    }\n    _toggleContractActive = 0;\n    _owner = msg.sender;\n    _uniSwapFactoryAddress = 0xc0a47dfe034b400b47bdad5fecda2621de6c4d95;\n    _nEWDAI_TOKEN_ADDRESS = 0x6b175474e89094c44da98b954eedeac495271d0f;\n    _cOMPOUND_TOKEN_ADDRESS = 0x5d3a536e4d6dbd6114cc1ead35777bab948e3643;\n    _oneSplitInterfaceAddress = 0xd010b65120e027419586216d25bf86c2c24fcc4a;\n    _oNESPLIT_ADDRESS = 0xd010b65120e027419586216d25bf86c2c24fcc4a;\n    _dAI_TOKEN_ADDRESS = 0x6b175474e89094c44da98b954eedeac495271d0f;\n    _eTH_TOKEN_ADDRESS = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n    if (!_initialize) {\n        _initialize = 0;\n    }\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _owner;\n}\n\nfunction getExpectedReturn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_oneSplitInterfaceAddress.code.size);\n    v0, v1 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, varg0, 1, 0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 64);\n    require(MEM[32 + v1] <= 0x100000000);\n    require(MEM[32 + v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[32 + v1] + v1] > 0x100000000) | (MEM[32 + v1] + v1 + 32 + (MEM[MEM[32 + v1] + v1] << 5) > v1 + RETURNDATASIZE())));\n    MEM[MEM[64]] = MEM[MEM[32 + v1] + v1];\n    v2 = v3 = 0;\n    while (v2 < MEM[MEM[32 + v1] + v1] << 5) {\n        MEM[MEM[64] + 32 + v2] = MEM[32 + (MEM[32 + v1] + v1) + v2];\n        v2 = v2 + 32;\n    }\n    return MEM[v1];\n}\n\nfunction set_new_UniSwapFactoryAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _uniSwapFactoryAddress = varg0;\n}\n\nfunction getMaxTokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = _SafeSub(varg2, varg0.balance);\n    require(varg1.code.size);\n    v1, v2 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = 0x3717(MEM[MEM[64]], varg2);\n    v4 = _SafeDiv(v0, v3);\n    return v4 + 1;\n}\n\nfunction getTokenReserves(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1.code.size);\n    v0, v1 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction LetsInvest(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = 0;\n    if (!_toggleContractActive) {\n        require(_uniSwapFactoryAddress.code.size);\n        v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v4 = 0x3717(505, msg.value);\n        v5 = _SafeDiv(1000, v4);\n        v6 = _SafeSub(v5, msg.value);\n        if (varg1 == 0) {\n            require(_oneSplitInterfaceAddress.code.size);\n            v7, v8 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, 1, 0).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());\n            require(RETURNDATASIZE() >= 64);\n            v9 = MEM[MEM[64]];\n            require(MEM[32 + MEM[64]] <= 0x100000000);\n            require(MEM[32 + MEM[64]] + MEM[64] + 32 <= MEM[64] + RETURNDATASIZE());\n            require(!((MEM[MEM[32 + MEM[64]] + MEM[64]] > 0x100000000) | (MEM[32 + MEM[64]] + MEM[64] + 32 + (MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) > MEM[64] + RETURNDATASIZE())));\n            MEM[MEM[64]] = MEM[MEM[32 + MEM[64]] + MEM[64]];\n            v10 = v11 = 0;\n            while (v10 < MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) {\n                MEM[MEM[64] + 32 + v10] = MEM[32 + (MEM[32 + MEM[64]] + MEM[64]) + v10];\n                v10 = v10 + 32;\n            }\n        }\n        require(_oneSplitInterfaceAddress.code.size);\n        v12 = _oneSplitInterfaceAddress.goodSwap(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, v9, 1, 0).value(v5).gas(msg.gas);\n        require(v12); // checks call status, propagates error data on error\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v13, v14 = _nEWDAI_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', v15, v15, v9);\n        v16 = 0x3717(3, MEM[MEM[64]]);\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v17, v18 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v17); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]]);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v19, v20 = _cOMPOUND_TOKEN_ADDRESS.mint(MEM[MEM[64]]).gas(msg.gas);\n        require(v19); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v21, v22 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v21); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', 40, v9, v9);\n        emit ERC20TokenHoldingsOnConversionDaiChai(MEM[MEM[64]], MEM[MEM[64]]);\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v23, v24 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS, 0).gas(msg.gas);\n        require(v23); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v25, v26 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), MEM[MEM[64]]).gas(msg.gas);\n        require(v25); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v27 = _SafeSub(v6, (address(MEM[MEM[0x40]])).balance);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v28, v29 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(MEM[MEM[0x40]])).gas(msg.gas);\n        require(v28); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v30 = 0x3717(MEM[MEM[64]], v6);\n        v31 = _SafeDiv(v27, v30);\n        require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n        require((address(MEM[MEM[0x40]])).code.size);\n        v32, v33 = address(MEM[MEM[0x40]]).addLiquidity(1, v31 + 1, block.timestamp + 1800).value(v6).gas(msg.gas);\n        require(v32); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v34, v35 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), 0).gas(msg.gas);\n        require(v34); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(MEM[MEM[0x40]])).code.size);\n        v36, v0 = address(MEM[MEM[0x40]]).balanceOf(address(this)).gas(msg.gas);\n        require(v36); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        emit LiquidityTokens(v0);\n        require((address(MEM[MEM[0x40]])).code.size);\n        v37, v38 = address(MEM[MEM[0x40]]).transfer(varg0, v0).gas(msg.gas);\n        require(v37); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v39, v40 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v39); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v41, v42 = _cOMPOUND_TOKEN_ADDRESS.transfer(varg0, MEM[MEM[64]]).gas(msg.gas);\n        require(v41); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    return v0;\n}\n\nfunction NEWDAI_TOKEN_ADDRESS() public nonPayable { \n    return _nEWDAI_TOKEN_ADDRESS;\n}\n\nfunction getTotalShares(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0.code.size);\n    v0, v1 = varg0.totalSupply().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    require(varg0 != 0, 'Ownable: new owner is the zero address');\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x551196d5 > v0) {\n            if (0x2b68b9c6 > v0) {\n                if (0xc25e0e0 == v0) {\n                    set_OneSplitInterfaceAddress(address);\n                } else if (0xd30e929 == v0) {\n                    set_new_DAI_TOKEN_ADDRESS(address);\n                } else if (0x1385d24c == v0) {\n                    toggleContractActive();\n                } else if (0x1878d1f1 == v0) {\n                    ETH_TOKEN_ADDRESS();\n                } else if (0x1e1401f8 == v0) {\n                    getReturn(address,address,uint256);\n                } else if (0x222838db == v0) {\n                    Redeem(address,uint256);\n                }\n            } else if (0x3bd1db77 > v0) {\n                if (0x2b68b9c6 == v0) {\n                    destruct();\n                } else if (0x2c8158dc == v0) {\n                    OneSplitInterfaceAddress();\n                } else if (0x30139f7f == v0) {\n                    COMPOUND_TOKEN_ADDRESS();\n                }\n            } else if (0x3bd1db77 == v0) {\n                ONESPLIT_ADDRESS();\n            } else if (0x3ccfd60b == v0) {\n                withdraw();\n            } else if (0x4d2301cc == v0) {\n                getEthBalance(address);\n            } else if (0x525d509e == v0) {\n                UniSwapFactoryAddress();\n            }\n        } else if (0xae4de7fa > v0) {\n            if (0x8129fc1c > v0) {\n                if (0x551196d5 == v0) {\n                    inCaseTokengetsStuck(address);\n                } else if (0x588f08c4 == v0) {\n                    set_new_cDAI_TokenContractAddress(address);\n                } else if (0x80ad3008 == v0) {\n                    DAI_TOKEN_ADDRESS();\n                }\n            } else if (0x8129fc1c == v0) {\n                initialize();\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x8f32d59b == v0) {\n                isOwner();\n            } else if (0x965c0f28 == v0) {\n                getExpectedReturn(uint256);\n            }\n        } else if (0xe8c949c3 > v0) {\n            if (0xae4de7fa == v0) {\n                set_new_UniSwapFactoryAddress(address);\n            } else if (0xb1adb190 == v0) {\n                getMaxTokens(address,address,uint256);\n            } else if (0xd95b28bd == v0) {\n                getTokenReserves(address,address);\n            }\n        } else if (0xe8c949c3 == v0) {\n            LetsInvest(address,uint256);\n        } else if (0xea181d1d == v0) {\n            NEWDAI_TOKEN_ADDRESS();\n        } else if (0xf20d8634 == v0) {\n            getTotalShares(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 13:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint8 _initialize; // STORAGE[0x0] bytes 1 to 1\nuint8 _toggleContractActive; // STORAGE[0x33] bytes 0 to 0\naddress _owner; // STORAGE[0x33] bytes 1 to 20\naddress _uniSwapFactoryAddress; // STORAGE[0x34] bytes 0 to 19\naddress _oneSplitInterfaceAddress; // STORAGE[0x35] bytes 0 to 19\naddress _nEWDAI_TOKEN_ADDRESS; // STORAGE[0x36] bytes 0 to 19\naddress _cOMPOUND_TOKEN_ADDRESS; // STORAGE[0x37] bytes 0 to 19\nuint160 _dAI_TOKEN_ADDRESS; // STORAGE[0x38] bytes 0 to 19\nuint160 _eTH_TOKEN_ADDRESS; // STORAGE[0x39] bytes 0 to 19\nuint160 _oNESPLIT_ADDRESS; // STORAGE[0x3a] bytes 0 to 19\n\n// Events\nERC20TokenHoldingsOnConversionDaiChai(uint256);\nLiquidityTokens(uint256);\n\nfunction fallback() public payable { \n    if (msg.sender != _owner) {\n        v0 = v1 = 0;\n        if (!_toggleContractActive) {\n            require(_uniSwapFactoryAddress.code.size);\n            v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n            require(v2); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v4 = 0x3717(505, msg.value);\n            v5 = _SafeDiv(1000, v4);\n            v6 = _SafeSub(v5, msg.value);\n            if (v1 == 0) {\n                require(_oneSplitInterfaceAddress.code.size);\n                v7, v8 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, 1, 0).gas(msg.gas);\n                require(v7); // checks call status, propagates error data on error\n                RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());\n                require(RETURNDATASIZE() >= 64);\n                v0 = MEM[MEM[64]];\n                require(MEM[32 + MEM[64]] <= 0x100000000);\n                require(MEM[32 + MEM[64]] + MEM[64] + 32 <= MEM[64] + RETURNDATASIZE());\n                require(!((MEM[MEM[32 + MEM[64]] + MEM[64]] > 0x100000000) | (MEM[32 + MEM[64]] + MEM[64] + 32 + (MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) > MEM[64] + RETURNDATASIZE())));\n                MEM[MEM[64]] = MEM[MEM[32 + MEM[64]] + MEM[64]];\n                v9 = 0;\n                while (v9 < MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) {\n                    MEM[MEM[64] + 32 + v9] = MEM[32 + (MEM[32 + MEM[64]] + MEM[64]) + v9];\n                    v9 = v9 + 32;\n                }\n            }\n            require(_oneSplitInterfaceAddress.code.size);\n            v10 = _oneSplitInterfaceAddress.goodSwap(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, v0, 1, 0).value(v5).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v11, v12 = _nEWDAI_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', v13, v13, v0);\n            v14 = 0x3717(3, MEM[MEM[64]]);\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v15, v16 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n            require(v15); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]]);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v17, v18 = _cOMPOUND_TOKEN_ADDRESS.mint(MEM[MEM[64]]).gas(msg.gas);\n            require(v17); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v19, v20 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v19); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', 40, v0, v0);\n            emit ERC20TokenHoldingsOnConversionDaiChai(MEM[MEM[64]], MEM[MEM[64]]);\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v21, v22 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS, 0).gas(msg.gas);\n            require(v21); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v23, v24 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), MEM[MEM[64]]).gas(msg.gas);\n            require(v23); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v25 = _SafeSub(v6, (address(MEM[MEM[0x40]])).balance);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v26, v27 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(MEM[MEM[0x40]])).gas(msg.gas);\n            require(v26); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v28 = 0x3717(MEM[MEM[64]], v6);\n            v29 = _SafeDiv(v25, v28);\n            require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n            require((address(MEM[MEM[0x40]])).code.size);\n            v30, v31 = address(MEM[MEM[0x40]]).addLiquidity(1, v29 + 1, block.timestamp + 1800).value(v6).gas(msg.gas);\n            require(v30); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v32, v33 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), 0).gas(msg.gas);\n            require(v32); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(MEM[MEM[0x40]])).code.size);\n            v34, v35 = address(MEM[MEM[0x40]]).balanceOf(address(this)).gas(msg.gas);\n            require(v34); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            emit LiquidityTokens(v35);\n            require((address(MEM[MEM[0x40]])).code.size);\n            v36, v37 = address(MEM[MEM[0x40]]).transfer(msg.sender, v35).gas(msg.gas);\n            require(v36); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v38, v39 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v38); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v40, v41 = _cOMPOUND_TOKEN_ADDRESS.transfer(msg.sender, MEM[MEM[64]]).gas(msg.gas);\n            require(v40); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        }\n    }\n}\n\nfunction set_OneSplitInterfaceAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _oneSplitInterfaceAddress = varg0;\n    _oNESPLIT_ADDRESS = varg0;\n}\n\nfunction set_new_DAI_TOKEN_ADDRESS(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _nEWDAI_TOKEN_ADDRESS = varg0;\n    _dAI_TOKEN_ADDRESS = varg0;\n}\n\nfunction toggleContractActive() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _toggleContractActive = !_toggleContractActive;\n}\n\nfunction ETH_TOKEN_ADDRESS() public nonPayable { \n    return _eTH_TOKEN_ADDRESS;\n}\n\nfunction getReturn(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1.code.size);\n    v0, v1 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = 0x3717(varg0.balance, varg2);\n    v5 = _SafeDiv(MEM[MEM[64]], v4);\n    v6 = 0x3717(MEM[MEM[64]], varg2);\n    v7 = _SafeDiv(MEM[MEM[64]], v6);\n    require(varg0.code.size);\n    v8, v9 = varg0.getTokenToEthInputPrice(v7).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]] + v5 >= MEM[MEM[64]], 'SafeMath: addition overflow');\n    return MEM[MEM[64]] + v5, v5, v7;\n}\n\nfunction 0x3717(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (26) {\n            MEM[v0.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n        }\n        revert(v0);\n    }\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction Redeem(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = 0;\n    if (!_toggleContractActive) {\n        require(_uniSwapFactoryAddress.code.size);\n        v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v3)).code.size);\n        v4, v5 = address(v3).transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v6, v7 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(v3)).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v3)).code.size);\n        v8, v9 = address(v3).totalSupply().gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v10 = 0x3717((address(v3)).balance, varg1);\n        v11 = _SafeDiv(MEM[MEM[64]], v10);\n        v12 = 0x3717(MEM[MEM[64]], varg1);\n        v13 = _SafeDiv(MEM[MEM[64]], v12);\n        require((address(v3)).code.size);\n        v14, v15 = address(v3).getTokenToEthInputPrice(v13).gas(msg.gas);\n        require(v14); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] + v11 >= MEM[MEM[64]], 'SafeMath: addition overflow');\n        require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n        require((address(v3)).code.size);\n        v16, v17, v18 = address(v3).removeLiquidity(varg1, v19, v13, block.timestamp + 1800).gas(msg.gas);\n        require(v16); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 64);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v20, v21 = _cOMPOUND_TOKEN_ADDRESS.approve(_oNESPLIT_ADDRESS, v18).gas(msg.gas);\n        require(v20); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_oneSplitInterfaceAddress.code.size);\n        v22, v23 = _oneSplitInterfaceAddress.getExpectedReturn(_cOMPOUND_TOKEN_ADDRESS, _eTH_TOKEN_ADDRESS, v18, 1, 0).gas(msg.gas);\n        require(v22); // checks call status, propagates error data on error\n        RETURNDATACOPY(v23, 0, RETURNDATASIZE());\n        require(RETURNDATASIZE() >= 64);\n        require(MEM[32 + v23] <= 0x100000000);\n        require(MEM[32 + v23] + v23 + 32 <= v23 + RETURNDATASIZE());\n        require(!((MEM[MEM[32 + v23] + v23] > 0x100000000) | (MEM[32 + v23] + v23 + 32 + (MEM[MEM[32 + v23] + v23] << 5) > v23 + RETURNDATASIZE())));\n        MEM[MEM[64]] = MEM[MEM[32 + v23] + v23];\n        v24 = v25 = 0;\n        while (v24 < MEM[MEM[32 + v23] + v23] << 5) {\n            MEM[MEM[64] + 32 + v24] = MEM[32 + (MEM[32 + v23] + v23) + v24];\n            v24 = v24 + 32;\n        }\n        require(_oneSplitInterfaceAddress.code.size);\n        v26 = _oneSplitInterfaceAddress.goodSwap(_cOMPOUND_TOKEN_ADDRESS, _eTH_TOKEN_ADDRESS, v18, MEM[v23], 1, 0).gas(msg.gas);\n        require(v26); // checks call status, propagates error data on error\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v27, v28 = _cOMPOUND_TOKEN_ADDRESS.approve(_oNESPLIT_ADDRESS, 0).gas(msg.gas);\n        require(v27); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v0 = v17 + MEM[v23];\n        require(v0 >= v17, 'SafeMath: addition overflow');\n        v29, v30 = varg0.call().value(v0).gas(50000);\n        if (RETURNDATASIZE() != 0) {\n            v31 = new bytes[](RETURNDATASIZE());\n            v30 = v31.data;\n            RETURNDATACOPY(v30, 0, RETURNDATASIZE());\n        }\n        require(v29, 'transfer of ETH failed');\n    }\n    return v0;\n}\n\nfunction destruct() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    selfdestruct(_owner);\n}\n\nfunction OneSplitInterfaceAddress() public nonPayable { \n    return _oneSplitInterfaceAddress;\n}\n\nfunction COMPOUND_TOKEN_ADDRESS() public nonPayable { \n    return _cOMPOUND_TOKEN_ADDRESS;\n}\n\nfunction ONESPLIT_ADDRESS() public nonPayable { \n    return _oNESPLIT_ADDRESS;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction getEthBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return varg0.balance;\n}\n\nfunction UniSwapFactoryAddress() public nonPayable { \n    return _uniSwapFactoryAddress;\n}\n\nfunction inCaseTokengetsStuck(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction set_new_cDAI_TokenContractAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _cOMPOUND_TOKEN_ADDRESS = varg0;\n}\n\nfunction DAI_TOKEN_ADDRESS() public nonPayable { \n    return _dAI_TOKEN_ADDRESS;\n}\n\nfunction initialize() public nonPayable { \n    v0 = v1 = _initialize;\n    if (!v1) {\n        v0 = v2 = this.code.size == 0;\n    }\n    if (!v0) {\n        v0 = !stor_0_0_0;\n    }\n    require(v0, 'Contract instance has already been initialized');\n    if (!_initialize) {\n        _initialize = 1;\n        stor_0_0_0 = 1;\n    }\n    _toggleContractActive = 0;\n    _owner = msg.sender;\n    _uniSwapFactoryAddress = 0xc0a47dfe034b400b47bdad5fecda2621de6c4d95;\n    _nEWDAI_TOKEN_ADDRESS = 0x6b175474e89094c44da98b954eedeac495271d0f;\n    _cOMPOUND_TOKEN_ADDRESS = 0x5d3a536e4d6dbd6114cc1ead35777bab948e3643;\n    _oneSplitInterfaceAddress = 0xd010b65120e027419586216d25bf86c2c24fcc4a;\n    _oNESPLIT_ADDRESS = 0xd010b65120e027419586216d25bf86c2c24fcc4a;\n    _dAI_TOKEN_ADDRESS = 0x6b175474e89094c44da98b954eedeac495271d0f;\n    _eTH_TOKEN_ADDRESS = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n    if (!_initialize) {\n        _initialize = 0;\n    }\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _owner;\n}\n\nfunction getExpectedReturn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_oneSplitInterfaceAddress.code.size);\n    v0, v1 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, varg0, 1, 0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 64);\n    require(MEM[32 + v1] <= 0x100000000);\n    require(MEM[32 + v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[32 + v1] + v1] > 0x100000000) | (MEM[32 + v1] + v1 + 32 + (MEM[MEM[32 + v1] + v1] << 5) > v1 + RETURNDATASIZE())));\n    MEM[MEM[64]] = MEM[MEM[32 + v1] + v1];\n    v2 = v3 = 0;\n    while (v2 < MEM[MEM[32 + v1] + v1] << 5) {\n        MEM[MEM[64] + 32 + v2] = MEM[32 + (MEM[32 + v1] + v1) + v2];\n        v2 = v2 + 32;\n    }\n    return MEM[v1];\n}\n\nfunction set_new_UniSwapFactoryAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _uniSwapFactoryAddress = varg0;\n}\n\nfunction getMaxTokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = _SafeSub(varg2, varg0.balance);\n    require(varg1.code.size);\n    v1, v2 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = 0x3717(MEM[MEM[64]], varg2);\n    v4 = _SafeDiv(v0, v3);\n    return v4 + 1;\n}\n\nfunction getTokenReserves(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1.code.size);\n    v0, v1 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction LetsInvest(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = 0;\n    if (!_toggleContractActive) {\n        require(_uniSwapFactoryAddress.code.size);\n        v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v4 = 0x3717(505, msg.value);\n        v5 = _SafeDiv(1000, v4);\n        v6 = _SafeSub(v5, msg.value);\n        if (varg1 == 0) {\n            require(_oneSplitInterfaceAddress.code.size);\n            v7, v8 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, 1, 0).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());\n            require(RETURNDATASIZE() >= 64);\n            v9 = MEM[MEM[64]];\n            require(MEM[32 + MEM[64]] <= 0x100000000);\n            require(MEM[32 + MEM[64]] + MEM[64] + 32 <= MEM[64] + RETURNDATASIZE());\n            require(!((MEM[MEM[32 + MEM[64]] + MEM[64]] > 0x100000000) | (MEM[32 + MEM[64]] + MEM[64] + 32 + (MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) > MEM[64] + RETURNDATASIZE())));\n            MEM[MEM[64]] = MEM[MEM[32 + MEM[64]] + MEM[64]];\n            v10 = v11 = 0;\n            while (v10 < MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) {\n                MEM[MEM[64] + 32 + v10] = MEM[32 + (MEM[32 + MEM[64]] + MEM[64]) + v10];\n                v10 = v10 + 32;\n            }\n        }\n        require(_oneSplitInterfaceAddress.code.size);\n        v12 = _oneSplitInterfaceAddress.goodSwap(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, v9, 1, 0).value(v5).gas(msg.gas);\n        require(v12); // checks call status, propagates error data on error\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v13, v14 = _nEWDAI_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', v15, v15, v9);\n        v16 = 0x3717(3, MEM[MEM[64]]);\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v17, v18 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v17); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]]);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v19, v20 = _cOMPOUND_TOKEN_ADDRESS.mint(MEM[MEM[64]]).gas(msg.gas);\n        require(v19); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v21, v22 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v21); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', 40, v9, v9);\n        emit ERC20TokenHoldingsOnConversionDaiChai(MEM[MEM[64]], MEM[MEM[64]]);\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v23, v24 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS, 0).gas(msg.gas);\n        require(v23); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v25, v26 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), MEM[MEM[64]]).gas(msg.gas);\n        require(v25); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v27 = _SafeSub(v6, (address(MEM[MEM[0x40]])).balance);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v28, v29 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(MEM[MEM[0x40]])).gas(msg.gas);\n        require(v28); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v30 = 0x3717(MEM[MEM[64]], v6);\n        v31 = _SafeDiv(v27, v30);\n        require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n        require((address(MEM[MEM[0x40]])).code.size);\n        v32, v33 = address(MEM[MEM[0x40]]).addLiquidity(1, v31 + 1, block.timestamp + 1800).value(v6).gas(msg.gas);\n        require(v32); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v34, v35 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), 0).gas(msg.gas);\n        require(v34); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(MEM[MEM[0x40]])).code.size);\n        v36, v0 = address(MEM[MEM[0x40]]).balanceOf(address(this)).gas(msg.gas);\n        require(v36); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        emit LiquidityTokens(v0);\n        require((address(MEM[MEM[0x40]])).code.size);\n        v37, v38 = address(MEM[MEM[0x40]]).transfer(varg0, v0).gas(msg.gas);\n        require(v37); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v39, v40 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v39); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v41, v42 = _cOMPOUND_TOKEN_ADDRESS.transfer(varg0, MEM[MEM[64]]).gas(msg.gas);\n        require(v41); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    return v0;\n}\n\nfunction NEWDAI_TOKEN_ADDRESS() public nonPayable { \n    return _nEWDAI_TOKEN_ADDRESS;\n}\n\nfunction getTotalShares(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0.code.size);\n    v0, v1 = varg0.totalSupply().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    require(varg0 != 0, 'Ownable: new owner is the zero address');\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x551196d5 > v0) {\n            if (0x2b68b9c6 > v0) {\n                if (0xc25e0e0 == v0) {\n                    set_OneSplitInterfaceAddress(address);\n                } else if (0xd30e929 == v0) {\n                    set_new_DAI_TOKEN_ADDRESS(address);\n                } else if (0x1385d24c == v0) {\n                    toggleContractActive();\n                } else if (0x1878d1f1 == v0) {\n                    ETH_TOKEN_ADDRESS();\n                } else if (0x1e1401f8 == v0) {\n                    getReturn(address,address,uint256);\n                } else if (0x222838db == v0) {\n                    Redeem(address,uint256);\n                }\n            } else if (0x3bd1db77 > v0) {\n                if (0x2b68b9c6 == v0) {\n                    destruct();\n                } else if (0x2c8158dc == v0) {\n                    OneSplitInterfaceAddress();\n                } else if (0x30139f7f == v0) {\n                    COMPOUND_TOKEN_ADDRESS();\n                }\n            } else if (0x3bd1db77 == v0) {\n                ONESPLIT_ADDRESS();\n            } else if (0x3ccfd60b == v0) {\n                withdraw();\n            } else if (0x4d2301cc == v0) {\n                getEthBalance(address);\n            } else if (0x525d509e == v0) {\n                UniSwapFactoryAddress();\n            }\n        } else if (0xae4de7fa > v0) {\n            if (0x8129fc1c > v0) {\n                if (0x551196d5 == v0) {\n                    inCaseTokengetsStuck(address);\n                } else if (0x588f08c4 == v0) {\n                    set_new_cDAI_TokenContractAddress(address);\n                } else if (0x80ad3008 == v0) {\n                    DAI_TOKEN_ADDRESS();\n                }\n            } else if (0x8129fc1c == v0) {\n                initialize();\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x8f32d59b == v0) {\n                isOwner();\n            } else if (0x965c0f28 == v0) {\n                getExpectedReturn(uint256);\n            }\n        } else if (0xe8c949c3 > v0) {\n            if (0xae4de7fa == v0) {\n                set_new_UniSwapFactoryAddress(address);\n            } else if (0xb1adb190 == v0) {\n                getMaxTokens(address,address,uint256);\n            } else if (0xd95b28bd == v0) {\n                getTokenReserves(address,address);\n            }\n        } else if (0xe8c949c3 == v0) {\n            LetsInvest(address,uint256);\n        } else if (0xea181d1d == v0) {\n            NEWDAI_TOKEN_ADDRESS();\n        } else if (0xf20d8634 == v0) {\n            getTotalShares(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 13:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint8 _initialize; // STORAGE[0x0] bytes 1 to 1\nuint8 _toggleContractActive; // STORAGE[0x33] bytes 0 to 0\naddress _owner; // STORAGE[0x33] bytes 1 to 20\naddress _uniSwapFactoryAddress; // STORAGE[0x34] bytes 0 to 19\naddress _oneSplitInterfaceAddress; // STORAGE[0x35] bytes 0 to 19\naddress _nEWDAI_TOKEN_ADDRESS; // STORAGE[0x36] bytes 0 to 19\naddress _cOMPOUND_TOKEN_ADDRESS; // STORAGE[0x37] bytes 0 to 19\nuint160 _dAI_TOKEN_ADDRESS; // STORAGE[0x38] bytes 0 to 19\nuint160 _eTH_TOKEN_ADDRESS; // STORAGE[0x39] bytes 0 to 19\nuint160 _oNESPLIT_ADDRESS; // STORAGE[0x3a] bytes 0 to 19\n\n// Events\nERC20TokenHoldingsOnConversionDaiChai(uint256);\nLiquidityTokens(uint256);\n\nfunction fallback() public payable { \n    if (msg.sender != _owner) {\n        v0 = v1 = 0;\n        if (!_toggleContractActive) {\n            require(_uniSwapFactoryAddress.code.size);\n            v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n            require(v2); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v4 = 0x3717(505, msg.value);\n            v5 = _SafeDiv(1000, v4);\n            v6 = _SafeSub(v5, msg.value);\n            if (v1 == 0) {\n                require(_oneSplitInterfaceAddress.code.size);\n                v7, v8 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, 1, 0).gas(msg.gas);\n                require(v7); // checks call status, propagates error data on error\n                RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());\n                require(RETURNDATASIZE() >= 64);\n                v0 = MEM[MEM[64]];\n                require(MEM[32 + MEM[64]] <= 0x100000000);\n                require(MEM[32 + MEM[64]] + MEM[64] + 32 <= MEM[64] + RETURNDATASIZE());\n                require(!((MEM[MEM[32 + MEM[64]] + MEM[64]] > 0x100000000) | (MEM[32 + MEM[64]] + MEM[64] + 32 + (MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) > MEM[64] + RETURNDATASIZE())));\n                MEM[MEM[64]] = MEM[MEM[32 + MEM[64]] + MEM[64]];\n                v9 = 0;\n                while (v9 < MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) {\n                    MEM[MEM[64] + 32 + v9] = MEM[32 + (MEM[32 + MEM[64]] + MEM[64]) + v9];\n                    v9 = v9 + 32;\n                }\n            }\n            require(_oneSplitInterfaceAddress.code.size);\n            v10 = _oneSplitInterfaceAddress.goodSwap(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, v0, 1, 0).value(v5).gas(msg.gas);\n            require(v10); // checks call status, propagates error data on error\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v11, v12 = _nEWDAI_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v11); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', v13, v13, v0);\n            v14 = 0x3717(3, MEM[MEM[64]]);\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v15, v16 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n            require(v15); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]]);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v17, v18 = _cOMPOUND_TOKEN_ADDRESS.mint(MEM[MEM[64]]).gas(msg.gas);\n            require(v17); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v19, v20 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v19); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', 40, v0, v0);\n            emit ERC20TokenHoldingsOnConversionDaiChai(MEM[MEM[64]], MEM[MEM[64]]);\n            require(_nEWDAI_TOKEN_ADDRESS.code.size);\n            v21, v22 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS, 0).gas(msg.gas);\n            require(v21); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v23, v24 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), MEM[MEM[64]]).gas(msg.gas);\n            require(v23); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v25 = _SafeSub(v6, (address(MEM[MEM[0x40]])).balance);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v26, v27 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(MEM[MEM[0x40]])).gas(msg.gas);\n            require(v26); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v28 = 0x3717(MEM[MEM[64]], v6);\n            v29 = _SafeDiv(v25, v28);\n            require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n            require((address(MEM[MEM[0x40]])).code.size);\n            v30, v31 = address(MEM[MEM[0x40]]).addLiquidity(1, v29 + 1, block.timestamp + 1800).value(v6).gas(msg.gas);\n            require(v30); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v32, v33 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), 0).gas(msg.gas);\n            require(v32); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require((address(MEM[MEM[0x40]])).code.size);\n            v34, v35 = address(MEM[MEM[0x40]]).balanceOf(address(this)).gas(msg.gas);\n            require(v34); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            emit LiquidityTokens(v35);\n            require((address(MEM[MEM[0x40]])).code.size);\n            v36, v37 = address(MEM[MEM[0x40]]).transfer(msg.sender, v35).gas(msg.gas);\n            require(v36); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v38, v39 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n            require(v38); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n            v40, v41 = _cOMPOUND_TOKEN_ADDRESS.transfer(msg.sender, MEM[MEM[64]]).gas(msg.gas);\n            require(v40); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n        }\n    }\n}\n\nfunction set_OneSplitInterfaceAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _oneSplitInterfaceAddress = varg0;\n    _oNESPLIT_ADDRESS = varg0;\n}\n\nfunction set_new_DAI_TOKEN_ADDRESS(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _nEWDAI_TOKEN_ADDRESS = varg0;\n    _dAI_TOKEN_ADDRESS = varg0;\n}\n\nfunction toggleContractActive() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _toggleContractActive = !_toggleContractActive;\n}\n\nfunction ETH_TOKEN_ADDRESS() public nonPayable { \n    return _eTH_TOKEN_ADDRESS;\n}\n\nfunction getReturn(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1.code.size);\n    v0, v1 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.totalSupply().gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v4 = 0x3717(varg0.balance, varg2);\n    v5 = _SafeDiv(MEM[MEM[64]], v4);\n    v6 = 0x3717(MEM[MEM[64]], varg2);\n    v7 = _SafeDiv(MEM[MEM[64]], v6);\n    require(varg0.code.size);\n    v8, v9 = varg0.getTokenToEthInputPrice(v7).gas(msg.gas);\n    require(v8); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]] + v5 >= MEM[MEM[64]], 'SafeMath: addition overflow');\n    return MEM[MEM[64]] + v5, v5, v7;\n}\n\nfunction 0x3717(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (26) {\n            MEM[v0.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n        }\n        revert(v0);\n    }\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction Redeem(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = 0;\n    if (!_toggleContractActive) {\n        require(_uniSwapFactoryAddress.code.size);\n        v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v3)).code.size);\n        v4, v5 = address(v3).transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n        require(v4); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v6, v7 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(v3)).gas(msg.gas);\n        require(v6); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(v3)).code.size);\n        v8, v9 = address(v3).totalSupply().gas(msg.gas);\n        require(v8); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v10 = 0x3717((address(v3)).balance, varg1);\n        v11 = _SafeDiv(MEM[MEM[64]], v10);\n        v12 = 0x3717(MEM[MEM[64]], varg1);\n        v13 = _SafeDiv(MEM[MEM[64]], v12);\n        require((address(v3)).code.size);\n        v14, v15 = address(v3).getTokenToEthInputPrice(v13).gas(msg.gas);\n        require(v14); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] + v11 >= MEM[MEM[64]], 'SafeMath: addition overflow');\n        require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n        require((address(v3)).code.size);\n        v16, v17, v18 = address(v3).removeLiquidity(varg1, v19, v13, block.timestamp + 1800).gas(msg.gas);\n        require(v16); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 64);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v20, v21 = _cOMPOUND_TOKEN_ADDRESS.approve(_oNESPLIT_ADDRESS, v18).gas(msg.gas);\n        require(v20); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_oneSplitInterfaceAddress.code.size);\n        v22, v23 = _oneSplitInterfaceAddress.getExpectedReturn(_cOMPOUND_TOKEN_ADDRESS, _eTH_TOKEN_ADDRESS, v18, 1, 0).gas(msg.gas);\n        require(v22); // checks call status, propagates error data on error\n        RETURNDATACOPY(v23, 0, RETURNDATASIZE());\n        require(RETURNDATASIZE() >= 64);\n        require(MEM[32 + v23] <= 0x100000000);\n        require(MEM[32 + v23] + v23 + 32 <= v23 + RETURNDATASIZE());\n        require(!((MEM[MEM[32 + v23] + v23] > 0x100000000) | (MEM[32 + v23] + v23 + 32 + (MEM[MEM[32 + v23] + v23] << 5) > v23 + RETURNDATASIZE())));\n        MEM[MEM[64]] = MEM[MEM[32 + v23] + v23];\n        v24 = v25 = 0;\n        while (v24 < MEM[MEM[32 + v23] + v23] << 5) {\n            MEM[MEM[64] + 32 + v24] = MEM[32 + (MEM[32 + v23] + v23) + v24];\n            v24 = v24 + 32;\n        }\n        require(_oneSplitInterfaceAddress.code.size);\n        v26 = _oneSplitInterfaceAddress.goodSwap(_cOMPOUND_TOKEN_ADDRESS, _eTH_TOKEN_ADDRESS, v18, MEM[v23], 1, 0).gas(msg.gas);\n        require(v26); // checks call status, propagates error data on error\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v27, v28 = _cOMPOUND_TOKEN_ADDRESS.approve(_oNESPLIT_ADDRESS, 0).gas(msg.gas);\n        require(v27); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v0 = v17 + MEM[v23];\n        require(v0 >= v17, 'SafeMath: addition overflow');\n        v29, v30 = varg0.call().value(v0).gas(50000);\n        if (RETURNDATASIZE() != 0) {\n            v31 = new bytes[](RETURNDATASIZE());\n            v30 = v31.data;\n            RETURNDATACOPY(v30, 0, RETURNDATASIZE());\n        }\n        require(v29, 'transfer of ETH failed');\n    }\n    return v0;\n}\n\nfunction destruct() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    selfdestruct(_owner);\n}\n\nfunction OneSplitInterfaceAddress() public nonPayable { \n    return _oneSplitInterfaceAddress;\n}\n\nfunction COMPOUND_TOKEN_ADDRESS() public nonPayable { \n    return _cOMPOUND_TOKEN_ADDRESS;\n}\n\nfunction ONESPLIT_ADDRESS() public nonPayable { \n    return _oNESPLIT_ADDRESS;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction getEthBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return varg0.balance;\n}\n\nfunction UniSwapFactoryAddress() public nonPayable { \n    return _uniSwapFactoryAddress;\n}\n\nfunction inCaseTokengetsStuck(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(varg0.code.size);\n    v2, v3 = varg0.transfer(_owner, v1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction set_new_cDAI_TokenContractAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _cOMPOUND_TOKEN_ADDRESS = varg0;\n}\n\nfunction DAI_TOKEN_ADDRESS() public nonPayable { \n    return _dAI_TOKEN_ADDRESS;\n}\n\nfunction initialize() public nonPayable { \n    v0 = v1 = _initialize;\n    if (!v1) {\n        v0 = v2 = this.code.size == 0;\n    }\n    if (!v0) {\n        v0 = !stor_0_0_0;\n    }\n    require(v0, 'Contract instance has already been initialized');\n    if (!_initialize) {\n        _initialize = 1;\n        stor_0_0_0 = 1;\n    }\n    _toggleContractActive = 0;\n    _owner = msg.sender;\n    _uniSwapFactoryAddress = 0xc0a47dfe034b400b47bdad5fecda2621de6c4d95;\n    _nEWDAI_TOKEN_ADDRESS = 0x6b175474e89094c44da98b954eedeac495271d0f;\n    _cOMPOUND_TOKEN_ADDRESS = 0x5d3a536e4d6dbd6114cc1ead35777bab948e3643;\n    _oneSplitInterfaceAddress = 0xd010b65120e027419586216d25bf86c2c24fcc4a;\n    _oNESPLIT_ADDRESS = 0xd010b65120e027419586216d25bf86c2c24fcc4a;\n    _dAI_TOKEN_ADDRESS = 0x6b175474e89094c44da98b954eedeac495271d0f;\n    _eTH_TOKEN_ADDRESS = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\n    if (!_initialize) {\n        _initialize = 0;\n    }\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _owner;\n}\n\nfunction getExpectedReturn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_oneSplitInterfaceAddress.code.size);\n    v0, v1 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, varg0, 1, 0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 64);\n    require(MEM[32 + v1] <= 0x100000000);\n    require(MEM[32 + v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[32 + v1] + v1] > 0x100000000) | (MEM[32 + v1] + v1 + 32 + (MEM[MEM[32 + v1] + v1] << 5) > v1 + RETURNDATASIZE())));\n    MEM[MEM[64]] = MEM[MEM[32 + v1] + v1];\n    v2 = v3 = 0;\n    while (v2 < MEM[MEM[32 + v1] + v1] << 5) {\n        MEM[MEM[64] + 32 + v2] = MEM[32 + (MEM[32 + v1] + v1) + v2];\n        v2 = v2 + 32;\n    }\n    return MEM[v1];\n}\n\nfunction set_new_UniSwapFactoryAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    _uniSwapFactoryAddress = varg0;\n}\n\nfunction getMaxTokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    v0 = _SafeSub(varg2, varg0.balance);\n    require(varg1.code.size);\n    v1, v2 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = 0x3717(MEM[MEM[64]], varg2);\n    v4 = _SafeDiv(v0, v3);\n    return v4 + 1;\n}\n\nfunction getTokenReserves(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1.code.size);\n    v0, v1 = varg1.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction LetsInvest(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = 0;\n    if (!_toggleContractActive) {\n        require(_uniSwapFactoryAddress.code.size);\n        v2, v3 = _uniSwapFactoryAddress.getExchange(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v4 = 0x3717(505, msg.value);\n        v5 = _SafeDiv(1000, v4);\n        v6 = _SafeSub(v5, msg.value);\n        if (varg1 == 0) {\n            require(_oneSplitInterfaceAddress.code.size);\n            v7, v8 = _oneSplitInterfaceAddress.getExpectedReturn(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, 1, 0).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n            RETURNDATACOPY(MEM[64], 0, RETURNDATASIZE());\n            require(RETURNDATASIZE() >= 64);\n            v9 = MEM[MEM[64]];\n            require(MEM[32 + MEM[64]] <= 0x100000000);\n            require(MEM[32 + MEM[64]] + MEM[64] + 32 <= MEM[64] + RETURNDATASIZE());\n            require(!((MEM[MEM[32 + MEM[64]] + MEM[64]] > 0x100000000) | (MEM[32 + MEM[64]] + MEM[64] + 32 + (MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) > MEM[64] + RETURNDATASIZE())));\n            MEM[MEM[64]] = MEM[MEM[32 + MEM[64]] + MEM[64]];\n            v10 = v11 = 0;\n            while (v10 < MEM[MEM[32 + MEM[64]] + MEM[64]] << 5) {\n                MEM[MEM[64] + 32 + v10] = MEM[32 + (MEM[32 + MEM[64]] + MEM[64]) + v10];\n                v10 = v10 + 32;\n            }\n        }\n        require(_oneSplitInterfaceAddress.code.size);\n        v12 = _oneSplitInterfaceAddress.goodSwap(_eTH_TOKEN_ADDRESS, _dAI_TOKEN_ADDRESS, v5, v9, 1, 0).value(v5).gas(msg.gas);\n        require(v12); // checks call status, propagates error data on error\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v13, v14 = _nEWDAI_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v13); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', v15, v15, v9);\n        v16 = 0x3717(3, MEM[MEM[64]]);\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v17, v18 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS).gas(msg.gas);\n        require(v17); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]]);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v19, v20 = _cOMPOUND_TOKEN_ADDRESS.mint(MEM[MEM[64]]).gas(msg.gas);\n        require(v19); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v21, v22 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v21); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(MEM[MEM[64]] > 0, 'the conversion did not happen as planned', 40, v9, v9);\n        emit ERC20TokenHoldingsOnConversionDaiChai(MEM[MEM[64]], MEM[MEM[64]]);\n        require(_nEWDAI_TOKEN_ADDRESS.code.size);\n        v23, v24 = _nEWDAI_TOKEN_ADDRESS.approve(_cOMPOUND_TOKEN_ADDRESS, 0).gas(msg.gas);\n        require(v23); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v25, v26 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), MEM[MEM[64]]).gas(msg.gas);\n        require(v25); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v27 = _SafeSub(v6, (address(MEM[MEM[0x40]])).balance);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v28, v29 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(MEM[MEM[0x40]])).gas(msg.gas);\n        require(v28); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v30 = 0x3717(MEM[MEM[64]], v6);\n        v31 = _SafeDiv(v27, v30);\n        require(block.timestamp + 1800 >= block.timestamp, 'SafeMath: addition overflow');\n        require((address(MEM[MEM[0x40]])).code.size);\n        v32, v33 = address(MEM[MEM[0x40]]).addLiquidity(1, v31 + 1, block.timestamp + 1800).value(v6).gas(msg.gas);\n        require(v32); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v34, v35 = _cOMPOUND_TOKEN_ADDRESS.approve(address(MEM[MEM[0x40]]), 0).gas(msg.gas);\n        require(v34); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require((address(MEM[MEM[0x40]])).code.size);\n        v36, v0 = address(MEM[MEM[0x40]]).balanceOf(address(this)).gas(msg.gas);\n        require(v36); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        emit LiquidityTokens(v0);\n        require((address(MEM[MEM[0x40]])).code.size);\n        v37, v38 = address(MEM[MEM[0x40]]).transfer(varg0, v0).gas(msg.gas);\n        require(v37); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v39, v40 = _cOMPOUND_TOKEN_ADDRESS.balanceOf(address(this)).gas(msg.gas);\n        require(v39); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(_cOMPOUND_TOKEN_ADDRESS.code.size);\n        v41, v42 = _cOMPOUND_TOKEN_ADDRESS.transfer(varg0, MEM[MEM[64]]).gas(msg.gas);\n        require(v41); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n    }\n    return v0;\n}\n\nfunction NEWDAI_TOKEN_ADDRESS() public nonPayable { \n    return _nEWDAI_TOKEN_ADDRESS;\n}\n\nfunction getTotalShares(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0.code.size);\n    v0, v1 = varg0.totalSupply().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'you are not authorised to call this function');\n    require(varg0 != 0, 'Ownable: new owner is the zero address');\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x551196d5 > v0) {\n            if (0x2b68b9c6 > v0) {\n                if (0xc25e0e0 == v0) {\n                    set_OneSplitInterfaceAddress(address);\n                } else if (0xd30e929 == v0) {\n                    set_new_DAI_TOKEN_ADDRESS(address);\n                } else if (0x1385d24c == v0) {\n                    toggleContractActive();\n                } else if (0x1878d1f1 == v0) {\n                    ETH_TOKEN_ADDRESS();\n                } else if (0x1e1401f8 == v0) {\n                    getReturn(address,address,uint256);\n                } else if (0x222838db == v0) {\n                    Redeem(address,uint256);\n                }\n            } else if (0x3bd1db77 > v0) {\n                if (0x2b68b9c6 == v0) {\n                    destruct();\n                } else if (0x2c8158dc == v0) {\n                    OneSplitInterfaceAddress();\n                } else if (0x30139f7f == v0) {\n                    COMPOUND_TOKEN_ADDRESS();\n                }\n            } else if (0x3bd1db77 == v0) {\n                ONESPLIT_ADDRESS();\n            } else if (0x3ccfd60b == v0) {\n                withdraw();\n            } else if (0x4d2301cc == v0) {\n                getEthBalance(address);\n            } else if (0x525d509e == v0) {\n                UniSwapFactoryAddress();\n            }\n        } else if (0xae4de7fa > v0) {\n            if (0x8129fc1c > v0) {\n                if (0x551196d5 == v0) {\n                    inCaseTokengetsStuck(address);\n                } else if (0x588f08c4 == v0) {\n                    set_new_cDAI_TokenContractAddress(address);\n                } else if (0x80ad3008 == v0) {\n                    DAI_TOKEN_ADDRESS();\n                }\n            } else if (0x8129fc1c == v0) {\n                initialize();\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x8f32d59b == v0) {\n                isOwner();\n            } else if (0x965c0f28 == v0) {\n                getExpectedReturn(uint256);\n            }\n        } else if (0xe8c949c3 > v0) {\n            if (0xae4de7fa == v0) {\n                set_new_UniSwapFactoryAddress(address);\n            } else if (0xb1adb190 == v0) {\n                getMaxTokens(address,address,uint256);\n            } else if (0xd95b28bd == v0) {\n                getTokenReserves(address,address);\n            }\n        } else if (0xe8c949c3 == v0) {\n            LetsInvest(address,uint256);\n        } else if (0xea181d1d == v0) {\n            NEWDAI_TOKEN_ADDRESS();\n        } else if (0xf20d8634 == v0) {\n            getTotalShares(address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 37.21549916267395,
	"usage": {
		"completion_tokens": 553,
		"prompt_tokens": 8578,
		"total_tokens": 9131
	}
}