{
	"address": "0x7cc551b23ded82fa4109c62b6cdc97592539de95",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity code that represents the functionality of the presented decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract ERC20Token {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    address public owner;\n    uint256 public totalSupply;\n    string public name;\n    string public symbol;\n    uint8 constant public decimals = 18;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == owner);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n```\n\nThis contract is a simple implementation of the ERC20 token standard. It includes functions for token transfers, allowance setup, and ownership transfer. The contract owner is initially set to the contract creator and can be transferred to a new owner. \n\nThe transfer function moves tokens from the message sender's balance to a given address. The approve function allows a given address to withdraw tokens from the message sender's balance. The transferFrom function is used by an address to withdraw tokens from another's balance, provided they were approved for withdrawal by the token owner. The transferOwnership function allows the current owner to transfer contract ownership to a new owner.\n\nPlease note that the Solidity code above does not include all the functionality of the original contract's bytecode. Some functions or state variables might be missing or represented differently due to the limitations of the decompilation process. Decompiling EVM Bytecode to Solidity is not always a perfect one-to-one process and can result in loss of data or functionality. The code above should be used as a starting point for understanding the contract's functionality.",
				"role": "assistant"
			}
		}
	],
	"created": 1700631787,
	"id": "chatcmpl-8NaItSIxeDszdkPnkUBloiJr7g4Yo",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  stor1 is address at storage 1\n  allowance is mapping of uint256 at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is array of struct at storage 4\n  stor5 is array of struct at storage 5\n  stor6 is address at storage 6\n  owner is address at storage 7\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  owner = 0\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n\ndef unknown183274e3(uint256 _param1, uint256 _param2) payable: \n  require calldata.size - 4 >=\u2032 64\n  require _param1 == address(_param1)\n  if stor6 != caller:\n      revert with 0, 17\n  balanceOf[address(_param1)] = _param2\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  owner = newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if amount < amount:\n      revert with 0, 17\n  require ext_code.size(stor1)\n  call stor1.unknown194a51d8(uint256 _param1, uint256 _param2) with:\n       gas gas_remaining wei\n      args caller, recipient\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if ext_call.return_data[0] < 100:\n      revert with 0, 17\n  if not recipient:\n      revert with 0, 'ERC20: transfer to the zero address'\n  if balanceOf[caller] < amount:\n      revert with 0, 'ERC20: transfer amount exceeds balance'\n  balanceOf[caller] -= amount\n  balanceOf[recipient] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if amount < amount:\n      revert with 0, 17\n  require ext_code.size(stor1)\n  call stor1.unknown194a51d8(uint256 _param1, uint256 _param2) with:\n       gas gas_remaining wei\n      args address(sender), recipient\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if ext_call.return_data[0] < 100:\n      revert with 0, 17\n  if not recipient:\n      revert with 0, 'ERC20: transfer to the zero address'\n  if balanceOf[address(sender)] < amount:\n      revert with 0, 'ERC20: transfer amount exceeds balance'\n  balanceOf[address(sender)] -= amount\n  balanceOf[recipient] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef name() payable: \n  if bool(stor4.length):\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if bool(stor4.length):\n          if bool(stor4.length) == stor4.length.field_1 < 32:\n              revert with 0, 34\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      else:\n          if bool(stor4.length) == stor4.length.field_1 < 32:\n              revert with 0, 34\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n      if ceil32(stor4.length.field_1) > stor4.length.field_1:\n          mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n  if bool(stor4.length) == stor4.length.field_1 < 32:\n      revert with 0, 34\n  if bool(stor4.length):\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  else:\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n  if ceil32(stor4.length.field_1) > stor4.length.field_1:\n      mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n  return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor5.length):\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if bool(stor5.length):\n          if bool(stor5.length) == stor5.length.field_1 < 32:\n              revert with 0, 34\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      else:\n          if bool(stor5.length) == stor5.length.field_1 < 32:\n              revert with 0, 34\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n      if ceil32(stor5.length.field_1) > stor5.length.field_1:\n          mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n  if bool(stor5.length) == stor5.length.field_1 < 32:\n      revert with 0, 34\n  if bool(stor5.length):\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  else:\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n  if ceil32(stor5.length.field_1) > stor5.length.field_1:\n      mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n  return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  stor1 is address at storage 1\n  allowance is mapping of uint256 at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is array of struct at storage 4\n  stor5 is array of struct at storage 5\n  stor6 is address at storage 6\n  owner is address at storage 7\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  owner = 0\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n\ndef unknown183274e3(uint256 _param1, uint256 _param2) payable: \n  require calldata.size - 4 >=\u2032 64\n  require _param1 == address(_param1)\n  if stor6 != caller:\n      revert with 0, 17\n  balanceOf[address(_param1)] = _param2\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  owner = newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if amount < amount:\n      revert with 0, 17\n  require ext_code.size(stor1)\n  call stor1.unknown194a51d8(uint256 _param1, uint256 _param2) with:\n       gas gas_remaining wei\n      args caller, recipient\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if ext_call.return_data[0] < 100:\n      revert with 0, 17\n  if not recipient:\n      revert with 0, 'ERC20: transfer to the zero address'\n  if balanceOf[caller] < amount:\n      revert with 0, 'ERC20: transfer amount exceeds balance'\n  balanceOf[caller] -= amount\n  balanceOf[recipient] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if amount < amount:\n      revert with 0, 17\n  require ext_code.size(stor1)\n  call stor1.unknown194a51d8(uint256 _param1, uint256 _param2) with:\n       gas gas_remaining wei\n      args address(sender), recipient\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if ext_call.return_data[0] < 100:\n      revert with 0, 17\n  if not recipient:\n      revert with 0, 'ERC20: transfer to the zero address'\n  if balanceOf[address(sender)] < amount:\n      revert with 0, 'ERC20: transfer amount exceeds balance'\n  balanceOf[address(sender)] -= amount\n  balanceOf[recipient] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef name() payable: \n  if bool(stor4.length):\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if bool(stor4.length):\n          if bool(stor4.length) == stor4.length.field_1 < 32:\n              revert with 0, 34\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      else:\n          if bool(stor4.length) == stor4.length.field_1 < 32:\n              revert with 0, 34\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n      if ceil32(stor4.length.field_1) > stor4.length.field_1:\n          mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n  if bool(stor4.length) == stor4.length.field_1 < 32:\n      revert with 0, 34\n  if bool(stor4.length):\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  else:\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n  if ceil32(stor4.length.field_1) > stor4.length.field_1:\n      mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n  return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor5.length):\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if bool(stor5.length):\n          if bool(stor5.length) == stor5.length.field_1 < 32:\n              revert with 0, 34\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      else:\n          if bool(stor5.length) == stor5.length.field_1 < 32:\n              revert with 0, 34\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n      if ceil32(stor5.length.field_1) > stor5.length.field_1:\n          mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n  if bool(stor5.length) == stor5.length.field_1 < 32:\n      revert with 0, 34\n  if bool(stor5.length):\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  else:\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n  if ceil32(stor5.length.field_1) > stor5.length.field_1:\n      mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n  return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst decimals = 18\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  stor1 is address at storage 1\n  allowance is mapping of uint256 at storage 2\n  totalSupply is uint256 at storage 3\n  stor4 is array of struct at storage 4\n  stor5 is array of struct at storage 5\n  stor6 is address at storage 6\n  owner is address at storage 7\n\ndef totalSupply() payable: \n  return totalSupply\n\ndef balanceOf(address account) payable: \n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[address(account)]\n\ndef owner() payable: \n  return owner\n\ndef allowance(address owner, address spender) payable: \n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef renounceOwnership() payable: \n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  owner = 0\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n\ndef unknown183274e3(uint256 _param1, uint256 _param2) payable: \n  require calldata.size - 4 >=\u2032 64\n  require _param1 == address(_param1)\n  if stor6 != caller:\n      revert with 0, 17\n  balanceOf[address(_param1)] = _param2\n\ndef transferOwnership(address newOwner) payable: \n  require calldata.size - 4 >=\u2032 32\n  require newOwner == newOwner\n  if owner != caller:\n      revert with 0, 'Ownable: caller is not the owner'\n  if not newOwner:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'\n  owner = newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n\ndef approve(address spender, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n  if not spender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if not caller:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if amount < amount:\n      revert with 0, 17\n  require ext_code.size(stor1)\n  call stor1.unknown194a51d8(uint256 _param1, uint256 _param2) with:\n       gas gas_remaining wei\n      args caller, recipient\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if ext_call.return_data[0] < 100:\n      revert with 0, 17\n  if not recipient:\n      revert with 0, 'ERC20: transfer to the zero address'\n  if balanceOf[caller] < amount:\n      revert with 0, 'ERC20: transfer amount exceeds balance'\n  balanceOf[caller] -= amount\n  balanceOf[recipient] += amount\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount) payable: \n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] != -1:\n      if allowance[address(sender)][caller] < amount:\n          revert with 0, 'ERC20: insufficient allowance'\n      if not sender:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'\n      if not caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'\n      allowance[address(sender)][caller] -= amount\n      log Approval(\n            address owner=(allowance[address(sender)][caller] - amount),\n            address spender=sender,\n            uint256 value=caller)\n  if not sender:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'\n  if amount < amount:\n      revert with 0, 17\n  require ext_code.size(stor1)\n  call stor1.unknown194a51d8(uint256 _param1, uint256 _param2) with:\n       gas gas_remaining wei\n      args address(sender), recipient\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if ext_call.return_data[0] < 100:\n      revert with 0, 17\n  if not recipient:\n      revert with 0, 'ERC20: transfer to the zero address'\n  if balanceOf[address(sender)] < amount:\n      revert with 0, 'ERC20: transfer amount exceeds balance'\n  balanceOf[address(sender)] -= amount\n  balanceOf[recipient] += amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\ndef name() payable: \n  if bool(stor4.length):\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if bool(stor4.length):\n          if bool(stor4.length) == stor4.length.field_1 < 32:\n              revert with 0, 34\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      else:\n          if bool(stor4.length) == stor4.length.field_1 < 32:\n              revert with 0, 34\n          if stor4.length.field_1:\n              if 31 < stor4.length.field_1:\n                  mem[128] = uint256(stor4.field_0)\n                  idx = 128\n                  s = 0\n                  while stor4.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor4[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)])\n              mem[128] = 256 * stor4.length.field_8\n      mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n      if ceil32(stor4.length.field_1) > stor4.length.field_1:\n          mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor4.length.field_1), data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n  if bool(stor4.length) == stor4.length.field_1 < 32:\n      revert with 0, 34\n  if bool(stor4.length):\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  else:\n      if bool(stor4.length) == stor4.length.field_1 < 32:\n          revert with 0, 34\n      if stor4.length.field_1:\n          if 31 < stor4.length.field_1:\n              mem[128] = uint256(stor4.field_0)\n              idx = 128\n              s = 0\n              while stor4.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor4[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])\n          mem[128] = 256 * stor4.length.field_8\n  mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]\n  if ceil32(stor4.length.field_1) > stor4.length.field_1:\n      mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0\n  return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), \n\ndef symbol() payable: \n  if bool(stor5.length):\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if bool(stor5.length):\n          if bool(stor5.length) == stor5.length.field_1 < 32:\n              revert with 0, 34\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      else:\n          if bool(stor5.length) == stor5.length.field_1 < 32:\n              revert with 0, 34\n          if stor5.length.field_1:\n              if 31 < stor5.length.field_1:\n                  mem[128] = uint256(stor5.field_0)\n                  idx = 128\n                  s = 0\n                  while stor5.length.field_1 + 96 > idx:\n                      mem[idx + 32] = stor5[s].field_256\n                      idx = idx + 32\n                      s = s + 1\n                      continue \n                  return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)])\n              mem[128] = 256 * stor5.length.field_8\n      mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n      if ceil32(stor5.length.field_1) > stor5.length.field_1:\n          mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n      return Array(len=2 * Mask(256, -1, stor5.length.field_1), data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n  if bool(stor5.length) == stor5.length.field_1 < 32:\n      revert with 0, 34\n  if bool(stor5.length):\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  else:\n      if bool(stor5.length) == stor5.length.field_1 < 32:\n          revert with 0, 34\n      if stor5.length.field_1:\n          if 31 < stor5.length.field_1:\n              mem[128] = uint256(stor5.field_0)\n              idx = 128\n              s = 0\n              while stor5.length.field_1 + 96 > idx:\n                  mem[idx + 32] = stor5[s].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])\n          mem[128] = 256 * stor5.length.field_8\n  mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]\n  if ceil32(stor5.length.field_1) > stor5.length.field_1:\n      mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0\n  return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), \n\n.",
	"status": "1",
	"time_cost": 35.11437964439392,
	"usage": {
		"completion_tokens": 678,
		"prompt_tokens": 3645,
		"total_tokens": 4323
	}
}