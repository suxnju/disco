{
	"address": "0x6c424c25e9f1fff9642cb5b7750b0db7312c29ad",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the Solidity contract code based on the decompiled code:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract ArtworkContract {\n    // Data Structures\n    mapping(uint256 => uint256) private _supportsInterface;\n    mapping(uint256 => address) private _ownerOf;\n    mapping(uint256 => address) private _getApproved;\n    mapping(address => uint256) private _balanceOf;\n    mapping(address => bool) private _isApprovedForAll;\n    mapping(address => mapping(uint256 => uint256)) private _tokenOfOwnerByIndex;\n    mapping(uint256 => address) private owner_6;\n    uint256[] private _totalSupply;\n    mapping (uint256 => uint256) private map_8;\n    string private _name;\n    string private _symbol;\n    mapping (uint256 => string) private _tokenURI;\n    mapping (address => bool) private _whitelistedCreators;\n    mapping (uint256 => address[]) private _uniqueTokenCreators;\n    mapping (uint256 => uint256[]) private _getControlToken;\n    mapping (uint256 => uint256) private _buyPrices;\n    mapping (uint256 => uint256[3]) private _pendingBids;\n    mapping (uint256 => bool) private _tokenDidHaveFirstSale;\n    mapping (address => address) private _grantControlPermission;\n    uint256 private _platformFirstSalePercentage;\n    uint256 private _platformSecondSalePercentage;\n    uint256 private _artistSecondSalePercentage;\n    uint256 private _expectedTokenSupply;\n    address private _platformAddress;\n\n    // Events\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event BidWithdrawn(uint256 tokenId);\n    event BidProposed(uint256 tokenId, uint256 bidAmount, address bidder);\n    event ControlLeverUpdated(uint256 indexed tokenId, uint256 indexed payment, uint256[] levers, int256[] oldValues, int256[] newValues);\n    event RoyaltyAmountUpdated(uint256 platformFirstSalePercentage, uint256 platformSecondSalePercentage, uint256 artistSecondSalePercentage);\n    event PlatformAddressUpdated(address platformAddress);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event BuyPriceSet(uint256 indexed tokenId, uint256 buyPrice);\n    event TokenSale(uint256 indexed tokenId, uint256 salePrice, address buyer);\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    // Functions\n    // Note: The actual implementation of the functions will vary based on the specific decompiled code. \n    // The following functions are placeholders and do not represent the actual implementation.\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) { ... }\n    function approve(address to, uint256 tokenId) external { ... }\n    function getApproved(uint256 tokenId) external view returns (address) { ... }\n    function setApprovalForAll(address operator, bool _approved) external { ... }\n    function isApprovedForAll(address owner, address operator) external view returns (bool) { ... }\n    function transferFrom(address from, address to, uint256 tokenId) external { ... }\n    function safeTransferFrom(address from, address to, uint256 tokenId) external { ... }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external { ... }\n    // Other functions based on the decompiled code\n}\n\n```\nPlease note that the above code is a skeleton structure. The actual implementation of the functions will vary based on the specific decompiled code. The functions in the above code are placeholders and do not represent the actual implementation.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039664,
	"id": "chatcmpl-8ChyS75xJNjvUWzYFW7a2U7niMK0d",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 04:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _supportsInterface; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _ownerOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getApproved; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isApprovedForAll; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _tokenOfOwnerByIndex; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nuint256[] _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_8; // STORAGE[0x8]\nuint256[] _name; // STORAGE[0x9]\nuint256[] _symbol; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _tokenURI; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _whitelistedCreators; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _uniqueTokenCreators; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _getControlToken; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _buyPrices; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _pendingBids; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _tokenDidHaveFirstSale; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _grantControlPermission; // STORAGE[0x12]\nuint256 _platformFirstSalePercentage; // STORAGE[0x13]\nuint256 _platformSecondSalePercentage; // STORAGE[0x14]\nuint256 _artistSecondSalePercentage; // STORAGE[0x15]\nuint256 _expectedTokenSupply; // STORAGE[0x16]\naddress _platformAddress; // STORAGE[0x17] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nBidWithdrawn(uint256);\nBidProposed(uint256, uint256, address);\nControlLeverUpdated(uint256, uint256, uint256[], int256[], int256[]);\nRoyaltyAmountUpdated(uint256, uint256, uint256);\nPlatformAddressUpdated(address);\nApprovalForAll(address, address, bool);\nBuyPriceSet(uint256, uint256);\nTokenSale(uint256, uint256, address);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction 0x23dd(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(_ownerOf[varg1]);\n    require(v0);\n    v1 = v2 = msg.sender == address(v0);\n    if (msg.sender != address(v0)) {\n        v1 = v3 = address(_getApproved[varg1]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v1);\n    0x2781(varg1, varg2, varg3);\n    return ;\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _supportsInterface[~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0)];\n}\n\nfunction 0x268f(uint256 varg0, uint256 varg1) private { \n    MEM[64] += 32;\n    MEM[MEM[64]] = 0;\n    require(address(varg1));\n    require(!address(_ownerOf[varg0]), 'token already minted');\n    v0 = address(varg1);\n    _ownerOf[varg0] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n    _balanceOf[varg0] += 1;\n    emit Transfer(0, address(varg1), varg0);\n    v1 = address(varg1);\n    owner_6[varg0] = _tokenOfOwnerByIndex[v1];\n    MEM[32] = 5;\n    _tokenOfOwnerByIndex[v1] = _tokenOfOwnerByIndex[v1] + 1;\n    STORAGE[keccak256(keccak256(v1, 5)) + _tokenOfOwnerByIndex[v1]] = varg0;\n    map_8[varg0] = _totalSupply.length;\n    _totalSupply.length = _totalSupply.length + 1;\n    MEM[0] = 7;\n    STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _totalSupply.length] = varg0;\n    return ;\n}\n\nfunction 0x26a9(uint256 varg0, uint256 varg1) private { \n    require(address(_ownerOf[varg1]), 'URI set of nonexistent token');\n    v0 = v1 = varg0.data;\n    v2 = _tokenURI[varg1];\n    if (31 < varg0.length) {\n        _tokenURI[varg1] = 1 + (varg0.length + varg0.length);\n        if (varg0.length) {\n            while (v1 + varg0.length > v0) {\n                STORAGE[v3] = MEM[v0];\n                v0 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _tokenURI[varg1] = varg0.length + varg0.length | ~0xff & MEM[v1];\n    }\n    while (v4 + (31 + (((!(0x1 & v2) << 8) - 1 & v2) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    return ;\n}\n\nfunction 0x2781(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(_ownerOf[varg0]);\n    require(v0);\n    require(address(v0) == address(varg2), 'not owner');\n    require(address(varg1));\n    if (address(_getApproved[varg0])) {\n        _getApproved[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _getApproved[varg0];\n        goto 0x2d62B0x2781;\n    }\n    v1 = address(varg2);\n    if (1 <= _balanceOf[v1]) {\n        _balanceOf[v1] = _balanceOf[v1] - 1;\n        v2 = address(varg1);\n        _balanceOf[v2] += 1;\n        v3 = address(varg1);\n        _ownerOf[varg0] = v3 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n        emit Transfer(address(varg2), v3, varg0);\n        v4 = address(varg2);\n        if (1 <= _tokenOfOwnerByIndex[v4]) {\n            v5 = owner_6[varg0];\n            if (_tokenOfOwnerByIndex[v4] - 1 != v5) {\n                v6 = address(varg2);\n                assert(_tokenOfOwnerByIndex[v4] - 1 < _tokenOfOwnerByIndex[v6]);\n                v7 = address(varg2);\n                assert(v5 < _tokenOfOwnerByIndex[v7]);\n                STORAGE[v5 + keccak256(keccak256(v7, 5))] = STORAGE[keccak256(keccak256(v6, 5)) + (_tokenOfOwnerByIndex[v4] - 1)];\n                owner_6[keccak256(v7, 5)] = v5;\n            }\n            v8 = address(varg2);\n            _tokenOfOwnerByIndex[v8] = _tokenOfOwnerByIndex[v8] + ~0;\n            if (_tokenOfOwnerByIndex[v8] > _tokenOfOwnerByIndex[v8] + ~0) {\n                v9 = v10 = _tokenOfOwnerByIndex[v8] + ~0 + keccak256(keccak256(v8, 5));\n                while (keccak256(keccak256(v8, 5)) + _tokenOfOwnerByIndex[v8] > v9) {\n                    STORAGE[v9] = 0;\n                    v9 += 1;\n                }\n                goto 0x16f20x322cB0x2ec5B0x2bbeB0x2781;\n            }\n            v11 = address(varg1);\n            owner_6[varg0] = _tokenOfOwnerByIndex[v11];\n            MEM[32] = 5;\n            _tokenOfOwnerByIndex[v11] = _tokenOfOwnerByIndex[v11] + 1;\n            STORAGE[keccak256(keccak256(v11, 5)) + _tokenOfOwnerByIndex[v11]] = varg0;\n            _buyPrices[varg0] = 0;\n            return ;\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v12 = new array[](v13.length);\n            if (v13.length) {\n                v14 = v13.data;\n                v15 = v16 = 32;\n                while (v15 < v13.length) {\n                    MEM[v15 + v12.data] = MEM[v15 + v13.data];\n                    v15 += 32;\n                }\n            }\n            if (30) {\n                MEM[v12.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v12);\n        }\n    } else {\n        v17 = new array[](v18.length);\n        if (v18.length) {\n            v19 = v18.data;\n            v20 = v21 = 32;\n            while (v20 < v18.length) {\n                MEM[v20 + v17.data] = MEM[v20 + v18.data];\n                v20 += 32;\n            }\n        }\n        if (30) {\n            MEM[v17.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v17);\n    }\n}\n\nfunction 0x279f(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (!(0xff & _tokenDidHaveFirstSale[varg2])) {\n        _tokenDidHaveFirstSale[varg2] = 0x1 | ~0xff & _tokenDidHaveFirstSale[varg2];\n        v0 = v1 = 10565;\n        v2 = v3 = 100;\n        v4 = v5 = _SafeMul(_platformFirstSalePercentage, varg1);\n    } else {\n        v0 = v6 = 10206;\n        v2 = v7 = 100;\n        v4 = v8 = _SafeMul(_platformSecondSalePercentage, varg1);\n    }\n    while (!v2) {\n        if (!v2) {\n            v9 = new array[](v10.length);\n            v11 = v12 = 0;\n            while (v11 < v10.length) {\n                MEM[v11 + v9.data] = MEM[v11 + v10.data];\n                v11 += 32;\n            }\n            if (26) {\n                MEM[v9.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v9);\n        }\n        if (v2) {\n            break;\n        }\n        assert(v2);\n        v13 = v14 = MEM[64];\n        MEM[v14] = _uniqueTokenCreators[v15];\n        v16 = v17 = 10406;\n        v18 = v19 = v14 + 32;\n        if (_uniqueTokenCreators[v15]) {\n            v20 = v21 = v19 + (_uniqueTokenCreators[v15] << 5);\n        }\n        do {\n            MEM[v18] = address(STORAGE[v22]);\n            v22 = v22 + 1;\n            v18 += 32;\n        } while (v20 <= v18);\n        if (MEM[v13]) {\n            assert(MEM[v13]);\n            v23 = v24 = 0;\n            while (v23 < MEM[v13]) {\n                assert(v23 < MEM[v13]);\n                v25 = address(MEM[32 + (v23 << 5) + v13]).call().value(v15 / MEM[v13]).gas(!(v15 / MEM[v13]) * 2300);\n                require(v25); // checks call status, propagates error data on error\n                v23 += 1;\n            }\n            goto {'0x29fa', '0x28a6'};\n            require(address(_ownerOf[v15]));\n            if (v15 <= v15) {\n                if (v15 <= v15 - v15) {\n                    v26 = address(_ownerOf[v15]).call().value(v15 - v15 - v15).gas(2300 * !(v15 - v15 - v15));\n                    require(v26); // checks call status, propagates error data on error\n                } else {\n                    MEM[MEM[64] + 4] = 32;\n                    v27 = new array[](v28.length);\n                    if (v28.length) {\n                        v29 = v28.data;\n                        v30 = v31 = 32;\n                        while (v30 < v28.length) {\n                            MEM[v30 + v27.data] = MEM[v30 + v28.data];\n                            v30 += 32;\n                        }\n                    }\n                    if (30) {\n                        MEM[v27.data] = ~0xffff & 'SafeMath: subtraction overflow';\n                    }\n                    revert(v27);\n                }\n            } else {\n                MEM[MEM[64] + 4] = 32;\n                v32 = new array[](v33.length);\n                if (v33.length) {\n                    v34 = v33.data;\n                    v35 = v36 = 32;\n                    while (v35 < v33.length) {\n                        MEM[v35 + v32.data] = MEM[v35 + v33.data];\n                        v35 += 32;\n                    }\n                }\n                if (30) {\n                    MEM[v32.data] = ~0xffff & 'SafeMath: subtraction overflow';\n                }\n                revert(v32);\n            }\n            _pendingBids[v15] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[v15];\n            _pendingBids[v15][1] = 0;\n            _pendingBids[v15][2] = 0x0 | ~0xff & _pendingBids[v15][0x2];\n            require(address(_ownerOf[v15]));\n            MEM[MEM[64]] = 0;\n            0x23dd(MEM[64], v15, v15, address(_ownerOf[v15]));\n            v37 = address(v15);\n            emit TokenSale(v15, v15, v37);\n            return ;\n        } else {\n            v38 = new array[](v39.length);\n            MEM[4 + MEM[64]] = 32;\n            v40 = v41 = 0;\n            while (v40 < v39.length) {\n                MEM[v40 + v38.data] = MEM[v40 + v39.data];\n                v40 += 32;\n            }\n            if (26) {\n                MEM[v38.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v38);\n        }\n        v42 = _platformAddress.call().value(v15).gas(2300 * !v15);\n        require(v42); // checks call status, propagates error data on error\n        v16 = v43 = 10746;\n        if (v15 <= v15) {\n            v15 = v44 = v15 - v15;\n            v13 = v45 = MEM[64];\n            MEM[v45] = _uniqueTokenCreators[v15];\n            if (_uniqueTokenCreators[v15]) {\n                v20 = v46 = v45 + 32 + (_uniqueTokenCreators[v15] << 5);\n                MEM[v45 + 32] = address(STORAGE[keccak256(keccak256(v15, 13))]);\n                v22 = v47 = keccak256(keccak256(v15, 13)) + 1;\n                v18 = v48 = 32 + (v45 + 32);\n                if (v46 <= v48) {\n                }\n            }\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v49 = new array[](v50.length);\n            if (v50.length) {\n                v51 = v50.data;\n                v52 = v53 = 32;\n                while (v52 < v50.length) {\n                    MEM[v52 + v49.data] = MEM[v52 + v50.data];\n                    v52 += 32;\n                }\n            }\n            if (30) {\n                MEM[v49.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v49);\n        }\n        v15 = v4 / v2;\n        goto {'0x2945', '0x2836', '0x27de'};\n        v54 = _platformAddress.call().value(v15).gas(2300 * !v15);\n        require(v54); // checks call status, propagates error data on error\n        v0 = v55 = 10294;\n        v2 = v56 = 100;\n        v4 = _SafeMul(_artistSecondSalePercentage, v15);\n    }\n}\n\nfunction whitelistedCreators(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _whitelistedCreators[varg0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath: multiplication overflow');\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getApproved(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_getApproved[varg0]);\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg1]));\n    require(varg0 != address(_ownerOf[varg1]));\n    v0 = v1 = address(_ownerOf[varg1]) == msg.sender;\n    if (address(_ownerOf[varg1]) != msg.sender) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _getApproved[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _getApproved[varg1];\n    emit Approval(address(_ownerOf[varg1]), varg0, varg1);\n}\n\nfunction updateWhitelist(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _platformAddress);\n    _whitelistedCreators[varg0] = varg1 | ~0xff & _whitelistedCreators[varg0];\n}\n\nfunction withdrawBid(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 0xff & _pendingBids[varg0][0x2];\n    if (v1) {\n        v0 = v2 = msg.sender == address(_pendingBids[varg0]);\n    }\n    require(v0);\n    v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n    require(v3); // checks call status, propagates error data on error\n    _pendingBids[varg0] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n    _pendingBids[varg0][1] = 0;\n    _pendingBids[varg0][2] = 0x0 | ~0xff & _pendingBids[varg0][0x2];\n    emit BidWithdrawn(varg0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply.length;\n}\n\nfunction setupControlToken(uint256 varg0, string varg1, int256[] varg2, int256[] varg3, int256[] varg4, address[] varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v2 = new uint256[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg3, (?).length << 5);\n    v2[(?).length] = 0;\n    require(varg4 <= 0x100000000);\n    require(4 + varg4 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg4 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v3 = new uint256[]((?).length);\n    CALLDATACOPY(v3.data, 36 + varg4, (?).length << 5);\n    v3[(?).length] = 0;\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v4 = new uint256[]((?).length);\n    CALLDATACOPY(v4.data, 36 + varg5, (?).length << 5);\n    v4[(?).length] = 0;\n    require(0xff & _getControlToken[varg0][0x1], 'No control token found');\n    require(!(0xff & _getControlToken[varg0][1] >> 8), 'Already setup');\n    assert(_uniqueTokenCreators[varg0]);\n    require(address(STORAGE[keccak256(keccak256(varg0, 13)) + 0]) == msg.sender, 'Must be control token artist');\n    v5 = v6 = v1.length == v2.length;\n    if (v6) {\n        v5 = v7 = v2.length == v3.length;\n    }\n    require(v5, 'Values array mismatch');\n    0x268f(varg0, msg.sender);\n    0x26a9(v0, varg0);\n    v8 = new array[](v3.length);\n    v9 = v10 = 0;\n    _getControlToken[varg0] = v8.length;\n    _getControlToken[varg0][1] = (_getControlToken[varg0][0x1] & ~0xff | 0x1) & ~0xff00 | 0x100;\n    while (v9 < v3.length) {\n        if (v9 < v1.length) {\n            break;\n        }\n        assert(v9 < v1.length);\n        if (v9 < v2.length) {\n            break;\n        }\n        assert(v9 < v2.length);\n        if (v2[v9] >= v1[v9]) {\n            break;\n        }\n        require(v2[v9] >= v1[v9], 'Max val must >= min');\n        assert(v9 < v1.length);\n        assert(v9 < v3.length);\n        v11 = v12 = v3[v9] >= v1[v9];\n        if (v12) {\n            assert(v9 < v2.length);\n            assert(v9 < v3.length);\n            v11 = v13 = v3[v9] <= v2[v9];\n        }\n        require(v11, 'Invalid start val');\n        assert(v9 < v1.length);\n        assert(v9 < v2.length);\n        assert(v9 < v3.length);\n        _getControlToken[v9] = v1[v9];\n        _getControlToken[v9][1] = v2[v9];\n        _getControlToken[v9][2] = v3[v9];\n        _getControlToken[v9][3] = 0x1 | ~0xff & _getControlToken[v9][0x3];\n        v9 += 1;\n    }\n    v14 = v15 = 0;\n    while (v14 < v4.length) {\n        assert(v14 < v4.length);\n        require(address(v4[v14]) != 0);\n        assert(v14 < v4.length);\n        _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n        STORAGE[_uniqueTokenCreators[varg0] + keccak256(keccak256(varg0, 13))] = address(v4[v14]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[_uniqueTokenCreators[varg0] + keccak256(keccak256(varg0, 13))];\n        v14 += 1;\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        v0 = v2 = address(_getApproved[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    0x2781(varg2, varg1, varg0);\n}\n\nfunction acceptBid(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    require(0xff & _pendingBids[varg0][0x2]);\n    0x279f(address(_pendingBids[varg0]), _pendingBids[varg0][1], varg0);\n}\n\nfunction tokenOfOwnerByIndex(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 < _tokenOfOwnerByIndex[varg0]);\n    return STORAGE[keccak256(keccak256(varg0, 5)) + varg1];\n}\n\nfunction grantControlPermission(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _grantControlPermission[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _grantControlPermission[msg.sender];\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    MEM[64] += 32;\n    MEM[MEM[64]] = 0;\n    0x23dd(MEM[64], varg2, varg1, varg0);\n}\n\nfunction bid(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(!v0);\n    if (0xff & _pendingBids[varg0][0x2]) {\n        require(msg.value > _pendingBids[varg0][1], 'Bid must be > than current bid');\n        v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n        require(v3); // checks call status, propagates error data on error\n    }\n    _pendingBids[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n    _pendingBids[varg0][1] = msg.value;\n    _pendingBids[varg0][2] = 0x1 | ~0xff & _pendingBids[varg0][0x2];\n    emit BidProposed(varg0, msg.value, msg.sender);\n}\n\nfunction tokenDidHaveFirstSale(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _tokenDidHaveFirstSale[varg0];\n}\n\nfunction tokenByIndex(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(varg0 < _totalSupply.length);\n    return _totalSupply[varg0];\n}\n\nfunction expectedTokenSupply() public nonPayable { \n    return _expectedTokenSupply;\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    return address(_ownerOf[varg0]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction useControlToken(uint256 varg0, uint256[] varg1, int256[] varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length << 5);\n    v0[(?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(address(_ownerOf[varg0]));\n    v2 = v3 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v2 = v4 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v2) {\n        v2 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    if (!v5) {\n        require(address(_ownerOf[varg0]));\n        v2 = v6 = address(_grantControlPermission[address(address(_ownerOf[varg0]))]) == msg.sender;\n    }\n    require(v2, 'Owner or permissioned only');\n    v7 = new uint256[](v1.length);\n    if (v1.length) {\n        MEM[(v7.data) len (v1.length << 5)] = this.code[this.code.size len (v1.length << 5)];\n    }\n    v8 = v9 = 0;\n    while (v8 < v0.length) {\n        if (v8 < v0.length) {\n            break;\n        }\n        assert(v8 < v0.length);\n        if (v8 < v1.length) {\n            break;\n        }\n        assert(v8 < v1.length);\n        v10 = v11 = v1[v8] >= STORAGE[0 + keccak256(v0[v8], 2 + keccak256(varg0, 14))];\n        if (v11) {\n            assert(v8 < v1.length);\n            v10 = v12 = v1[v8] <= STORAGE[1 + keccak256(v0[v8], 2 + keccak256(varg0, 14))];\n        }\n        require(v10, 'Invalid val');\n        assert(v8 < v1.length);\n        require(v1[v8] != STORAGE[2 + keccak256(v0[v8], 2 + keccak256(varg0, 14))], 'Must provide different val');\n        assert(v8 < v1.length);\n        STORAGE[2 + keccak256(v0[v8], 2 + keccak256(varg0, 14))] = v1[v8];\n        assert(v8 < v7.length);\n        v7[v8] = STORAGE[keccak256(v0[v8], 2 + keccak256(varg0, 14)) + 2];\n        v8 += 1;\n    }\n    if (msg.value) {\n        v13 = _platformAddress.call().value(msg.value).gas(2300 * !msg.value);\n        require(v13); // checks call status, propagates error data on error\n    }\n    v14 = new array[](v0.length);\n    v15 = v16 = 0;\n    while (v15 < v0.length << 5) {\n        MEM[v15 + v14.data] = MEM[v15 + v0.data];\n        v15 += 32;\n    }\n    v17 = new array[](v7.length);\n    v18 = v19 = 0;\n    while (v18 < v7.length << 5) {\n        MEM[v18 + v17.data] = MEM[v18 + v7.data];\n        v18 += 32;\n    }\n    v20 = new array[](v1.length);\n    v21 = v22 = 0;\n    while (v21 < v1.length << 5) {\n        MEM[v21 + v20.data] = MEM[v21 + v1.data];\n        v21 += 32;\n    }\n    emit ControlLeverUpdated(varg0, msg.value, v14, v17, v20);\n}\n\nfunction updateRoyaltyPercentages(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _platformAddress);\n    require(varg0 < 100);\n    require(varg2 + varg1 >= varg1, 'SafeMath: addition overflow');\n    require(varg2 + varg1 < 100);\n    _platformFirstSalePercentage = varg0;\n    _platformSecondSalePercentage = varg1;\n    _artistSecondSalePercentage = varg2;\n    emit RoyaltyAmountUpdated(varg0, varg1, varg2);\n}\n\nfunction updatePlatformAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _platformAddress);\n    _platformAddress = varg0;\n    emit PlatformAddressUpdated(varg0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getControlToken(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _getControlToken[varg0][0x1]);\n    v0 = _SafeMul(3, _getControlToken[varg0]);\n    v1 = new uint256[](v0);\n    if (v0) {\n        MEM[(v1.data) len (v0 << 5)] = this.code[this.code.size len (v0 << 5)];\n    }\n    v2 = v3 = 0;\n    while (v2 < _getControlToken[varg0]) {\n        if (v2 < v1.length) {\n            break;\n        }\n        assert(v2 < v1.length);\n        v1[v2] = STORAGE[keccak256(v2, keccak256(varg0, 14) + 2)];\n        if (1 + v2 >= v2) {\n            break;\n        }\n        require(1 + v2 >= v2, 'SafeMath: addition overflow');\n        assert(1 + v2 < v1.length);\n        v1[1 + v2] = STORAGE[1 + keccak256(v2, 2 + keccak256(varg0, 14))];\n        require(2 + v2 >= 1 + v2, 'SafeMath: addition overflow');\n        assert(2 + v2 < v1.length);\n        v1[2 + v2] = STORAGE[2 + keccak256(v2, 2 + keccak256(varg0, 14))];\n        v2 += 3;\n        require(v2 >= 2 + v2, 'SafeMath: addition overflow');\n        v2 += 1;\n    }\n    v4 = new array[](v1.length);\n    v5 = v6 = 0;\n    while (v5 < v1.length << 5) {\n        MEM[v5 + v4.data] = MEM[v5 + v1.data];\n        v5 += 32;\n    }\n    return v4;\n}\n\nfunction permissionedControllers(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_grantControlPermission[varg0]);\n}\n\nfunction mintArtwork(uint256 varg0, string varg1, address[] varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(1 == 0xff & _whitelistedCreators[msg.sender]);\n    require(varg0 == _expectedTokenSupply, 'ExpectedTokenSupply different');\n    0x268f(varg0, msg.sender);\n    _expectedTokenSupply += 1;\n    0x26a9(v0, varg0);\n    v2 = v3 = 0;\n    _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n    STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]];\n    while (v2 < v1.length) {\n        assert(v2 < v1.length);\n        require(address(v1[v2]) != 0);\n        _expectedTokenSupply = _expectedTokenSupply + 1;\n        assert(v2 < v1.length);\n        _uniqueTokenCreators[_expectedTokenSupply] = _uniqueTokenCreators[_expectedTokenSupply] + 1;\n        STORAGE[_uniqueTokenCreators[_expectedTokenSupply] + keccak256(keccak256(_expectedTokenSupply, 13))] = address(v1[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[_uniqueTokenCreators[_expectedTokenSupply] + keccak256(keccak256(_expectedTokenSupply, 13))];\n        _getControlToken[keccak256(_expectedTokenSupply, 13)] = 0;\n        _getControlToken[keccak256(_expectedTokenSupply, 13)][1] = 0x0 | ~0xff00 & (0x1 | _getControlToken[keccak256(_expectedTokenSupply, 13)][0x1] & ~0xff);\n        assert(v2 < v1.length);\n        if (address(v1[v2]) != msg.sender) {\n            v4 = v5 = 0;\n            while (v4 < _uniqueTokenCreators[varg0]) {\n                assert(v2 < v1.length);\n                assert(v4 < _uniqueTokenCreators[varg0]);\n                if (address(STORAGE[keccak256(keccak256(varg0, 13)) + v4]) != address(v1[v2])) {\n                    v4 += 1;\n                } else {\n                    v4 = v6 = 1;\n                    break;\n                }\n            }\n            if (!v4) {\n                assert(v2 < v1.length);\n                _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n                STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]] = address(v1[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]];\n            }\n        }\n        v2 += 1;\n    }\n}\n\nfunction setApprovalForAll(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender != varg0);\n    _isApprovedForAll[varg0] = varg1 | ~0xff & _isApprovedForAll[varg0];\n    emit ApprovalForAll(msg.sender, varg0, varg1);\n}\n\nfunction buyPrices(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _buyPrices[varg0];\n}\n\nfunction uniqueTokenCreators(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 < _uniqueTokenCreators[varg0]);\n    return address(STORAGE[keccak256(keccak256(varg0, 13)) + varg1]);\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(address(_ownerOf[varg2]));\n    v1 = v2 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        v1 = v3 = address(_getApproved[varg2]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v1);\n    0x2781(varg2, varg1, varg0);\n}\n\nfunction platformFirstSalePercentage() public nonPayable { \n    return _platformFirstSalePercentage;\n}\n\nfunction artistSecondSalePercentage() public nonPayable { \n    return _artistSecondSalePercentage;\n}\n\nfunction tokenURI(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new bytes[](v1);\n    v1 = (_tokenURI[varg0] & (!(_tokenURI[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenURI[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction pendingBids(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_pendingBids[varg0]), _pendingBids[varg0][1], 0xff & _pendingBids[varg0][0x2];\n}\n\nfunction platformSecondSalePercentage() public nonPayable { \n    return _platformSecondSalePercentage;\n}\n\nfunction makeBuyPrice(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _buyPrices[varg0] = varg1;\n    emit BuyPriceSet(varg0, varg1);\n}\n\nfunction platformAddress() public nonPayable { \n    return _platformAddress;\n}\n\nfunction takeBuyPrice(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(!v0);\n    require(_buyPrices[varg0]);\n    require(msg.value >= _buyPrices[varg0]);\n    if (0xff & _pendingBids[varg0][0x2]) {\n        v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n        require(v3); // checks call status, propagates error data on error\n        _pendingBids[varg0] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n        _pendingBids[varg0][1] = 0;\n        _pendingBids[varg0][2] = 0x0 | ~0xff & _pendingBids[varg0][0x2];\n    }\n    0x279f(msg.sender, _buyPrices[varg0], varg0);\n}\n\nfunction isApprovedForAll(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _isApprovedForAll[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x755db7b3 > v0) {\n            if (0x2b1fd58a > v0) {\n                if (0xd392cd9 > v0) {\n                    if (0x1ffc9a7 == v0) {\n                        supportsInterface(bytes4);\n                    } else if (0x41bb6ff == v0) {\n                        whitelistedCreators(address);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x81812fc == v0) {\n                        getApproved(uint256);\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    }\n                } else if (0xd392cd9 == v0) {\n                    updateWhitelist(address,bool);\n                } else if (0xeaaf4c8 == v0) {\n                    withdrawBid(uint256);\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1e9b0f52 == v0) {\n                    setupControlToken(uint256,string,int256[],int256[],int256[],address[]);\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x462399cd > v0) {\n                if (0x2b1fd58a == v0) {\n                    acceptBid(uint256);\n                } else if (0x2f745c59 == v0) {\n                    tokenOfOwnerByIndex(address,uint256);\n                } else if (0x41afca00 == v0) {\n                    grantControlPermission(address);\n                } else if (0x42842e0e == v0) {\n                    safeTransferFrom(address,address,uint256);\n                } else if (0x454a2ab3 == v0) {\n                    bid(uint256);\n                }\n            } else if (0x462399cd == v0) {\n                tokenDidHaveFirstSale(uint256);\n            } else if (0x4f6ccce7 == v0) {\n                tokenByIndex(uint256);\n            } else if (0x556d8628 == v0) {\n                expectedTokenSupply();\n            } else if (0x6352211e == v0) {\n                ownerOf(uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            }\n        } else if (0xb88d4fde > v0) {\n            if (0x98207051 > v0) {\n                if (0x755db7b3 == v0) {\n                    useControlToken(uint256,uint256[],int256[]);\n                } else if (0x8cb6ddcb == v0) {\n                    updateRoyaltyPercentages(uint256,uint256,uint256);\n                } else if (0x8f9f193f == v0) {\n                    updatePlatformAddress(address);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x96bc50b0 == v0) {\n                    getControlToken(uint256);\n                }\n            } else if (0x98207051 == v0) {\n                permissionedControllers(address);\n            } else if (0x98c8103e == v0) {\n                mintArtwork(uint256,string,address[]);\n            } else if (0xa22cb465 == v0) {\n                setApprovalForAll(address,bool);\n            } else if (0xa90d6de3 == v0) {\n                buyPrices(uint256);\n            } else if (0xa94141a1 == v0) {\n                uniqueTokenCreators(uint256,uint256);\n            }\n        } else if (0xd66767ab > v0) {\n            if (0xb88d4fde == v0) {\n                safeTransferFrom(address,address,uint256,bytes);\n            } else if (0xb8c18015 == v0) {\n                platformFirstSalePercentage();\n            } else if (0xbab2d111 == v0) {\n                artistSecondSalePercentage();\n            } else if (0xc87b56dd == v0) {\n                tokenURI(uint256);\n            } else if (0xcf8589b9 == v0) {\n                pendingBids(uint256);\n            }\n        } else if (0xd66767ab == v0) {\n            platformSecondSalePercentage();\n        } else if (0xd91c070c == v0) {\n            makeBuyPrice(uint256,uint256);\n        } else if (0xdbe55e56 == v0) {\n            platformAddress();\n        } else if (0xe66c7f35 == v0) {\n            takeBuyPrice(uint256);\n        } else if (0xe985e9c5 == v0) {\n            isApprovedForAll(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 04:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _supportsInterface; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _ownerOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getApproved; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isApprovedForAll; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _tokenOfOwnerByIndex; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nuint256[] _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_8; // STORAGE[0x8]\nuint256[] _name; // STORAGE[0x9]\nuint256[] _symbol; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _tokenURI; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _whitelistedCreators; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _uniqueTokenCreators; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _getControlToken; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _buyPrices; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _pendingBids; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _tokenDidHaveFirstSale; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _grantControlPermission; // STORAGE[0x12]\nuint256 _platformFirstSalePercentage; // STORAGE[0x13]\nuint256 _platformSecondSalePercentage; // STORAGE[0x14]\nuint256 _artistSecondSalePercentage; // STORAGE[0x15]\nuint256 _expectedTokenSupply; // STORAGE[0x16]\naddress _platformAddress; // STORAGE[0x17] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nBidWithdrawn(uint256);\nBidProposed(uint256, uint256, address);\nControlLeverUpdated(uint256, uint256, uint256[], int256[], int256[]);\nRoyaltyAmountUpdated(uint256, uint256, uint256);\nPlatformAddressUpdated(address);\nApprovalForAll(address, address, bool);\nBuyPriceSet(uint256, uint256);\nTokenSale(uint256, uint256, address);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction 0x23dd(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(_ownerOf[varg1]);\n    require(v0);\n    v1 = v2 = msg.sender == address(v0);\n    if (msg.sender != address(v0)) {\n        v1 = v3 = address(_getApproved[varg1]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v1);\n    0x2781(varg1, varg2, varg3);\n    return ;\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _supportsInterface[~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0)];\n}\n\nfunction 0x268f(uint256 varg0, uint256 varg1) private { \n    MEM[64] += 32;\n    MEM[MEM[64]] = 0;\n    require(address(varg1));\n    require(!address(_ownerOf[varg0]), 'token already minted');\n    v0 = address(varg1);\n    _ownerOf[varg0] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n    _balanceOf[varg0] += 1;\n    emit Transfer(0, address(varg1), varg0);\n    v1 = address(varg1);\n    owner_6[varg0] = _tokenOfOwnerByIndex[v1];\n    MEM[32] = 5;\n    _tokenOfOwnerByIndex[v1] = _tokenOfOwnerByIndex[v1] + 1;\n    STORAGE[keccak256(keccak256(v1, 5)) + _tokenOfOwnerByIndex[v1]] = varg0;\n    map_8[varg0] = _totalSupply.length;\n    _totalSupply.length = _totalSupply.length + 1;\n    MEM[0] = 7;\n    STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _totalSupply.length] = varg0;\n    return ;\n}\n\nfunction 0x26a9(uint256 varg0, uint256 varg1) private { \n    require(address(_ownerOf[varg1]), 'URI set of nonexistent token');\n    v0 = v1 = varg0.data;\n    v2 = _tokenURI[varg1];\n    if (31 < varg0.length) {\n        _tokenURI[varg1] = 1 + (varg0.length + varg0.length);\n        if (varg0.length) {\n            while (v1 + varg0.length > v0) {\n                STORAGE[v3] = MEM[v0];\n                v0 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _tokenURI[varg1] = varg0.length + varg0.length | ~0xff & MEM[v1];\n    }\n    while (v4 + (31 + (((!(0x1 & v2) << 8) - 1 & v2) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    return ;\n}\n\nfunction 0x2781(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(_ownerOf[varg0]);\n    require(v0);\n    require(address(v0) == address(varg2), 'not owner');\n    require(address(varg1));\n    if (address(_getApproved[varg0])) {\n        _getApproved[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _getApproved[varg0];\n        goto 0x2d62B0x2781;\n    }\n    v1 = address(varg2);\n    if (1 <= _balanceOf[v1]) {\n        _balanceOf[v1] = _balanceOf[v1] - 1;\n        v2 = address(varg1);\n        _balanceOf[v2] += 1;\n        v3 = address(varg1);\n        _ownerOf[varg0] = v3 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n        emit Transfer(address(varg2), v3, varg0);\n        v4 = address(varg2);\n        if (1 <= _tokenOfOwnerByIndex[v4]) {\n            v5 = owner_6[varg0];\n            if (_tokenOfOwnerByIndex[v4] - 1 != v5) {\n                v6 = address(varg2);\n                assert(_tokenOfOwnerByIndex[v4] - 1 < _tokenOfOwnerByIndex[v6]);\n                v7 = address(varg2);\n                assert(v5 < _tokenOfOwnerByIndex[v7]);\n                STORAGE[v5 + keccak256(keccak256(v7, 5))] = STORAGE[keccak256(keccak256(v6, 5)) + (_tokenOfOwnerByIndex[v4] - 1)];\n                owner_6[keccak256(v7, 5)] = v5;\n            }\n            v8 = address(varg2);\n            _tokenOfOwnerByIndex[v8] = _tokenOfOwnerByIndex[v8] + ~0;\n            if (_tokenOfOwnerByIndex[v8] > _tokenOfOwnerByIndex[v8] + ~0) {\n                v9 = v10 = _tokenOfOwnerByIndex[v8] + ~0 + keccak256(keccak256(v8, 5));\n                while (keccak256(keccak256(v8, 5)) + _tokenOfOwnerByIndex[v8] > v9) {\n                    STORAGE[v9] = 0;\n                    v9 += 1;\n                }\n                goto 0x16f20x322cB0x2ec5B0x2bbeB0x2781;\n            }\n            v11 = address(varg1);\n            owner_6[varg0] = _tokenOfOwnerByIndex[v11];\n            MEM[32] = 5;\n            _tokenOfOwnerByIndex[v11] = _tokenOfOwnerByIndex[v11] + 1;\n            STORAGE[keccak256(keccak256(v11, 5)) + _tokenOfOwnerByIndex[v11]] = varg0;\n            _buyPrices[varg0] = 0;\n            return ;\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v12 = new array[](v13.length);\n            if (v13.length) {\n                v14 = v13.data;\n                v15 = v16 = 32;\n                while (v15 < v13.length) {\n                    MEM[v15 + v12.data] = MEM[v15 + v13.data];\n                    v15 += 32;\n                }\n            }\n            if (30) {\n                MEM[v12.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v12);\n        }\n    } else {\n        v17 = new array[](v18.length);\n        if (v18.length) {\n            v19 = v18.data;\n            v20 = v21 = 32;\n            while (v20 < v18.length) {\n                MEM[v20 + v17.data] = MEM[v20 + v18.data];\n                v20 += 32;\n            }\n        }\n        if (30) {\n            MEM[v17.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v17);\n    }\n}\n\nfunction 0x279f(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (!(0xff & _tokenDidHaveFirstSale[varg2])) {\n        _tokenDidHaveFirstSale[varg2] = 0x1 | ~0xff & _tokenDidHaveFirstSale[varg2];\n        v0 = v1 = 10565;\n        v2 = v3 = 100;\n        v4 = v5 = _SafeMul(_platformFirstSalePercentage, varg1);\n    } else {\n        v0 = v6 = 10206;\n        v2 = v7 = 100;\n        v4 = v8 = _SafeMul(_platformSecondSalePercentage, varg1);\n    }\n    while (!v2) {\n        if (!v2) {\n            v9 = new array[](v10.length);\n            v11 = v12 = 0;\n            while (v11 < v10.length) {\n                MEM[v11 + v9.data] = MEM[v11 + v10.data];\n                v11 += 32;\n            }\n            if (26) {\n                MEM[v9.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v9);\n        }\n        if (v2) {\n            break;\n        }\n        assert(v2);\n        v13 = v14 = MEM[64];\n        MEM[v14] = _uniqueTokenCreators[v15];\n        v16 = v17 = 10406;\n        v18 = v19 = v14 + 32;\n        if (_uniqueTokenCreators[v15]) {\n            v20 = v21 = v19 + (_uniqueTokenCreators[v15] << 5);\n        }\n        do {\n            MEM[v18] = address(STORAGE[v22]);\n            v22 = v22 + 1;\n            v18 += 32;\n        } while (v20 <= v18);\n        if (MEM[v13]) {\n            assert(MEM[v13]);\n            v23 = v24 = 0;\n            while (v23 < MEM[v13]) {\n                assert(v23 < MEM[v13]);\n                v25 = address(MEM[32 + (v23 << 5) + v13]).call().value(v15 / MEM[v13]).gas(!(v15 / MEM[v13]) * 2300);\n                require(v25); // checks call status, propagates error data on error\n                v23 += 1;\n            }\n            goto {'0x29fa', '0x28a6'};\n            require(address(_ownerOf[v15]));\n            if (v15 <= v15) {\n                if (v15 <= v15 - v15) {\n                    v26 = address(_ownerOf[v15]).call().value(v15 - v15 - v15).gas(2300 * !(v15 - v15 - v15));\n                    require(v26); // checks call status, propagates error data on error\n                } else {\n                    MEM[MEM[64] + 4] = 32;\n                    v27 = new array[](v28.length);\n                    if (v28.length) {\n                        v29 = v28.data;\n                        v30 = v31 = 32;\n                        while (v30 < v28.length) {\n                            MEM[v30 + v27.data] = MEM[v30 + v28.data];\n                            v30 += 32;\n                        }\n                    }\n                    if (30) {\n                        MEM[v27.data] = ~0xffff & 'SafeMath: subtraction overflow';\n                    }\n                    revert(v27);\n                }\n            } else {\n                MEM[MEM[64] + 4] = 32;\n                v32 = new array[](v33.length);\n                if (v33.length) {\n                    v34 = v33.data;\n                    v35 = v36 = 32;\n                    while (v35 < v33.length) {\n                        MEM[v35 + v32.data] = MEM[v35 + v33.data];\n                        v35 += 32;\n                    }\n                }\n                if (30) {\n                    MEM[v32.data] = ~0xffff & 'SafeMath: subtraction overflow';\n                }\n                revert(v32);\n            }\n            _pendingBids[v15] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[v15];\n            _pendingBids[v15][1] = 0;\n            _pendingBids[v15][2] = 0x0 | ~0xff & _pendingBids[v15][0x2];\n            require(address(_ownerOf[v15]));\n            MEM[MEM[64]] = 0;\n            0x23dd(MEM[64], v15, v15, address(_ownerOf[v15]));\n            v37 = address(v15);\n            emit TokenSale(v15, v15, v37);\n            return ;\n        } else {\n            v38 = new array[](v39.length);\n            MEM[4 + MEM[64]] = 32;\n            v40 = v41 = 0;\n            while (v40 < v39.length) {\n                MEM[v40 + v38.data] = MEM[v40 + v39.data];\n                v40 += 32;\n            }\n            if (26) {\n                MEM[v38.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v38);\n        }\n        v42 = _platformAddress.call().value(v15).gas(2300 * !v15);\n        require(v42); // checks call status, propagates error data on error\n        v16 = v43 = 10746;\n        if (v15 <= v15) {\n            v15 = v44 = v15 - v15;\n            v13 = v45 = MEM[64];\n            MEM[v45] = _uniqueTokenCreators[v15];\n            if (_uniqueTokenCreators[v15]) {\n                v20 = v46 = v45 + 32 + (_uniqueTokenCreators[v15] << 5);\n                MEM[v45 + 32] = address(STORAGE[keccak256(keccak256(v15, 13))]);\n                v22 = v47 = keccak256(keccak256(v15, 13)) + 1;\n                v18 = v48 = 32 + (v45 + 32);\n                if (v46 <= v48) {\n                }\n            }\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v49 = new array[](v50.length);\n            if (v50.length) {\n                v51 = v50.data;\n                v52 = v53 = 32;\n                while (v52 < v50.length) {\n                    MEM[v52 + v49.data] = MEM[v52 + v50.data];\n                    v52 += 32;\n                }\n            }\n            if (30) {\n                MEM[v49.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v49);\n        }\n        v15 = v4 / v2;\n        goto {'0x2945', '0x2836', '0x27de'};\n        v54 = _platformAddress.call().value(v15).gas(2300 * !v15);\n        require(v54); // checks call status, propagates error data on error\n        v0 = v55 = 10294;\n        v2 = v56 = 100;\n        v4 = _SafeMul(_artistSecondSalePercentage, v15);\n    }\n}\n\nfunction whitelistedCreators(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _whitelistedCreators[varg0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath: multiplication overflow');\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getApproved(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_getApproved[varg0]);\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg1]));\n    require(varg0 != address(_ownerOf[varg1]));\n    v0 = v1 = address(_ownerOf[varg1]) == msg.sender;\n    if (address(_ownerOf[varg1]) != msg.sender) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _getApproved[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _getApproved[varg1];\n    emit Approval(address(_ownerOf[varg1]), varg0, varg1);\n}\n\nfunction updateWhitelist(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _platformAddress);\n    _whitelistedCreators[varg0] = varg1 | ~0xff & _whitelistedCreators[varg0];\n}\n\nfunction withdrawBid(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 0xff & _pendingBids[varg0][0x2];\n    if (v1) {\n        v0 = v2 = msg.sender == address(_pendingBids[varg0]);\n    }\n    require(v0);\n    v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n    require(v3); // checks call status, propagates error data on error\n    _pendingBids[varg0] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n    _pendingBids[varg0][1] = 0;\n    _pendingBids[varg0][2] = 0x0 | ~0xff & _pendingBids[varg0][0x2];\n    emit BidWithdrawn(varg0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply.length;\n}\n\nfunction setupControlToken(uint256 varg0, string varg1, int256[] varg2, int256[] varg3, int256[] varg4, address[] varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v2 = new uint256[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg3, (?).length << 5);\n    v2[(?).length] = 0;\n    require(varg4 <= 0x100000000);\n    require(4 + varg4 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg4 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v3 = new uint256[]((?).length);\n    CALLDATACOPY(v3.data, 36 + varg4, (?).length << 5);\n    v3[(?).length] = 0;\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v4 = new uint256[]((?).length);\n    CALLDATACOPY(v4.data, 36 + varg5, (?).length << 5);\n    v4[(?).length] = 0;\n    require(0xff & _getControlToken[varg0][0x1], 'No control token found');\n    require(!(0xff & _getControlToken[varg0][1] >> 8), 'Already setup');\n    assert(_uniqueTokenCreators[varg0]);\n    require(address(STORAGE[keccak256(keccak256(varg0, 13)) + 0]) == msg.sender, 'Must be control token artist');\n    v5 = v6 = v1.length == v2.length;\n    if (v6) {\n        v5 = v7 = v2.length == v3.length;\n    }\n    require(v5, 'Values array mismatch');\n    0x268f(varg0, msg.sender);\n    0x26a9(v0, varg0);\n    v8 = new array[](v3.length);\n    v9 = v10 = 0;\n    _getControlToken[varg0] = v8.length;\n    _getControlToken[varg0][1] = (_getControlToken[varg0][0x1] & ~0xff | 0x1) & ~0xff00 | 0x100;\n    while (v9 < v3.length) {\n        if (v9 < v1.length) {\n            break;\n        }\n        assert(v9 < v1.length);\n        if (v9 < v2.length) {\n            break;\n        }\n        assert(v9 < v2.length);\n        if (v2[v9] >= v1[v9]) {\n            break;\n        }\n        require(v2[v9] >= v1[v9], 'Max val must >= min');\n        assert(v9 < v1.length);\n        assert(v9 < v3.length);\n        v11 = v12 = v3[v9] >= v1[v9];\n        if (v12) {\n            assert(v9 < v2.length);\n            assert(v9 < v3.length);\n            v11 = v13 = v3[v9] <= v2[v9];\n        }\n        require(v11, 'Invalid start val');\n        assert(v9 < v1.length);\n        assert(v9 < v2.length);\n        assert(v9 < v3.length);\n        _getControlToken[v9] = v1[v9];\n        _getControlToken[v9][1] = v2[v9];\n        _getControlToken[v9][2] = v3[v9];\n        _getControlToken[v9][3] = 0x1 | ~0xff & _getControlToken[v9][0x3];\n        v9 += 1;\n    }\n    v14 = v15 = 0;\n    while (v14 < v4.length) {\n        assert(v14 < v4.length);\n        require(address(v4[v14]) != 0);\n        assert(v14 < v4.length);\n        _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n        STORAGE[_uniqueTokenCreators[varg0] + keccak256(keccak256(varg0, 13))] = address(v4[v14]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[_uniqueTokenCreators[varg0] + keccak256(keccak256(varg0, 13))];\n        v14 += 1;\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        v0 = v2 = address(_getApproved[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    0x2781(varg2, varg1, varg0);\n}\n\nfunction acceptBid(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    require(0xff & _pendingBids[varg0][0x2]);\n    0x279f(address(_pendingBids[varg0]), _pendingBids[varg0][1], varg0);\n}\n\nfunction tokenOfOwnerByIndex(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 < _tokenOfOwnerByIndex[varg0]);\n    return STORAGE[keccak256(keccak256(varg0, 5)) + varg1];\n}\n\nfunction grantControlPermission(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _grantControlPermission[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _grantControlPermission[msg.sender];\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    MEM[64] += 32;\n    MEM[MEM[64]] = 0;\n    0x23dd(MEM[64], varg2, varg1, varg0);\n}\n\nfunction bid(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(!v0);\n    if (0xff & _pendingBids[varg0][0x2]) {\n        require(msg.value > _pendingBids[varg0][1], 'Bid must be > than current bid');\n        v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n        require(v3); // checks call status, propagates error data on error\n    }\n    _pendingBids[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n    _pendingBids[varg0][1] = msg.value;\n    _pendingBids[varg0][2] = 0x1 | ~0xff & _pendingBids[varg0][0x2];\n    emit BidProposed(varg0, msg.value, msg.sender);\n}\n\nfunction tokenDidHaveFirstSale(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _tokenDidHaveFirstSale[varg0];\n}\n\nfunction tokenByIndex(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(varg0 < _totalSupply.length);\n    return _totalSupply[varg0];\n}\n\nfunction expectedTokenSupply() public nonPayable { \n    return _expectedTokenSupply;\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    return address(_ownerOf[varg0]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction useControlToken(uint256 varg0, uint256[] varg1, int256[] varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length << 5);\n    v0[(?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(address(_ownerOf[varg0]));\n    v2 = v3 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v2 = v4 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v2) {\n        v2 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    if (!v5) {\n        require(address(_ownerOf[varg0]));\n        v2 = v6 = address(_grantControlPermission[address(address(_ownerOf[varg0]))]) == msg.sender;\n    }\n    require(v2, 'Owner or permissioned only');\n    v7 = new uint256[](v1.length);\n    if (v1.length) {\n        MEM[(v7.data) len (v1.length << 5)] = this.code[this.code.size len (v1.length << 5)];\n    }\n    v8 = v9 = 0;\n    while (v8 < v0.length) {\n        if (v8 < v0.length) {\n            break;\n        }\n        assert(v8 < v0.length);\n        if (v8 < v1.length) {\n            break;\n        }\n        assert(v8 < v1.length);\n        v10 = v11 = v1[v8] >= STORAGE[0 + keccak256(v0[v8], 2 + keccak256(varg0, 14))];\n        if (v11) {\n            assert(v8 < v1.length);\n            v10 = v12 = v1[v8] <= STORAGE[1 + keccak256(v0[v8], 2 + keccak256(varg0, 14))];\n        }\n        require(v10, 'Invalid val');\n        assert(v8 < v1.length);\n        require(v1[v8] != STORAGE[2 + keccak256(v0[v8], 2 + keccak256(varg0, 14))], 'Must provide different val');\n        assert(v8 < v1.length);\n        STORAGE[2 + keccak256(v0[v8], 2 + keccak256(varg0, 14))] = v1[v8];\n        assert(v8 < v7.length);\n        v7[v8] = STORAGE[keccak256(v0[v8], 2 + keccak256(varg0, 14)) + 2];\n        v8 += 1;\n    }\n    if (msg.value) {\n        v13 = _platformAddress.call().value(msg.value).gas(2300 * !msg.value);\n        require(v13); // checks call status, propagates error data on error\n    }\n    v14 = new array[](v0.length);\n    v15 = v16 = 0;\n    while (v15 < v0.length << 5) {\n        MEM[v15 + v14.data] = MEM[v15 + v0.data];\n        v15 += 32;\n    }\n    v17 = new array[](v7.length);\n    v18 = v19 = 0;\n    while (v18 < v7.length << 5) {\n        MEM[v18 + v17.data] = MEM[v18 + v7.data];\n        v18 += 32;\n    }\n    v20 = new array[](v1.length);\n    v21 = v22 = 0;\n    while (v21 < v1.length << 5) {\n        MEM[v21 + v20.data] = MEM[v21 + v1.data];\n        v21 += 32;\n    }\n    emit ControlLeverUpdated(varg0, msg.value, v14, v17, v20);\n}\n\nfunction updateRoyaltyPercentages(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _platformAddress);\n    require(varg0 < 100);\n    require(varg2 + varg1 >= varg1, 'SafeMath: addition overflow');\n    require(varg2 + varg1 < 100);\n    _platformFirstSalePercentage = varg0;\n    _platformSecondSalePercentage = varg1;\n    _artistSecondSalePercentage = varg2;\n    emit RoyaltyAmountUpdated(varg0, varg1, varg2);\n}\n\nfunction updatePlatformAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _platformAddress);\n    _platformAddress = varg0;\n    emit PlatformAddressUpdated(varg0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getControlToken(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _getControlToken[varg0][0x1]);\n    v0 = _SafeMul(3, _getControlToken[varg0]);\n    v1 = new uint256[](v0);\n    if (v0) {\n        MEM[(v1.data) len (v0 << 5)] = this.code[this.code.size len (v0 << 5)];\n    }\n    v2 = v3 = 0;\n    while (v2 < _getControlToken[varg0]) {\n        if (v2 < v1.length) {\n            break;\n        }\n        assert(v2 < v1.length);\n        v1[v2] = STORAGE[keccak256(v2, keccak256(varg0, 14) + 2)];\n        if (1 + v2 >= v2) {\n            break;\n        }\n        require(1 + v2 >= v2, 'SafeMath: addition overflow');\n        assert(1 + v2 < v1.length);\n        v1[1 + v2] = STORAGE[1 + keccak256(v2, 2 + keccak256(varg0, 14))];\n        require(2 + v2 >= 1 + v2, 'SafeMath: addition overflow');\n        assert(2 + v2 < v1.length);\n        v1[2 + v2] = STORAGE[2 + keccak256(v2, 2 + keccak256(varg0, 14))];\n        v2 += 3;\n        require(v2 >= 2 + v2, 'SafeMath: addition overflow');\n        v2 += 1;\n    }\n    v4 = new array[](v1.length);\n    v5 = v6 = 0;\n    while (v5 < v1.length << 5) {\n        MEM[v5 + v4.data] = MEM[v5 + v1.data];\n        v5 += 32;\n    }\n    return v4;\n}\n\nfunction permissionedControllers(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_grantControlPermission[varg0]);\n}\n\nfunction mintArtwork(uint256 varg0, string varg1, address[] varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(1 == 0xff & _whitelistedCreators[msg.sender]);\n    require(varg0 == _expectedTokenSupply, 'ExpectedTokenSupply different');\n    0x268f(varg0, msg.sender);\n    _expectedTokenSupply += 1;\n    0x26a9(v0, varg0);\n    v2 = v3 = 0;\n    _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n    STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]];\n    while (v2 < v1.length) {\n        assert(v2 < v1.length);\n        require(address(v1[v2]) != 0);\n        _expectedTokenSupply = _expectedTokenSupply + 1;\n        assert(v2 < v1.length);\n        _uniqueTokenCreators[_expectedTokenSupply] = _uniqueTokenCreators[_expectedTokenSupply] + 1;\n        STORAGE[_uniqueTokenCreators[_expectedTokenSupply] + keccak256(keccak256(_expectedTokenSupply, 13))] = address(v1[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[_uniqueTokenCreators[_expectedTokenSupply] + keccak256(keccak256(_expectedTokenSupply, 13))];\n        _getControlToken[keccak256(_expectedTokenSupply, 13)] = 0;\n        _getControlToken[keccak256(_expectedTokenSupply, 13)][1] = 0x0 | ~0xff00 & (0x1 | _getControlToken[keccak256(_expectedTokenSupply, 13)][0x1] & ~0xff);\n        assert(v2 < v1.length);\n        if (address(v1[v2]) != msg.sender) {\n            v4 = v5 = 0;\n            while (v4 < _uniqueTokenCreators[varg0]) {\n                assert(v2 < v1.length);\n                assert(v4 < _uniqueTokenCreators[varg0]);\n                if (address(STORAGE[keccak256(keccak256(varg0, 13)) + v4]) != address(v1[v2])) {\n                    v4 += 1;\n                } else {\n                    v4 = v6 = 1;\n                    break;\n                }\n            }\n            if (!v4) {\n                assert(v2 < v1.length);\n                _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n                STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]] = address(v1[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]];\n            }\n        }\n        v2 += 1;\n    }\n}\n\nfunction setApprovalForAll(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender != varg0);\n    _isApprovedForAll[varg0] = varg1 | ~0xff & _isApprovedForAll[varg0];\n    emit ApprovalForAll(msg.sender, varg0, varg1);\n}\n\nfunction buyPrices(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _buyPrices[varg0];\n}\n\nfunction uniqueTokenCreators(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 < _uniqueTokenCreators[varg0]);\n    return address(STORAGE[keccak256(keccak256(varg0, 13)) + varg1]);\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(address(_ownerOf[varg2]));\n    v1 = v2 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        v1 = v3 = address(_getApproved[varg2]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v1);\n    0x2781(varg2, varg1, varg0);\n}\n\nfunction platformFirstSalePercentage() public nonPayable { \n    return _platformFirstSalePercentage;\n}\n\nfunction artistSecondSalePercentage() public nonPayable { \n    return _artistSecondSalePercentage;\n}\n\nfunction tokenURI(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new bytes[](v1);\n    v1 = (_tokenURI[varg0] & (!(_tokenURI[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenURI[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction pendingBids(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_pendingBids[varg0]), _pendingBids[varg0][1], 0xff & _pendingBids[varg0][0x2];\n}\n\nfunction platformSecondSalePercentage() public nonPayable { \n    return _platformSecondSalePercentage;\n}\n\nfunction makeBuyPrice(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _buyPrices[varg0] = varg1;\n    emit BuyPriceSet(varg0, varg1);\n}\n\nfunction platformAddress() public nonPayable { \n    return _platformAddress;\n}\n\nfunction takeBuyPrice(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(!v0);\n    require(_buyPrices[varg0]);\n    require(msg.value >= _buyPrices[varg0]);\n    if (0xff & _pendingBids[varg0][0x2]) {\n        v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n        require(v3); // checks call status, propagates error data on error\n        _pendingBids[varg0] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n        _pendingBids[varg0][1] = 0;\n        _pendingBids[varg0][2] = 0x0 | ~0xff & _pendingBids[varg0][0x2];\n    }\n    0x279f(msg.sender, _buyPrices[varg0], varg0);\n}\n\nfunction isApprovedForAll(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _isApprovedForAll[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x755db7b3 > v0) {\n            if (0x2b1fd58a > v0) {\n                if (0xd392cd9 > v0) {\n                    if (0x1ffc9a7 == v0) {\n                        supportsInterface(bytes4);\n                    } else if (0x41bb6ff == v0) {\n                        whitelistedCreators(address);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x81812fc == v0) {\n                        getApproved(uint256);\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    }\n                } else if (0xd392cd9 == v0) {\n                    updateWhitelist(address,bool);\n                } else if (0xeaaf4c8 == v0) {\n                    withdrawBid(uint256);\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1e9b0f52 == v0) {\n                    setupControlToken(uint256,string,int256[],int256[],int256[],address[]);\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x462399cd > v0) {\n                if (0x2b1fd58a == v0) {\n                    acceptBid(uint256);\n                } else if (0x2f745c59 == v0) {\n                    tokenOfOwnerByIndex(address,uint256);\n                } else if (0x41afca00 == v0) {\n                    grantControlPermission(address);\n                } else if (0x42842e0e == v0) {\n                    safeTransferFrom(address,address,uint256);\n                } else if (0x454a2ab3 == v0) {\n                    bid(uint256);\n                }\n            } else if (0x462399cd == v0) {\n                tokenDidHaveFirstSale(uint256);\n            } else if (0x4f6ccce7 == v0) {\n                tokenByIndex(uint256);\n            } else if (0x556d8628 == v0) {\n                expectedTokenSupply();\n            } else if (0x6352211e == v0) {\n                ownerOf(uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            }\n        } else if (0xb88d4fde > v0) {\n            if (0x98207051 > v0) {\n                if (0x755db7b3 == v0) {\n                    useControlToken(uint256,uint256[],int256[]);\n                } else if (0x8cb6ddcb == v0) {\n                    updateRoyaltyPercentages(uint256,uint256,uint256);\n                } else if (0x8f9f193f == v0) {\n                    updatePlatformAddress(address);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x96bc50b0 == v0) {\n                    getControlToken(uint256);\n                }\n            } else if (0x98207051 == v0) {\n                permissionedControllers(address);\n            } else if (0x98c8103e == v0) {\n                mintArtwork(uint256,string,address[]);\n            } else if (0xa22cb465 == v0) {\n                setApprovalForAll(address,bool);\n            } else if (0xa90d6de3 == v0) {\n                buyPrices(uint256);\n            } else if (0xa94141a1 == v0) {\n                uniqueTokenCreators(uint256,uint256);\n            }\n        } else if (0xd66767ab > v0) {\n            if (0xb88d4fde == v0) {\n                safeTransferFrom(address,address,uint256,bytes);\n            } else if (0xb8c18015 == v0) {\n                platformFirstSalePercentage();\n            } else if (0xbab2d111 == v0) {\n                artistSecondSalePercentage();\n            } else if (0xc87b56dd == v0) {\n                tokenURI(uint256);\n            } else if (0xcf8589b9 == v0) {\n                pendingBids(uint256);\n            }\n        } else if (0xd66767ab == v0) {\n            platformSecondSalePercentage();\n        } else if (0xd91c070c == v0) {\n            makeBuyPrice(uint256,uint256);\n        } else if (0xdbe55e56 == v0) {\n            platformAddress();\n        } else if (0xe66c7f35 == v0) {\n            takeBuyPrice(uint256);\n        } else if (0xe985e9c5 == v0) {\n            isApprovedForAll(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 04:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _supportsInterface; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _ownerOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getApproved; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _isApprovedForAll; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _tokenOfOwnerByIndex; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nuint256[] _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) map_8; // STORAGE[0x8]\nuint256[] _name; // STORAGE[0x9]\nuint256[] _symbol; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _tokenURI; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _whitelistedCreators; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _uniqueTokenCreators; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _getControlToken; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _buyPrices; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _pendingBids; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _tokenDidHaveFirstSale; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _grantControlPermission; // STORAGE[0x12]\nuint256 _platformFirstSalePercentage; // STORAGE[0x13]\nuint256 _platformSecondSalePercentage; // STORAGE[0x14]\nuint256 _artistSecondSalePercentage; // STORAGE[0x15]\nuint256 _expectedTokenSupply; // STORAGE[0x16]\naddress _platformAddress; // STORAGE[0x17] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nBidWithdrawn(uint256);\nBidProposed(uint256, uint256, address);\nControlLeverUpdated(uint256, uint256, uint256[], int256[], int256[]);\nRoyaltyAmountUpdated(uint256, uint256, uint256);\nPlatformAddressUpdated(address);\nApprovalForAll(address, address, bool);\nBuyPriceSet(uint256, uint256);\nTokenSale(uint256, uint256, address);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction 0x23dd(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(_ownerOf[varg1]);\n    require(v0);\n    v1 = v2 = msg.sender == address(v0);\n    if (msg.sender != address(v0)) {\n        v1 = v3 = address(_getApproved[varg1]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v1);\n    0x2781(varg1, varg2, varg3);\n    return ;\n}\n\nfunction supportsInterface(bytes4 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _supportsInterface[~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0)];\n}\n\nfunction 0x268f(uint256 varg0, uint256 varg1) private { \n    MEM[64] += 32;\n    MEM[MEM[64]] = 0;\n    require(address(varg1));\n    require(!address(_ownerOf[varg0]), 'token already minted');\n    v0 = address(varg1);\n    _ownerOf[varg0] = v0 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n    _balanceOf[varg0] += 1;\n    emit Transfer(0, address(varg1), varg0);\n    v1 = address(varg1);\n    owner_6[varg0] = _tokenOfOwnerByIndex[v1];\n    MEM[32] = 5;\n    _tokenOfOwnerByIndex[v1] = _tokenOfOwnerByIndex[v1] + 1;\n    STORAGE[keccak256(keccak256(v1, 5)) + _tokenOfOwnerByIndex[v1]] = varg0;\n    map_8[varg0] = _totalSupply.length;\n    _totalSupply.length = _totalSupply.length + 1;\n    MEM[0] = 7;\n    STORAGE[0xa66cc928b5edb82af9bd49922954155ab7b0942694bea4ce44661d9a8736c688 + _totalSupply.length] = varg0;\n    return ;\n}\n\nfunction 0x26a9(uint256 varg0, uint256 varg1) private { \n    require(address(_ownerOf[varg1]), 'URI set of nonexistent token');\n    v0 = v1 = varg0.data;\n    v2 = _tokenURI[varg1];\n    if (31 < varg0.length) {\n        _tokenURI[varg1] = 1 + (varg0.length + varg0.length);\n        if (varg0.length) {\n            while (v1 + varg0.length > v0) {\n                STORAGE[v3] = MEM[v0];\n                v0 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _tokenURI[varg1] = varg0.length + varg0.length | ~0xff & MEM[v1];\n    }\n    while (v4 + (31 + (((!(0x1 & v2) << 8) - 1 & v2) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    return ;\n}\n\nfunction 0x2781(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(_ownerOf[varg0]);\n    require(v0);\n    require(address(v0) == address(varg2), 'not owner');\n    require(address(varg1));\n    if (address(_getApproved[varg0])) {\n        _getApproved[varg0] = ~0xffffffffffffffffffffffffffffffffffffffff & _getApproved[varg0];\n        goto 0x2d62B0x2781;\n    }\n    v1 = address(varg2);\n    if (1 <= _balanceOf[v1]) {\n        _balanceOf[v1] = _balanceOf[v1] - 1;\n        v2 = address(varg1);\n        _balanceOf[v2] += 1;\n        v3 = address(varg1);\n        _ownerOf[varg0] = v3 | ~0xffffffffffffffffffffffffffffffffffffffff & _ownerOf[varg0];\n        emit Transfer(address(varg2), v3, varg0);\n        v4 = address(varg2);\n        if (1 <= _tokenOfOwnerByIndex[v4]) {\n            v5 = owner_6[varg0];\n            if (_tokenOfOwnerByIndex[v4] - 1 != v5) {\n                v6 = address(varg2);\n                assert(_tokenOfOwnerByIndex[v4] - 1 < _tokenOfOwnerByIndex[v6]);\n                v7 = address(varg2);\n                assert(v5 < _tokenOfOwnerByIndex[v7]);\n                STORAGE[v5 + keccak256(keccak256(v7, 5))] = STORAGE[keccak256(keccak256(v6, 5)) + (_tokenOfOwnerByIndex[v4] - 1)];\n                owner_6[keccak256(v7, 5)] = v5;\n            }\n            v8 = address(varg2);\n            _tokenOfOwnerByIndex[v8] = _tokenOfOwnerByIndex[v8] + ~0;\n            if (_tokenOfOwnerByIndex[v8] > _tokenOfOwnerByIndex[v8] + ~0) {\n                v9 = v10 = _tokenOfOwnerByIndex[v8] + ~0 + keccak256(keccak256(v8, 5));\n                while (keccak256(keccak256(v8, 5)) + _tokenOfOwnerByIndex[v8] > v9) {\n                    STORAGE[v9] = 0;\n                    v9 += 1;\n                }\n                goto 0x16f20x322cB0x2ec5B0x2bbeB0x2781;\n            }\n            v11 = address(varg1);\n            owner_6[varg0] = _tokenOfOwnerByIndex[v11];\n            MEM[32] = 5;\n            _tokenOfOwnerByIndex[v11] = _tokenOfOwnerByIndex[v11] + 1;\n            STORAGE[keccak256(keccak256(v11, 5)) + _tokenOfOwnerByIndex[v11]] = varg0;\n            _buyPrices[varg0] = 0;\n            return ;\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v12 = new array[](v13.length);\n            if (v13.length) {\n                v14 = v13.data;\n                v15 = v16 = 32;\n                while (v15 < v13.length) {\n                    MEM[v15 + v12.data] = MEM[v15 + v13.data];\n                    v15 += 32;\n                }\n            }\n            if (30) {\n                MEM[v12.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v12);\n        }\n    } else {\n        v17 = new array[](v18.length);\n        if (v18.length) {\n            v19 = v18.data;\n            v20 = v21 = 32;\n            while (v20 < v18.length) {\n                MEM[v20 + v17.data] = MEM[v20 + v18.data];\n                v20 += 32;\n            }\n        }\n        if (30) {\n            MEM[v17.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v17);\n    }\n}\n\nfunction 0x279f(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (!(0xff & _tokenDidHaveFirstSale[varg2])) {\n        _tokenDidHaveFirstSale[varg2] = 0x1 | ~0xff & _tokenDidHaveFirstSale[varg2];\n        v0 = v1 = 10565;\n        v2 = v3 = 100;\n        v4 = v5 = _SafeMul(_platformFirstSalePercentage, varg1);\n    } else {\n        v0 = v6 = 10206;\n        v2 = v7 = 100;\n        v4 = v8 = _SafeMul(_platformSecondSalePercentage, varg1);\n    }\n    while (!v2) {\n        if (!v2) {\n            v9 = new array[](v10.length);\n            v11 = v12 = 0;\n            while (v11 < v10.length) {\n                MEM[v11 + v9.data] = MEM[v11 + v10.data];\n                v11 += 32;\n            }\n            if (26) {\n                MEM[v9.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v9);\n        }\n        if (v2) {\n            break;\n        }\n        assert(v2);\n        v13 = v14 = MEM[64];\n        MEM[v14] = _uniqueTokenCreators[v15];\n        v16 = v17 = 10406;\n        v18 = v19 = v14 + 32;\n        if (_uniqueTokenCreators[v15]) {\n            v20 = v21 = v19 + (_uniqueTokenCreators[v15] << 5);\n        }\n        do {\n            MEM[v18] = address(STORAGE[v22]);\n            v22 = v22 + 1;\n            v18 += 32;\n        } while (v20 <= v18);\n        if (MEM[v13]) {\n            assert(MEM[v13]);\n            v23 = v24 = 0;\n            while (v23 < MEM[v13]) {\n                assert(v23 < MEM[v13]);\n                v25 = address(MEM[32 + (v23 << 5) + v13]).call().value(v15 / MEM[v13]).gas(!(v15 / MEM[v13]) * 2300);\n                require(v25); // checks call status, propagates error data on error\n                v23 += 1;\n            }\n            goto {'0x29fa', '0x28a6'};\n            require(address(_ownerOf[v15]));\n            if (v15 <= v15) {\n                if (v15 <= v15 - v15) {\n                    v26 = address(_ownerOf[v15]).call().value(v15 - v15 - v15).gas(2300 * !(v15 - v15 - v15));\n                    require(v26); // checks call status, propagates error data on error\n                } else {\n                    MEM[MEM[64] + 4] = 32;\n                    v27 = new array[](v28.length);\n                    if (v28.length) {\n                        v29 = v28.data;\n                        v30 = v31 = 32;\n                        while (v30 < v28.length) {\n                            MEM[v30 + v27.data] = MEM[v30 + v28.data];\n                            v30 += 32;\n                        }\n                    }\n                    if (30) {\n                        MEM[v27.data] = ~0xffff & 'SafeMath: subtraction overflow';\n                    }\n                    revert(v27);\n                }\n            } else {\n                MEM[MEM[64] + 4] = 32;\n                v32 = new array[](v33.length);\n                if (v33.length) {\n                    v34 = v33.data;\n                    v35 = v36 = 32;\n                    while (v35 < v33.length) {\n                        MEM[v35 + v32.data] = MEM[v35 + v33.data];\n                        v35 += 32;\n                    }\n                }\n                if (30) {\n                    MEM[v32.data] = ~0xffff & 'SafeMath: subtraction overflow';\n                }\n                revert(v32);\n            }\n            _pendingBids[v15] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[v15];\n            _pendingBids[v15][1] = 0;\n            _pendingBids[v15][2] = 0x0 | ~0xff & _pendingBids[v15][0x2];\n            require(address(_ownerOf[v15]));\n            MEM[MEM[64]] = 0;\n            0x23dd(MEM[64], v15, v15, address(_ownerOf[v15]));\n            v37 = address(v15);\n            emit TokenSale(v15, v15, v37);\n            return ;\n        } else {\n            v38 = new array[](v39.length);\n            MEM[4 + MEM[64]] = 32;\n            v40 = v41 = 0;\n            while (v40 < v39.length) {\n                MEM[v40 + v38.data] = MEM[v40 + v39.data];\n                v40 += 32;\n            }\n            if (26) {\n                MEM[v38.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v38);\n        }\n        v42 = _platformAddress.call().value(v15).gas(2300 * !v15);\n        require(v42); // checks call status, propagates error data on error\n        v16 = v43 = 10746;\n        if (v15 <= v15) {\n            v15 = v44 = v15 - v15;\n            v13 = v45 = MEM[64];\n            MEM[v45] = _uniqueTokenCreators[v15];\n            if (_uniqueTokenCreators[v15]) {\n                v20 = v46 = v45 + 32 + (_uniqueTokenCreators[v15] << 5);\n                MEM[v45 + 32] = address(STORAGE[keccak256(keccak256(v15, 13))]);\n                v22 = v47 = keccak256(keccak256(v15, 13)) + 1;\n                v18 = v48 = 32 + (v45 + 32);\n                if (v46 <= v48) {\n                }\n            }\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v49 = new array[](v50.length);\n            if (v50.length) {\n                v51 = v50.data;\n                v52 = v53 = 32;\n                while (v52 < v50.length) {\n                    MEM[v52 + v49.data] = MEM[v52 + v50.data];\n                    v52 += 32;\n                }\n            }\n            if (30) {\n                MEM[v49.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v49);\n        }\n        v15 = v4 / v2;\n        goto {'0x2945', '0x2836', '0x27de'};\n        v54 = _platformAddress.call().value(v15).gas(2300 * !v15);\n        require(v54); // checks call status, propagates error data on error\n        v0 = v55 = 10294;\n        v2 = v56 = 100;\n        v4 = _SafeMul(_artistSecondSalePercentage, v15);\n    }\n}\n\nfunction whitelistedCreators(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _whitelistedCreators[varg0];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath: multiplication overflow');\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & (!(_name.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getApproved(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_getApproved[varg0]);\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg1]));\n    require(varg0 != address(_ownerOf[varg1]));\n    v0 = v1 = address(_ownerOf[varg1]) == msg.sender;\n    if (address(_ownerOf[varg1]) != msg.sender) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _getApproved[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _getApproved[varg1];\n    emit Approval(address(_ownerOf[varg1]), varg0, varg1);\n}\n\nfunction updateWhitelist(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _platformAddress);\n    _whitelistedCreators[varg0] = varg1 | ~0xff & _whitelistedCreators[varg0];\n}\n\nfunction withdrawBid(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = v1 = 0xff & _pendingBids[varg0][0x2];\n    if (v1) {\n        v0 = v2 = msg.sender == address(_pendingBids[varg0]);\n    }\n    require(v0);\n    v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n    require(v3); // checks call status, propagates error data on error\n    _pendingBids[varg0] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n    _pendingBids[varg0][1] = 0;\n    _pendingBids[varg0][2] = 0x0 | ~0xff & _pendingBids[varg0][0x2];\n    emit BidWithdrawn(varg0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply.length;\n}\n\nfunction setupControlToken(uint256 varg0, string varg1, int256[] varg2, int256[] varg3, int256[] varg4, address[] varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v2 = new uint256[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg3, (?).length << 5);\n    v2[(?).length] = 0;\n    require(varg4 <= 0x100000000);\n    require(4 + varg4 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg4 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v3 = new uint256[]((?).length);\n    CALLDATACOPY(v3.data, 36 + varg4, (?).length << 5);\n    v3[(?).length] = 0;\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v4 = new uint256[]((?).length);\n    CALLDATACOPY(v4.data, 36 + varg5, (?).length << 5);\n    v4[(?).length] = 0;\n    require(0xff & _getControlToken[varg0][0x1], 'No control token found');\n    require(!(0xff & _getControlToken[varg0][1] >> 8), 'Already setup');\n    assert(_uniqueTokenCreators[varg0]);\n    require(address(STORAGE[keccak256(keccak256(varg0, 13)) + 0]) == msg.sender, 'Must be control token artist');\n    v5 = v6 = v1.length == v2.length;\n    if (v6) {\n        v5 = v7 = v2.length == v3.length;\n    }\n    require(v5, 'Values array mismatch');\n    0x268f(varg0, msg.sender);\n    0x26a9(v0, varg0);\n    v8 = new array[](v3.length);\n    v9 = v10 = 0;\n    _getControlToken[varg0] = v8.length;\n    _getControlToken[varg0][1] = (_getControlToken[varg0][0x1] & ~0xff | 0x1) & ~0xff00 | 0x100;\n    while (v9 < v3.length) {\n        if (v9 < v1.length) {\n            break;\n        }\n        assert(v9 < v1.length);\n        if (v9 < v2.length) {\n            break;\n        }\n        assert(v9 < v2.length);\n        if (v2[v9] >= v1[v9]) {\n            break;\n        }\n        require(v2[v9] >= v1[v9], 'Max val must >= min');\n        assert(v9 < v1.length);\n        assert(v9 < v3.length);\n        v11 = v12 = v3[v9] >= v1[v9];\n        if (v12) {\n            assert(v9 < v2.length);\n            assert(v9 < v3.length);\n            v11 = v13 = v3[v9] <= v2[v9];\n        }\n        require(v11, 'Invalid start val');\n        assert(v9 < v1.length);\n        assert(v9 < v2.length);\n        assert(v9 < v3.length);\n        _getControlToken[v9] = v1[v9];\n        _getControlToken[v9][1] = v2[v9];\n        _getControlToken[v9][2] = v3[v9];\n        _getControlToken[v9][3] = 0x1 | ~0xff & _getControlToken[v9][0x3];\n        v9 += 1;\n    }\n    v14 = v15 = 0;\n    while (v14 < v4.length) {\n        assert(v14 < v4.length);\n        require(address(v4[v14]) != 0);\n        assert(v14 < v4.length);\n        _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n        STORAGE[_uniqueTokenCreators[varg0] + keccak256(keccak256(varg0, 13))] = address(v4[v14]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[_uniqueTokenCreators[varg0] + keccak256(keccak256(varg0, 13))];\n        v14 += 1;\n    }\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(address(_ownerOf[varg2]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        v0 = v2 = address(_getApproved[varg2]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    0x2781(varg2, varg1, varg0);\n}\n\nfunction acceptBid(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    require(0xff & _pendingBids[varg0][0x2]);\n    0x279f(address(_pendingBids[varg0]), _pendingBids[varg0][1], varg0);\n}\n\nfunction tokenOfOwnerByIndex(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 < _tokenOfOwnerByIndex[varg0]);\n    return STORAGE[keccak256(keccak256(varg0, 5)) + varg1];\n}\n\nfunction grantControlPermission(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _grantControlPermission[msg.sender] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _grantControlPermission[msg.sender];\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    MEM[64] += 32;\n    MEM[MEM[64]] = 0;\n    0x23dd(MEM[64], varg2, varg1, varg0);\n}\n\nfunction bid(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(!v0);\n    if (0xff & _pendingBids[varg0][0x2]) {\n        require(msg.value > _pendingBids[varg0][1], 'Bid must be > than current bid');\n        v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n        require(v3); // checks call status, propagates error data on error\n    }\n    _pendingBids[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n    _pendingBids[varg0][1] = msg.value;\n    _pendingBids[varg0][2] = 0x1 | ~0xff & _pendingBids[varg0][0x2];\n    emit BidProposed(varg0, msg.value, msg.sender);\n}\n\nfunction tokenDidHaveFirstSale(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _tokenDidHaveFirstSale[varg0];\n}\n\nfunction tokenByIndex(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(varg0 < _totalSupply.length);\n    return _totalSupply[varg0];\n}\n\nfunction expectedTokenSupply() public nonPayable { \n    return _expectedTokenSupply;\n}\n\nfunction ownerOf(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    return address(_ownerOf[varg0]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0);\n    return _balanceOf[varg0];\n}\n\nfunction useControlToken(uint256 varg0, uint256[] varg1, int256[] varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length << 5);\n    v0[(?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(address(_ownerOf[varg0]));\n    v2 = v3 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v2 = v4 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v2) {\n        v2 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    if (!v5) {\n        require(address(_ownerOf[varg0]));\n        v2 = v6 = address(_grantControlPermission[address(address(_ownerOf[varg0]))]) == msg.sender;\n    }\n    require(v2, 'Owner or permissioned only');\n    v7 = new uint256[](v1.length);\n    if (v1.length) {\n        MEM[(v7.data) len (v1.length << 5)] = this.code[this.code.size len (v1.length << 5)];\n    }\n    v8 = v9 = 0;\n    while (v8 < v0.length) {\n        if (v8 < v0.length) {\n            break;\n        }\n        assert(v8 < v0.length);\n        if (v8 < v1.length) {\n            break;\n        }\n        assert(v8 < v1.length);\n        v10 = v11 = v1[v8] >= STORAGE[0 + keccak256(v0[v8], 2 + keccak256(varg0, 14))];\n        if (v11) {\n            assert(v8 < v1.length);\n            v10 = v12 = v1[v8] <= STORAGE[1 + keccak256(v0[v8], 2 + keccak256(varg0, 14))];\n        }\n        require(v10, 'Invalid val');\n        assert(v8 < v1.length);\n        require(v1[v8] != STORAGE[2 + keccak256(v0[v8], 2 + keccak256(varg0, 14))], 'Must provide different val');\n        assert(v8 < v1.length);\n        STORAGE[2 + keccak256(v0[v8], 2 + keccak256(varg0, 14))] = v1[v8];\n        assert(v8 < v7.length);\n        v7[v8] = STORAGE[keccak256(v0[v8], 2 + keccak256(varg0, 14)) + 2];\n        v8 += 1;\n    }\n    if (msg.value) {\n        v13 = _platformAddress.call().value(msg.value).gas(2300 * !msg.value);\n        require(v13); // checks call status, propagates error data on error\n    }\n    v14 = new array[](v0.length);\n    v15 = v16 = 0;\n    while (v15 < v0.length << 5) {\n        MEM[v15 + v14.data] = MEM[v15 + v0.data];\n        v15 += 32;\n    }\n    v17 = new array[](v7.length);\n    v18 = v19 = 0;\n    while (v18 < v7.length << 5) {\n        MEM[v18 + v17.data] = MEM[v18 + v7.data];\n        v18 += 32;\n    }\n    v20 = new array[](v1.length);\n    v21 = v22 = 0;\n    while (v21 < v1.length << 5) {\n        MEM[v21 + v20.data] = MEM[v21 + v1.data];\n        v21 += 32;\n    }\n    emit ControlLeverUpdated(varg0, msg.value, v14, v17, v20);\n}\n\nfunction updateRoyaltyPercentages(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _platformAddress);\n    require(varg0 < 100);\n    require(varg2 + varg1 >= varg1, 'SafeMath: addition overflow');\n    require(varg2 + varg1 < 100);\n    _platformFirstSalePercentage = varg0;\n    _platformSecondSalePercentage = varg1;\n    _artistSecondSalePercentage = varg2;\n    emit RoyaltyAmountUpdated(varg0, varg1, varg2);\n}\n\nfunction updatePlatformAddress(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _platformAddress);\n    _platformAddress = varg0;\n    emit PlatformAddressUpdated(varg0);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & (!(_symbol.length & 0x1) << 8) + ~0) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getControlToken(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _getControlToken[varg0][0x1]);\n    v0 = _SafeMul(3, _getControlToken[varg0]);\n    v1 = new uint256[](v0);\n    if (v0) {\n        MEM[(v1.data) len (v0 << 5)] = this.code[this.code.size len (v0 << 5)];\n    }\n    v2 = v3 = 0;\n    while (v2 < _getControlToken[varg0]) {\n        if (v2 < v1.length) {\n            break;\n        }\n        assert(v2 < v1.length);\n        v1[v2] = STORAGE[keccak256(v2, keccak256(varg0, 14) + 2)];\n        if (1 + v2 >= v2) {\n            break;\n        }\n        require(1 + v2 >= v2, 'SafeMath: addition overflow');\n        assert(1 + v2 < v1.length);\n        v1[1 + v2] = STORAGE[1 + keccak256(v2, 2 + keccak256(varg0, 14))];\n        require(2 + v2 >= 1 + v2, 'SafeMath: addition overflow');\n        assert(2 + v2 < v1.length);\n        v1[2 + v2] = STORAGE[2 + keccak256(v2, 2 + keccak256(varg0, 14))];\n        v2 += 3;\n        require(v2 >= 2 + v2, 'SafeMath: addition overflow');\n        v2 += 1;\n    }\n    v4 = new array[](v1.length);\n    v5 = v6 = 0;\n    while (v5 < v1.length << 5) {\n        MEM[v5 + v4.data] = MEM[v5 + v1.data];\n        v5 += 32;\n    }\n    return v4;\n}\n\nfunction permissionedControllers(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_grantControlPermission[varg0]);\n}\n\nfunction mintArtwork(uint256 varg0, string varg1, address[] varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg2 + ((?).length << 5) > 4 + (msg.data.length - 4))));\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length << 5);\n    v1[(?).length] = 0;\n    require(1 == 0xff & _whitelistedCreators[msg.sender]);\n    require(varg0 == _expectedTokenSupply, 'ExpectedTokenSupply different');\n    0x268f(varg0, msg.sender);\n    _expectedTokenSupply += 1;\n    0x26a9(v0, varg0);\n    v2 = v3 = 0;\n    _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n    STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]];\n    while (v2 < v1.length) {\n        assert(v2 < v1.length);\n        require(address(v1[v2]) != 0);\n        _expectedTokenSupply = _expectedTokenSupply + 1;\n        assert(v2 < v1.length);\n        _uniqueTokenCreators[_expectedTokenSupply] = _uniqueTokenCreators[_expectedTokenSupply] + 1;\n        STORAGE[_uniqueTokenCreators[_expectedTokenSupply] + keccak256(keccak256(_expectedTokenSupply, 13))] = address(v1[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[_uniqueTokenCreators[_expectedTokenSupply] + keccak256(keccak256(_expectedTokenSupply, 13))];\n        _getControlToken[keccak256(_expectedTokenSupply, 13)] = 0;\n        _getControlToken[keccak256(_expectedTokenSupply, 13)][1] = 0x0 | ~0xff00 & (0x1 | _getControlToken[keccak256(_expectedTokenSupply, 13)][0x1] & ~0xff);\n        assert(v2 < v1.length);\n        if (address(v1[v2]) != msg.sender) {\n            v4 = v5 = 0;\n            while (v4 < _uniqueTokenCreators[varg0]) {\n                assert(v2 < v1.length);\n                assert(v4 < _uniqueTokenCreators[varg0]);\n                if (address(STORAGE[keccak256(keccak256(varg0, 13)) + v4]) != address(v1[v2])) {\n                    v4 += 1;\n                } else {\n                    v4 = v6 = 1;\n                    break;\n                }\n            }\n            if (!v4) {\n                assert(v2 < v1.length);\n                _uniqueTokenCreators[varg0] = _uniqueTokenCreators[varg0] + 1;\n                STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]] = address(v1[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(keccak256(varg0, 13)) + _uniqueTokenCreators[varg0]];\n            }\n        }\n        v2 += 1;\n    }\n}\n\nfunction setApprovalForAll(address varg0, bool varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender != varg0);\n    _isApprovedForAll[varg0] = varg1 | ~0xff & _isApprovedForAll[varg0];\n    emit ApprovalForAll(msg.sender, varg0, varg1);\n}\n\nfunction buyPrices(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _buyPrices[varg0];\n}\n\nfunction uniqueTokenCreators(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 < _uniqueTokenCreators[varg0]);\n    return address(STORAGE[keccak256(keccak256(varg0, 13)) + varg1]);\n}\n\nfunction safeTransferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(4 + varg3 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg3 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(address(_ownerOf[varg2]));\n    v1 = v2 = msg.sender == address(_ownerOf[varg2]);\n    if (msg.sender != address(_ownerOf[varg2])) {\n        v1 = v3 = address(_getApproved[varg2]) == msg.sender;\n    }\n    if (!v1) {\n        v1 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v1);\n    0x2781(varg2, varg1, varg0);\n}\n\nfunction platformFirstSalePercentage() public nonPayable { \n    return _platformFirstSalePercentage;\n}\n\nfunction artistSecondSalePercentage() public nonPayable { \n    return _artistSecondSalePercentage;\n}\n\nfunction tokenURI(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new bytes[](v1);\n    v1 = (_tokenURI[varg0] & (!(_tokenURI[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _tokenURI[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction pendingBids(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_pendingBids[varg0]), _pendingBids[varg0][1], 0xff & _pendingBids[varg0][0x2];\n}\n\nfunction platformSecondSalePercentage() public nonPayable { \n    return _platformSecondSalePercentage;\n}\n\nfunction makeBuyPrice(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(v0);\n    _buyPrices[varg0] = varg1;\n    emit BuyPriceSet(varg0, varg1);\n}\n\nfunction platformAddress() public nonPayable { \n    return _platformAddress;\n}\n\nfunction takeBuyPrice(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(address(_ownerOf[varg0]));\n    v0 = v1 = msg.sender == address(_ownerOf[varg0]);\n    if (msg.sender != address(_ownerOf[varg0])) {\n        v0 = v2 = address(_getApproved[varg0]) == msg.sender;\n    }\n    if (!v0) {\n        v0 = 0xff & _isApprovedForAll[msg.sender];\n    }\n    require(!v0);\n    require(_buyPrices[varg0]);\n    require(msg.value >= _buyPrices[varg0]);\n    if (0xff & _pendingBids[varg0][0x2]) {\n        v3 = address(_pendingBids[varg0]).call().value(_pendingBids[varg0][1]).gas(2300 * !_pendingBids[varg0][1]);\n        require(v3); // checks call status, propagates error data on error\n        _pendingBids[varg0] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingBids[varg0];\n        _pendingBids[varg0][1] = 0;\n        _pendingBids[varg0][2] = 0x0 | ~0xff & _pendingBids[varg0][0x2];\n    }\n    0x279f(msg.sender, _buyPrices[varg0], varg0);\n}\n\nfunction isApprovedForAll(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _isApprovedForAll[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x755db7b3 > v0) {\n            if (0x2b1fd58a > v0) {\n                if (0xd392cd9 > v0) {\n                    if (0x1ffc9a7 == v0) {\n                        supportsInterface(bytes4);\n                    } else if (0x41bb6ff == v0) {\n                        whitelistedCreators(address);\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x81812fc == v0) {\n                        getApproved(uint256);\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    }\n                } else if (0xd392cd9 == v0) {\n                    updateWhitelist(address,bool);\n                } else if (0xeaaf4c8 == v0) {\n                    withdrawBid(uint256);\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x1e9b0f52 == v0) {\n                    setupControlToken(uint256,string,int256[],int256[],int256[],address[]);\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x462399cd > v0) {\n                if (0x2b1fd58a == v0) {\n                    acceptBid(uint256);\n                } else if (0x2f745c59 == v0) {\n                    tokenOfOwnerByIndex(address,uint256);\n                } else if (0x41afca00 == v0) {\n                    grantControlPermission(address);\n                } else if (0x42842e0e == v0) {\n                    safeTransferFrom(address,address,uint256);\n                } else if (0x454a2ab3 == v0) {\n                    bid(uint256);\n                }\n            } else if (0x462399cd == v0) {\n                tokenDidHaveFirstSale(uint256);\n            } else if (0x4f6ccce7 == v0) {\n                tokenByIndex(uint256);\n            } else if (0x556d8628 == v0) {\n                expectedTokenSupply();\n            } else if (0x6352211e == v0) {\n                ownerOf(uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            }\n        } else if (0xb88d4fde > v0) {\n            if (0x98207051 > v0) {\n                if (0x755db7b3 == v0) {\n                    useControlToken(uint256,uint256[],int256[]);\n                } else if (0x8cb6ddcb == v0) {\n                    updateRoyaltyPercentages(uint256,uint256,uint256);\n                } else if (0x8f9f193f == v0) {\n                    updatePlatformAddress(address);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x96bc50b0 == v0) {\n                    getControlToken(uint256);\n                }\n            } else if (0x98207051 == v0) {\n                permissionedControllers(address);\n            } else if (0x98c8103e == v0) {\n                mintArtwork(uint256,string,address[]);\n            } else if (0xa22cb465 == v0) {\n                setApprovalForAll(address,bool);\n            } else if (0xa90d6de3 == v0) {\n                buyPrices(uint256);\n            } else if (0xa94141a1 == v0) {\n                uniqueTokenCreators(uint256,uint256);\n            }\n        } else if (0xd66767ab > v0) {\n            if (0xb88d4fde == v0) {\n                safeTransferFrom(address,address,uint256,bytes);\n            } else if (0xb8c18015 == v0) {\n                platformFirstSalePercentage();\n            } else if (0xbab2d111 == v0) {\n                artistSecondSalePercentage();\n            } else if (0xc87b56dd == v0) {\n                tokenURI(uint256);\n            } else if (0xcf8589b9 == v0) {\n                pendingBids(uint256);\n            }\n        } else if (0xd66767ab == v0) {\n            platformSecondSalePercentage();\n        } else if (0xd91c070c == v0) {\n            makeBuyPrice(uint256,uint256);\n        } else if (0xdbe55e56 == v0) {\n            platformAddress();\n        } else if (0xe66c7f35 == v0) {\n            takeBuyPrice(uint256);\n        } else if (0xe985e9c5 == v0) {\n            isApprovedForAll(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 45.71001148223877,
	"usage": {
		"completion_tokens": 765,
		"prompt_tokens": 12948,
		"total_tokens": 13713
	}
}