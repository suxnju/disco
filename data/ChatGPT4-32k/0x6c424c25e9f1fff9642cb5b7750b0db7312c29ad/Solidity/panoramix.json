{
	"address": "0x6c424c25e9f1fff9642cb5b7750b0db7312c29ad",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a simplified Solidity version of the decompiled code you've provided:\n\n```solidity\n\npragma solidity ^0.5.0;\n\ncontract MyContract {\n\n    mapping (uint8 => bool) private stor0;\n    mapping (address => uint256) private balanceOf;\n    string private name;\n    string private symbol;\n    mapping (uint256 => string) private tokenURI;\n    address private platformAddress;\n    mapping (address => bool) private approval;\n    mapping (address => uint256) private ownerOf;\n    uint256 private totalSupply;\n\n    constructor() public {\n        platformAddress = msg.sender;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return stor0[uint8(interfaceId)];\n    }\n\n    function name() public view returns (string memory) {\n        return name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return symbol;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOf[_owner];\n    }\n\n    function ownerOf(uint256 _tokenId) public view returns (address owner) {\n        return ownerOf[_tokenId];\n    }\n\n    function approve(address _approved, uint256 _tokenId) public {\n        require(msg.sender == ownerOf[_tokenId]);\n        approval[_tokenId] = _approved;\n    }\n\n    function getApproved(uint256 _tokenId) public view returns (address operator) {\n        return approval[_tokenId];\n    }\n\n    function setApprovalForAll(address _operator, bool _approved) public {\n        stor0[uint8(_operator)] = _approved;\n    }\n\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n        return stor0[uint8(_operator)];\n    }\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n        require(msg.sender == _from);\n        require(ownerOf[_tokenId] == _from);\n        require(_to != address(0));\n        ownerOf[_tokenId] = _to;\n        balanceOf[_from] -= 1;\n        balanceOf[_to] += 1;\n    }\n\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {\n        return tokenURI[_tokenId];\n    }\n\n    function mint(address _to, uint256 _tokenId, string memory _tokenURI) public {\n        require(msg.sender == platformAddress);\n        totalSupply += 1;\n        balanceOf[_to] += 1;\n        ownerOf[_tokenId] = _to;\n        tokenURI[_tokenId] = _tokenURI;\n    }\n}\n```\n\nThis is a highly simplified version and may not include all the functions, especially the unknown functions, that are present in the decompiled code. Also, please note that the decompiled code seems to be incomplete and may contain errors. For the best results, it is highly recommended to obtain the original Solidity source code.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472480,
	"id": "chatcmpl-8MurQCPBzJRdpPeTvK6GmpFvYDXx6",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of uint8 at storage 0\n  ownerOf is mapping of addr at storage 1\n  approved is mapping of addr at storage 2\n  balanceOf is mapping of uint256 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  tokenOfOwnerByIndex is array of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  tokenByIndex is array of uint256 at storage 7\n  stor8 is mapping of uint256 at storage 8\n  name is array of uint256 at storage 9\n  symbol is array of uint256 at storage 10\n  tokenURI is array of uint256 at storage 11\n  stor12 is mapping of uint8 at storage 12\n  unknowna94141a1 is array of addr at storage 13\n  stor14 is mapping of struct at storage 14\n  unknowna90d6de3 is mapping of uint256 at storage 15\n  unknowncf8589b9 is mapping of struct at storage 16\n  stor17 is mapping of uint8 at storage 17\n  unknown98207051 is mapping of addr at storage 18\n  unknownb8c18015 is uint256 at storage 19\n  unknownd66767ab is uint256 at storage 20\n  unknownbab2d111 is uint256 at storage 21\n  unknown556d8628 is uint256 at storage 22\n  platformAddress is addr at storage 23\n\ndef supportsInterface(bytes4 _interfaceId): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor0[Mask(32, 224, _interfaceId)])\n\ndef unknown041bb6ff(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor12[_param1])\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef getApproved(uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 32\n  return approved[_tokenId]\n\ndef totalSupply(): # not payable\n  return tokenByIndex.length\n\ndef tokenOfOwnerByIndex(address _owner, uint256 _index): # not payable\n  require calldata.size - 4 >= 64\n  require _index < tokenOfOwnerByIndex[addr(_owner)]\n  return tokenOfOwnerByIndex[addr(_owner)][_index]\n\ndef unknown462399cd(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor17[_param1])\n\ndef tokenByIndex(uint256 _index): # not payable\n  require calldata.size - 4 >= 32\n  require _index < tokenByIndex.length\n  return tokenByIndex[_index]\n\ndef unknown556d8628(): # not payable\n  return unknown556d8628\n\ndef ownerOf(uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[_tokenId]\n  return ownerOf[_tokenId]\n\ndef balanceOf(address _owner): # not payable\n  require calldata.size - 4 >= 32\n  require _owner\n  return balanceOf[addr(_owner)]\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef unknown98207051(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknown98207051[_param1]\n\ndef unknowna90d6de3(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknowna90d6de3[_param1]\n\ndef unknowna94141a1(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param2 < uint256(unknowna94141a1[_param1])\n  return addr(unknowna94141a1[_param1][_param2])\n\ndef unknownb8c18015(): # not payable\n  return unknownb8c18015\n\ndef unknownbab2d111(): # not payable\n  return unknownbab2d111\n\ndef tokenURI(uint256 _tokenId): # not payable\n  return tokenURI[_tokenId][0 len tokenURI[_tokenId].length]\n\ndef unknowncf8589b9(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknowncf8589b9[_param1].field_0, unknowncf8589b9[_param1].field_256, bool(unknowncf8589b9[_param1].field_512)\n\ndef unknownd66767ab(): # not payable\n  return unknownd66767ab\n\ndef platformAddress(): # not payable\n  return platformAddress\n\ndef isApprovedForAll(address _owner, address _operator): # not payable\n  require calldata.size - 4 >= 64\n  return bool(stor4[addr(_owner)][addr(_operator)])\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef unknown41afca00(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  unknown98207051[caller] = _param1\n\ndef unknown8f9f193f(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  require caller == platformAddress\n  platformAddress = _param1\n  log 0xb2903028: _param1\n\ndef updateWhitelist(address _whitelistedAddress, bool _isWhitelisted): # not payable\n  require calldata.size - 4 >= 64\n  require caller == platformAddress\n  stor12[addr(_whitelistedAddress)] = uint8(_isWhitelisted)\n\ndef setApprovalForAll(address _to, bool _approved): # not payable\n  require calldata.size - 4 >= 64\n  require _to != caller\n  stor4[caller][addr(_to)] = uint8(_approved)\n  log ApprovalForAll(\n        address owner=_approved,\n        address operator=caller,\n        bool approved=_to)\n\ndef unknownd91c070c(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[_param1]\n  if ownerOf[_param1] != caller:\n      if approved[_param1] != caller:\n          require stor4[stor1[_param1]][caller]\n  unknowna90d6de3[_param1] = _param2\n  log 0xd765eb1c: _param1, _param2\n\ndef unknown8cb6ddcb(uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require calldata.size - 4 >= 96\n  require caller == platformAddress\n  require _param1 < 100\n  if _param3 + _param2 < _param2:\n      revert with 0, 'SafeMath: addition overflow'\n  require _param3 + _param2 < 100\n  unknownb8c18015 = _param1\n  unknownd66767ab = _param2\n  unknownbab2d111 = _param3\n  log 0xd9469663: _param1, _param2, _param3\n\ndef approve(address _spender, uint256 _value): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[_value]\n  require _spender != ownerOf[_value]\n  if ownerOf[_value] != caller:\n      require stor4[stor1[_value]][caller]\n  approved[_value] = _spender\n  log Approval(\n        address tokenOwner=ownerOf[_value],\n        address spender=_spender,\n        uint256 tokens=_value)\n\ndef withdrawBid(uint256 _editionNumber): # not payable\n  require calldata.size - 4 >= 32\n  require unknowncf8589b9[_editionNumber].field_512\n  require caller == unknowncf8589b9[_editionNumber].field_0\n  call unknowncf8589b9[_editionNumber].field_0 with:\n     value unknowncf8589b9[_editionNumber].field_256 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  unknowncf8589b9[_editionNumber].field_0 = 0\n  unknowncf8589b9[_editionNumber].field_256 = 0\n  unknowncf8589b9[_editionNumber].field_256 = 0\n  unknowncf8589b9[_editionNumber].field_512 = 0\n  log 0x99319fa1: _editionNumber\n\ndef bid(uint256 _assetId) payable: \n  require calldata.size - 4 >= 32\n  require ownerOf[_assetId]\n  require ownerOf[_assetId] != caller\n  require approved[_assetId] != caller\n  require not stor4[stor1[_assetId]][caller]\n  if unknowncf8589b9[_assetId].field_512:\n      if call.value <= unknowncf8589b9[_assetId].field_256:\n          revert with 0, 'Bid must be > than current bid'\n      call unknowncf8589b9[_assetId].field_0 with:\n         value unknowncf8589b9[_assetId].field_256 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n  unknowncf8589b9[_assetId].field_0 = caller\n  unknowncf8589b9[_assetId].field_256 = call.value\n  unknowncf8589b9[_assetId].field_512 = 1\n  log 0xcbf61548: _assetId, call.value, caller\n\ndef transferFrom(address _from, address _to, uint256 _value): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[_value]\n  if ownerOf[_value] != caller:\n      if approved[_value] != caller:\n          require stor4[stor1[_value]][caller]\n  require ownerOf[_value]\n  if ownerOf[_value] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_value]:\n      approved[_value] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_value] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_value)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_value]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_value] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_value]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_value]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_value] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _value\n  unknowna90d6de3[_value] = 0\n\ndef safeTransferFrom(address _from, address _to, uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != caller:\n      if approved[_tokenId] != caller:\n          require stor4[stor1[_tokenId]][caller]\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_tokenId]:\n      approved[_tokenId] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_tokenId] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_tokenId)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_tokenId]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_tokenId] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_tokenId]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_tokenId]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_tokenId] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _tokenId\n  unknowna90d6de3[_tokenId] = 0\n\ndef safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data): # not payable\n  require calldata.size - 4 >= 128\n  require _data <= 4294967296\n  require _data + 36 <= calldata.size\n  require _data.length <= 4294967296 and _data + _data.length + 36 <= calldata.size\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != caller:\n      if approved[_tokenId] != caller:\n          require stor4[stor1[_tokenId]][caller]\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_tokenId]:\n      approved[_tokenId] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_tokenId] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_tokenId)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_tokenId]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_tokenId] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_tokenId]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_tokenId]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_tokenId] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _tokenId\n  unknowna90d6de3[_tokenId] = 0\n\ndef unknown96bc50b0(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  require stor14[_param1].field_256\n  if not stor14[_param1].field_0:\n      idx = 0\n      s = 0\n      while idx < stor14[_param1].field_0:\n          require s < 0\n          mem[(32 * s) + 128] = stor14[_param1][2][idx].field_0\n          if s + 1 < s:\n              revert with 0, 'SafeMath: addition overflow'\n          require s + 1 < 0\n          mem[(32 * s + 1) + 128] = stor14[_param1][2][idx].field_256\n          mem[0] = idx\n          mem[32] = sha3(_param1, 14) + 2\n          require s + 2 < 0\n          mem[(32 * s + 2) + 128] = stor14[_param1][2][idx].field_512\n          idx = idx + 1\n          s = s + 3\n          continue \n      return ''\n  if 3 * stor14[_param1].field_0 / stor14[_param1].field_0 != 3:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  33,\n                  0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                  mem[197 len 31]\n  if 3 * stor14[_param1].field_0:\n      mem[128 len 32 * 3 * stor14[_param1].field_0] = code.data[12988 len 32 * 3 * stor14[_param1].field_0]\n  idx = 0\n  s = 0\n  while idx < stor14[_param1].field_0:\n      require s < 3 * stor14[_param1].field_0\n      mem[(32 * s) + 128] = stor14[_param1][2][idx].field_0\n      if s + 1 < s:\n          revert with 0, 'SafeMath: addition overflow'\n      require s + 1 < 3 * stor14[_param1].field_0\n      mem[(32 * s + 1) + 128] = stor14[_param1][2][idx].field_256\n      mem[0] = idx\n      mem[32] = sha3(_param1, 14) + 2\n      require s + 2 < 3 * stor14[_param1].field_0\n      mem[(32 * s + 2) + 128] = stor14[_param1][2][idx].field_512\n      idx = idx + 1\n      s = s + 3\n      continue \n  mem[(32 * 3 * stor14[_param1].field_0) + 192 len floor32(3 * stor14[_param1].field_0)] = mem[128 len floor32(3 * stor14[_param1].field_0)]\n  return Array(len=3 * stor14[_param1].field_0, data=mem[128 len floor32(3 * stor14[_param1].field_0)], mem[(32 * 3 * stor14[_param1].field_0) + floor32(3 * stor14[_param1].field_0) + 192 len (32 * 3 * stor14[_param1].field_0) - floor32(3 * stor14[_param1].field_0)]), \n\ndef acceptBid(uint256 _editionNumber): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[_editionNumber]\n  if ownerOf[_editionNumber] != caller:\n      if approved[_editionNumber] != caller:\n          require stor4[stor1[_editionNumber]][caller]\n  require unknowncf8589b9[_editionNumber].field_512\n  if stor17[_editionNumber]:\n      if not unknowncf8589b9[_editionNumber].field_256:\n          call platformAddress with:\n               gas 2300 wei\n      else:\n          if unknownd66767ab * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownd66767ab:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          33,\n                          0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                          mem[197 len 31]\n          call platformAddress with:\n             value unknownd66767ab * unknowncf8589b9[_editionNumber].field_256 / 100 wei\n               gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      if unknowncf8589b9[_editionNumber].field_256:\n          if unknownbab2d111 * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownbab2d111:\n              revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]\n      if not uint256(unknowna94141a1[_editionNumber]):\n  else:\n      stor17[_editionNumber] = 1\n      if not unknowncf8589b9[_editionNumber].field_256:\n          call platformAddress with:\n               gas 2300 wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if 0 <= unknowncf8589b9[_editionNumber].field_256:\n              if uint256(unknowna94141a1[_editionNumber]):\n                  if (32 * uint256(unknowna94141a1[_editionNumber])) + 32 <= 64:\n      else:\n          if unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownb8c18015:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          33,\n                          0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                          mem[197 len 31]\n          call platformAddress with:\n             value unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / 100 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / 100 <= unknowncf8589b9[_editionNumber].field_256:\n              if uint256(unknowna94141a1[_editionNumber]):\n                  if (32 * uint256(unknowna94141a1[_editionNumber])) + 32 <= 64:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown98c8103e(uint256 _param1, array _param2, array _param3): # not payable\n  require calldata.size - 4 >= 96\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[_param2.length + 128] = 0\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + 128] = _param3.length\n  mem[ceil32(_param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require 1 == bool(stor12[caller])\n  if _param1 != unknown556d8628:\n      revert with 0, 'ExpectedTokenSupply different'\n  mem[64] = ceil32(_param2.length) + (32 * _param3.length) + 192\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 160] = 0\n  require caller\n  if ownerOf[_param1]:\n      revert with 0, 'token already minted'\n  ownerOf[_param1] = caller\n  balanceOf[caller]++\n  log Transfer(\n        address from=0,\n        address to=caller,\n        uint256 tokens=_param1)\n  stor6[_param1] = tokenOfOwnerByIndex[caller]\n  tokenOfOwnerByIndex[caller]++\n  tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = _param1\n  stor8[_param1] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = _param1\n  unknown556d8628++\n  if not ownerOf[_param1]:\n      revert with 0, 'URI set of nonexistent token'\n  tokenURI[_param1][] = Array(len=_param2.length, data=_param2[all])\n  uint256(unknowna94141a1[_param1])++\n  addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = caller\n  idx = 0\n  while idx < _param3.length:\n      require idx < mem[ceil32(_param2.length) + 128]\n      require mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      unknown556d8628++\n      mem[32] = 13\n      require idx < mem[ceil32(_param2.length) + 128]\n      uint256(unknowna94141a1[stor22])++\n      mem[0] = sha3(unknown556d8628, 13)\n      addr(unknowna94141a1[stor22][uint256(unknowna94141a1[stor22])]) = mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      _272 = mem[64]\n      mem[64] = mem[64] + 96\n      mem[_272] = 0\n      mem[_272 + 32] = 1\n      mem[_272 + 64] = 0\n      mem[0] = unknown556d8628\n      mem[32] = 14\n      stor14[stor22].field_0 = 0\n      stor14[stor22].field_256 = 1\n      stor14[stor22].field_264 = 0\n      stor14[stor22].field_272 = 0\n      require idx < mem[ceil32(_param2.length) + 128]\n      if mem[(32 * idx) + ceil32(_param2.length) + 172 len 20] != caller:\n          s = 0\n          while s < uint256(unknowna94141a1[_param1]):\n              require idx < mem[ceil32(_param2.length) + 128]\n              require s < uint256(unknowna94141a1[_param1])\n              mem[0] = _param1\n              mem[32] = 13\n              if addr(unknowna94141a1[_param1][s]) != mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]:\n                  s = s + 1\n                  continue \n              idx = idx + 1\n              continue \n          mem[32] = 13\n          require idx < mem[ceil32(_param2.length) + 128]\n          uint256(unknowna94141a1[_param1])++\n          mem[0] = sha3(_param1, 13)\n          addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      idx = idx + 1\n      continue \n\ndef unknown755db7b3(uint256 _param1, array _param2, array _param3) payable: \n  require calldata.size - 4 >= 96\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + (32 * _param2.length) + 36 <= calldata.size\n  mem[128 len 32 * _param2.length] = call.data[_param2 + 36 len 32 * _param2.length]\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[(32 * _param2.length) + 128] = _param3.length\n  mem[(32 * _param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require ownerOf[_param1]\n  if ownerOf[_param1] != caller:\n      if approved[_param1] != caller:\n          if not stor4[stor1[_param1]][caller]:\n              require ownerOf[_param1]\n              if unknown98207051[stor1[_param1]] != caller:\n                  revert with 0, 'Owner or permissioned only'\n  mem[(32 * _param2.length) + (32 * _param3.length) + 160] = _param3.length\n  if _param3.length:\n      mem[(32 * _param2.length) + (32 * _param3.length) + 192 len 32 * _param3.length] = code.data[12988 len 32 * _param3.length]\n  idx = 0\n  while idx < _param2.length:\n      require idx < _param2.length\n      mem[0] = mem[(32 * idx) + 128]\n      mem[32] = sha3(_param1, 14) + 2\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] <\u2032 stor14[_param1][2][mem[(32 * idx) + 128]].field_0:\n          revert with 0, 'Invalid val'\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] >\u2032 stor14[_param1][2][mem[(32 * idx) + 128]].field_256:\n          revert with 0, 'Invalid val'\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] == stor14[_param1][2][mem[(32 * idx) + 128]].field_512:\n          revert with 0, 'Must provide different val'\n      require idx < _param3.length\n      stor14[_param1][2][mem[(32 * idx) + 128]].field_512 = mem[(32 * idx) + (32 * _param2.length) + 160]\n      require idx < _param3.length\n      mem[(32 * idx) + (32 * _param2.length) + (32 * _param3.length) + 192] = stor14[_param1][2][mem[(32 * idx) + 128]].field_512\n      idx = idx + 1\n      continue \n  if not call.value:\n      mem[(32 * _param2.length) + (64 * _param3.length) + 192] = _param1\n      mem[(32 * _param2.length) + (64 * _param3.length) + 224] = call.value\n      mem[(32 * _param2.length) + (64 * _param3.length) + 256] = 160\n      mem[(32 * _param2.length) + (64 * _param3.length) + 352] = _param2.length\n      mem[(32 * _param2.length) + (64 * _param3.length) + 384 len floor32(_param2.length)] = call.data[_param2 + 36 len floor32(_param2.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 288] = (32 * _param2.length) + 192\n      mem[(64 * _param2.length) + (64 * _param3.length) + 384] = _param3.length\n      mem[(64 * _param2.length) + (64 * _param3.length) + 416 len floor32(_param3.length)] = mem[(32 * _param2.length) + (32 * _param3.length) + 192 len floor32(_param3.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 320] = (32 * _param3.length) + (32 * _param2.length) + 224\n      mem[(98 * _param3.length) + (64 * _param2.length) + 416] = _param3.length\n      s = 0\n      while _param2.length < 32 * _param3.length:\n          mem[(67 * _param2.length) + (98 * _param3.length) + 448] = mem[(34 * _param2.length) + 160]\n          s = _param2.length + 32\n          continue \n  else:\n      call platformAddress with:\n         value call.value wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 192] = _param1\n      mem[(32 * _param2.length) + (64 * _param3.length) + 224] = call.value\n      mem[(32 * _param2.length) + (64 * _param3.length) + 256] = 160\n      mem[(32 * _param2.length) + (64 * _param3.length) + 352] = _param2.length\n      mem[(32 * _param2.length) + (64 * _param3.length) + 384 len floor32(_param2.length)] = call.data[_param2 + 36 len floor32(_param2.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 288] = (32 * _param2.length) + 192\n      mem[(64 * _param2.length) + (64 * _param3.length) + 384] = _param3.length\n      mem[(64 * _param2.length) + (64 * _param3.length) + 416 len floor32(_param3.length)] = mem[(32 * _param2.length) + (32 * _param3.length) + 192 len floor32(_param3.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 320] = (32 * _param3.length) + (32 * _param2.length) + 224\n      mem[(98 * _param3.length) + (64 * _param2.length) + 416] = _param3.length\n      mem[(98 * _param3.length) + (64 * _param2.length) + 448 len floor32(_param3.length)] = call.data[_param3 + 36 len floor32(_param3.length)]\n  log 0x1864c0e2: mem[(32 * _param2.length) + (64 * _param3.length) + 192 len (162 * _param3.length) + (32 * _param2.length) + 256]\n\ndef unknowne66c7f35(uint256 _param1) payable: \n  require calldata.size - 4 >= 32\n  require ownerOf[_param1]\n  require ownerOf[_param1] != caller\n  require approved[_param1] != caller\n  require not stor4[stor1[_param1]][caller]\n  require unknowna90d6de3[_param1]\n  require call.value >= unknowna90d6de3[_param1]\n  if not unknowncf8589b9[_param1].field_512:\n      if stor17[_param1]:\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n          else:\n              if unknownd66767ab * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownd66767ab:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                              32,\n                              33,\n                              0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                              mem[197 len 31]\n              call platformAddress with:\n                 value unknownd66767ab * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknowna90d6de3[_param1]:\n              if unknownbab2d111 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownbab2d111:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]\n          if not uint256(unknowna94141a1[_param1]):\n      else:\n          stor17[_param1] = 1\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if 0 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n          else:\n              if unknownb8c18015 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownb8c18015:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                              32,\n                              33,\n                              0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                              mem[197 len 31]\n              call platformAddress with:\n                 value unknownb8c18015 * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if unknownb8c18015 * unknowna90d6de3[_param1] / 100 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n  else:\n      call unknowncf8589b9[_param1].field_0 with:\n         value unknowncf8589b9[_param1].field_256 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      unknowncf8589b9[_param1].field_0 = 0\n      unknowncf8589b9[_param1].field_256 = 0\n      unknowncf8589b9[_param1].field_256 = 0\n      unknowncf8589b9[_param1].field_512 = 0\n      if stor17[_param1]:\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n          else:\n              if unknownd66767ab * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownd66767ab:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]\n              call platformAddress with:\n                 value unknownd66767ab * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknowna90d6de3[_param1]:\n              if unknownbab2d111 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownbab2d111:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]\n          if not uint256(unknowna94141a1[_param1]):\n      else:\n          stor17[_param1] = 1\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if 0 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n          else:\n              if unknownb8c18015 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownb8c18015:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]\n              call platformAddress with:\n                 value unknownb8c18015 * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if unknownb8c18015 * unknowna90d6de3[_param1] / 100 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown1e9b0f52(uint256 _param1, array _param2, array _param3, array _param4, array _param5, array _param6): # not payable\n  require calldata.size - 4 >= 192\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[96] = _param2.length\n  mem[128 len _param2.length] = _param2[all]\n  mem[_param2.length + 128] = 0\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + 128] = _param3.length\n  mem[ceil32(_param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require _param4 <= 4294967296\n  require _param4 + 36 <= calldata.size\n  require _param4.length <= 4294967296 and _param4 + (32 * _param4.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 160] = _param4.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 192 len 32 * _param4.length] = call.data[_param4 + 36 len 32 * _param4.length]\n  require _param5 <= 4294967296\n  require _param5 + 36 <= calldata.size\n  require _param5.length <= 4294967296 and _param5 + (32 * _param5.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192] = _param5.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224 len 32 * _param5.length] = call.data[_param5 + 36 len 32 * _param5.length]\n  require _param6 <= 4294967296\n  require _param6 + 36 <= calldata.size\n  require _param6.length <= 4294967296 and _param6 + (32 * _param6.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224] = _param6.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 256 len 32 * _param6.length] = call.data[_param6 + 36 len 32 * _param6.length]\n  if not stor14[_param1].field_256:\n      revert with 0, 'No control token found'\n  if stor14[_param1].field_264:\n      revert with 0, 'Already setup'\n  require uint256(unknowna94141a1[_param1])\n  if addr(unknowna94141a1[_param1]) != caller:\n      revert with 0, 'Must be control token artist'\n  if _param3.length != _param4.length:\n      revert with 0, 'Values array mismatch'\n  if _param4.length != _param5.length:\n      revert with 0, 'Values array mismatch'\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 256] = 0\n  require caller\n  if ownerOf[_param1]:\n      revert with 0, 'token already minted'\n  ownerOf[_param1] = caller\n  balanceOf[caller]++\n  log Transfer(\n        address from=0,\n        address to=caller,\n        uint256 tokens=_param1)\n  stor6[_param1] = tokenOfOwnerByIndex[caller]\n  tokenOfOwnerByIndex[caller]++\n  tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = _param1\n  stor8[_param1] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = _param1\n  if not ownerOf[_param1]:\n      revert with 0, 'URI set of nonexistent token'\n  tokenURI[_param1][] = Array(len=_param2.length, data=_param2[all])\n  mem[64] = ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 384\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 288] = _param5.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 320] = 1\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 352] = 1\n  mem[0] = _param1\n  mem[32] = 14\n  stor14[_param1].field_0 = _param5.length\n  stor14[_param1].field_256 = 1\n  stor14[_param1].field_264 = 1\n  stor14[_param1].field_272 = 0\n  idx = 0\n  while idx < _param5.length:\n      require idx < mem[ceil32(_param2.length) + 128]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192] <\u2032 mem[(32 * idx) + ceil32(_param2.length) + 160]:\n          revert with 0, 'Max val must >= min'\n      require idx < mem[ceil32(_param2.length) + 128]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224] <\u2032 mem[(32 * idx) + ceil32(_param2.length) + 160]:\n          revert with 0, 'Invalid start val'\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224] >\u2032 mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192]:\n          revert with 0, 'Invalid start val'\n      _475 = mem[64]\n      mem[64] = mem[64] + 128\n      require idx < mem[ceil32(_param2.length) + 128]\n      mem[_475] = mem[(32 * idx) + ceil32(_param2.length) + 160]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      mem[_475 + 32] = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      mem[_475 + 64] = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224]\n      mem[_475 + 96] = 1\n      mem[0] = idx\n      mem[32] = sha3(_param1, 14) + 2\n      stor14[_param1][2][idx].field_0 = mem[_475]\n      stor14[_param1][2][idx].field_256 = mem[_475 + 32]\n      stor14[_param1][2][idx].field_512 = mem[_475 + 64]\n      stor14[_param1][2][idx].field_768 = 1\n      idx = idx + 1\n      continue \n  idx = 0\n  while idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]:\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]\n      require mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 268 len 20]\n      mem[32] = 13\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]\n      uint256(unknowna94141a1[_param1])++\n      mem[0] = sha3(_param1, 13)\n      addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 268 len 20]\n      idx = idx + 1\n      continue \n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of uint8 at storage 0\n  ownerOf is mapping of addr at storage 1\n  approved is mapping of addr at storage 2\n  balanceOf is mapping of uint256 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  tokenOfOwnerByIndex is array of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  tokenByIndex is array of uint256 at storage 7\n  stor8 is mapping of uint256 at storage 8\n  name is array of uint256 at storage 9\n  symbol is array of uint256 at storage 10\n  tokenURI is array of uint256 at storage 11\n  stor12 is mapping of uint8 at storage 12\n  unknowna94141a1 is array of addr at storage 13\n  stor14 is mapping of struct at storage 14\n  unknowna90d6de3 is mapping of uint256 at storage 15\n  unknowncf8589b9 is mapping of struct at storage 16\n  stor17 is mapping of uint8 at storage 17\n  unknown98207051 is mapping of addr at storage 18\n  unknownb8c18015 is uint256 at storage 19\n  unknownd66767ab is uint256 at storage 20\n  unknownbab2d111 is uint256 at storage 21\n  unknown556d8628 is uint256 at storage 22\n  platformAddress is addr at storage 23\n\ndef supportsInterface(bytes4 _interfaceId): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor0[Mask(32, 224, _interfaceId)])\n\ndef unknown041bb6ff(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor12[_param1])\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef getApproved(uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 32\n  return approved[_tokenId]\n\ndef totalSupply(): # not payable\n  return tokenByIndex.length\n\ndef tokenOfOwnerByIndex(address _owner, uint256 _index): # not payable\n  require calldata.size - 4 >= 64\n  require _index < tokenOfOwnerByIndex[addr(_owner)]\n  return tokenOfOwnerByIndex[addr(_owner)][_index]\n\ndef unknown462399cd(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor17[_param1])\n\ndef tokenByIndex(uint256 _index): # not payable\n  require calldata.size - 4 >= 32\n  require _index < tokenByIndex.length\n  return tokenByIndex[_index]\n\ndef unknown556d8628(): # not payable\n  return unknown556d8628\n\ndef ownerOf(uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[_tokenId]\n  return ownerOf[_tokenId]\n\ndef balanceOf(address _owner): # not payable\n  require calldata.size - 4 >= 32\n  require _owner\n  return balanceOf[addr(_owner)]\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef unknown98207051(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknown98207051[_param1]\n\ndef unknowna90d6de3(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknowna90d6de3[_param1]\n\ndef unknowna94141a1(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param2 < uint256(unknowna94141a1[_param1])\n  return addr(unknowna94141a1[_param1][_param2])\n\ndef unknownb8c18015(): # not payable\n  return unknownb8c18015\n\ndef unknownbab2d111(): # not payable\n  return unknownbab2d111\n\ndef tokenURI(uint256 _tokenId): # not payable\n  return tokenURI[_tokenId][0 len tokenURI[_tokenId].length]\n\ndef unknowncf8589b9(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknowncf8589b9[_param1].field_0, unknowncf8589b9[_param1].field_256, bool(unknowncf8589b9[_param1].field_512)\n\ndef unknownd66767ab(): # not payable\n  return unknownd66767ab\n\ndef platformAddress(): # not payable\n  return platformAddress\n\ndef isApprovedForAll(address _owner, address _operator): # not payable\n  require calldata.size - 4 >= 64\n  return bool(stor4[addr(_owner)][addr(_operator)])\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef unknown41afca00(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  unknown98207051[caller] = _param1\n\ndef unknown8f9f193f(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  require caller == platformAddress\n  platformAddress = _param1\n  log 0xb2903028: _param1\n\ndef updateWhitelist(address _whitelistedAddress, bool _isWhitelisted): # not payable\n  require calldata.size - 4 >= 64\n  require caller == platformAddress\n  stor12[addr(_whitelistedAddress)] = uint8(_isWhitelisted)\n\ndef setApprovalForAll(address _to, bool _approved): # not payable\n  require calldata.size - 4 >= 64\n  require _to != caller\n  stor4[caller][addr(_to)] = uint8(_approved)\n  log ApprovalForAll(\n        address owner=_approved,\n        address operator=caller,\n        bool approved=_to)\n\ndef unknownd91c070c(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[_param1]\n  if ownerOf[_param1] != caller:\n      if approved[_param1] != caller:\n          require stor4[stor1[_param1]][caller]\n  unknowna90d6de3[_param1] = _param2\n  log 0xd765eb1c: _param1, _param2\n\ndef unknown8cb6ddcb(uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require calldata.size - 4 >= 96\n  require caller == platformAddress\n  require _param1 < 100\n  if _param3 + _param2 < _param2:\n      revert with 0, 'SafeMath: addition overflow'\n  require _param3 + _param2 < 100\n  unknownb8c18015 = _param1\n  unknownd66767ab = _param2\n  unknownbab2d111 = _param3\n  log 0xd9469663: _param1, _param2, _param3\n\ndef approve(address _spender, uint256 _value): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[_value]\n  require _spender != ownerOf[_value]\n  if ownerOf[_value] != caller:\n      require stor4[stor1[_value]][caller]\n  approved[_value] = _spender\n  log Approval(\n        address tokenOwner=ownerOf[_value],\n        address spender=_spender,\n        uint256 tokens=_value)\n\ndef withdrawBid(uint256 _editionNumber): # not payable\n  require calldata.size - 4 >= 32\n  require unknowncf8589b9[_editionNumber].field_512\n  require caller == unknowncf8589b9[_editionNumber].field_0\n  call unknowncf8589b9[_editionNumber].field_0 with:\n     value unknowncf8589b9[_editionNumber].field_256 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  unknowncf8589b9[_editionNumber].field_0 = 0\n  unknowncf8589b9[_editionNumber].field_256 = 0\n  unknowncf8589b9[_editionNumber].field_256 = 0\n  unknowncf8589b9[_editionNumber].field_512 = 0\n  log 0x99319fa1: _editionNumber\n\ndef bid(uint256 _assetId) payable: \n  require calldata.size - 4 >= 32\n  require ownerOf[_assetId]\n  require ownerOf[_assetId] != caller\n  require approved[_assetId] != caller\n  require not stor4[stor1[_assetId]][caller]\n  if unknowncf8589b9[_assetId].field_512:\n      if call.value <= unknowncf8589b9[_assetId].field_256:\n          revert with 0, 'Bid must be > than current bid'\n      call unknowncf8589b9[_assetId].field_0 with:\n         value unknowncf8589b9[_assetId].field_256 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n  unknowncf8589b9[_assetId].field_0 = caller\n  unknowncf8589b9[_assetId].field_256 = call.value\n  unknowncf8589b9[_assetId].field_512 = 1\n  log 0xcbf61548: _assetId, call.value, caller\n\ndef transferFrom(address _from, address _to, uint256 _value): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[_value]\n  if ownerOf[_value] != caller:\n      if approved[_value] != caller:\n          require stor4[stor1[_value]][caller]\n  require ownerOf[_value]\n  if ownerOf[_value] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_value]:\n      approved[_value] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_value] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_value)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_value]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_value] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_value]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_value]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_value] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _value\n  unknowna90d6de3[_value] = 0\n\ndef safeTransferFrom(address _from, address _to, uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != caller:\n      if approved[_tokenId] != caller:\n          require stor4[stor1[_tokenId]][caller]\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_tokenId]:\n      approved[_tokenId] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_tokenId] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_tokenId)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_tokenId]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_tokenId] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_tokenId]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_tokenId]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_tokenId] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _tokenId\n  unknowna90d6de3[_tokenId] = 0\n\ndef safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data): # not payable\n  require calldata.size - 4 >= 128\n  require _data <= 4294967296\n  require _data + 36 <= calldata.size\n  require _data.length <= 4294967296 and _data + _data.length + 36 <= calldata.size\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != caller:\n      if approved[_tokenId] != caller:\n          require stor4[stor1[_tokenId]][caller]\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_tokenId]:\n      approved[_tokenId] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_tokenId] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_tokenId)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_tokenId]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_tokenId] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_tokenId]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_tokenId]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_tokenId] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _tokenId\n  unknowna90d6de3[_tokenId] = 0\n\ndef unknown96bc50b0(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  require stor14[_param1].field_256\n  if not stor14[_param1].field_0:\n      idx = 0\n      s = 0\n      while idx < stor14[_param1].field_0:\n          require s < 0\n          mem[(32 * s) + 128] = stor14[_param1][2][idx].field_0\n          if s + 1 < s:\n              revert with 0, 'SafeMath: addition overflow'\n          require s + 1 < 0\n          mem[(32 * s + 1) + 128] = stor14[_param1][2][idx].field_256\n          mem[0] = idx\n          mem[32] = sha3(_param1, 14) + 2\n          require s + 2 < 0\n          mem[(32 * s + 2) + 128] = stor14[_param1][2][idx].field_512\n          idx = idx + 1\n          s = s + 3\n          continue \n      return ''\n  if 3 * stor14[_param1].field_0 / stor14[_param1].field_0 != 3:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  33,\n                  0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                  mem[197 len 31]\n  if 3 * stor14[_param1].field_0:\n      mem[128 len 32 * 3 * stor14[_param1].field_0] = code.data[12988 len 32 * 3 * stor14[_param1].field_0]\n  idx = 0\n  s = 0\n  while idx < stor14[_param1].field_0:\n      require s < 3 * stor14[_param1].field_0\n      mem[(32 * s) + 128] = stor14[_param1][2][idx].field_0\n      if s + 1 < s:\n          revert with 0, 'SafeMath: addition overflow'\n      require s + 1 < 3 * stor14[_param1].field_0\n      mem[(32 * s + 1) + 128] = stor14[_param1][2][idx].field_256\n      mem[0] = idx\n      mem[32] = sha3(_param1, 14) + 2\n      require s + 2 < 3 * stor14[_param1].field_0\n      mem[(32 * s + 2) + 128] = stor14[_param1][2][idx].field_512\n      idx = idx + 1\n      s = s + 3\n      continue \n  mem[(32 * 3 * stor14[_param1].field_0) + 192 len floor32(3 * stor14[_param1].field_0)] = mem[128 len floor32(3 * stor14[_param1].field_0)]\n  return Array(len=3 * stor14[_param1].field_0, data=mem[128 len floor32(3 * stor14[_param1].field_0)], mem[(32 * 3 * stor14[_param1].field_0) + floor32(3 * stor14[_param1].field_0) + 192 len (32 * 3 * stor14[_param1].field_0) - floor32(3 * stor14[_param1].field_0)]), \n\ndef acceptBid(uint256 _editionNumber): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[_editionNumber]\n  if ownerOf[_editionNumber] != caller:\n      if approved[_editionNumber] != caller:\n          require stor4[stor1[_editionNumber]][caller]\n  require unknowncf8589b9[_editionNumber].field_512\n  if stor17[_editionNumber]:\n      if not unknowncf8589b9[_editionNumber].field_256:\n          call platformAddress with:\n               gas 2300 wei\n      else:\n          if unknownd66767ab * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownd66767ab:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          33,\n                          0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                          mem[197 len 31]\n          call platformAddress with:\n             value unknownd66767ab * unknowncf8589b9[_editionNumber].field_256 / 100 wei\n               gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      if unknowncf8589b9[_editionNumber].field_256:\n          if unknownbab2d111 * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownbab2d111:\n              revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]\n      if not uint256(unknowna94141a1[_editionNumber]):\n  else:\n      stor17[_editionNumber] = 1\n      if not unknowncf8589b9[_editionNumber].field_256:\n          call platformAddress with:\n               gas 2300 wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if 0 <= unknowncf8589b9[_editionNumber].field_256:\n              if uint256(unknowna94141a1[_editionNumber]):\n                  if (32 * uint256(unknowna94141a1[_editionNumber])) + 32 <= 64:\n      else:\n          if unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownb8c18015:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          33,\n                          0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                          mem[197 len 31]\n          call platformAddress with:\n             value unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / 100 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / 100 <= unknowncf8589b9[_editionNumber].field_256:\n              if uint256(unknowna94141a1[_editionNumber]):\n                  if (32 * uint256(unknowna94141a1[_editionNumber])) + 32 <= 64:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown98c8103e(uint256 _param1, array _param2, array _param3): # not payable\n  require calldata.size - 4 >= 96\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[_param2.length + 128] = 0\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + 128] = _param3.length\n  mem[ceil32(_param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require 1 == bool(stor12[caller])\n  if _param1 != unknown556d8628:\n      revert with 0, 'ExpectedTokenSupply different'\n  mem[64] = ceil32(_param2.length) + (32 * _param3.length) + 192\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 160] = 0\n  require caller\n  if ownerOf[_param1]:\n      revert with 0, 'token already minted'\n  ownerOf[_param1] = caller\n  balanceOf[caller]++\n  log Transfer(\n        address from=0,\n        address to=caller,\n        uint256 tokens=_param1)\n  stor6[_param1] = tokenOfOwnerByIndex[caller]\n  tokenOfOwnerByIndex[caller]++\n  tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = _param1\n  stor8[_param1] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = _param1\n  unknown556d8628++\n  if not ownerOf[_param1]:\n      revert with 0, 'URI set of nonexistent token'\n  tokenURI[_param1][] = Array(len=_param2.length, data=_param2[all])\n  uint256(unknowna94141a1[_param1])++\n  addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = caller\n  idx = 0\n  while idx < _param3.length:\n      require idx < mem[ceil32(_param2.length) + 128]\n      require mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      unknown556d8628++\n      mem[32] = 13\n      require idx < mem[ceil32(_param2.length) + 128]\n      uint256(unknowna94141a1[stor22])++\n      mem[0] = sha3(unknown556d8628, 13)\n      addr(unknowna94141a1[stor22][uint256(unknowna94141a1[stor22])]) = mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      _272 = mem[64]\n      mem[64] = mem[64] + 96\n      mem[_272] = 0\n      mem[_272 + 32] = 1\n      mem[_272 + 64] = 0\n      mem[0] = unknown556d8628\n      mem[32] = 14\n      stor14[stor22].field_0 = 0\n      stor14[stor22].field_256 = 1\n      stor14[stor22].field_264 = 0\n      stor14[stor22].field_272 = 0\n      require idx < mem[ceil32(_param2.length) + 128]\n      if mem[(32 * idx) + ceil32(_param2.length) + 172 len 20] != caller:\n          s = 0\n          while s < uint256(unknowna94141a1[_param1]):\n              require idx < mem[ceil32(_param2.length) + 128]\n              require s < uint256(unknowna94141a1[_param1])\n              mem[0] = _param1\n              mem[32] = 13\n              if addr(unknowna94141a1[_param1][s]) != mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]:\n                  s = s + 1\n                  continue \n              idx = idx + 1\n              continue \n          mem[32] = 13\n          require idx < mem[ceil32(_param2.length) + 128]\n          uint256(unknowna94141a1[_param1])++\n          mem[0] = sha3(_param1, 13)\n          addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      idx = idx + 1\n      continue \n\ndef unknown755db7b3(uint256 _param1, array _param2, array _param3) payable: \n  require calldata.size - 4 >= 96\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + (32 * _param2.length) + 36 <= calldata.size\n  mem[128 len 32 * _param2.length] = call.data[_param2 + 36 len 32 * _param2.length]\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[(32 * _param2.length) + 128] = _param3.length\n  mem[(32 * _param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require ownerOf[_param1]\n  if ownerOf[_param1] != caller:\n      if approved[_param1] != caller:\n          if not stor4[stor1[_param1]][caller]:\n              require ownerOf[_param1]\n              if unknown98207051[stor1[_param1]] != caller:\n                  revert with 0, 'Owner or permissioned only'\n  mem[(32 * _param2.length) + (32 * _param3.length) + 160] = _param3.length\n  if _param3.length:\n      mem[(32 * _param2.length) + (32 * _param3.length) + 192 len 32 * _param3.length] = code.data[12988 len 32 * _param3.length]\n  idx = 0\n  while idx < _param2.length:\n      require idx < _param2.length\n      mem[0] = mem[(32 * idx) + 128]\n      mem[32] = sha3(_param1, 14) + 2\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] <\u2032 stor14[_param1][2][mem[(32 * idx) + 128]].field_0:\n          revert with 0, 'Invalid val'\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] >\u2032 stor14[_param1][2][mem[(32 * idx) + 128]].field_256:\n          revert with 0, 'Invalid val'\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] == stor14[_param1][2][mem[(32 * idx) + 128]].field_512:\n          revert with 0, 'Must provide different val'\n      require idx < _param3.length\n      stor14[_param1][2][mem[(32 * idx) + 128]].field_512 = mem[(32 * idx) + (32 * _param2.length) + 160]\n      require idx < _param3.length\n      mem[(32 * idx) + (32 * _param2.length) + (32 * _param3.length) + 192] = stor14[_param1][2][mem[(32 * idx) + 128]].field_512\n      idx = idx + 1\n      continue \n  if not call.value:\n      mem[(32 * _param2.length) + (64 * _param3.length) + 192] = _param1\n      mem[(32 * _param2.length) + (64 * _param3.length) + 224] = call.value\n      mem[(32 * _param2.length) + (64 * _param3.length) + 256] = 160\n      mem[(32 * _param2.length) + (64 * _param3.length) + 352] = _param2.length\n      mem[(32 * _param2.length) + (64 * _param3.length) + 384 len floor32(_param2.length)] = call.data[_param2 + 36 len floor32(_param2.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 288] = (32 * _param2.length) + 192\n      mem[(64 * _param2.length) + (64 * _param3.length) + 384] = _param3.length\n      mem[(64 * _param2.length) + (64 * _param3.length) + 416 len floor32(_param3.length)] = mem[(32 * _param2.length) + (32 * _param3.length) + 192 len floor32(_param3.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 320] = (32 * _param3.length) + (32 * _param2.length) + 224\n      mem[(98 * _param3.length) + (64 * _param2.length) + 416] = _param3.length\n      s = 0\n      while _param2.length < 32 * _param3.length:\n          mem[(67 * _param2.length) + (98 * _param3.length) + 448] = mem[(34 * _param2.length) + 160]\n          s = _param2.length + 32\n          continue \n  else:\n      call platformAddress with:\n         value call.value wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 192] = _param1\n      mem[(32 * _param2.length) + (64 * _param3.length) + 224] = call.value\n      mem[(32 * _param2.length) + (64 * _param3.length) + 256] = 160\n      mem[(32 * _param2.length) + (64 * _param3.length) + 352] = _param2.length\n      mem[(32 * _param2.length) + (64 * _param3.length) + 384 len floor32(_param2.length)] = call.data[_param2 + 36 len floor32(_param2.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 288] = (32 * _param2.length) + 192\n      mem[(64 * _param2.length) + (64 * _param3.length) + 384] = _param3.length\n      mem[(64 * _param2.length) + (64 * _param3.length) + 416 len floor32(_param3.length)] = mem[(32 * _param2.length) + (32 * _param3.length) + 192 len floor32(_param3.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 320] = (32 * _param3.length) + (32 * _param2.length) + 224\n      mem[(98 * _param3.length) + (64 * _param2.length) + 416] = _param3.length\n      mem[(98 * _param3.length) + (64 * _param2.length) + 448 len floor32(_param3.length)] = call.data[_param3 + 36 len floor32(_param3.length)]\n  log 0x1864c0e2: mem[(32 * _param2.length) + (64 * _param3.length) + 192 len (162 * _param3.length) + (32 * _param2.length) + 256]\n\ndef unknowne66c7f35(uint256 _param1) payable: \n  require calldata.size - 4 >= 32\n  require ownerOf[_param1]\n  require ownerOf[_param1] != caller\n  require approved[_param1] != caller\n  require not stor4[stor1[_param1]][caller]\n  require unknowna90d6de3[_param1]\n  require call.value >= unknowna90d6de3[_param1]\n  if not unknowncf8589b9[_param1].field_512:\n      if stor17[_param1]:\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n          else:\n              if unknownd66767ab * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownd66767ab:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                              32,\n                              33,\n                              0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                              mem[197 len 31]\n              call platformAddress with:\n                 value unknownd66767ab * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknowna90d6de3[_param1]:\n              if unknownbab2d111 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownbab2d111:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]\n          if not uint256(unknowna94141a1[_param1]):\n      else:\n          stor17[_param1] = 1\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if 0 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n          else:\n              if unknownb8c18015 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownb8c18015:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                              32,\n                              33,\n                              0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                              mem[197 len 31]\n              call platformAddress with:\n                 value unknownb8c18015 * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if unknownb8c18015 * unknowna90d6de3[_param1] / 100 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n  else:\n      call unknowncf8589b9[_param1].field_0 with:\n         value unknowncf8589b9[_param1].field_256 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      unknowncf8589b9[_param1].field_0 = 0\n      unknowncf8589b9[_param1].field_256 = 0\n      unknowncf8589b9[_param1].field_256 = 0\n      unknowncf8589b9[_param1].field_512 = 0\n      if stor17[_param1]:\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n          else:\n              if unknownd66767ab * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownd66767ab:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]\n              call platformAddress with:\n                 value unknownd66767ab * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknowna90d6de3[_param1]:\n              if unknownbab2d111 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownbab2d111:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]\n          if not uint256(unknowna94141a1[_param1]):\n      else:\n          stor17[_param1] = 1\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if 0 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n          else:\n              if unknownb8c18015 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownb8c18015:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]\n              call platformAddress with:\n                 value unknownb8c18015 * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if unknownb8c18015 * unknowna90d6de3[_param1] / 100 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown1e9b0f52(uint256 _param1, array _param2, array _param3, array _param4, array _param5, array _param6): # not payable\n  require calldata.size - 4 >= 192\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[96] = _param2.length\n  mem[128 len _param2.length] = _param2[all]\n  mem[_param2.length + 128] = 0\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + 128] = _param3.length\n  mem[ceil32(_param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require _param4 <= 4294967296\n  require _param4 + 36 <= calldata.size\n  require _param4.length <= 4294967296 and _param4 + (32 * _param4.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 160] = _param4.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 192 len 32 * _param4.length] = call.data[_param4 + 36 len 32 * _param4.length]\n  require _param5 <= 4294967296\n  require _param5 + 36 <= calldata.size\n  require _param5.length <= 4294967296 and _param5 + (32 * _param5.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192] = _param5.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224 len 32 * _param5.length] = call.data[_param5 + 36 len 32 * _param5.length]\n  require _param6 <= 4294967296\n  require _param6 + 36 <= calldata.size\n  require _param6.length <= 4294967296 and _param6 + (32 * _param6.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224] = _param6.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 256 len 32 * _param6.length] = call.data[_param6 + 36 len 32 * _param6.length]\n  if not stor14[_param1].field_256:\n      revert with 0, 'No control token found'\n  if stor14[_param1].field_264:\n      revert with 0, 'Already setup'\n  require uint256(unknowna94141a1[_param1])\n  if addr(unknowna94141a1[_param1]) != caller:\n      revert with 0, 'Must be control token artist'\n  if _param3.length != _param4.length:\n      revert with 0, 'Values array mismatch'\n  if _param4.length != _param5.length:\n      revert with 0, 'Values array mismatch'\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 256] = 0\n  require caller\n  if ownerOf[_param1]:\n      revert with 0, 'token already minted'\n  ownerOf[_param1] = caller\n  balanceOf[caller]++\n  log Transfer(\n        address from=0,\n        address to=caller,\n        uint256 tokens=_param1)\n  stor6[_param1] = tokenOfOwnerByIndex[caller]\n  tokenOfOwnerByIndex[caller]++\n  tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = _param1\n  stor8[_param1] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = _param1\n  if not ownerOf[_param1]:\n      revert with 0, 'URI set of nonexistent token'\n  tokenURI[_param1][] = Array(len=_param2.length, data=_param2[all])\n  mem[64] = ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 384\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 288] = _param5.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 320] = 1\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 352] = 1\n  mem[0] = _param1\n  mem[32] = 14\n  stor14[_param1].field_0 = _param5.length\n  stor14[_param1].field_256 = 1\n  stor14[_param1].field_264 = 1\n  stor14[_param1].field_272 = 0\n  idx = 0\n  while idx < _param5.length:\n      require idx < mem[ceil32(_param2.length) + 128]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192] <\u2032 mem[(32 * idx) + ceil32(_param2.length) + 160]:\n          revert with 0, 'Max val must >= min'\n      require idx < mem[ceil32(_param2.length) + 128]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224] <\u2032 mem[(32 * idx) + ceil32(_param2.length) + 160]:\n          revert with 0, 'Invalid start val'\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224] >\u2032 mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192]:\n          revert with 0, 'Invalid start val'\n      _475 = mem[64]\n      mem[64] = mem[64] + 128\n      require idx < mem[ceil32(_param2.length) + 128]\n      mem[_475] = mem[(32 * idx) + ceil32(_param2.length) + 160]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      mem[_475 + 32] = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      mem[_475 + 64] = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224]\n      mem[_475 + 96] = 1\n      mem[0] = idx\n      mem[32] = sha3(_param1, 14) + 2\n      stor14[_param1][2][idx].field_0 = mem[_475]\n      stor14[_param1][2][idx].field_256 = mem[_475 + 32]\n      stor14[_param1][2][idx].field_512 = mem[_475 + 64]\n      stor14[_param1][2][idx].field_768 = 1\n      idx = idx + 1\n      continue \n  idx = 0\n  while idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]:\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]\n      require mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 268 len 20]\n      mem[32] = 13\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]\n      uint256(unknowna94141a1[_param1])++\n      mem[0] = sha3(_param1, 13)\n      addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 268 len 20]\n      idx = idx + 1\n      continue \n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of uint8 at storage 0\n  ownerOf is mapping of addr at storage 1\n  approved is mapping of addr at storage 2\n  balanceOf is mapping of uint256 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  tokenOfOwnerByIndex is array of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  tokenByIndex is array of uint256 at storage 7\n  stor8 is mapping of uint256 at storage 8\n  name is array of uint256 at storage 9\n  symbol is array of uint256 at storage 10\n  tokenURI is array of uint256 at storage 11\n  stor12 is mapping of uint8 at storage 12\n  unknowna94141a1 is array of addr at storage 13\n  stor14 is mapping of struct at storage 14\n  unknowna90d6de3 is mapping of uint256 at storage 15\n  unknowncf8589b9 is mapping of struct at storage 16\n  stor17 is mapping of uint8 at storage 17\n  unknown98207051 is mapping of addr at storage 18\n  unknownb8c18015 is uint256 at storage 19\n  unknownd66767ab is uint256 at storage 20\n  unknownbab2d111 is uint256 at storage 21\n  unknown556d8628 is uint256 at storage 22\n  platformAddress is addr at storage 23\n\ndef supportsInterface(bytes4 _interfaceId): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor0[Mask(32, 224, _interfaceId)])\n\ndef unknown041bb6ff(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor12[_param1])\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef getApproved(uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 32\n  return approved[_tokenId]\n\ndef totalSupply(): # not payable\n  return tokenByIndex.length\n\ndef tokenOfOwnerByIndex(address _owner, uint256 _index): # not payable\n  require calldata.size - 4 >= 64\n  require _index < tokenOfOwnerByIndex[addr(_owner)]\n  return tokenOfOwnerByIndex[addr(_owner)][_index]\n\ndef unknown462399cd(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor17[_param1])\n\ndef tokenByIndex(uint256 _index): # not payable\n  require calldata.size - 4 >= 32\n  require _index < tokenByIndex.length\n  return tokenByIndex[_index]\n\ndef unknown556d8628(): # not payable\n  return unknown556d8628\n\ndef ownerOf(uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[_tokenId]\n  return ownerOf[_tokenId]\n\ndef balanceOf(address _owner): # not payable\n  require calldata.size - 4 >= 32\n  require _owner\n  return balanceOf[addr(_owner)]\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef unknown98207051(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknown98207051[_param1]\n\ndef unknowna90d6de3(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknowna90d6de3[_param1]\n\ndef unknowna94141a1(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param2 < uint256(unknowna94141a1[_param1])\n  return addr(unknowna94141a1[_param1][_param2])\n\ndef unknownb8c18015(): # not payable\n  return unknownb8c18015\n\ndef unknownbab2d111(): # not payable\n  return unknownbab2d111\n\ndef tokenURI(uint256 _tokenId): # not payable\n  return tokenURI[_tokenId][0 len tokenURI[_tokenId].length]\n\ndef unknowncf8589b9(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return unknowncf8589b9[_param1].field_0, unknowncf8589b9[_param1].field_256, bool(unknowncf8589b9[_param1].field_512)\n\ndef unknownd66767ab(): # not payable\n  return unknownd66767ab\n\ndef platformAddress(): # not payable\n  return platformAddress\n\ndef isApprovedForAll(address _owner, address _operator): # not payable\n  require calldata.size - 4 >= 64\n  return bool(stor4[addr(_owner)][addr(_operator)])\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef unknown41afca00(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  unknown98207051[caller] = _param1\n\ndef unknown8f9f193f(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  require caller == platformAddress\n  platformAddress = _param1\n  log 0xb2903028: _param1\n\ndef updateWhitelist(address _whitelistedAddress, bool _isWhitelisted): # not payable\n  require calldata.size - 4 >= 64\n  require caller == platformAddress\n  stor12[addr(_whitelistedAddress)] = uint8(_isWhitelisted)\n\ndef setApprovalForAll(address _to, bool _approved): # not payable\n  require calldata.size - 4 >= 64\n  require _to != caller\n  stor4[caller][addr(_to)] = uint8(_approved)\n  log ApprovalForAll(\n        address owner=_approved,\n        address operator=caller,\n        bool approved=_to)\n\ndef unknownd91c070c(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[_param1]\n  if ownerOf[_param1] != caller:\n      if approved[_param1] != caller:\n          require stor4[stor1[_param1]][caller]\n  unknowna90d6de3[_param1] = _param2\n  log 0xd765eb1c: _param1, _param2\n\ndef unknown8cb6ddcb(uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require calldata.size - 4 >= 96\n  require caller == platformAddress\n  require _param1 < 100\n  if _param3 + _param2 < _param2:\n      revert with 0, 'SafeMath: addition overflow'\n  require _param3 + _param2 < 100\n  unknownb8c18015 = _param1\n  unknownd66767ab = _param2\n  unknownbab2d111 = _param3\n  log 0xd9469663: _param1, _param2, _param3\n\ndef approve(address _spender, uint256 _value): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[_value]\n  require _spender != ownerOf[_value]\n  if ownerOf[_value] != caller:\n      require stor4[stor1[_value]][caller]\n  approved[_value] = _spender\n  log Approval(\n        address tokenOwner=ownerOf[_value],\n        address spender=_spender,\n        uint256 tokens=_value)\n\ndef withdrawBid(uint256 _editionNumber): # not payable\n  require calldata.size - 4 >= 32\n  require unknowncf8589b9[_editionNumber].field_512\n  require caller == unknowncf8589b9[_editionNumber].field_0\n  call unknowncf8589b9[_editionNumber].field_0 with:\n     value unknowncf8589b9[_editionNumber].field_256 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  unknowncf8589b9[_editionNumber].field_0 = 0\n  unknowncf8589b9[_editionNumber].field_256 = 0\n  unknowncf8589b9[_editionNumber].field_256 = 0\n  unknowncf8589b9[_editionNumber].field_512 = 0\n  log 0x99319fa1: _editionNumber\n\ndef bid(uint256 _assetId) payable: \n  require calldata.size - 4 >= 32\n  require ownerOf[_assetId]\n  require ownerOf[_assetId] != caller\n  require approved[_assetId] != caller\n  require not stor4[stor1[_assetId]][caller]\n  if unknowncf8589b9[_assetId].field_512:\n      if call.value <= unknowncf8589b9[_assetId].field_256:\n          revert with 0, 'Bid must be > than current bid'\n      call unknowncf8589b9[_assetId].field_0 with:\n         value unknowncf8589b9[_assetId].field_256 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n  unknowncf8589b9[_assetId].field_0 = caller\n  unknowncf8589b9[_assetId].field_256 = call.value\n  unknowncf8589b9[_assetId].field_512 = 1\n  log 0xcbf61548: _assetId, call.value, caller\n\ndef transferFrom(address _from, address _to, uint256 _value): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[_value]\n  if ownerOf[_value] != caller:\n      if approved[_value] != caller:\n          require stor4[stor1[_value]][caller]\n  require ownerOf[_value]\n  if ownerOf[_value] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_value]:\n      approved[_value] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_value] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_value)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_value]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_value] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_value]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_value]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_value] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _value\n  unknowna90d6de3[_value] = 0\n\ndef safeTransferFrom(address _from, address _to, uint256 _tokenId): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != caller:\n      if approved[_tokenId] != caller:\n          require stor4[stor1[_tokenId]][caller]\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_tokenId]:\n      approved[_tokenId] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_tokenId] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_tokenId)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_tokenId]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_tokenId] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_tokenId]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_tokenId]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_tokenId] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _tokenId\n  unknowna90d6de3[_tokenId] = 0\n\ndef safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data): # not payable\n  require calldata.size - 4 >= 128\n  require _data <= 4294967296\n  require _data + 36 <= calldata.size\n  require _data.length <= 4294967296 and _data + _data.length + 36 <= calldata.size\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != caller:\n      if approved[_tokenId] != caller:\n          require stor4[stor1[_tokenId]][caller]\n  require ownerOf[_tokenId]\n  if ownerOf[_tokenId] != _from:\n      revert with 0, 'not owner'\n  require _to\n  if approved[_tokenId]:\n      approved[_tokenId] = 0\n  if 1 > balanceOf[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  balanceOf[addr(_from)]--\n  balanceOf[addr(_to)]++\n  ownerOf[_tokenId] = _to\n  log Transfer(\n        address from=_from,\n        address to=_to,\n        uint256 tokens=_tokenId)\n  if 1 > tokenOfOwnerByIndex[addr(_from)]:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if tokenOfOwnerByIndex[addr(_from)] - 1 != stor6[_tokenId]:\n      require tokenOfOwnerByIndex[addr(_from)] - 1 < tokenOfOwnerByIndex[addr(_from)]\n      require stor6[_tokenId] < tokenOfOwnerByIndex[addr(_from)]\n      tokenOfOwnerByIndex[addr(_from)][stor6[_tokenId]] = tokenOfOwnerByIndex[addr(_from)][tokenOfOwnerByIndex[addr(_from)]]\n      stor6[stor5[addr(_from)][stor5[addr(_from)]]] = stor6[_tokenId]\n  tokenOfOwnerByIndex[addr(_from)]--\n  if tokenOfOwnerByIndex[addr(_from)] > tokenOfOwnerByIndex[addr(_from)] - 1:\n      idx = tokenOfOwnerByIndex[addr(_from)] - 1\n      while tokenOfOwnerByIndex[addr(_from)] > idx:\n          tokenOfOwnerByIndex[addr(_from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[_tokenId] = tokenOfOwnerByIndex[addr(_to)]\n  tokenOfOwnerByIndex[addr(_to)]++\n  tokenOfOwnerByIndex[addr(_to)][tokenOfOwnerByIndex[addr(_to)]] = _tokenId\n  unknowna90d6de3[_tokenId] = 0\n\ndef unknown96bc50b0(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  require stor14[_param1].field_256\n  if not stor14[_param1].field_0:\n      idx = 0\n      s = 0\n      while idx < stor14[_param1].field_0:\n          require s < 0\n          mem[(32 * s) + 128] = stor14[_param1][2][idx].field_0\n          if s + 1 < s:\n              revert with 0, 'SafeMath: addition overflow'\n          require s + 1 < 0\n          mem[(32 * s + 1) + 128] = stor14[_param1][2][idx].field_256\n          mem[0] = idx\n          mem[32] = sha3(_param1, 14) + 2\n          require s + 2 < 0\n          mem[(32 * s + 2) + 128] = stor14[_param1][2][idx].field_512\n          idx = idx + 1\n          s = s + 3\n          continue \n      return ''\n  if 3 * stor14[_param1].field_0 / stor14[_param1].field_0 != 3:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  32,\n                  33,\n                  0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                  mem[197 len 31]\n  if 3 * stor14[_param1].field_0:\n      mem[128 len 32 * 3 * stor14[_param1].field_0] = code.data[12988 len 32 * 3 * stor14[_param1].field_0]\n  idx = 0\n  s = 0\n  while idx < stor14[_param1].field_0:\n      require s < 3 * stor14[_param1].field_0\n      mem[(32 * s) + 128] = stor14[_param1][2][idx].field_0\n      if s + 1 < s:\n          revert with 0, 'SafeMath: addition overflow'\n      require s + 1 < 3 * stor14[_param1].field_0\n      mem[(32 * s + 1) + 128] = stor14[_param1][2][idx].field_256\n      mem[0] = idx\n      mem[32] = sha3(_param1, 14) + 2\n      require s + 2 < 3 * stor14[_param1].field_0\n      mem[(32 * s + 2) + 128] = stor14[_param1][2][idx].field_512\n      idx = idx + 1\n      s = s + 3\n      continue \n  mem[(32 * 3 * stor14[_param1].field_0) + 192 len floor32(3 * stor14[_param1].field_0)] = mem[128 len floor32(3 * stor14[_param1].field_0)]\n  return Array(len=3 * stor14[_param1].field_0, data=mem[128 len floor32(3 * stor14[_param1].field_0)], mem[(32 * 3 * stor14[_param1].field_0) + floor32(3 * stor14[_param1].field_0) + 192 len (32 * 3 * stor14[_param1].field_0) - floor32(3 * stor14[_param1].field_0)]), \n\ndef acceptBid(uint256 _editionNumber): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[_editionNumber]\n  if ownerOf[_editionNumber] != caller:\n      if approved[_editionNumber] != caller:\n          require stor4[stor1[_editionNumber]][caller]\n  require unknowncf8589b9[_editionNumber].field_512\n  if stor17[_editionNumber]:\n      if not unknowncf8589b9[_editionNumber].field_256:\n          call platformAddress with:\n               gas 2300 wei\n      else:\n          if unknownd66767ab * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownd66767ab:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          33,\n                          0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                          mem[197 len 31]\n          call platformAddress with:\n             value unknownd66767ab * unknowncf8589b9[_editionNumber].field_256 / 100 wei\n               gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      if unknowncf8589b9[_editionNumber].field_256:\n          if unknownbab2d111 * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownbab2d111:\n              revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]\n      if not uint256(unknowna94141a1[_editionNumber]):\n  else:\n      stor17[_editionNumber] = 1\n      if not unknowncf8589b9[_editionNumber].field_256:\n          call platformAddress with:\n               gas 2300 wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if 0 <= unknowncf8589b9[_editionNumber].field_256:\n              if uint256(unknowna94141a1[_editionNumber]):\n                  if (32 * uint256(unknowna94141a1[_editionNumber])) + 32 <= 64:\n      else:\n          if unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / unknowncf8589b9[_editionNumber].field_256 != unknownb8c18015:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          33,\n                          0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                          mem[197 len 31]\n          call platformAddress with:\n             value unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / 100 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknownb8c18015 * unknowncf8589b9[_editionNumber].field_256 / 100 <= unknowncf8589b9[_editionNumber].field_256:\n              if uint256(unknowna94141a1[_editionNumber]):\n                  if (32 * uint256(unknowna94141a1[_editionNumber])) + 32 <= 64:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown98c8103e(uint256 _param1, array _param2, array _param3): # not payable\n  require calldata.size - 4 >= 96\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[_param2.length + 128] = 0\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + 128] = _param3.length\n  mem[ceil32(_param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require 1 == bool(stor12[caller])\n  if _param1 != unknown556d8628:\n      revert with 0, 'ExpectedTokenSupply different'\n  mem[64] = ceil32(_param2.length) + (32 * _param3.length) + 192\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 160] = 0\n  require caller\n  if ownerOf[_param1]:\n      revert with 0, 'token already minted'\n  ownerOf[_param1] = caller\n  balanceOf[caller]++\n  log Transfer(\n        address from=0,\n        address to=caller,\n        uint256 tokens=_param1)\n  stor6[_param1] = tokenOfOwnerByIndex[caller]\n  tokenOfOwnerByIndex[caller]++\n  tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = _param1\n  stor8[_param1] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = _param1\n  unknown556d8628++\n  if not ownerOf[_param1]:\n      revert with 0, 'URI set of nonexistent token'\n  tokenURI[_param1][] = Array(len=_param2.length, data=_param2[all])\n  uint256(unknowna94141a1[_param1])++\n  addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = caller\n  idx = 0\n  while idx < _param3.length:\n      require idx < mem[ceil32(_param2.length) + 128]\n      require mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      unknown556d8628++\n      mem[32] = 13\n      require idx < mem[ceil32(_param2.length) + 128]\n      uint256(unknowna94141a1[stor22])++\n      mem[0] = sha3(unknown556d8628, 13)\n      addr(unknowna94141a1[stor22][uint256(unknowna94141a1[stor22])]) = mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      _272 = mem[64]\n      mem[64] = mem[64] + 96\n      mem[_272] = 0\n      mem[_272 + 32] = 1\n      mem[_272 + 64] = 0\n      mem[0] = unknown556d8628\n      mem[32] = 14\n      stor14[stor22].field_0 = 0\n      stor14[stor22].field_256 = 1\n      stor14[stor22].field_264 = 0\n      stor14[stor22].field_272 = 0\n      require idx < mem[ceil32(_param2.length) + 128]\n      if mem[(32 * idx) + ceil32(_param2.length) + 172 len 20] != caller:\n          s = 0\n          while s < uint256(unknowna94141a1[_param1]):\n              require idx < mem[ceil32(_param2.length) + 128]\n              require s < uint256(unknowna94141a1[_param1])\n              mem[0] = _param1\n              mem[32] = 13\n              if addr(unknowna94141a1[_param1][s]) != mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]:\n                  s = s + 1\n                  continue \n              idx = idx + 1\n              continue \n          mem[32] = 13\n          require idx < mem[ceil32(_param2.length) + 128]\n          uint256(unknowna94141a1[_param1])++\n          mem[0] = sha3(_param1, 13)\n          addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = mem[(32 * idx) + ceil32(_param2.length) + 172 len 20]\n      idx = idx + 1\n      continue \n\ndef unknown755db7b3(uint256 _param1, array _param2, array _param3) payable: \n  require calldata.size - 4 >= 96\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + (32 * _param2.length) + 36 <= calldata.size\n  mem[128 len 32 * _param2.length] = call.data[_param2 + 36 len 32 * _param2.length]\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[(32 * _param2.length) + 128] = _param3.length\n  mem[(32 * _param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require ownerOf[_param1]\n  if ownerOf[_param1] != caller:\n      if approved[_param1] != caller:\n          if not stor4[stor1[_param1]][caller]:\n              require ownerOf[_param1]\n              if unknown98207051[stor1[_param1]] != caller:\n                  revert with 0, 'Owner or permissioned only'\n  mem[(32 * _param2.length) + (32 * _param3.length) + 160] = _param3.length\n  if _param3.length:\n      mem[(32 * _param2.length) + (32 * _param3.length) + 192 len 32 * _param3.length] = code.data[12988 len 32 * _param3.length]\n  idx = 0\n  while idx < _param2.length:\n      require idx < _param2.length\n      mem[0] = mem[(32 * idx) + 128]\n      mem[32] = sha3(_param1, 14) + 2\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] <\u2032 stor14[_param1][2][mem[(32 * idx) + 128]].field_0:\n          revert with 0, 'Invalid val'\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] >\u2032 stor14[_param1][2][mem[(32 * idx) + 128]].field_256:\n          revert with 0, 'Invalid val'\n      require idx < _param3.length\n      if mem[(32 * idx) + (32 * _param2.length) + 160] == stor14[_param1][2][mem[(32 * idx) + 128]].field_512:\n          revert with 0, 'Must provide different val'\n      require idx < _param3.length\n      stor14[_param1][2][mem[(32 * idx) + 128]].field_512 = mem[(32 * idx) + (32 * _param2.length) + 160]\n      require idx < _param3.length\n      mem[(32 * idx) + (32 * _param2.length) + (32 * _param3.length) + 192] = stor14[_param1][2][mem[(32 * idx) + 128]].field_512\n      idx = idx + 1\n      continue \n  if not call.value:\n      mem[(32 * _param2.length) + (64 * _param3.length) + 192] = _param1\n      mem[(32 * _param2.length) + (64 * _param3.length) + 224] = call.value\n      mem[(32 * _param2.length) + (64 * _param3.length) + 256] = 160\n      mem[(32 * _param2.length) + (64 * _param3.length) + 352] = _param2.length\n      mem[(32 * _param2.length) + (64 * _param3.length) + 384 len floor32(_param2.length)] = call.data[_param2 + 36 len floor32(_param2.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 288] = (32 * _param2.length) + 192\n      mem[(64 * _param2.length) + (64 * _param3.length) + 384] = _param3.length\n      mem[(64 * _param2.length) + (64 * _param3.length) + 416 len floor32(_param3.length)] = mem[(32 * _param2.length) + (32 * _param3.length) + 192 len floor32(_param3.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 320] = (32 * _param3.length) + (32 * _param2.length) + 224\n      mem[(98 * _param3.length) + (64 * _param2.length) + 416] = _param3.length\n      s = 0\n      while _param2.length < 32 * _param3.length:\n          mem[(67 * _param2.length) + (98 * _param3.length) + 448] = mem[(34 * _param2.length) + 160]\n          s = _param2.length + 32\n          continue \n  else:\n      call platformAddress with:\n         value call.value wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 192] = _param1\n      mem[(32 * _param2.length) + (64 * _param3.length) + 224] = call.value\n      mem[(32 * _param2.length) + (64 * _param3.length) + 256] = 160\n      mem[(32 * _param2.length) + (64 * _param3.length) + 352] = _param2.length\n      mem[(32 * _param2.length) + (64 * _param3.length) + 384 len floor32(_param2.length)] = call.data[_param2 + 36 len floor32(_param2.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 288] = (32 * _param2.length) + 192\n      mem[(64 * _param2.length) + (64 * _param3.length) + 384] = _param3.length\n      mem[(64 * _param2.length) + (64 * _param3.length) + 416 len floor32(_param3.length)] = mem[(32 * _param2.length) + (32 * _param3.length) + 192 len floor32(_param3.length)]\n      mem[(32 * _param2.length) + (64 * _param3.length) + 320] = (32 * _param3.length) + (32 * _param2.length) + 224\n      mem[(98 * _param3.length) + (64 * _param2.length) + 416] = _param3.length\n      mem[(98 * _param3.length) + (64 * _param2.length) + 448 len floor32(_param3.length)] = call.data[_param3 + 36 len floor32(_param3.length)]\n  log 0x1864c0e2: mem[(32 * _param2.length) + (64 * _param3.length) + 192 len (162 * _param3.length) + (32 * _param2.length) + 256]\n\ndef unknowne66c7f35(uint256 _param1) payable: \n  require calldata.size - 4 >= 32\n  require ownerOf[_param1]\n  require ownerOf[_param1] != caller\n  require approved[_param1] != caller\n  require not stor4[stor1[_param1]][caller]\n  require unknowna90d6de3[_param1]\n  require call.value >= unknowna90d6de3[_param1]\n  if not unknowncf8589b9[_param1].field_512:\n      if stor17[_param1]:\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n          else:\n              if unknownd66767ab * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownd66767ab:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                              32,\n                              33,\n                              0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                              mem[197 len 31]\n              call platformAddress with:\n                 value unknownd66767ab * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknowna90d6de3[_param1]:\n              if unknownbab2d111 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownbab2d111:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]\n          if not uint256(unknowna94141a1[_param1]):\n      else:\n          stor17[_param1] = 1\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if 0 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n          else:\n              if unknownb8c18015 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownb8c18015:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                              32,\n                              33,\n                              0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,\n                              mem[197 len 31]\n              call platformAddress with:\n                 value unknownb8c18015 * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if unknownb8c18015 * unknowna90d6de3[_param1] / 100 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n  else:\n      call unknowncf8589b9[_param1].field_0 with:\n         value unknowncf8589b9[_param1].field_256 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      unknowncf8589b9[_param1].field_0 = 0\n      unknowncf8589b9[_param1].field_256 = 0\n      unknowncf8589b9[_param1].field_256 = 0\n      unknowncf8589b9[_param1].field_512 = 0\n      if stor17[_param1]:\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n          else:\n              if unknownd66767ab * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownd66767ab:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]\n              call platformAddress with:\n                 value unknownd66767ab * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if unknowna90d6de3[_param1]:\n              if unknownbab2d111 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownbab2d111:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[357 len 31]\n          if not uint256(unknowna94141a1[_param1]):\n      else:\n          stor17[_param1] = 1\n          if not unknowna90d6de3[_param1]:\n              call platformAddress with:\n                   gas 2300 wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if 0 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n          else:\n              if unknownb8c18015 * unknowna90d6de3[_param1] / unknowna90d6de3[_param1] != unknownb8c18015:\n                  revert with 0, 32, 33, 0xfe536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[293 len 31]\n              call platformAddress with:\n                 value unknownb8c18015 * unknowna90d6de3[_param1] / 100 wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if unknownb8c18015 * unknowna90d6de3[_param1] / 100 <= unknowna90d6de3[_param1]:\n                  if uint256(unknowna94141a1[_param1]):\n                      if (32 * uint256(unknowna94141a1[_param1])) + 32 <= 64:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown1e9b0f52(uint256 _param1, array _param2, array _param3, array _param4, array _param5, array _param6): # not payable\n  require calldata.size - 4 >= 192\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[96] = _param2.length\n  mem[128 len _param2.length] = _param2[all]\n  mem[_param2.length + 128] = 0\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + (32 * _param3.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + 128] = _param3.length\n  mem[ceil32(_param2.length) + 160 len 32 * _param3.length] = call.data[_param3 + 36 len 32 * _param3.length]\n  require _param4 <= 4294967296\n  require _param4 + 36 <= calldata.size\n  require _param4.length <= 4294967296 and _param4 + (32 * _param4.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 160] = _param4.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + 192 len 32 * _param4.length] = call.data[_param4 + 36 len 32 * _param4.length]\n  require _param5 <= 4294967296\n  require _param5 + 36 <= calldata.size\n  require _param5.length <= 4294967296 and _param5 + (32 * _param5.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192] = _param5.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224 len 32 * _param5.length] = call.data[_param5 + 36 len 32 * _param5.length]\n  require _param6 <= 4294967296\n  require _param6 + 36 <= calldata.size\n  require _param6.length <= 4294967296 and _param6 + (32 * _param6.length) + 36 <= calldata.size\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224] = _param6.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 256 len 32 * _param6.length] = call.data[_param6 + 36 len 32 * _param6.length]\n  if not stor14[_param1].field_256:\n      revert with 0, 'No control token found'\n  if stor14[_param1].field_264:\n      revert with 0, 'Already setup'\n  require uint256(unknowna94141a1[_param1])\n  if addr(unknowna94141a1[_param1]) != caller:\n      revert with 0, 'Must be control token artist'\n  if _param3.length != _param4.length:\n      revert with 0, 'Values array mismatch'\n  if _param4.length != _param5.length:\n      revert with 0, 'Values array mismatch'\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 256] = 0\n  require caller\n  if ownerOf[_param1]:\n      revert with 0, 'token already minted'\n  ownerOf[_param1] = caller\n  balanceOf[caller]++\n  log Transfer(\n        address from=0,\n        address to=caller,\n        uint256 tokens=_param1)\n  stor6[_param1] = tokenOfOwnerByIndex[caller]\n  tokenOfOwnerByIndex[caller]++\n  tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = _param1\n  stor8[_param1] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = _param1\n  if not ownerOf[_param1]:\n      revert with 0, 'URI set of nonexistent token'\n  tokenURI[_param1][] = Array(len=_param2.length, data=_param2[all])\n  mem[64] = ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 384\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 288] = _param5.length\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 320] = 1\n  mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + (32 * _param6.length) + 352] = 1\n  mem[0] = _param1\n  mem[32] = 14\n  stor14[_param1].field_0 = _param5.length\n  stor14[_param1].field_256 = 1\n  stor14[_param1].field_264 = 1\n  stor14[_param1].field_272 = 0\n  idx = 0\n  while idx < _param5.length:\n      require idx < mem[ceil32(_param2.length) + 128]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192] <\u2032 mem[(32 * idx) + ceil32(_param2.length) + 160]:\n          revert with 0, 'Max val must >= min'\n      require idx < mem[ceil32(_param2.length) + 128]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224] <\u2032 mem[(32 * idx) + ceil32(_param2.length) + 160]:\n          revert with 0, 'Invalid start val'\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      if mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224] >\u2032 mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192]:\n          revert with 0, 'Invalid start val'\n      _475 = mem[64]\n      mem[64] = mem[64] + 128\n      require idx < mem[ceil32(_param2.length) + 128]\n      mem[_475] = mem[(32 * idx) + ceil32(_param2.length) + 160]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + 160]\n      mem[_475 + 32] = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + 192]\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 192]\n      mem[_475 + 64] = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + 224]\n      mem[_475 + 96] = 1\n      mem[0] = idx\n      mem[32] = sha3(_param1, 14) + 2\n      stor14[_param1][2][idx].field_0 = mem[_475]\n      stor14[_param1][2][idx].field_256 = mem[_475 + 32]\n      stor14[_param1][2][idx].field_512 = mem[_475 + 64]\n      stor14[_param1][2][idx].field_768 = 1\n      idx = idx + 1\n      continue \n  idx = 0\n  while idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]:\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]\n      require mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 268 len 20]\n      mem[32] = 13\n      require idx < mem[ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 224]\n      uint256(unknowna94141a1[_param1])++\n      mem[0] = sha3(_param1, 13)\n      addr(unknowna94141a1[_param1][uint256(unknowna94141a1[_param1])]) = mem[(32 * idx) + ceil32(_param2.length) + (32 * _param3.length) + (32 * _param4.length) + (32 * _param5.length) + 268 len 20]\n      idx = idx + 1\n      continue \n\n.",
	"status": "1",
	"time_cost": 39.98135948181152,
	"usage": {
		"completion_tokens": 628,
		"prompt_tokens": 12540,
		"total_tokens": 13168
	}
}