{
	"address": "0x6822aaf4ab22e6cca8352a927b9ae0a8fdb58d9d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code contract for the provided decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Contract {\n    mapping (address => uint256) public balanceOf;\n    mapping (uint256 => bool) public claimedDividends;\n    mapping (uint256 => uint256) public dividends;\n    uint256 public recycleTime;\n    address public owner;\n    uint256 public miniMeToken;\n    uint256 public RECYCLE_TIME;\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address newOwner) public {\n        require(msg.sender == owner);\n        owner = newOwner;\n    }\n    \n    function depositDividend() payable public {\n        require(balanceOf[msg.sender] > 0);\n        dividends[block.number] = msg.value;\n    }\n    \n    function claimDividend(uint256 blockNumber) public {\n        require(!claimedDividends[blockNumber]);\n        require(dividends[blockNumber] > 0);\n        uint256 amount = dividends[blockNumber] * balanceOf[msg.sender] / miniMeToken;\n        balanceOf[msg.sender] -= amount;\n        claimedDividends[blockNumber] = true;\n        msg.sender.transfer(amount);\n    }\n    \n    function recycleDividend(uint256 blockNumber) public {\n        require(block.timestamp > blockNumber + recycleTime);\n        require(!claimedDividends[blockNumber]);\n        require(dividends[blockNumber] > 0);\n        miniMeToken += dividends[blockNumber];\n        dividends[blockNumber] = 0;\n    }\n    \n    function claimDividendAll() public {\n        for(uint256 i = 0; i < block.number; i++){\n            if(claimedDividends[i] == false && dividends[i] > 0){\n                claimDividend(i);\n            }\n        }\n    }\n}\n```\n\nPlease note: \n\nThis code is an interpretation of the decompiled code. The actual functionality may differ based on the implementation details which are not visible in the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471892,
	"id": "chatcmpl-8Muhwg3y1FumBOoeP103JXqvgMEch",
	"input_format": "DecompiledCode",
	"ir": "contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { assert(); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x02 ** 0xe0 & 0xffffffff;\n    \n        if (var0 == 0x22c9427e) {\n            // Dispatch table entry for recycleDividend(uint256)\n            if (msg.value) { assert(); }\n        \n            var var1 = 0x0092;\n            var var2 = msg.data[0x04:0x24];\n            recycleDividend(var2);\n            stop();\n        } else if (var0 == 0x30e1f16f) {\n            // Dispatch table entry for claimDividendAll()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            claimDividendAll();\n            stop();\n        } else if (var0 == 0x6423b5f0) {\n            // Dispatch table entry for miniMeToken()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00b6;\n            var2 = miniMeToken();\n        \n        label_00B6:\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + temp0 - temp1 + 0x20];\n        } else if (var0 == 0x7c1a35d7) {\n            // Dispatch table entry for RECYCLE_TIME()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00e2;\n            var2 = RECYCLE_TIME();\n            var temp2 = memory[0x40:0x60];\n            memory[temp2:temp2 + 0x20] = var2;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + temp2 - temp3 + 0x20];\n        } else if (var0 == 0x814b3fe0) {\n            // Dispatch table entry for dividends(uint256)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0107;\n            var2 = msg.data[0x04:0x24];\n            var var3;\n            var var4;\n            var var5;\n            var var6;\n            var var7;\n            var2, var3, var4, var5, var6, var7 = dividends(var2);\n            var temp4 = memory[0x40:0x60];\n            memory[temp4:temp4 + 0x20] = var2;\n            memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var3;\n            memory[temp4 + 0x40:temp4 + 0x40 + 0x20] = var4;\n            memory[temp4 + 0x60:temp4 + 0x60 + 0x20] = var5;\n            memory[temp4 + 0x80:temp4 + 0x80 + 0x20] = var6;\n            memory[temp4 + 0xa0:temp4 + 0xa0 + 0x20] = !!var7;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + temp4 - temp5 + 0xc0];\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00b6;\n            var2 = owner();\n            goto label_00B6;\n        } else if (var0 == 0x9abd3572) {\n            // Dispatch table entry for claimDividend(uint256)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            var2 = msg.data[0x04:0x24];\n            claimDividend(var2);\n            stop();\n        } else if (var0 == 0xa289d187) {\n            // Dispatch table entry for depositDividend()\n            var1 = 0x0092;\n            var2 = 0x00;\n            var3 = var2;\n            var4 = var3;\n            var temp6 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[var4] & temp6 != temp6 & msg.sender) { revert(memory[0x00:0x00]); }\n        \n            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n            var temp7 = memory[0x40:0x60];\n            memory[temp7:temp7 + 0x20] = 0x0981b24d * 0x02 ** 0xe4;\n            memory[temp7 + 0x04:temp7 + 0x04 + 0x20] = block.number;\n            var var9 = memory[0x40:0x60];\n            var5 = storage[0x01] & 0x02 ** 0xa0 - 0x01;\n            var6 = 0x981b24d0;\n            var7 = temp7 + 0x24;\n            var var8 = 0x20;\n            var var10 = temp7 - var9 + 0x24;\n            var var11 = var9;\n            var var12 = 0x00;\n            var var13 = var5;\n        \n            if (!address(var13).code.length) { assert(); }\n        \n            var temp8;\n            temp8, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n        \n            if (!temp8) { assert(); }\n        \n            var2 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n            var3 = storage[0x03];\n            var5 = 0x07e8;\n            var6 = block.number;\n            var7 = 0x01;\n            var5 = func_093B(var6, var7);\n            var4 = var5;\n            var5 = 0x03;\n            var6 = storage[var5];\n            var7 = var6 + 0x01;\n            var8 = 0x07fe;\n            var10 = var7;\n            var9 = var5;\n            func_09B8(var9, var10);\n            var temp9 = var5;\n            var5 = var7;\n            memory[0x00:0x20] = temp9;\n            var6 = var6 * 0x07 + keccak256(memory[0x00:0x20]);\n            var7 = 0x00;\n            var temp10 = memory[0x40:0x60];\n            var8 = temp10;\n            memory[0x40:0x60] = var8 + 0xc0;\n            memory[var8:var8 + 0x20] = var4;\n            var9 = var8 + 0x20;\n            var10 = 0x0829;\n            var10 = func_0936();\n            var temp11 = var9;\n            memory[temp11:temp11 + 0x20] = var10;\n            var temp12 = msg.value;\n            memory[temp11 + 0x20:temp11 + 0x20 + 0x20] = temp12;\n            memory[temp11 + 0x40:temp11 + 0x40 + 0x20] = 0x00;\n            var temp13 = var2;\n            memory[temp11 + 0x60:temp11 + 0x60 + 0x20] = temp13;\n            memory[temp11 + 0x80:temp11 + 0x80 + 0x20] = 0x00;\n            var temp14 = var8;\n            var temp15 = var6;\n            storage[temp15] = memory[temp14:temp14 + 0x20];\n            storage[temp15 + 0x01] = memory[temp14 + 0x20:temp14 + 0x20 + 0x20];\n            storage[temp15 + 0x02] = memory[temp14 + 0x40:temp14 + 0x40 + 0x20];\n            storage[temp15 + 0x03] = memory[temp14 + 0x60:temp14 + 0x60 + 0x20];\n            storage[temp15 + 0x04] = memory[temp14 + 0x80:temp14 + 0x80 + 0x20];\n            var temp16 = temp15 + 0x05;\n            storage[temp16] = !!memory[temp14 + 0xa0:temp14 + 0xa0 + 0x20] | (storage[temp16] & ~0xff);\n            var temp17 = memory[0x40:0x60];\n            memory[temp17:temp17 + 0x20] = var4;\n            memory[temp17 + 0x20:temp17 + 0x20 + 0x20] = temp12;\n            memory[temp17 + 0x40:temp17 + 0x40 + 0x20] = temp13;\n            memory[temp17 + 0x60:temp17 + 0x60 + 0x20] = var3;\n            var temp18 = memory[0x40:0x60];\n            log(memory[temp18:temp18 + temp17 - temp18 + 0x80], [0xcbf89ed8b63aa0a8f6e744e4023554f41dc830838d138eb2d4099cbcfe4a0831, msg.sender]);\n            // Error: Could not resolve jump destination!\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else { assert(); }\n    }\n    \n    function recycleDividend(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = var2;\n        var var4 = var3;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var4] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var5 = arg0;\n    \n        if (var5 >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        var var6 = 0x03;\n        var var7 = arg0;\n    \n        if (var7 >= storage[var6]) { assert(); }\n    \n        memory[0x00:0x20] = var6;\n        var0 = var7 * 0x07 + keccak256(memory[0x00:0x20]);\n    \n        if (storage[var0 + 0x05] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var6 = 0x0224;\n        var7 = 0x021c;\n        var7 = func_0936();\n        var6 = func_021C(var7);\n    \n        if (storage[var0 + 0x01] >= var6) { revert(memory[0x00:0x00]); }\n    \n        var6 = 0x01;\n        var7 = 0x03;\n        var var8 = arg0;\n    \n        if (var8 >= storage[var7]) { assert(); }\n    \n        memory[0x00:0x20] = var7;\n        var temp1 = var8 * 0x07 + keccak256(memory[0x00:0x20]) + 0x05;\n        storage[temp1] = !!var6 | (storage[temp1] & ~0xff);\n        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = 0x0981b24d * 0x02 ** 0xe4;\n        memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = block.number;\n        var var10 = memory[0x40:0x60];\n        var6 = storage[0x01] & 0x02 ** 0xa0 - 0x01;\n        var7 = 0x981b24d0;\n        var8 = temp2 + 0x24;\n        var var9 = 0x20;\n        var var11 = temp2 - var10 + 0x24;\n        var var13 = 0x00;\n        var var12 = var10;\n        var var14 = var6;\n    \n        if (!address(var14).code.length) { assert(); }\n    \n        var temp3;\n        temp3, memory[var10:var10 + var9] = address(var14).call.gas(msg.gas - 0x02c6).value(var13)(memory[var12:var12 + var11]);\n    \n        if (!temp3) { assert(); }\n    \n        var1 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n        var6 = 0x02e9;\n        var temp4 = var0;\n        var7 = storage[temp4 + 0x02];\n        var8 = storage[temp4 + 0x03];\n        var6 = func_093B(var7, var8);\n        var2 = var6;\n        var3 = storage[0x03];\n        var6 = 0x02fc;\n        var7 = block.number;\n        var8 = 0x01;\n        var6 = func_093B(var7, var8);\n        var4 = var6;\n        var6 = 0x03;\n        var7 = storage[var6];\n        var8 = var7 + 0x01;\n        var9 = 0x0312;\n        var11 = var8;\n        var10 = var6;\n        func_09B8(var10, var11);\n        var temp5 = var6;\n        var6 = var8;\n        memory[0x00:0x20] = temp5;\n        var7 = var7 * 0x07 + keccak256(memory[0x00:0x20]);\n        var8 = 0x00;\n        var temp6 = memory[0x40:0x60];\n        var9 = temp6;\n        memory[0x40:0x60] = var9 + 0xc0;\n        memory[var9:var9 + 0x20] = var4;\n        var10 = var9 + 0x20;\n        var11 = 0x033d;\n        var11 = func_0936();\n        var temp7 = var10;\n        memory[temp7:temp7 + 0x20] = var11;\n        var temp8 = var2;\n        memory[temp7 + 0x20:temp7 + 0x20 + 0x20] = temp8;\n        memory[temp7 + 0x40:temp7 + 0x40 + 0x20] = 0x00;\n        var temp9 = var1;\n        memory[temp7 + 0x60:temp7 + 0x60 + 0x20] = temp9;\n        memory[temp7 + 0x80:temp7 + 0x80 + 0x20] = 0x00;\n        var temp10 = var9;\n        var temp11 = var7;\n        storage[temp11] = memory[temp10:temp10 + 0x20];\n        storage[temp11 + 0x01] = memory[temp10 + 0x20:temp10 + 0x20 + 0x20];\n        storage[temp11 + 0x02] = memory[temp10 + 0x40:temp10 + 0x40 + 0x20];\n        storage[temp11 + 0x03] = memory[temp10 + 0x60:temp10 + 0x60 + 0x20];\n        storage[temp11 + 0x04] = memory[temp10 + 0x80:temp10 + 0x80 + 0x20];\n        var temp12 = temp11 + 0x05;\n        storage[temp12] = !!memory[temp10 + 0xa0:temp10 + 0xa0 + 0x20] | (storage[temp12] & ~0xff);\n        var temp13 = memory[0x40:0x60];\n        memory[temp13:temp13 + 0x20] = var4;\n        memory[temp13 + 0x20:temp13 + 0x20 + 0x20] = temp8;\n        memory[temp13 + 0x40:temp13 + 0x40 + 0x20] = temp9;\n        memory[temp13 + 0x60:temp13 + 0x60 + 0x20] = var3;\n        var temp14 = memory[0x40:0x60];\n        log(memory[temp14:temp14 + temp13 - temp14 + 0x80], [0x820e5e0bd7a055839c0210e84ddba311de47df61f9c489947f436bcf0f302ff1, msg.sender]);\n    }\n    \n    function func_021C(var arg0) returns (var r0) {\n        var var0 = storage[0x02];\n        r0 = func_093B(arg0, var0);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function claimDividendAll() {\n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x04;\n        var var0 = 0x00;\n    \n        if (storage[keccak256(memory[var0:var0 + 0x40])] >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x04;\n        var0 = storage[keccak256(memory[0x00:0x40])];\n    \n        if (var0 >= storage[0x03]) {\n        label_04FD:\n            return;\n        } else {\n        label_0451:\n            var var1 = 0x03;\n            var var2 = var0;\n        \n            if (var2 >= storage[var1]) { assert(); }\n        \n            memory[0x00:0x20] = var1;\n            var temp0 = var2 * 0x07 + keccak256(memory[0x00:0x20]);\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = temp0 + 0x06;\n            var1 = !(storage[keccak256(memory[0x00:0x40])] & 0xff);\n        \n            if (!var1) {\n            label_04C1:\n            \n                if (!var1) {\n                label_04F3:\n                    var0 = var0 + 0x01;\n                \n                    if (var0 >= storage[0x03]) { goto label_04FD; }\n                    else { goto label_0451; }\n                } else {\n                    var1 = 0x04d1;\n                    var2 = var0;\n                    var var3 = 0x01;\n                    var1 = func_0952(var2, var3);\n                    memory[0x00:0x20] = msg.sender;\n                    memory[0x20:0x40] = 0x04;\n                    storage[keccak256(memory[0x00:0x40])] = var1;\n                    var1 = 0x04f3;\n                    var2 = var0;\n                    claimDividend(var2);\n                    goto label_04F3;\n                }\n            } else {\n                var1 = 0x03;\n                var2 = var0;\n            \n                if (var2 >= storage[var1]) { assert(); }\n            \n                memory[0x00:0x20] = var1;\n                var1 = !(storage[var2 * 0x07 + keccak256(memory[0x00:0x20]) + 0x05] & 0xff);\n                goto label_04C1;\n            }\n        }\n    }\n    \n    function miniMeToken() returns (var r0) { return storage[0x01] & 0x02 ** 0xa0 - 0x01; }\n    \n    function RECYCLE_TIME() returns (var r0) { return storage[0x02]; }\n    \n    function dividends(var arg0) returns (var arg0, var r1, var r2, var r3, var r4, var r5) {\n        r1 = 0x03;\n        r2 = arg0;\n    \n        if (r2 >= storage[r1]) { assert(); }\n    \n        memory[0x00:0x20] = r1;\n        var temp0 = r2 * 0x07 + keccak256(memory[0x00:0x20]);\n        arg0 = storage[temp0];\n        r3 = storage[temp0 + 0x03];\n        r1 = storage[temp0 + 0x01];\n        r4 = storage[temp0 + 0x04];\n        r2 = storage[temp0 + 0x02];\n        r5 = storage[temp0 + 0x05] & 0xff;\n        return arg0, r1, r2, r3, r4, r5;\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function claimDividend(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = arg0;\n    \n        if (var3 >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        var var4 = 0x03;\n        var var5 = arg0;\n    \n        if (var5 >= storage[var4]) { assert(); }\n    \n        memory[0x00:0x20] = var4;\n        var temp0 = var5 * 0x07 + keccak256(memory[0x00:0x20]);\n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = temp0 + 0x06;\n        var0 = temp0;\n    \n        if (storage[keccak256(memory[0x00:0x40])] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        if (storage[var0 + 0x05] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var var7 = 0x20;\n        memory[var7 + memory[0x40:0x60]:var7 + memory[0x40:0x60] + 0x20] = 0x00;\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = 0x277166bf * 0x02 ** 0xe1;\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = temp2 & msg.sender;\n        memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = storage[var0];\n        var4 = storage[0x01] & temp2;\n        var5 = 0x4ee2cd7e;\n        var var6 = temp1 + 0x44;\n        var var8 = memory[0x40:0x60];\n        var var9 = temp1 - var8 + 0x44;\n        var var10 = var8;\n        var var11 = 0x00;\n        var var12 = var4;\n    \n        if (!address(var12).code.length) { assert(); }\n    \n        var temp3;\n        temp3, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n    \n        if (!temp3) { assert(); }\n    \n        var temp4 = var0;\n        var1 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n        var4 = 0x068b;\n        var5 = storage[temp4 + 0x04];\n        var6 = 0x067f;\n        var8 = storage[temp4 + 0x02];\n        var7 = var1;\n        var6 = func_096C(var7, var8);\n        var4 = func_067F(var5, var6);\n        memory[0x00:0x20] = msg.sender;\n        var temp5 = var0;\n        memory[0x20:0x40] = temp5 + 0x06;\n        var temp6 = keccak256(memory[0x00:0x40]);\n        storage[temp6] = (storage[temp6] & ~0xff) | 0x01;\n        var temp7 = var4;\n        var2 = temp7;\n        var5 = storage[temp5 + 0x03];\n        var4 = 0x06c2;\n        var6 = var2;\n        var4 = func_0952(var5, var6);\n        storage[var0 + 0x03] = var4;\n    \n        if (var2 <= 0x00) {\n        label_0741:\n            return;\n        } else {\n            var temp8 = memory[0x40:0x60];\n            var temp9 = var2;\n            var temp10;\n            temp10, memory[temp8:temp8 + 0x00] = address(msg.sender).call.gas(!temp9 * 0x08fc).value(temp9)(memory[temp8:temp8 + 0x00]);\n        \n            if (!temp10) { assert(); }\n        \n            var temp11 = memory[0x40:0x60];\n            memory[temp11:temp11 + 0x20] = arg0;\n            memory[temp11 + 0x20:temp11 + 0x20 + 0x20] = var2;\n            var temp12 = memory[0x40:0x60];\n            log(memory[temp12:temp12 + temp11 - temp12 + 0x40], [0xa1c93169468f71ef26f4adf10bca8df21460f11843a01ed9c69da306e33c3847, msg.sender]);\n            goto label_0741;\n        }\n    }\n    \n    function func_067F(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = arg1;\n        arg1 = temp0;\n        var var0 = 0x00;\n        var var1 = 0x00;\n        var var2 = arg1;\n        var var3 = arg0;\n    \n        if (var2) { return var3 / var2; }\n        else { assert(); }\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { return; }\n    \n        storage[0x00] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~(0x02 ** 0xa0 - 0x01));\n    }\n    \n    function func_0936() returns (var r0) { return block.timestamp; }\n    \n    function func_093B(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (arg1 <= arg0) { return arg0 - arg1; }\n        else { assert(); }\n    }\n    \n    function func_0952(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { assert(); }\n    }\n    \n    function func_096C(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 * temp0;\n        var var2 = !temp0;\n    \n        if (var2) {\n        label_0988:\n        \n            if (var2) { return var1; }\n            else { assert(); }\n        } else {\n            var2 = arg1;\n            var var3 = arg0;\n            var var4 = var1;\n        \n            if (!var3) { assert(); }\n        \n            var2 = var4 / var3 == var2;\n            goto label_0988;\n        }\n    }\n    \n    function func_09B8(var arg0, var arg1) {\n        var temp0 = arg0;\n        var temp1 = storage[temp0];\n        var var0 = temp1;\n        var temp2 = arg1;\n        storage[temp0] = temp2;\n    \n        if (!var0 > temp2) {\n        label_08E4:\n            return;\n        } else {\n            memory[0x00:0x20] = arg0;\n            var temp3 = keccak256(memory[0x00:0x20]);\n            var temp4 = temp3 + var0 * 0x07;\n            var0 = 0x08e4;\n            var var2 = temp3 + arg1 * 0x07;\n            var var1 = temp4;\n            var0 = func_09EA(var1, var2);\n            goto label_08E4;\n        }\n    }\n    \n    function func_09EA(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = 0x0938;\n        var temp1 = arg1;\n        arg1 = temp0;\n        var var0 = temp1;\n    \n        if (arg1 <= var0) { return func_0A2B(arg1, var0); }\n    \n    label_09F9:\n        var temp2 = var0;\n        storage[temp2] = 0x00;\n        storage[temp2 + 0x01] = 0x00;\n        storage[temp2 + 0x02] = 0x00;\n        storage[temp2 + 0x03] = 0x00;\n        storage[temp2 + 0x04] = 0x00;\n        var temp3 = temp2 + 0x05;\n        storage[temp3] = storage[temp3] & ~0xff;\n        var0 = temp2 + 0x07;\n    \n        if (arg1 > var0) { goto label_09F9; }\n    \n        arg0 = func_0A2B(arg1, var0);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function func_0A2B(var arg0, var arg1) returns (var r0) { return arg0; }\n}\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { assert(); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x02 ** 0xe0 & 0xffffffff;\n    \n        if (var0 == 0x22c9427e) {\n            // Dispatch table entry for recycleDividend(uint256)\n            if (msg.value) { assert(); }\n        \n            var var1 = 0x0092;\n            var var2 = msg.data[0x04:0x24];\n            recycleDividend(var2);\n            stop();\n        } else if (var0 == 0x30e1f16f) {\n            // Dispatch table entry for claimDividendAll()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            claimDividendAll();\n            stop();\n        } else if (var0 == 0x6423b5f0) {\n            // Dispatch table entry for miniMeToken()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00b6;\n            var2 = miniMeToken();\n        \n        label_00B6:\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + temp0 - temp1 + 0x20];\n        } else if (var0 == 0x7c1a35d7) {\n            // Dispatch table entry for RECYCLE_TIME()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00e2;\n            var2 = RECYCLE_TIME();\n            var temp2 = memory[0x40:0x60];\n            memory[temp2:temp2 + 0x20] = var2;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + temp2 - temp3 + 0x20];\n        } else if (var0 == 0x814b3fe0) {\n            // Dispatch table entry for dividends(uint256)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0107;\n            var2 = msg.data[0x04:0x24];\n            var var3;\n            var var4;\n            var var5;\n            var var6;\n            var var7;\n            var2, var3, var4, var5, var6, var7 = dividends(var2);\n            var temp4 = memory[0x40:0x60];\n            memory[temp4:temp4 + 0x20] = var2;\n            memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var3;\n            memory[temp4 + 0x40:temp4 + 0x40 + 0x20] = var4;\n            memory[temp4 + 0x60:temp4 + 0x60 + 0x20] = var5;\n            memory[temp4 + 0x80:temp4 + 0x80 + 0x20] = var6;\n            memory[temp4 + 0xa0:temp4 + 0xa0 + 0x20] = !!var7;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + temp4 - temp5 + 0xc0];\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00b6;\n            var2 = owner();\n            goto label_00B6;\n        } else if (var0 == 0x9abd3572) {\n            // Dispatch table entry for claimDividend(uint256)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            var2 = msg.data[0x04:0x24];\n            claimDividend(var2);\n            stop();\n        } else if (var0 == 0xa289d187) {\n            // Dispatch table entry for depositDividend()\n            var1 = 0x0092;\n            var2 = 0x00;\n            var3 = var2;\n            var4 = var3;\n            var temp6 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[var4] & temp6 != temp6 & msg.sender) { revert(memory[0x00:0x00]); }\n        \n            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n            var temp7 = memory[0x40:0x60];\n            memory[temp7:temp7 + 0x20] = 0x0981b24d * 0x02 ** 0xe4;\n            memory[temp7 + 0x04:temp7 + 0x04 + 0x20] = block.number;\n            var var9 = memory[0x40:0x60];\n            var5 = storage[0x01] & 0x02 ** 0xa0 - 0x01;\n            var6 = 0x981b24d0;\n            var7 = temp7 + 0x24;\n            var var8 = 0x20;\n            var var10 = temp7 - var9 + 0x24;\n            var var11 = var9;\n            var var12 = 0x00;\n            var var13 = var5;\n        \n            if (!address(var13).code.length) { assert(); }\n        \n            var temp8;\n            temp8, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n        \n            if (!temp8) { assert(); }\n        \n            var2 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n            var3 = storage[0x03];\n            var5 = 0x07e8;\n            var6 = block.number;\n            var7 = 0x01;\n            var5 = func_093B(var6, var7);\n            var4 = var5;\n            var5 = 0x03;\n            var6 = storage[var5];\n            var7 = var6 + 0x01;\n            var8 = 0x07fe;\n            var10 = var7;\n            var9 = var5;\n            func_09B8(var9, var10);\n            var temp9 = var5;\n            var5 = var7;\n            memory[0x00:0x20] = temp9;\n            var6 = var6 * 0x07 + keccak256(memory[0x00:0x20]);\n            var7 = 0x00;\n            var temp10 = memory[0x40:0x60];\n            var8 = temp10;\n            memory[0x40:0x60] = var8 + 0xc0;\n            memory[var8:var8 + 0x20] = var4;\n            var9 = var8 + 0x20;\n            var10 = 0x0829;\n            var10 = func_0936();\n            var temp11 = var9;\n            memory[temp11:temp11 + 0x20] = var10;\n            var temp12 = msg.value;\n            memory[temp11 + 0x20:temp11 + 0x20 + 0x20] = temp12;\n            memory[temp11 + 0x40:temp11 + 0x40 + 0x20] = 0x00;\n            var temp13 = var2;\n            memory[temp11 + 0x60:temp11 + 0x60 + 0x20] = temp13;\n            memory[temp11 + 0x80:temp11 + 0x80 + 0x20] = 0x00;\n            var temp14 = var8;\n            var temp15 = var6;\n            storage[temp15] = memory[temp14:temp14 + 0x20];\n            storage[temp15 + 0x01] = memory[temp14 + 0x20:temp14 + 0x20 + 0x20];\n            storage[temp15 + 0x02] = memory[temp14 + 0x40:temp14 + 0x40 + 0x20];\n            storage[temp15 + 0x03] = memory[temp14 + 0x60:temp14 + 0x60 + 0x20];\n            storage[temp15 + 0x04] = memory[temp14 + 0x80:temp14 + 0x80 + 0x20];\n            var temp16 = temp15 + 0x05;\n            storage[temp16] = !!memory[temp14 + 0xa0:temp14 + 0xa0 + 0x20] | (storage[temp16] & ~0xff);\n            var temp17 = memory[0x40:0x60];\n            memory[temp17:temp17 + 0x20] = var4;\n            memory[temp17 + 0x20:temp17 + 0x20 + 0x20] = temp12;\n            memory[temp17 + 0x40:temp17 + 0x40 + 0x20] = temp13;\n            memory[temp17 + 0x60:temp17 + 0x60 + 0x20] = var3;\n            var temp18 = memory[0x40:0x60];\n            log(memory[temp18:temp18 + temp17 - temp18 + 0x80], [0xcbf89ed8b63aa0a8f6e744e4023554f41dc830838d138eb2d4099cbcfe4a0831, msg.sender]);\n            // Error: Could not resolve jump destination!\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else { assert(); }\n    }\n    \n    function recycleDividend(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = var2;\n        var var4 = var3;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var4] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var5 = arg0;\n    \n        if (var5 >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        var var6 = 0x03;\n        var var7 = arg0;\n    \n        if (var7 >= storage[var6]) { assert(); }\n    \n        memory[0x00:0x20] = var6;\n        var0 = var7 * 0x07 + keccak256(memory[0x00:0x20]);\n    \n        if (storage[var0 + 0x05] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var6 = 0x0224;\n        var7 = 0x021c;\n        var7 = func_0936();\n        var6 = func_021C(var7);\n    \n        if (storage[var0 + 0x01] >= var6) { revert(memory[0x00:0x00]); }\n    \n        var6 = 0x01;\n        var7 = 0x03;\n        var var8 = arg0;\n    \n        if (var8 >= storage[var7]) { assert(); }\n    \n        memory[0x00:0x20] = var7;\n        var temp1 = var8 * 0x07 + keccak256(memory[0x00:0x20]) + 0x05;\n        storage[temp1] = !!var6 | (storage[temp1] & ~0xff);\n        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = 0x0981b24d * 0x02 ** 0xe4;\n        memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = block.number;\n        var var10 = memory[0x40:0x60];\n        var6 = storage[0x01] & 0x02 ** 0xa0 - 0x01;\n        var7 = 0x981b24d0;\n        var8 = temp2 + 0x24;\n        var var9 = 0x20;\n        var var11 = temp2 - var10 + 0x24;\n        var var13 = 0x00;\n        var var12 = var10;\n        var var14 = var6;\n    \n        if (!address(var14).code.length) { assert(); }\n    \n        var temp3;\n        temp3, memory[var10:var10 + var9] = address(var14).call.gas(msg.gas - 0x02c6).value(var13)(memory[var12:var12 + var11]);\n    \n        if (!temp3) { assert(); }\n    \n        var1 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n        var6 = 0x02e9;\n        var temp4 = var0;\n        var7 = storage[temp4 + 0x02];\n        var8 = storage[temp4 + 0x03];\n        var6 = func_093B(var7, var8);\n        var2 = var6;\n        var3 = storage[0x03];\n        var6 = 0x02fc;\n        var7 = block.number;\n        var8 = 0x01;\n        var6 = func_093B(var7, var8);\n        var4 = var6;\n        var6 = 0x03;\n        var7 = storage[var6];\n        var8 = var7 + 0x01;\n        var9 = 0x0312;\n        var11 = var8;\n        var10 = var6;\n        func_09B8(var10, var11);\n        var temp5 = var6;\n        var6 = var8;\n        memory[0x00:0x20] = temp5;\n        var7 = var7 * 0x07 + keccak256(memory[0x00:0x20]);\n        var8 = 0x00;\n        var temp6 = memory[0x40:0x60];\n        var9 = temp6;\n        memory[0x40:0x60] = var9 + 0xc0;\n        memory[var9:var9 + 0x20] = var4;\n        var10 = var9 + 0x20;\n        var11 = 0x033d;\n        var11 = func_0936();\n        var temp7 = var10;\n        memory[temp7:temp7 + 0x20] = var11;\n        var temp8 = var2;\n        memory[temp7 + 0x20:temp7 + 0x20 + 0x20] = temp8;\n        memory[temp7 + 0x40:temp7 + 0x40 + 0x20] = 0x00;\n        var temp9 = var1;\n        memory[temp7 + 0x60:temp7 + 0x60 + 0x20] = temp9;\n        memory[temp7 + 0x80:temp7 + 0x80 + 0x20] = 0x00;\n        var temp10 = var9;\n        var temp11 = var7;\n        storage[temp11] = memory[temp10:temp10 + 0x20];\n        storage[temp11 + 0x01] = memory[temp10 + 0x20:temp10 + 0x20 + 0x20];\n        storage[temp11 + 0x02] = memory[temp10 + 0x40:temp10 + 0x40 + 0x20];\n        storage[temp11 + 0x03] = memory[temp10 + 0x60:temp10 + 0x60 + 0x20];\n        storage[temp11 + 0x04] = memory[temp10 + 0x80:temp10 + 0x80 + 0x20];\n        var temp12 = temp11 + 0x05;\n        storage[temp12] = !!memory[temp10 + 0xa0:temp10 + 0xa0 + 0x20] | (storage[temp12] & ~0xff);\n        var temp13 = memory[0x40:0x60];\n        memory[temp13:temp13 + 0x20] = var4;\n        memory[temp13 + 0x20:temp13 + 0x20 + 0x20] = temp8;\n        memory[temp13 + 0x40:temp13 + 0x40 + 0x20] = temp9;\n        memory[temp13 + 0x60:temp13 + 0x60 + 0x20] = var3;\n        var temp14 = memory[0x40:0x60];\n        log(memory[temp14:temp14 + temp13 - temp14 + 0x80], [0x820e5e0bd7a055839c0210e84ddba311de47df61f9c489947f436bcf0f302ff1, msg.sender]);\n    }\n    \n    function func_021C(var arg0) returns (var r0) {\n        var var0 = storage[0x02];\n        r0 = func_093B(arg0, var0);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function claimDividendAll() {\n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x04;\n        var var0 = 0x00;\n    \n        if (storage[keccak256(memory[var0:var0 + 0x40])] >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x04;\n        var0 = storage[keccak256(memory[0x00:0x40])];\n    \n        if (var0 >= storage[0x03]) {\n        label_04FD:\n            return;\n        } else {\n        label_0451:\n            var var1 = 0x03;\n            var var2 = var0;\n        \n            if (var2 >= storage[var1]) { assert(); }\n        \n            memory[0x00:0x20] = var1;\n            var temp0 = var2 * 0x07 + keccak256(memory[0x00:0x20]);\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = temp0 + 0x06;\n            var1 = !(storage[keccak256(memory[0x00:0x40])] & 0xff);\n        \n            if (!var1) {\n            label_04C1:\n            \n                if (!var1) {\n                label_04F3:\n                    var0 = var0 + 0x01;\n                \n                    if (var0 >= storage[0x03]) { goto label_04FD; }\n                    else { goto label_0451; }\n                } else {\n                    var1 = 0x04d1;\n                    var2 = var0;\n                    var var3 = 0x01;\n                    var1 = func_0952(var2, var3);\n                    memory[0x00:0x20] = msg.sender;\n                    memory[0x20:0x40] = 0x04;\n                    storage[keccak256(memory[0x00:0x40])] = var1;\n                    var1 = 0x04f3;\n                    var2 = var0;\n                    claimDividend(var2);\n                    goto label_04F3;\n                }\n            } else {\n                var1 = 0x03;\n                var2 = var0;\n            \n                if (var2 >= storage[var1]) { assert(); }\n            \n                memory[0x00:0x20] = var1;\n                var1 = !(storage[var2 * 0x07 + keccak256(memory[0x00:0x20]) + 0x05] & 0xff);\n                goto label_04C1;\n            }\n        }\n    }\n    \n    function miniMeToken() returns (var r0) { return storage[0x01] & 0x02 ** 0xa0 - 0x01; }\n    \n    function RECYCLE_TIME() returns (var r0) { return storage[0x02]; }\n    \n    function dividends(var arg0) returns (var arg0, var r1, var r2, var r3, var r4, var r5) {\n        r1 = 0x03;\n        r2 = arg0;\n    \n        if (r2 >= storage[r1]) { assert(); }\n    \n        memory[0x00:0x20] = r1;\n        var temp0 = r2 * 0x07 + keccak256(memory[0x00:0x20]);\n        arg0 = storage[temp0];\n        r3 = storage[temp0 + 0x03];\n        r1 = storage[temp0 + 0x01];\n        r4 = storage[temp0 + 0x04];\n        r2 = storage[temp0 + 0x02];\n        r5 = storage[temp0 + 0x05] & 0xff;\n        return arg0, r1, r2, r3, r4, r5;\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function claimDividend(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = arg0;\n    \n        if (var3 >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        var var4 = 0x03;\n        var var5 = arg0;\n    \n        if (var5 >= storage[var4]) { assert(); }\n    \n        memory[0x00:0x20] = var4;\n        var temp0 = var5 * 0x07 + keccak256(memory[0x00:0x20]);\n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = temp0 + 0x06;\n        var0 = temp0;\n    \n        if (storage[keccak256(memory[0x00:0x40])] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        if (storage[var0 + 0x05] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var var7 = 0x20;\n        memory[var7 + memory[0x40:0x60]:var7 + memory[0x40:0x60] + 0x20] = 0x00;\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = 0x277166bf * 0x02 ** 0xe1;\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = temp2 & msg.sender;\n        memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = storage[var0];\n        var4 = storage[0x01] & temp2;\n        var5 = 0x4ee2cd7e;\n        var var6 = temp1 + 0x44;\n        var var8 = memory[0x40:0x60];\n        var var9 = temp1 - var8 + 0x44;\n        var var10 = var8;\n        var var11 = 0x00;\n        var var12 = var4;\n    \n        if (!address(var12).code.length) { assert(); }\n    \n        var temp3;\n        temp3, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n    \n        if (!temp3) { assert(); }\n    \n        var temp4 = var0;\n        var1 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n        var4 = 0x068b;\n        var5 = storage[temp4 + 0x04];\n        var6 = 0x067f;\n        var8 = storage[temp4 + 0x02];\n        var7 = var1;\n        var6 = func_096C(var7, var8);\n        var4 = func_067F(var5, var6);\n        memory[0x00:0x20] = msg.sender;\n        var temp5 = var0;\n        memory[0x20:0x40] = temp5 + 0x06;\n        var temp6 = keccak256(memory[0x00:0x40]);\n        storage[temp6] = (storage[temp6] & ~0xff) | 0x01;\n        var temp7 = var4;\n        var2 = temp7;\n        var5 = storage[temp5 + 0x03];\n        var4 = 0x06c2;\n        var6 = var2;\n        var4 = func_0952(var5, var6);\n        storage[var0 + 0x03] = var4;\n    \n        if (var2 <= 0x00) {\n        label_0741:\n            return;\n        } else {\n            var temp8 = memory[0x40:0x60];\n            var temp9 = var2;\n            var temp10;\n            temp10, memory[temp8:temp8 + 0x00] = address(msg.sender).call.gas(!temp9 * 0x08fc).value(temp9)(memory[temp8:temp8 + 0x00]);\n        \n            if (!temp10) { assert(); }\n        \n            var temp11 = memory[0x40:0x60];\n            memory[temp11:temp11 + 0x20] = arg0;\n            memory[temp11 + 0x20:temp11 + 0x20 + 0x20] = var2;\n            var temp12 = memory[0x40:0x60];\n            log(memory[temp12:temp12 + temp11 - temp12 + 0x40], [0xa1c93169468f71ef26f4adf10bca8df21460f11843a01ed9c69da306e33c3847, msg.sender]);\n            goto label_0741;\n        }\n    }\n    \n    function func_067F(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = arg1;\n        arg1 = temp0;\n        var var0 = 0x00;\n        var var1 = 0x00;\n        var var2 = arg1;\n        var var3 = arg0;\n    \n        if (var2) { return var3 / var2; }\n        else { assert(); }\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { return; }\n    \n        storage[0x00] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~(0x02 ** 0xa0 - 0x01));\n    }\n    \n    function func_0936() returns (var r0) { return block.timestamp; }\n    \n    function func_093B(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (arg1 <= arg0) { return arg0 - arg1; }\n        else { assert(); }\n    }\n    \n    function func_0952(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { assert(); }\n    }\n    \n    function func_096C(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 * temp0;\n        var var2 = !temp0;\n    \n        if (var2) {\n        label_0988:\n        \n            if (var2) { return var1; }\n            else { assert(); }\n        } else {\n            var2 = arg1;\n            var var3 = arg0;\n            var var4 = var1;\n        \n            if (!var3) { assert(); }\n        \n            var2 = var4 / var3 == var2;\n            goto label_0988;\n        }\n    }\n    \n    function func_09B8(var arg0, var arg1) {\n        var temp0 = arg0;\n        var temp1 = storage[temp0];\n        var var0 = temp1;\n        var temp2 = arg1;\n        storage[temp0] = temp2;\n    \n        if (!var0 > temp2) {\n        label_08E4:\n            return;\n        } else {\n            memory[0x00:0x20] = arg0;\n            var temp3 = keccak256(memory[0x00:0x20]);\n            var temp4 = temp3 + var0 * 0x07;\n            var0 = 0x08e4;\n            var var2 = temp3 + arg1 * 0x07;\n            var var1 = temp4;\n            var0 = func_09EA(var1, var2);\n            goto label_08E4;\n        }\n    }\n    \n    function func_09EA(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = 0x0938;\n        var temp1 = arg1;\n        arg1 = temp0;\n        var var0 = temp1;\n    \n        if (arg1 <= var0) { return func_0A2B(arg1, var0); }\n    \n    label_09F9:\n        var temp2 = var0;\n        storage[temp2] = 0x00;\n        storage[temp2 + 0x01] = 0x00;\n        storage[temp2 + 0x02] = 0x00;\n        storage[temp2 + 0x03] = 0x00;\n        storage[temp2 + 0x04] = 0x00;\n        var temp3 = temp2 + 0x05;\n        storage[temp3] = storage[temp3] & ~0xff;\n        var0 = temp2 + 0x07;\n    \n        if (arg1 > var0) { goto label_09F9; }\n    \n        arg0 = func_0A2B(arg1, var0);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function func_0A2B(var arg0, var arg1) returns (var r0) { return arg0; }\n}\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (!msg.data.length) { assert(); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x02 ** 0xe0 & 0xffffffff;\n    \n        if (var0 == 0x22c9427e) {\n            // Dispatch table entry for recycleDividend(uint256)\n            if (msg.value) { assert(); }\n        \n            var var1 = 0x0092;\n            var var2 = msg.data[0x04:0x24];\n            recycleDividend(var2);\n            stop();\n        } else if (var0 == 0x30e1f16f) {\n            // Dispatch table entry for claimDividendAll()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            claimDividendAll();\n            stop();\n        } else if (var0 == 0x6423b5f0) {\n            // Dispatch table entry for miniMeToken()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00b6;\n            var2 = miniMeToken();\n        \n        label_00B6:\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0x02 ** 0xa0 - 0x01;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + temp0 - temp1 + 0x20];\n        } else if (var0 == 0x7c1a35d7) {\n            // Dispatch table entry for RECYCLE_TIME()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00e2;\n            var2 = RECYCLE_TIME();\n            var temp2 = memory[0x40:0x60];\n            memory[temp2:temp2 + 0x20] = var2;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + temp2 - temp3 + 0x20];\n        } else if (var0 == 0x814b3fe0) {\n            // Dispatch table entry for dividends(uint256)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0107;\n            var2 = msg.data[0x04:0x24];\n            var var3;\n            var var4;\n            var var5;\n            var var6;\n            var var7;\n            var2, var3, var4, var5, var6, var7 = dividends(var2);\n            var temp4 = memory[0x40:0x60];\n            memory[temp4:temp4 + 0x20] = var2;\n            memory[temp4 + 0x20:temp4 + 0x20 + 0x20] = var3;\n            memory[temp4 + 0x40:temp4 + 0x40 + 0x20] = var4;\n            memory[temp4 + 0x60:temp4 + 0x60 + 0x20] = var5;\n            memory[temp4 + 0x80:temp4 + 0x80 + 0x20] = var6;\n            memory[temp4 + 0xa0:temp4 + 0xa0 + 0x20] = !!var7;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + temp4 - temp5 + 0xc0];\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { assert(); }\n        \n            var1 = 0x00b6;\n            var2 = owner();\n            goto label_00B6;\n        } else if (var0 == 0x9abd3572) {\n            // Dispatch table entry for claimDividend(uint256)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            var2 = msg.data[0x04:0x24];\n            claimDividend(var2);\n            stop();\n        } else if (var0 == 0xa289d187) {\n            // Dispatch table entry for depositDividend()\n            var1 = 0x0092;\n            var2 = 0x00;\n            var3 = var2;\n            var4 = var3;\n            var temp6 = 0x02 ** 0xa0 - 0x01;\n        \n            if (storage[var4] & temp6 != temp6 & msg.sender) { revert(memory[0x00:0x00]); }\n        \n            memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n            var temp7 = memory[0x40:0x60];\n            memory[temp7:temp7 + 0x20] = 0x0981b24d * 0x02 ** 0xe4;\n            memory[temp7 + 0x04:temp7 + 0x04 + 0x20] = block.number;\n            var var9 = memory[0x40:0x60];\n            var5 = storage[0x01] & 0x02 ** 0xa0 - 0x01;\n            var6 = 0x981b24d0;\n            var7 = temp7 + 0x24;\n            var var8 = 0x20;\n            var var10 = temp7 - var9 + 0x24;\n            var var11 = var9;\n            var var12 = 0x00;\n            var var13 = var5;\n        \n            if (!address(var13).code.length) { assert(); }\n        \n            var temp8;\n            temp8, memory[var9:var9 + var8] = address(var13).call.gas(msg.gas - 0x02c6).value(var12)(memory[var11:var11 + var10]);\n        \n            if (!temp8) { assert(); }\n        \n            var2 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n            var3 = storage[0x03];\n            var5 = 0x07e8;\n            var6 = block.number;\n            var7 = 0x01;\n            var5 = func_093B(var6, var7);\n            var4 = var5;\n            var5 = 0x03;\n            var6 = storage[var5];\n            var7 = var6 + 0x01;\n            var8 = 0x07fe;\n            var10 = var7;\n            var9 = var5;\n            func_09B8(var9, var10);\n            var temp9 = var5;\n            var5 = var7;\n            memory[0x00:0x20] = temp9;\n            var6 = var6 * 0x07 + keccak256(memory[0x00:0x20]);\n            var7 = 0x00;\n            var temp10 = memory[0x40:0x60];\n            var8 = temp10;\n            memory[0x40:0x60] = var8 + 0xc0;\n            memory[var8:var8 + 0x20] = var4;\n            var9 = var8 + 0x20;\n            var10 = 0x0829;\n            var10 = func_0936();\n            var temp11 = var9;\n            memory[temp11:temp11 + 0x20] = var10;\n            var temp12 = msg.value;\n            memory[temp11 + 0x20:temp11 + 0x20 + 0x20] = temp12;\n            memory[temp11 + 0x40:temp11 + 0x40 + 0x20] = 0x00;\n            var temp13 = var2;\n            memory[temp11 + 0x60:temp11 + 0x60 + 0x20] = temp13;\n            memory[temp11 + 0x80:temp11 + 0x80 + 0x20] = 0x00;\n            var temp14 = var8;\n            var temp15 = var6;\n            storage[temp15] = memory[temp14:temp14 + 0x20];\n            storage[temp15 + 0x01] = memory[temp14 + 0x20:temp14 + 0x20 + 0x20];\n            storage[temp15 + 0x02] = memory[temp14 + 0x40:temp14 + 0x40 + 0x20];\n            storage[temp15 + 0x03] = memory[temp14 + 0x60:temp14 + 0x60 + 0x20];\n            storage[temp15 + 0x04] = memory[temp14 + 0x80:temp14 + 0x80 + 0x20];\n            var temp16 = temp15 + 0x05;\n            storage[temp16] = !!memory[temp14 + 0xa0:temp14 + 0xa0 + 0x20] | (storage[temp16] & ~0xff);\n            var temp17 = memory[0x40:0x60];\n            memory[temp17:temp17 + 0x20] = var4;\n            memory[temp17 + 0x20:temp17 + 0x20 + 0x20] = temp12;\n            memory[temp17 + 0x40:temp17 + 0x40 + 0x20] = temp13;\n            memory[temp17 + 0x60:temp17 + 0x60 + 0x20] = var3;\n            var temp18 = memory[0x40:0x60];\n            log(memory[temp18:temp18 + temp17 - temp18 + 0x80], [0xcbf89ed8b63aa0a8f6e744e4023554f41dc830838d138eb2d4099cbcfe4a0831, msg.sender]);\n            // Error: Could not resolve jump destination!\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { assert(); }\n        \n            var1 = 0x0092;\n            var2 = msg.data[0x04:0x24] & 0x02 ** 0xa0 - 0x01;\n            transferOwnership(var2);\n            stop();\n        } else { assert(); }\n    }\n    \n    function recycleDividend(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = var2;\n        var var4 = var3;\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[var4] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        var var5 = arg0;\n    \n        if (var5 >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        var var6 = 0x03;\n        var var7 = arg0;\n    \n        if (var7 >= storage[var6]) { assert(); }\n    \n        memory[0x00:0x20] = var6;\n        var0 = var7 * 0x07 + keccak256(memory[0x00:0x20]);\n    \n        if (storage[var0 + 0x05] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var6 = 0x0224;\n        var7 = 0x021c;\n        var7 = func_0936();\n        var6 = func_021C(var7);\n    \n        if (storage[var0 + 0x01] >= var6) { revert(memory[0x00:0x00]); }\n    \n        var6 = 0x01;\n        var7 = 0x03;\n        var var8 = arg0;\n    \n        if (var8 >= storage[var7]) { assert(); }\n    \n        memory[0x00:0x20] = var7;\n        var temp1 = var8 * 0x07 + keccak256(memory[0x00:0x20]) + 0x05;\n        storage[temp1] = !!var6 | (storage[temp1] & ~0xff);\n        memory[memory[0x40:0x60] + 0x20:memory[0x40:0x60] + 0x20 + 0x20] = 0x00;\n        var temp2 = memory[0x40:0x60];\n        memory[temp2:temp2 + 0x20] = 0x0981b24d * 0x02 ** 0xe4;\n        memory[temp2 + 0x04:temp2 + 0x04 + 0x20] = block.number;\n        var var10 = memory[0x40:0x60];\n        var6 = storage[0x01] & 0x02 ** 0xa0 - 0x01;\n        var7 = 0x981b24d0;\n        var8 = temp2 + 0x24;\n        var var9 = 0x20;\n        var var11 = temp2 - var10 + 0x24;\n        var var13 = 0x00;\n        var var12 = var10;\n        var var14 = var6;\n    \n        if (!address(var14).code.length) { assert(); }\n    \n        var temp3;\n        temp3, memory[var10:var10 + var9] = address(var14).call.gas(msg.gas - 0x02c6).value(var13)(memory[var12:var12 + var11]);\n    \n        if (!temp3) { assert(); }\n    \n        var1 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n        var6 = 0x02e9;\n        var temp4 = var0;\n        var7 = storage[temp4 + 0x02];\n        var8 = storage[temp4 + 0x03];\n        var6 = func_093B(var7, var8);\n        var2 = var6;\n        var3 = storage[0x03];\n        var6 = 0x02fc;\n        var7 = block.number;\n        var8 = 0x01;\n        var6 = func_093B(var7, var8);\n        var4 = var6;\n        var6 = 0x03;\n        var7 = storage[var6];\n        var8 = var7 + 0x01;\n        var9 = 0x0312;\n        var11 = var8;\n        var10 = var6;\n        func_09B8(var10, var11);\n        var temp5 = var6;\n        var6 = var8;\n        memory[0x00:0x20] = temp5;\n        var7 = var7 * 0x07 + keccak256(memory[0x00:0x20]);\n        var8 = 0x00;\n        var temp6 = memory[0x40:0x60];\n        var9 = temp6;\n        memory[0x40:0x60] = var9 + 0xc0;\n        memory[var9:var9 + 0x20] = var4;\n        var10 = var9 + 0x20;\n        var11 = 0x033d;\n        var11 = func_0936();\n        var temp7 = var10;\n        memory[temp7:temp7 + 0x20] = var11;\n        var temp8 = var2;\n        memory[temp7 + 0x20:temp7 + 0x20 + 0x20] = temp8;\n        memory[temp7 + 0x40:temp7 + 0x40 + 0x20] = 0x00;\n        var temp9 = var1;\n        memory[temp7 + 0x60:temp7 + 0x60 + 0x20] = temp9;\n        memory[temp7 + 0x80:temp7 + 0x80 + 0x20] = 0x00;\n        var temp10 = var9;\n        var temp11 = var7;\n        storage[temp11] = memory[temp10:temp10 + 0x20];\n        storage[temp11 + 0x01] = memory[temp10 + 0x20:temp10 + 0x20 + 0x20];\n        storage[temp11 + 0x02] = memory[temp10 + 0x40:temp10 + 0x40 + 0x20];\n        storage[temp11 + 0x03] = memory[temp10 + 0x60:temp10 + 0x60 + 0x20];\n        storage[temp11 + 0x04] = memory[temp10 + 0x80:temp10 + 0x80 + 0x20];\n        var temp12 = temp11 + 0x05;\n        storage[temp12] = !!memory[temp10 + 0xa0:temp10 + 0xa0 + 0x20] | (storage[temp12] & ~0xff);\n        var temp13 = memory[0x40:0x60];\n        memory[temp13:temp13 + 0x20] = var4;\n        memory[temp13 + 0x20:temp13 + 0x20 + 0x20] = temp8;\n        memory[temp13 + 0x40:temp13 + 0x40 + 0x20] = temp9;\n        memory[temp13 + 0x60:temp13 + 0x60 + 0x20] = var3;\n        var temp14 = memory[0x40:0x60];\n        log(memory[temp14:temp14 + temp13 - temp14 + 0x80], [0x820e5e0bd7a055839c0210e84ddba311de47df61f9c489947f436bcf0f302ff1, msg.sender]);\n    }\n    \n    function func_021C(var arg0) returns (var r0) {\n        var var0 = storage[0x02];\n        r0 = func_093B(arg0, var0);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function claimDividendAll() {\n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x04;\n        var var0 = 0x00;\n    \n        if (storage[keccak256(memory[var0:var0 + 0x40])] >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = 0x04;\n        var0 = storage[keccak256(memory[0x00:0x40])];\n    \n        if (var0 >= storage[0x03]) {\n        label_04FD:\n            return;\n        } else {\n        label_0451:\n            var var1 = 0x03;\n            var var2 = var0;\n        \n            if (var2 >= storage[var1]) { assert(); }\n        \n            memory[0x00:0x20] = var1;\n            var temp0 = var2 * 0x07 + keccak256(memory[0x00:0x20]);\n            memory[0x00:0x20] = msg.sender;\n            memory[0x20:0x40] = temp0 + 0x06;\n            var1 = !(storage[keccak256(memory[0x00:0x40])] & 0xff);\n        \n            if (!var1) {\n            label_04C1:\n            \n                if (!var1) {\n                label_04F3:\n                    var0 = var0 + 0x01;\n                \n                    if (var0 >= storage[0x03]) { goto label_04FD; }\n                    else { goto label_0451; }\n                } else {\n                    var1 = 0x04d1;\n                    var2 = var0;\n                    var var3 = 0x01;\n                    var1 = func_0952(var2, var3);\n                    memory[0x00:0x20] = msg.sender;\n                    memory[0x20:0x40] = 0x04;\n                    storage[keccak256(memory[0x00:0x40])] = var1;\n                    var1 = 0x04f3;\n                    var2 = var0;\n                    claimDividend(var2);\n                    goto label_04F3;\n                }\n            } else {\n                var1 = 0x03;\n                var2 = var0;\n            \n                if (var2 >= storage[var1]) { assert(); }\n            \n                memory[0x00:0x20] = var1;\n                var1 = !(storage[var2 * 0x07 + keccak256(memory[0x00:0x20]) + 0x05] & 0xff);\n                goto label_04C1;\n            }\n        }\n    }\n    \n    function miniMeToken() returns (var r0) { return storage[0x01] & 0x02 ** 0xa0 - 0x01; }\n    \n    function RECYCLE_TIME() returns (var r0) { return storage[0x02]; }\n    \n    function dividends(var arg0) returns (var arg0, var r1, var r2, var r3, var r4, var r5) {\n        r1 = 0x03;\n        r2 = arg0;\n    \n        if (r2 >= storage[r1]) { assert(); }\n    \n        memory[0x00:0x20] = r1;\n        var temp0 = r2 * 0x07 + keccak256(memory[0x00:0x20]);\n        arg0 = storage[temp0];\n        r3 = storage[temp0 + 0x03];\n        r1 = storage[temp0 + 0x01];\n        r4 = storage[temp0 + 0x04];\n        r2 = storage[temp0 + 0x02];\n        r5 = storage[temp0 + 0x05] & 0xff;\n        return arg0, r1, r2, r3, r4, r5;\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0x02 ** 0xa0 - 0x01; }\n    \n    function claimDividend(var arg0) {\n        var var0 = 0x00;\n        var var1 = var0;\n        var var2 = var1;\n        var var3 = arg0;\n    \n        if (var3 >= storage[0x03]) { revert(memory[0x00:0x00]); }\n    \n        var var4 = 0x03;\n        var var5 = arg0;\n    \n        if (var5 >= storage[var4]) { assert(); }\n    \n        memory[0x00:0x20] = var4;\n        var temp0 = var5 * 0x07 + keccak256(memory[0x00:0x20]);\n        memory[0x00:0x20] = msg.sender;\n        memory[0x20:0x40] = temp0 + 0x06;\n        var0 = temp0;\n    \n        if (storage[keccak256(memory[0x00:0x40])] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        if (storage[var0 + 0x05] & 0xff) { revert(memory[0x00:0x00]); }\n    \n        var var7 = 0x20;\n        memory[var7 + memory[0x40:0x60]:var7 + memory[0x40:0x60] + 0x20] = 0x00;\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = 0x277166bf * 0x02 ** 0xe1;\n        var temp2 = 0x02 ** 0xa0 - 0x01;\n        memory[temp1 + 0x04:temp1 + 0x04 + 0x20] = temp2 & msg.sender;\n        memory[temp1 + 0x24:temp1 + 0x24 + 0x20] = storage[var0];\n        var4 = storage[0x01] & temp2;\n        var5 = 0x4ee2cd7e;\n        var var6 = temp1 + 0x44;\n        var var8 = memory[0x40:0x60];\n        var var9 = temp1 - var8 + 0x44;\n        var var10 = var8;\n        var var11 = 0x00;\n        var var12 = var4;\n    \n        if (!address(var12).code.length) { assert(); }\n    \n        var temp3;\n        temp3, memory[var8:var8 + var7] = address(var12).call.gas(msg.gas - 0x02c6).value(var11)(memory[var10:var10 + var9]);\n    \n        if (!temp3) { assert(); }\n    \n        var temp4 = var0;\n        var1 = memory[memory[0x40:0x60]:memory[0x40:0x60] + 0x20];\n        var4 = 0x068b;\n        var5 = storage[temp4 + 0x04];\n        var6 = 0x067f;\n        var8 = storage[temp4 + 0x02];\n        var7 = var1;\n        var6 = func_096C(var7, var8);\n        var4 = func_067F(var5, var6);\n        memory[0x00:0x20] = msg.sender;\n        var temp5 = var0;\n        memory[0x20:0x40] = temp5 + 0x06;\n        var temp6 = keccak256(memory[0x00:0x40]);\n        storage[temp6] = (storage[temp6] & ~0xff) | 0x01;\n        var temp7 = var4;\n        var2 = temp7;\n        var5 = storage[temp5 + 0x03];\n        var4 = 0x06c2;\n        var6 = var2;\n        var4 = func_0952(var5, var6);\n        storage[var0 + 0x03] = var4;\n    \n        if (var2 <= 0x00) {\n        label_0741:\n            return;\n        } else {\n            var temp8 = memory[0x40:0x60];\n            var temp9 = var2;\n            var temp10;\n            temp10, memory[temp8:temp8 + 0x00] = address(msg.sender).call.gas(!temp9 * 0x08fc).value(temp9)(memory[temp8:temp8 + 0x00]);\n        \n            if (!temp10) { assert(); }\n        \n            var temp11 = memory[0x40:0x60];\n            memory[temp11:temp11 + 0x20] = arg0;\n            memory[temp11 + 0x20:temp11 + 0x20 + 0x20] = var2;\n            var temp12 = memory[0x40:0x60];\n            log(memory[temp12:temp12 + temp11 - temp12 + 0x40], [0xa1c93169468f71ef26f4adf10bca8df21460f11843a01ed9c69da306e33c3847, msg.sender]);\n            goto label_0741;\n        }\n    }\n    \n    function func_067F(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = arg1;\n        arg1 = temp0;\n        var var0 = 0x00;\n        var var1 = 0x00;\n        var var2 = arg1;\n        var var3 = arg0;\n    \n        if (var2) { return var3 / var2; }\n        else { assert(); }\n    }\n    \n    function transferOwnership(var arg0) {\n        var temp0 = 0x02 ** 0xa0 - 0x01;\n    \n        if (storage[0x00] & temp0 != temp0 & msg.sender) { revert(memory[0x00:0x00]); }\n    \n        if (!(arg0 & 0x02 ** 0xa0 - 0x01)) { return; }\n    \n        storage[0x00] = (arg0 & 0x02 ** 0xa0 - 0x01) | (storage[0x00] & ~(0x02 ** 0xa0 - 0x01));\n    }\n    \n    function func_0936() returns (var r0) { return block.timestamp; }\n    \n    function func_093B(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n    \n        if (arg1 <= arg0) { return arg0 - arg1; }\n        else { assert(); }\n    }\n    \n    function func_0952(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 + temp0;\n    \n        if (var1 >= temp0) { return var1; }\n        else { assert(); }\n    }\n    \n    function func_096C(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = arg1 * temp0;\n        var var2 = !temp0;\n    \n        if (var2) {\n        label_0988:\n        \n            if (var2) { return var1; }\n            else { assert(); }\n        } else {\n            var2 = arg1;\n            var var3 = arg0;\n            var var4 = var1;\n        \n            if (!var3) { assert(); }\n        \n            var2 = var4 / var3 == var2;\n            goto label_0988;\n        }\n    }\n    \n    function func_09B8(var arg0, var arg1) {\n        var temp0 = arg0;\n        var temp1 = storage[temp0];\n        var var0 = temp1;\n        var temp2 = arg1;\n        storage[temp0] = temp2;\n    \n        if (!var0 > temp2) {\n        label_08E4:\n            return;\n        } else {\n            memory[0x00:0x20] = arg0;\n            var temp3 = keccak256(memory[0x00:0x20]);\n            var temp4 = temp3 + var0 * 0x07;\n            var0 = 0x08e4;\n            var var2 = temp3 + arg1 * 0x07;\n            var var1 = temp4;\n            var0 = func_09EA(var1, var2);\n            goto label_08E4;\n        }\n    }\n    \n    function func_09EA(var arg0, var arg1) returns (var r0) {\n        var temp0 = arg0;\n        arg0 = 0x0938;\n        var temp1 = arg1;\n        arg1 = temp0;\n        var var0 = temp1;\n    \n        if (arg1 <= var0) { return func_0A2B(arg1, var0); }\n    \n    label_09F9:\n        var temp2 = var0;\n        storage[temp2] = 0x00;\n        storage[temp2 + 0x01] = 0x00;\n        storage[temp2 + 0x02] = 0x00;\n        storage[temp2 + 0x03] = 0x00;\n        storage[temp2 + 0x04] = 0x00;\n        var temp3 = temp2 + 0x05;\n        storage[temp3] = storage[temp3] & ~0xff;\n        var0 = temp2 + 0x07;\n    \n        if (arg1 > var0) { goto label_09F9; }\n    \n        arg0 = func_0A2B(arg1, var0);\n        // Error: Could not resolve method call return address!\n    }\n    \n    function func_0A2B(var arg0, var arg1) returns (var r0) { return arg0; }\n}\n\n.",
	"status": "1",
	"time_cost": 24.253341674804688,
	"usage": {
		"completion_tokens": 413,
		"prompt_tokens": 7270,
		"total_tokens": 7683
	}
}