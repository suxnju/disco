{
	"address": "0xf9b5ef95a21b53ee92a37139aa5b5cdf1976f161",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract that corresponds to the given decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract ProxyContract {\n    mapping(bytes32 => address) public STORAGE;\n\n    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Upgraded(address indexed newImplementation);\n\n    modifier onlyProxyOwner() {\n        require(msg.sender == STORAGE[keccak256(\"org.zeppelinos.proxy.owner\")]);\n        _;\n    }\n\n    function proxyOwner() public view returns (address) {\n        return STORAGE[keccak256(\"org.zeppelinos.proxy.owner\")];\n    }\n\n    function upgradeTo(address newImplementation) public onlyProxyOwner {\n        require(newImplementation != address(0));\n        require(newImplementation != STORAGE[keccak256(\"org.zeppelinos.proxy.implementation\")]);\n        STORAGE[keccak256(\"org.zeppelinos.proxy.implementation\")] = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable onlyProxyOwner {\n        require(newImplementation != address(0));\n        require(newImplementation != STORAGE[keccak256(\"org.zeppelinos.proxy.implementation\")]);\n        STORAGE[keccak256(\"org.zeppelinos.proxy.implementation\")] = newImplementation;\n        emit Upgraded(newImplementation);\n        (bool success,) = newImplementation.delegatecall(data);\n        require(success);\n    }\n\n    function implementation() public view returns (address) {\n        return STORAGE[keccak256(\"org.zeppelinos.proxy.implementation\")];\n    }\n\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n        require(newOwner != address(0));\n        emit ProxyOwnershipTransferred(STORAGE[keccak256(\"org.zeppelinos.proxy.owner\")], newOwner);\n        STORAGE[keccak256(\"org.zeppelinos.proxy.owner\")] = newOwner;\n    }\n\n    function() external payable {\n        address _impl = implementation();\n        require(_impl != address(0));\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n```\n\nPlease note, the `returnInitialiseData` function was not clear from the decompiled code and, as such, was not included in the Solidity contract. Also, the `__function_selector__` method was not included as function selectors are typically handled by the Solidity compiler rather than manually within the contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701463350,
	"id": "chatcmpl-8R4dC1zaDuQLQwLilpDYXuxVcbkwG",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.26 12:56 UTC\n\n\n// Events\nProxyOwnershipTransferred(address, address);\nUpgraded(address);\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]) != varg0);\n    STORAGE[keccak256(MEM[(v1.data) len 35])] = varg0;\n    emit Upgraded(varg0);\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(address(STORAGE[keccak256(MEM[(v1.data) len 0x23])]) != varg0);\n    STORAGE[keccak256(MEM[(v2.data) len 35])] = varg0;\n    emit Upgraded(varg0);\n    v3 = v4 = v4.data;\n    v5 = v6 = v0.length;\n    v7 = v8 = v0.data;\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(this).call(v4.data).value(msg.value).gas(0x30d40);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        v10 = v11.data;\n        RETURNDATACOPY(v10, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction implementation() public nonPayable { \n    return address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]);\n}\n\nfunction returnInitialiseData(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new array[](36);\n    v1 = v2 = 0;\n    while (v1 < 36) {\n        MEM[v0.data + v1] = MEM[32 + MEM[64] + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = 36 + v0.data;\n    if (4) {\n        MEM[v4 - 4] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0;\n    }\n    return v0, v5, varg0 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff | 0xc4d66de800000000000000000000000000000000000000000000000000000000;\n}\n\nfunction transferProxyOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(varg0 != 0);\n    emit ProxyOwnershipTransferred(address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]), varg0);\n    STORAGE[keccak256('org.zeppelinos.proxy.owner')] = varg0;\n}\n\nfunction fallback() public payable { \n    require(address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]) != 0);\n    v1 = STORAGE[keccak256(MEM[(v0.data) len 0x23])].delegatecall(MEM[(MEM[64]) len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1 != 0, MEM[64], RETURNDATASIZE());\n    return MEM[(MEM[64]) len (RETURNDATASIZE())];\n}\n\nfunction proxyOwner() public nonPayable { \n    return address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x25313a2 == function_selector >> 224) {\n            proxyOwner();\n        } else if (0x3659cfe6 == function_selector >> 224) {\n            upgradeTo(address);\n        } else if (0x4f1ef286 == function_selector >> 224) {\n            upgradeToAndCall(address,bytes);\n        } else if (0x5c60da1b == function_selector >> 224) {\n            implementation();\n        } else if (0x8a73acdc == function_selector >> 224) {\n            returnInitialiseData(address);\n        } else if (0xf1739cae == function_selector >> 224) {\n            transferProxyOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 12:56 UTC\n\n\n// Events\nProxyOwnershipTransferred(address, address);\nUpgraded(address);\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]) != varg0);\n    STORAGE[keccak256(MEM[(v1.data) len 35])] = varg0;\n    emit Upgraded(varg0);\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(address(STORAGE[keccak256(MEM[(v1.data) len 0x23])]) != varg0);\n    STORAGE[keccak256(MEM[(v2.data) len 35])] = varg0;\n    emit Upgraded(varg0);\n    v3 = v4 = v4.data;\n    v5 = v6 = v0.length;\n    v7 = v8 = v0.data;\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(this).call(v4.data).value(msg.value).gas(0x30d40);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        v10 = v11.data;\n        RETURNDATACOPY(v10, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction implementation() public nonPayable { \n    return address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]);\n}\n\nfunction returnInitialiseData(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new array[](36);\n    v1 = v2 = 0;\n    while (v1 < 36) {\n        MEM[v0.data + v1] = MEM[32 + MEM[64] + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = 36 + v0.data;\n    if (4) {\n        MEM[v4 - 4] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0;\n    }\n    return v0, v5, varg0 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff | 0xc4d66de800000000000000000000000000000000000000000000000000000000;\n}\n\nfunction transferProxyOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(varg0 != 0);\n    emit ProxyOwnershipTransferred(address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]), varg0);\n    STORAGE[keccak256('org.zeppelinos.proxy.owner')] = varg0;\n}\n\nfunction fallback() public payable { \n    require(address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]) != 0);\n    v1 = STORAGE[keccak256(MEM[(v0.data) len 0x23])].delegatecall(MEM[(MEM[64]) len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1 != 0, MEM[64], RETURNDATASIZE());\n    return MEM[(MEM[64]) len (RETURNDATASIZE())];\n}\n\nfunction proxyOwner() public nonPayable { \n    return address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x25313a2 == function_selector >> 224) {\n            proxyOwner();\n        } else if (0x3659cfe6 == function_selector >> 224) {\n            upgradeTo(address);\n        } else if (0x4f1ef286 == function_selector >> 224) {\n            upgradeToAndCall(address,bytes);\n        } else if (0x5c60da1b == function_selector >> 224) {\n            implementation();\n        } else if (0x8a73acdc == function_selector >> 224) {\n            returnInitialiseData(address);\n        } else if (0xf1739cae == function_selector >> 224) {\n            transferProxyOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 12:56 UTC\n\n\n// Events\nProxyOwnershipTransferred(address, address);\nUpgraded(address);\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]) != varg0);\n    STORAGE[keccak256(MEM[(v1.data) len 35])] = varg0;\n    emit Upgraded(varg0);\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(address(STORAGE[keccak256(MEM[(v1.data) len 0x23])]) != varg0);\n    STORAGE[keccak256(MEM[(v2.data) len 35])] = varg0;\n    emit Upgraded(varg0);\n    v3 = v4 = v4.data;\n    v5 = v6 = v0.length;\n    v7 = v8 = v0.data;\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(this).call(v4.data).value(msg.value).gas(0x30d40);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        v10 = v11.data;\n        RETURNDATACOPY(v10, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction implementation() public nonPayable { \n    return address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]);\n}\n\nfunction returnInitialiseData(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = new array[](36);\n    v1 = v2 = 0;\n    while (v1 < 36) {\n        MEM[v0.data + v1] = MEM[32 + MEM[64] + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = 36 + v0.data;\n    if (4) {\n        MEM[v4 - 4] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0;\n    }\n    return v0, v5, varg0 & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff | 0xc4d66de800000000000000000000000000000000000000000000000000000000;\n}\n\nfunction transferProxyOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]));\n    require(varg0 != 0);\n    emit ProxyOwnershipTransferred(address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]), varg0);\n    STORAGE[keccak256('org.zeppelinos.proxy.owner')] = varg0;\n}\n\nfunction fallback() public payable { \n    require(address(STORAGE[keccak256(MEM[(v0.data) len 0x23])]) != 0);\n    v1 = STORAGE[keccak256(MEM[(v0.data) len 0x23])].delegatecall(MEM[(MEM[64]) len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1 != 0, MEM[64], RETURNDATASIZE());\n    return MEM[(MEM[64]) len (RETURNDATASIZE())];\n}\n\nfunction proxyOwner() public nonPayable { \n    return address(STORAGE[keccak256('org.zeppelinos.proxy.owner')]);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x25313a2 == function_selector >> 224) {\n            proxyOwner();\n        } else if (0x3659cfe6 == function_selector >> 224) {\n            upgradeTo(address);\n        } else if (0x4f1ef286 == function_selector >> 224) {\n            upgradeToAndCall(address,bytes);\n        } else if (0x5c60da1b == function_selector >> 224) {\n            implementation();\n        } else if (0x8a73acdc == function_selector >> 224) {\n            returnInitialiseData(address);\n        } else if (0xf1739cae == function_selector >> 224) {\n            transferProxyOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 30.165396213531494,
	"usage": {
		"completion_tokens": 598,
		"prompt_tokens": 1348,
		"total_tokens": 1946
	}
}