{
	"address": "0x8937a0ab96e07edbd93cbd473174fe9b147cda4f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, here is the Solidity contract code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    event Paused();\n    event Unpaused();\n    event OwnershipAccepted(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    address private _owner;\n    address private _acceptOwnership;\n    address private _vOKEN;\n    address private _pUBLIC_SALE;\n    uint256 private _txs;\n    bool private _paused;\n\n    constructor() public {\n        _owner = msg.sender;\n        _paused = false;\n    }\n\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function setPaused(bool paused) public onlyOwner {\n        _paused = paused;\n        if (_paused) {\n            emit Paused();\n        } else {\n            emit Unpaused();\n        }\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    function txs() public view returns (uint256) {\n        return _txs;\n    }\n\n    function withdrawEther(address payable recipient, uint256 amount) public onlyOwner {\n        require(address(this).balance >= amount, \"Withdraw: amount exceeds balance\");\n        recipient.transfer(amount);\n    }\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    function PUBLIC_SALE() public view returns (address) {\n        return _pUBLIC_SALE;\n    }\n\n    function acceptOwnership() public {\n        require(msg.sender == _acceptOwnership, 'Ownable: caller is not the new owner address');\n        emit OwnershipAccepted(_owner, _acceptOwnership);\n        _owner = _acceptOwnership;\n        _acceptOwnership = address(0);\n    }\n\n    function owner() public view returns (address, address) {\n        return (_owner, _acceptOwnership);\n    }\n\n    function VOKEN() public view returns (address) {\n        return _vOKEN;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        _acceptOwnership = newOwner;\n        emit OwnershipTransferred(_owner, newOwner);\n    }\n\n    function() external payable {\n        require(!_paused, 'Paused');\n        // add your fallback code here\n    }\n}\n```\n\nPlease note that the ERC20 token interaction code (rescueTokens and fallback function) is omitted since the decompiled code is not clear enough to recover this part.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459400,
	"id": "chatcmpl-8R3bUyFMCpZ9gFU27vSfOWIt4Hy2E",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 06:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 _txs; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _acceptOwnership; // STORAGE[0x1] bytes 0 to 19\naddress _vOKEN; // STORAGE[0x2] bytes 0 to 19\naddress _pUBLIC_SALE; // STORAGE[0x3] bytes 0 to 19\nuint8 _paused; // STORAGE[0x1] bytes 20 to 20\n\n// Events\nPaused();\nUnpaused();\nOwnershipAccepted(address, address);\nOwnershipTransferred(address, address);\n\nfunction setPaused(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    _paused = varg0;\n    if (!_paused) {\n        emit Unpaused();\n    } else {\n        emit Paused();\n    }\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return varg0 == _owner;\n}\n\nfunction txs() public nonPayable { \n    return _txs;\n}\n\nfunction withdrawEther(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg0, 'Withdraw: recipient is the zero address');\n    require(this.balance >= varg1, 'Withdraw: amount exceeds balance');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction PUBLIC_SALE() public nonPayable { \n    return _pUBLIC_SALE;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _acceptOwnership, 'Ownable: caller is not the new owner address');\n    require(msg.sender, 'Ownable: caller is the zero address');\n    emit OwnershipAccepted(_owner, msg.sender);\n    _owner = msg.sender;\n    _acceptOwnership = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner, _acceptOwnership;\n}\n\nfunction VOKEN() public nonPayable { \n    return _vOKEN;\n}\n\nfunction rescueTokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg1, 'Rescue: recipient is the zero address');\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 >= varg2, 'Rescue: amount exceeds balance');\n    require(varg0.code.size);\n    v2 = varg0.transfer(varg1, varg2).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg0, 'Ownable: new owner is the zero address');\n    emit OwnershipTransferred(_owner, varg0);\n    _acceptOwnership = varg0;\n}\n\nfunction 0x751(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(!_paused, 'Paused');\n    require(msg.value >= stor_4, 'Get1001Voken2: sent less than 1 ether');\n    require(_vOKEN.code.size);\n    v0, v1 = _vOKEN.balanceOf(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 <= 0, 'Get1001Voken2: balance is greater than zero');\n    require(_vOKEN.code.size);\n    v2, v3 = _vOKEN.whitelisted(msg.sender).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v3, 'Get1001Voken2: already whitelisted');\n    require(!(0xff & owner_7[msg.sender]), 'Get1001Voken2: had got already');\n    require(_pUBLIC_SALE.code.size);\n    v4 = _pUBLIC_SALE.status().gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 160);\n    v5 = v6 = MEM['SafeMath: division by zero' + 64];\n    v7 = v8 = 927;\n    v5 = v9 = 10;\n    v10 = v11 = 0x751(8, MEM['SafeMath: division by zero' + 96]);\n    while (!v5) {\n        if (!v5) {\n            v12 = new array[](v13.length);\n            v14 = v15 = 0;\n            while (v14 < v13.length) {\n                MEM[v14 + v12.data] = MEM[v14 + v16.data];\n                v14 += 32;\n            }\n            if (26) {\n                MEM[v12.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v12);\n        }\n        if (v5) {\n            break;\n        }\n        assert(v5);\n        require(msg.value >= v5, 'Get1001Voken2: ether is not enough');\n        require(1 + _txs >= _txs, 'SafeMath: addition overflow');\n        _txs += 1;\n        owner_7[msg.sender] = 0x1 | ~0xff & owner_7[msg.sender];\n        if (v5 <= msg.value) {\n            v17 = msg.sender.call().value(msg.value - v5).gas(2300 * !(msg.value - v5));\n            require(v17); // checks call status, propagates error data on error\n            MEM[MEM[64] + 4] = msg.sender;\n            require(_vOKEN.code.size);\n            v18, v19 = _vOKEN.mint(msg.sender, stor_5).gas(msg.gas);\n            require(v18); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v19);\n            exit;\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v20 = new array[](v21.length);\n            if (v21.length) {\n                v22 = v21.data;\n                v23 = v24 = 32;\n                while (v23 < v21.length) {\n                    MEM[v23 + v20.data] = MEM[v23 + v21.data];\n                    v23 += 32;\n                }\n            }\n            if (30) {\n                MEM[v20.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v20);\n        }\n        v5 = v10 / v5;\n        goto {'0x41e', '0x39f', '0x3fe'};\n        require(v5 > 0, 'Voken2PublicSale2: empty ether price');\n        v7 = v25 = 1022;\n        v5 = v26 = 0xf4240;\n        v10 = 0x751(v5, stor_5);\n        v7 = v27 = 1054;\n        v10 = 0x751(0xde0b6b3a7640000, v5);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5f89584e > function_selector >> 224) {\n            if (0x16c38b3c == function_selector >> 224) {\n                setPaused(bool);\n            } else if (0x2f54bf6e == function_selector >> 224) {\n                isOwner(address);\n            } else if (0x4fb30d8b == function_selector >> 224) {\n                txs();\n            } else if (0x522f6815 == function_selector >> 224) {\n                withdrawEther(address,uint256);\n            } else if (0x5c975abb == function_selector >> 224) {\n                paused();\n            }\n        } else if (0x5f89584e == function_selector >> 224) {\n            PUBLIC_SALE();\n        } else if (0x79ba5097 == function_selector >> 224) {\n            acceptOwnership();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x9b28fa7b == function_selector >> 224) {\n            VOKEN();\n        } else if (0xcea9d26f == function_selector >> 224) {\n            rescueTokens(address,address,uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 06:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 _txs; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _acceptOwnership; // STORAGE[0x1] bytes 0 to 19\naddress _vOKEN; // STORAGE[0x2] bytes 0 to 19\naddress _pUBLIC_SALE; // STORAGE[0x3] bytes 0 to 19\nuint8 _paused; // STORAGE[0x1] bytes 20 to 20\n\n// Events\nPaused();\nUnpaused();\nOwnershipAccepted(address, address);\nOwnershipTransferred(address, address);\n\nfunction setPaused(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    _paused = varg0;\n    if (!_paused) {\n        emit Unpaused();\n    } else {\n        emit Paused();\n    }\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return varg0 == _owner;\n}\n\nfunction txs() public nonPayable { \n    return _txs;\n}\n\nfunction withdrawEther(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg0, 'Withdraw: recipient is the zero address');\n    require(this.balance >= varg1, 'Withdraw: amount exceeds balance');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction PUBLIC_SALE() public nonPayable { \n    return _pUBLIC_SALE;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _acceptOwnership, 'Ownable: caller is not the new owner address');\n    require(msg.sender, 'Ownable: caller is the zero address');\n    emit OwnershipAccepted(_owner, msg.sender);\n    _owner = msg.sender;\n    _acceptOwnership = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner, _acceptOwnership;\n}\n\nfunction VOKEN() public nonPayable { \n    return _vOKEN;\n}\n\nfunction rescueTokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg1, 'Rescue: recipient is the zero address');\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 >= varg2, 'Rescue: amount exceeds balance');\n    require(varg0.code.size);\n    v2 = varg0.transfer(varg1, varg2).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg0, 'Ownable: new owner is the zero address');\n    emit OwnershipTransferred(_owner, varg0);\n    _acceptOwnership = varg0;\n}\n\nfunction 0x751(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(!_paused, 'Paused');\n    require(msg.value >= stor_4, 'Get1001Voken2: sent less than 1 ether');\n    require(_vOKEN.code.size);\n    v0, v1 = _vOKEN.balanceOf(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 <= 0, 'Get1001Voken2: balance is greater than zero');\n    require(_vOKEN.code.size);\n    v2, v3 = _vOKEN.whitelisted(msg.sender).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v3, 'Get1001Voken2: already whitelisted');\n    require(!(0xff & owner_7[msg.sender]), 'Get1001Voken2: had got already');\n    require(_pUBLIC_SALE.code.size);\n    v4 = _pUBLIC_SALE.status().gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 160);\n    v5 = v6 = MEM['SafeMath: division by zero' + 64];\n    v7 = v8 = 927;\n    v5 = v9 = 10;\n    v10 = v11 = 0x751(8, MEM['SafeMath: division by zero' + 96]);\n    while (!v5) {\n        if (!v5) {\n            v12 = new array[](v13.length);\n            v14 = v15 = 0;\n            while (v14 < v13.length) {\n                MEM[v14 + v12.data] = MEM[v14 + v16.data];\n                v14 += 32;\n            }\n            if (26) {\n                MEM[v12.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v12);\n        }\n        if (v5) {\n            break;\n        }\n        assert(v5);\n        require(msg.value >= v5, 'Get1001Voken2: ether is not enough');\n        require(1 + _txs >= _txs, 'SafeMath: addition overflow');\n        _txs += 1;\n        owner_7[msg.sender] = 0x1 | ~0xff & owner_7[msg.sender];\n        if (v5 <= msg.value) {\n            v17 = msg.sender.call().value(msg.value - v5).gas(2300 * !(msg.value - v5));\n            require(v17); // checks call status, propagates error data on error\n            MEM[MEM[64] + 4] = msg.sender;\n            require(_vOKEN.code.size);\n            v18, v19 = _vOKEN.mint(msg.sender, stor_5).gas(msg.gas);\n            require(v18); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v19);\n            exit;\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v20 = new array[](v21.length);\n            if (v21.length) {\n                v22 = v21.data;\n                v23 = v24 = 32;\n                while (v23 < v21.length) {\n                    MEM[v23 + v20.data] = MEM[v23 + v21.data];\n                    v23 += 32;\n                }\n            }\n            if (30) {\n                MEM[v20.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v20);\n        }\n        v5 = v10 / v5;\n        goto {'0x41e', '0x39f', '0x3fe'};\n        require(v5 > 0, 'Voken2PublicSale2: empty ether price');\n        v7 = v25 = 1022;\n        v5 = v26 = 0xf4240;\n        v10 = 0x751(v5, stor_5);\n        v7 = v27 = 1054;\n        v10 = 0x751(0xde0b6b3a7640000, v5);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5f89584e > function_selector >> 224) {\n            if (0x16c38b3c == function_selector >> 224) {\n                setPaused(bool);\n            } else if (0x2f54bf6e == function_selector >> 224) {\n                isOwner(address);\n            } else if (0x4fb30d8b == function_selector >> 224) {\n                txs();\n            } else if (0x522f6815 == function_selector >> 224) {\n                withdrawEther(address,uint256);\n            } else if (0x5c975abb == function_selector >> 224) {\n                paused();\n            }\n        } else if (0x5f89584e == function_selector >> 224) {\n            PUBLIC_SALE();\n        } else if (0x79ba5097 == function_selector >> 224) {\n            acceptOwnership();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x9b28fa7b == function_selector >> 224) {\n            VOKEN();\n        } else if (0xcea9d26f == function_selector >> 224) {\n            rescueTokens(address,address,uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 06:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_4; // STORAGE[0x4]\nuint256 stor_5; // STORAGE[0x5]\nuint256 _txs; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _acceptOwnership; // STORAGE[0x1] bytes 0 to 19\naddress _vOKEN; // STORAGE[0x2] bytes 0 to 19\naddress _pUBLIC_SALE; // STORAGE[0x3] bytes 0 to 19\nuint8 _paused; // STORAGE[0x1] bytes 20 to 20\n\n// Events\nPaused();\nUnpaused();\nOwnershipAccepted(address, address);\nOwnershipTransferred(address, address);\n\nfunction setPaused(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    _paused = varg0;\n    if (!_paused) {\n        emit Unpaused();\n    } else {\n        emit Paused();\n    }\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return varg0 == _owner;\n}\n\nfunction txs() public nonPayable { \n    return _txs;\n}\n\nfunction withdrawEther(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg0, 'Withdraw: recipient is the zero address');\n    require(this.balance >= varg1, 'Withdraw: amount exceeds balance');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction PUBLIC_SALE() public nonPayable { \n    return _pUBLIC_SALE;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _acceptOwnership, 'Ownable: caller is not the new owner address');\n    require(msg.sender, 'Ownable: caller is the zero address');\n    emit OwnershipAccepted(_owner, msg.sender);\n    _owner = msg.sender;\n    _acceptOwnership = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner, _acceptOwnership;\n}\n\nfunction VOKEN() public nonPayable { \n    return _vOKEN;\n}\n\nfunction rescueTokens(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg1, 'Rescue: recipient is the zero address');\n    require(varg0.code.size);\n    v0, v1 = varg0.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 >= varg2, 'Rescue: amount exceeds balance');\n    require(varg0.code.size);\n    v2 = varg0.transfer(varg1, varg2).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'Ownable: caller is not the owner');\n    require(varg0, 'Ownable: new owner is the zero address');\n    emit OwnershipTransferred(_owner, varg0);\n    _acceptOwnership = varg0;\n}\n\nfunction 0x751(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    require(!_paused, 'Paused');\n    require(msg.value >= stor_4, 'Get1001Voken2: sent less than 1 ether');\n    require(_vOKEN.code.size);\n    v0, v1 = _vOKEN.balanceOf(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1 <= 0, 'Get1001Voken2: balance is greater than zero');\n    require(_vOKEN.code.size);\n    v2, v3 = _vOKEN.whitelisted(msg.sender).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(!v3, 'Get1001Voken2: already whitelisted');\n    require(!(0xff & owner_7[msg.sender]), 'Get1001Voken2: had got already');\n    require(_pUBLIC_SALE.code.size);\n    v4 = _pUBLIC_SALE.status().gas(msg.gas);\n    require(v4); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 160);\n    v5 = v6 = MEM['SafeMath: division by zero' + 64];\n    v7 = v8 = 927;\n    v5 = v9 = 10;\n    v10 = v11 = 0x751(8, MEM['SafeMath: division by zero' + 96]);\n    while (!v5) {\n        if (!v5) {\n            v12 = new array[](v13.length);\n            v14 = v15 = 0;\n            while (v14 < v13.length) {\n                MEM[v14 + v12.data] = MEM[v14 + v16.data];\n                v14 += 32;\n            }\n            if (26) {\n                MEM[v12.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n            }\n            revert(v12);\n        }\n        if (v5) {\n            break;\n        }\n        assert(v5);\n        require(msg.value >= v5, 'Get1001Voken2: ether is not enough');\n        require(1 + _txs >= _txs, 'SafeMath: addition overflow');\n        _txs += 1;\n        owner_7[msg.sender] = 0x1 | ~0xff & owner_7[msg.sender];\n        if (v5 <= msg.value) {\n            v17 = msg.sender.call().value(msg.value - v5).gas(2300 * !(msg.value - v5));\n            require(v17); // checks call status, propagates error data on error\n            MEM[MEM[64] + 4] = msg.sender;\n            require(_vOKEN.code.size);\n            v18, v19 = _vOKEN.mint(msg.sender, stor_5).gas(msg.gas);\n            require(v18); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            assert(v19);\n            exit;\n        } else {\n            MEM[MEM[64] + 4] = 32;\n            v20 = new array[](v21.length);\n            if (v21.length) {\n                v22 = v21.data;\n                v23 = v24 = 32;\n                while (v23 < v21.length) {\n                    MEM[v23 + v20.data] = MEM[v23 + v21.data];\n                    v23 += 32;\n                }\n            }\n            if (30) {\n                MEM[v20.data] = ~0xffff & 'SafeMath: subtraction overflow';\n            }\n            revert(v20);\n        }\n        v5 = v10 / v5;\n        goto {'0x41e', '0x39f', '0x3fe'};\n        require(v5 > 0, 'Voken2PublicSale2: empty ether price');\n        v7 = v25 = 1022;\n        v5 = v26 = 0xf4240;\n        v10 = 0x751(v5, stor_5);\n        v7 = v27 = 1054;\n        v10 = 0x751(0xde0b6b3a7640000, v5);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5f89584e > function_selector >> 224) {\n            if (0x16c38b3c == function_selector >> 224) {\n                setPaused(bool);\n            } else if (0x2f54bf6e == function_selector >> 224) {\n                isOwner(address);\n            } else if (0x4fb30d8b == function_selector >> 224) {\n                txs();\n            } else if (0x522f6815 == function_selector >> 224) {\n                withdrawEther(address,uint256);\n            } else if (0x5c975abb == function_selector >> 224) {\n                paused();\n            }\n        } else if (0x5f89584e == function_selector >> 224) {\n            PUBLIC_SALE();\n        } else if (0x79ba5097 == function_selector >> 224) {\n            acceptOwnership();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x9b28fa7b == function_selector >> 224) {\n            VOKEN();\n        } else if (0xcea9d26f == function_selector >> 224) {\n            rescueTokens(address,address,uint256);\n        } else if (0xf2fde38b == function_selector >> 224) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 18.5051429271698,
	"usage": {
		"completion_tokens": 519,
		"prompt_tokens": 2342,
		"total_tokens": 2861
	}
}