{
	"address": "0x219218f117dc9348b358b8471c55a073e5e0da0b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity version of the contract described in the decompiled code.\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MyContract {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    mapping (address => bool) public frozen;\n    mapping (address => bool) public admins;\n    mapping (address => bool) public canTrade;\n    mapping (address => bool) public userRewarderCount;\n    mapping (address => uint256) public totalLockedRewardsOf;\n    mapping (address => uint256) public lockedRewardsOf;\n    mapping (address => uint256) public userRewardCount;\n    mapping (address => uint256) public totalRewardIssuedOut;\n    \n    uint256 public totalSupply;\n    uint256 public sellPrice;\n    uint256 public buyPrice;\n    address public owner;\n    uint8 public decimals;\n    bool public usersCanTrade;\n    bool public usersCanUnfreeze;\n    bool public ico;\n    string public name;\n    string public symbol;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event Reward(address indexed from, address indexed to, uint256 value, string message, uint256 timestamp);\n    event Withdrawn(address indexed to, uint256 value);\n    event Frozen(address indexed target, bool frozen);\n    event Unlock(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, address centralMinter) public {\n        if(centralMinter != address(0)) owner = msg.sender;\n        else owner = centralMinter;\n        totalSupply = initialSupply;\n        balanceOf[msg.sender] = initialSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n    }\n\n    // Other function declarations as per the decompiled code\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public {\n        require(msg.sender == owner);\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n    }\n\n    function freezeAccount(address target, bool freeze) public {\n        require(msg.sender == owner);\n        frozen[target] = freeze;\n        emit Frozen(target, freeze);\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        require(balanceOf[msg.sender] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n    }\n\n    // and so on...\n}\n```\n\nThis Solidity version of the contract has similar functionality to the decompiled code, but the function names and arguments may differ. Also, note that due to the decompilation process, some details (like function visibility) might not be fully accurate.",
				"role": "assistant"
			}
		}
	],
	"created": 1701467752,
	"id": "chatcmpl-8R5mC36llSskQlxHg82z7v1oGKzJU",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 23:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x1]\nuint256[] _name; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _admin; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _frozen; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _canTrade; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _totalLockedRewardsOf; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _lockedRewardsOf; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _userRewarders; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _userRewardCount; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _userRewarderCount; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _totalRewardIssuedOut; // STORAGE[0x12]\nuint256 _sellPrice; // STORAGE[0x13]\nuint256 _buyPrice; // STORAGE[0x14]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\nuint8 _usersCanTrade; // STORAGE[0x7] bytes 0 to 0\nuint8 _usersCanUnfreeze; // STORAGE[0x7] bytes 1 to 1\nuint8 _ico; // STORAGE[0x7] bytes 2 to 2\n\n// Events\nTransfer(address, address, uint256);\nUnlock(address, address, uint256);\nBurn(address, uint256);\nReward(address, address, uint256, string, uint256);\nWithdrawn(address, uint256);\nFrozen(address, bool);\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x2d66(uint256 varg0, uint256 varg1) private { \n    if (!varg0) {\n        varg0 = v0 = !varg0;\n        if (v0) {\n            varg0 = v1 = !_usersCanUnfreeze;\n        }\n    }\n    if (varg0) {\n        require(0xff & _admin[msg.sender]);\n    }\n    v2 = address(varg1);\n    _frozen[v2] = varg0 | ~0xff & _frozen[v2];\n    v3 = varg0;\n    emit Frozen(address(varg1), v3);\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction 0x316b(uint256 varg0) private { \n    require(!(0xff & _frozen[msg.sender]));\n    v0 = v1 = !_usersCanTrade;\n    if (!_usersCanTrade) {\n        v0 = v2 = !(0xff & _canTrade[msg.sender]);\n    }\n    if (v0) {\n        assert(_sellPrice);\n        require(stor_6 > varg0 / _sellPrice);\n    }\n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[address(this)] = _balanceOf[address(this)] + varg0;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(_sellPrice);\n    v3 = varg0 / _sellPrice;\n    v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n    require(v4);\n    emit Transfer(msg.sender, address(this), varg0);\n    return v3;\n}\n\nfunction transferReward(address varg0, uint256 varg1) public nonPayable { \n    require(!(0xff & _frozen[msg.sender]));\n    require(_lockedRewardsOf[varg0] >= varg1);\n    require(_totalLockedRewardsOf[msg.sender] >= varg1);\n    if (msg.sender.balance < stor_6) {\n        v0 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    _totalLockedRewardsOf[msg.sender] = _totalLockedRewardsOf[msg.sender] - varg1;\n    _lockedRewardsOf[varg0] = _lockedRewardsOf[varg0] - varg1;\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction 0x361d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(!(0xff & _frozen[v0]));\n    v1 = address(varg2);\n    require(_balanceOf[v1] >= varg0);\n    v2 = address(varg1);\n    v3 = address(varg1);\n    require(_balanceOf[v3] + varg0 > _balanceOf[v2]);\n    v4 = address(varg2);\n    _balanceOf[v4] = _balanceOf[v4] - varg0;\n    v5 = address(varg1);\n    _balanceOf[v5] = _balanceOf[v5] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction setCanTrade(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _canTrade[varg0] = varg1 | ~0xff & _canTrade[varg0];\n}\n\nfunction unlockReward(address varg0, uint256 varg1) public nonPayable { \n    require(_totalLockedRewardsOf[varg0] > varg1);\n    require(_lockedRewardsOf[msg.sender] >= varg1);\n    if (varg1 == 0) {\n        v0 = v1 = _lockedRewardsOf[msg.sender];\n    }\n    if (msg.sender.balance < stor_6) {\n        v2 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    _totalLockedRewardsOf[varg0] = _totalLockedRewardsOf[varg0] - v0;\n    _lockedRewardsOf[msg.sender] = _lockedRewardsOf[msg.sender] - v0;\n    _balanceOf[varg0] = _balanceOf[varg0] + v0;\n    emit Unlock(varg0, msg.sender, v0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(!(0xff & _frozen[varg0]));\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x361d(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction makeAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction usersCanUnfreeze() public nonPayable { \n    return _usersCanUnfreeze;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admin[varg0] = varg1 | ~0xff & _admin[varg0];\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction canTrade(address varg0) public nonPayable { \n    return 0xff & _canTrade[varg0];\n}\n\nfunction ico() public nonPayable { \n    return _ico;\n}\n\nfunction usersCanTrade() public nonPayable { \n    return _usersCanTrade;\n}\n\nfunction admin(address varg0) public nonPayable { \n    return 0xff & _admin[varg0];\n}\n\nfunction totalRewardIssuedOut(address varg0) public nonPayable { \n    return _totalRewardIssuedOut[varg0];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[varg0] >= varg1);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction reward(address varg0, uint256 varg1, bool varg2, string varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    require(varg0 != 0);\n    require(!(0xff & _frozen[msg.sender]));\n    if (msg.sender.balance < stor_6) {\n        v1 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    if (varg2) {\n        require(_balanceOf[msg.sender] >= varg1);\n        require(_totalLockedRewardsOf[varg0] + varg1 > _totalLockedRewardsOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + varg1;\n        if (uint32(_userRewardCount[address(address(msg.sender))]) == 0) {\n            _userRewarderCount[varg0] = uint32(uint32(_userRewarderCount[address(address(varg0))]) + 1) | ~0xffffffff & _userRewarderCount[varg0];\n            _userRewarders[uint32(_userRewarders[address(address(varg0))])] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _userRewarders[uint32(_userRewarders[address(address(varg0))])];\n        }\n        _userRewardCount[msg.sender] = uint32(uint32(_userRewardCount[address(address(msg.sender))]) + 1) | ~0xffffffff & _userRewardCount[msg.sender];\n        _userRewardCount[msg.sender] = _userRewardCount[msg.sender] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    } else {\n        0x361d(varg1, varg0, msg.sender);\n    }\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v2.data + v3] = MEM[v0.data + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    emit Reward(msg.sender, varg0, varg1, v2, block.timestamp);\n}\n\nfunction transferAndFreeze(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _admins[msg.sender] == 1);\n    0x361d(varg1, varg0, msg.sender);\n    0x2d66(1, varg0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction userRewarderCount(address varg0) public nonPayable { \n    return uint32(_userRewarderCount[varg0]);\n}\n\nfunction buy() public payable { \n    v0 = v1 = !_usersCanTrade;\n    if (!_usersCanTrade) {\n        v0 = !(0xff & _canTrade[msg.sender]);\n    }\n    require(!v0);\n    require(_balanceOf[address(this)] >= msg.value * _buyPrice);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _buyPrice;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - msg.value * _buyPrice;\n    emit Transfer(address(this), msg.sender, msg.value * _buyPrice);\n    return msg.value * _buyPrice;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = 0xff & _admin[msg.sender];\n    if (!v1) {\n        v0 = !_ico;\n    }\n    require(v0);\n    require(!(0xff & _frozen[msg.sender]));\n    if (msg.sender.balance < stor_6) {\n        v2 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    0x361d(varg1, varg0, msg.sender);\n}\n\nfunction totalLockedRewardsOf(address varg0) public nonPayable { \n    return _totalLockedRewardsOf[varg0];\n}\n\nfunction increaseTotalSupply(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    emit Transfer(0, _owner, varg1);\n    emit Transfer(_owner, varg0, varg1);\n}\n\nfunction lockedRewardsOf(address varg0, address varg1) public nonPayable { \n    return _lockedRewardsOf[varg1];\n}\n\nfunction freeze(address varg0, bool varg1) public nonPayable { \n    0x2d66(varg1, varg0);\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    stor_6 = varg0;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    v1 = v2 = 0;\n    require(msg.sender == _owner);\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas - 710);\n        require(v8);\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction userRewarders(address varg0, uint32 varg1) public nonPayable { \n    return address(_userRewarders[varg1]);\n}\n\nfunction frozen(address varg0) public nonPayable { \n    return 0xff & _frozen[varg0];\n}\n\nfunction setUsersCanTrade(bool varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _usersCanTrade = varg0;\n}\n\nfunction userRewardCount(address varg0, address varg1) public nonPayable { \n    return uint32(_userRewardCount[varg1]);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    v0 = 0x316b(varg0);\n    return v0;\n}\n\nfunction setICO(bool varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _ico = varg0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0);\n    emit Withdrawn(varg0, varg1);\n}\n\nfunction usersCanUnFreeze(bool varg0) public nonPayable { \n    _usersCanUnfreeze = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x15490ebb == function_selector) {\n            transferReward(address,uint256);\n        } else if (0x15c32297 == function_selector) {\n            setCanTrade(address,bool);\n        } else if (0x1631eb07 == function_selector) {\n            unlockReward(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x40a57cb8 == function_selector) {\n            makeAdmin(address,bool);\n        } else if (0x41282fe0 == function_selector) {\n            usersCanUnfreeze();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x429b62e5 == function_selector) {\n            admins(address);\n        } else if (0x4b0bddd2 == function_selector) {\n            setAdmin(address,bool);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x559f05dc == function_selector) {\n            canTrade(address);\n        } else if (0x5d452201 == function_selector) {\n            ico();\n        } else if (0x5dd4599a == function_selector) {\n            usersCanTrade();\n        } else if (0x63a846f8 == function_selector) {\n            admin(address);\n        } else if (0x6f58659b == function_selector) {\n            totalRewardIssuedOut(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8d60e30b == function_selector) {\n            reward(address,uint256,bool,string);\n        } else if (0x8d995f94 == function_selector) {\n            transferAndFreeze(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa5fb929a == function_selector) {\n            userRewarderCount(address);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xaab60ebc == function_selector) {\n            totalLockedRewardsOf(address);\n        } else if (0xb2aa9f0f == function_selector) {\n            increaseTotalSupply(address,uint256);\n        } else if (0xb5a1a64b == function_selector) {\n            lockedRewardsOf(address,address);\n        } else if (0xbf120ae5 == function_selector) {\n            freeze(address,bool);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcc5cab33 == function_selector) {\n            userRewarders(address,uint32);\n        } else if (0xd0516650 == function_selector) {\n            frozen(address);\n        } else if (0xd15ee9ff == function_selector) {\n            setUsersCanTrade(bool);\n        } else if (0xd75b363f == function_selector) {\n            userRewardCount(address,address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xed9beb05 == function_selector) {\n            setICO(bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf58d3321 == function_selector) {\n            usersCanUnFreeze(bool);\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 23:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x1]\nuint256[] _name; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _admin; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _frozen; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _canTrade; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _totalLockedRewardsOf; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _lockedRewardsOf; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _userRewarders; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _userRewardCount; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _userRewarderCount; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _totalRewardIssuedOut; // STORAGE[0x12]\nuint256 _sellPrice; // STORAGE[0x13]\nuint256 _buyPrice; // STORAGE[0x14]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\nuint8 _usersCanTrade; // STORAGE[0x7] bytes 0 to 0\nuint8 _usersCanUnfreeze; // STORAGE[0x7] bytes 1 to 1\nuint8 _ico; // STORAGE[0x7] bytes 2 to 2\n\n// Events\nTransfer(address, address, uint256);\nUnlock(address, address, uint256);\nBurn(address, uint256);\nReward(address, address, uint256, string, uint256);\nWithdrawn(address, uint256);\nFrozen(address, bool);\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x2d66(uint256 varg0, uint256 varg1) private { \n    if (!varg0) {\n        varg0 = v0 = !varg0;\n        if (v0) {\n            varg0 = v1 = !_usersCanUnfreeze;\n        }\n    }\n    if (varg0) {\n        require(0xff & _admin[msg.sender]);\n    }\n    v2 = address(varg1);\n    _frozen[v2] = varg0 | ~0xff & _frozen[v2];\n    v3 = varg0;\n    emit Frozen(address(varg1), v3);\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction 0x316b(uint256 varg0) private { \n    require(!(0xff & _frozen[msg.sender]));\n    v0 = v1 = !_usersCanTrade;\n    if (!_usersCanTrade) {\n        v0 = v2 = !(0xff & _canTrade[msg.sender]);\n    }\n    if (v0) {\n        assert(_sellPrice);\n        require(stor_6 > varg0 / _sellPrice);\n    }\n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[address(this)] = _balanceOf[address(this)] + varg0;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(_sellPrice);\n    v3 = varg0 / _sellPrice;\n    v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n    require(v4);\n    emit Transfer(msg.sender, address(this), varg0);\n    return v3;\n}\n\nfunction transferReward(address varg0, uint256 varg1) public nonPayable { \n    require(!(0xff & _frozen[msg.sender]));\n    require(_lockedRewardsOf[varg0] >= varg1);\n    require(_totalLockedRewardsOf[msg.sender] >= varg1);\n    if (msg.sender.balance < stor_6) {\n        v0 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    _totalLockedRewardsOf[msg.sender] = _totalLockedRewardsOf[msg.sender] - varg1;\n    _lockedRewardsOf[varg0] = _lockedRewardsOf[varg0] - varg1;\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction 0x361d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(!(0xff & _frozen[v0]));\n    v1 = address(varg2);\n    require(_balanceOf[v1] >= varg0);\n    v2 = address(varg1);\n    v3 = address(varg1);\n    require(_balanceOf[v3] + varg0 > _balanceOf[v2]);\n    v4 = address(varg2);\n    _balanceOf[v4] = _balanceOf[v4] - varg0;\n    v5 = address(varg1);\n    _balanceOf[v5] = _balanceOf[v5] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction setCanTrade(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _canTrade[varg0] = varg1 | ~0xff & _canTrade[varg0];\n}\n\nfunction unlockReward(address varg0, uint256 varg1) public nonPayable { \n    require(_totalLockedRewardsOf[varg0] > varg1);\n    require(_lockedRewardsOf[msg.sender] >= varg1);\n    if (varg1 == 0) {\n        v0 = v1 = _lockedRewardsOf[msg.sender];\n    }\n    if (msg.sender.balance < stor_6) {\n        v2 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    _totalLockedRewardsOf[varg0] = _totalLockedRewardsOf[varg0] - v0;\n    _lockedRewardsOf[msg.sender] = _lockedRewardsOf[msg.sender] - v0;\n    _balanceOf[varg0] = _balanceOf[varg0] + v0;\n    emit Unlock(varg0, msg.sender, v0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(!(0xff & _frozen[varg0]));\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x361d(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction makeAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction usersCanUnfreeze() public nonPayable { \n    return _usersCanUnfreeze;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admin[varg0] = varg1 | ~0xff & _admin[varg0];\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction canTrade(address varg0) public nonPayable { \n    return 0xff & _canTrade[varg0];\n}\n\nfunction ico() public nonPayable { \n    return _ico;\n}\n\nfunction usersCanTrade() public nonPayable { \n    return _usersCanTrade;\n}\n\nfunction admin(address varg0) public nonPayable { \n    return 0xff & _admin[varg0];\n}\n\nfunction totalRewardIssuedOut(address varg0) public nonPayable { \n    return _totalRewardIssuedOut[varg0];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[varg0] >= varg1);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction reward(address varg0, uint256 varg1, bool varg2, string varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    require(varg0 != 0);\n    require(!(0xff & _frozen[msg.sender]));\n    if (msg.sender.balance < stor_6) {\n        v1 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    if (varg2) {\n        require(_balanceOf[msg.sender] >= varg1);\n        require(_totalLockedRewardsOf[varg0] + varg1 > _totalLockedRewardsOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + varg1;\n        if (uint32(_userRewardCount[address(address(msg.sender))]) == 0) {\n            _userRewarderCount[varg0] = uint32(uint32(_userRewarderCount[address(address(varg0))]) + 1) | ~0xffffffff & _userRewarderCount[varg0];\n            _userRewarders[uint32(_userRewarders[address(address(varg0))])] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _userRewarders[uint32(_userRewarders[address(address(varg0))])];\n        }\n        _userRewardCount[msg.sender] = uint32(uint32(_userRewardCount[address(address(msg.sender))]) + 1) | ~0xffffffff & _userRewardCount[msg.sender];\n        _userRewardCount[msg.sender] = _userRewardCount[msg.sender] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    } else {\n        0x361d(varg1, varg0, msg.sender);\n    }\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v2.data + v3] = MEM[v0.data + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    emit Reward(msg.sender, varg0, varg1, v2, block.timestamp);\n}\n\nfunction transferAndFreeze(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _admins[msg.sender] == 1);\n    0x361d(varg1, varg0, msg.sender);\n    0x2d66(1, varg0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction userRewarderCount(address varg0) public nonPayable { \n    return uint32(_userRewarderCount[varg0]);\n}\n\nfunction buy() public payable { \n    v0 = v1 = !_usersCanTrade;\n    if (!_usersCanTrade) {\n        v0 = !(0xff & _canTrade[msg.sender]);\n    }\n    require(!v0);\n    require(_balanceOf[address(this)] >= msg.value * _buyPrice);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _buyPrice;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - msg.value * _buyPrice;\n    emit Transfer(address(this), msg.sender, msg.value * _buyPrice);\n    return msg.value * _buyPrice;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = 0xff & _admin[msg.sender];\n    if (!v1) {\n        v0 = !_ico;\n    }\n    require(v0);\n    require(!(0xff & _frozen[msg.sender]));\n    if (msg.sender.balance < stor_6) {\n        v2 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    0x361d(varg1, varg0, msg.sender);\n}\n\nfunction totalLockedRewardsOf(address varg0) public nonPayable { \n    return _totalLockedRewardsOf[varg0];\n}\n\nfunction increaseTotalSupply(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    emit Transfer(0, _owner, varg1);\n    emit Transfer(_owner, varg0, varg1);\n}\n\nfunction lockedRewardsOf(address varg0, address varg1) public nonPayable { \n    return _lockedRewardsOf[varg1];\n}\n\nfunction freeze(address varg0, bool varg1) public nonPayable { \n    0x2d66(varg1, varg0);\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    stor_6 = varg0;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    v1 = v2 = 0;\n    require(msg.sender == _owner);\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas - 710);\n        require(v8);\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction userRewarders(address varg0, uint32 varg1) public nonPayable { \n    return address(_userRewarders[varg1]);\n}\n\nfunction frozen(address varg0) public nonPayable { \n    return 0xff & _frozen[varg0];\n}\n\nfunction setUsersCanTrade(bool varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _usersCanTrade = varg0;\n}\n\nfunction userRewardCount(address varg0, address varg1) public nonPayable { \n    return uint32(_userRewardCount[varg1]);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    v0 = 0x316b(varg0);\n    return v0;\n}\n\nfunction setICO(bool varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _ico = varg0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0);\n    emit Withdrawn(varg0, varg1);\n}\n\nfunction usersCanUnFreeze(bool varg0) public nonPayable { \n    _usersCanUnfreeze = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x15490ebb == function_selector) {\n            transferReward(address,uint256);\n        } else if (0x15c32297 == function_selector) {\n            setCanTrade(address,bool);\n        } else if (0x1631eb07 == function_selector) {\n            unlockReward(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x40a57cb8 == function_selector) {\n            makeAdmin(address,bool);\n        } else if (0x41282fe0 == function_selector) {\n            usersCanUnfreeze();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x429b62e5 == function_selector) {\n            admins(address);\n        } else if (0x4b0bddd2 == function_selector) {\n            setAdmin(address,bool);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x559f05dc == function_selector) {\n            canTrade(address);\n        } else if (0x5d452201 == function_selector) {\n            ico();\n        } else if (0x5dd4599a == function_selector) {\n            usersCanTrade();\n        } else if (0x63a846f8 == function_selector) {\n            admin(address);\n        } else if (0x6f58659b == function_selector) {\n            totalRewardIssuedOut(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8d60e30b == function_selector) {\n            reward(address,uint256,bool,string);\n        } else if (0x8d995f94 == function_selector) {\n            transferAndFreeze(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa5fb929a == function_selector) {\n            userRewarderCount(address);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xaab60ebc == function_selector) {\n            totalLockedRewardsOf(address);\n        } else if (0xb2aa9f0f == function_selector) {\n            increaseTotalSupply(address,uint256);\n        } else if (0xb5a1a64b == function_selector) {\n            lockedRewardsOf(address,address);\n        } else if (0xbf120ae5 == function_selector) {\n            freeze(address,bool);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcc5cab33 == function_selector) {\n            userRewarders(address,uint32);\n        } else if (0xd0516650 == function_selector) {\n            frozen(address);\n        } else if (0xd15ee9ff == function_selector) {\n            setUsersCanTrade(bool);\n        } else if (0xd75b363f == function_selector) {\n            userRewardCount(address,address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xed9beb05 == function_selector) {\n            setICO(bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf58d3321 == function_selector) {\n            usersCanUnFreeze(bool);\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 23:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x1]\nuint256[] _name; // STORAGE[0x2]\nuint256[] _symbol; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 stor_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _admin; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _frozen; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _canTrade; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _totalLockedRewardsOf; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _lockedRewardsOf; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _userRewarders; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _userRewardCount; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _userRewarderCount; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _totalRewardIssuedOut; // STORAGE[0x12]\nuint256 _sellPrice; // STORAGE[0x13]\nuint256 _buyPrice; // STORAGE[0x14]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\nuint8 _usersCanTrade; // STORAGE[0x7] bytes 0 to 0\nuint8 _usersCanUnfreeze; // STORAGE[0x7] bytes 1 to 1\nuint8 _ico; // STORAGE[0x7] bytes 2 to 2\n\n// Events\nTransfer(address, address, uint256);\nUnlock(address, address, uint256);\nBurn(address, uint256);\nReward(address, address, uint256, string, uint256);\nWithdrawn(address, uint256);\nFrozen(address, bool);\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x2d66(uint256 varg0, uint256 varg1) private { \n    if (!varg0) {\n        varg0 = v0 = !varg0;\n        if (v0) {\n            varg0 = v1 = !_usersCanUnfreeze;\n        }\n    }\n    if (varg0) {\n        require(0xff & _admin[msg.sender]);\n    }\n    v2 = address(varg1);\n    _frozen[v2] = varg0 | ~0xff & _frozen[v2];\n    v3 = varg0;\n    emit Frozen(address(varg1), v3);\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction 0x316b(uint256 varg0) private { \n    require(!(0xff & _frozen[msg.sender]));\n    v0 = v1 = !_usersCanTrade;\n    if (!_usersCanTrade) {\n        v0 = v2 = !(0xff & _canTrade[msg.sender]);\n    }\n    if (v0) {\n        assert(_sellPrice);\n        require(stor_6 > varg0 / _sellPrice);\n    }\n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[address(this)] = _balanceOf[address(this)] + varg0;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(_sellPrice);\n    v3 = varg0 / _sellPrice;\n    v4 = msg.sender.call().value(v3).gas(!v3 * 2300);\n    require(v4);\n    emit Transfer(msg.sender, address(this), varg0);\n    return v3;\n}\n\nfunction transferReward(address varg0, uint256 varg1) public nonPayable { \n    require(!(0xff & _frozen[msg.sender]));\n    require(_lockedRewardsOf[varg0] >= varg1);\n    require(_totalLockedRewardsOf[msg.sender] >= varg1);\n    if (msg.sender.balance < stor_6) {\n        v0 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    _totalLockedRewardsOf[msg.sender] = _totalLockedRewardsOf[msg.sender] - varg1;\n    _lockedRewardsOf[varg0] = _lockedRewardsOf[varg0] - varg1;\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction 0x361d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(!(0xff & _frozen[v0]));\n    v1 = address(varg2);\n    require(_balanceOf[v1] >= varg0);\n    v2 = address(varg1);\n    v3 = address(varg1);\n    require(_balanceOf[v3] + varg0 > _balanceOf[v2]);\n    v4 = address(varg2);\n    _balanceOf[v4] = _balanceOf[v4] - varg0;\n    v5 = address(varg1);\n    _balanceOf[v5] = _balanceOf[v5] + varg0;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction setCanTrade(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _canTrade[varg0] = varg1 | ~0xff & _canTrade[varg0];\n}\n\nfunction unlockReward(address varg0, uint256 varg1) public nonPayable { \n    require(_totalLockedRewardsOf[varg0] > varg1);\n    require(_lockedRewardsOf[msg.sender] >= varg1);\n    if (varg1 == 0) {\n        v0 = v1 = _lockedRewardsOf[msg.sender];\n    }\n    if (msg.sender.balance < stor_6) {\n        v2 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    _totalLockedRewardsOf[varg0] = _totalLockedRewardsOf[varg0] - v0;\n    _lockedRewardsOf[msg.sender] = _lockedRewardsOf[msg.sender] - v0;\n    _balanceOf[varg0] = _balanceOf[varg0] + v0;\n    emit Unlock(varg0, msg.sender, v0);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(!(0xff & _frozen[varg0]));\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x361d(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction makeAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction usersCanUnfreeze() public nonPayable { \n    return _usersCanUnfreeze;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balanceOf[msg.sender] >= varg0);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _admin[varg0] = varg1 | ~0xff & _admin[varg0];\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction canTrade(address varg0) public nonPayable { \n    return 0xff & _canTrade[varg0];\n}\n\nfunction ico() public nonPayable { \n    return _ico;\n}\n\nfunction usersCanTrade() public nonPayable { \n    return _usersCanTrade;\n}\n\nfunction admin(address varg0) public nonPayable { \n    return 0xff & _admin[varg0];\n}\n\nfunction totalRewardIssuedOut(address varg0) public nonPayable { \n    return _totalRewardIssuedOut[varg0];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[varg0] >= varg1);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction reward(address varg0, uint256 varg1, bool varg2, string varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg3, (?).length);\n    require(varg0 != 0);\n    require(!(0xff & _frozen[msg.sender]));\n    if (msg.sender.balance < stor_6) {\n        v1 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    if (varg2) {\n        require(_balanceOf[msg.sender] >= varg1);\n        require(_totalLockedRewardsOf[varg0] + varg1 > _totalLockedRewardsOf[varg0]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + varg1;\n        if (uint32(_userRewardCount[address(address(msg.sender))]) == 0) {\n            _userRewarderCount[varg0] = uint32(uint32(_userRewarderCount[address(address(varg0))]) + 1) | ~0xffffffff & _userRewarderCount[varg0];\n            _userRewarders[uint32(_userRewarders[address(address(varg0))])] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _userRewarders[uint32(_userRewarders[address(address(varg0))])];\n        }\n        _userRewardCount[msg.sender] = uint32(uint32(_userRewardCount[address(address(msg.sender))]) + 1) | ~0xffffffff & _userRewardCount[msg.sender];\n        _userRewardCount[msg.sender] = _userRewardCount[msg.sender] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    } else {\n        0x361d(varg1, varg0, msg.sender);\n    }\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v2.data + v3] = MEM[v0.data + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    emit Reward(msg.sender, varg0, varg1, v2, block.timestamp);\n}\n\nfunction transferAndFreeze(address varg0, uint256 varg1) public nonPayable { \n    require(0xff & _admins[msg.sender] == 1);\n    0x361d(varg1, varg0, msg.sender);\n    0x2d66(1, varg0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction userRewarderCount(address varg0) public nonPayable { \n    return uint32(_userRewarderCount[varg0]);\n}\n\nfunction buy() public payable { \n    v0 = v1 = !_usersCanTrade;\n    if (!_usersCanTrade) {\n        v0 = !(0xff & _canTrade[msg.sender]);\n    }\n    require(!v0);\n    require(_balanceOf[address(this)] >= msg.value * _buyPrice);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _buyPrice;\n    _balanceOf[address(this)] = _balanceOf[address(this)] - msg.value * _buyPrice;\n    emit Transfer(address(this), msg.sender, msg.value * _buyPrice);\n    return msg.value * _buyPrice;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = 0xff & _admin[msg.sender];\n    if (!v1) {\n        v0 = !_ico;\n    }\n    require(v0);\n    require(!(0xff & _frozen[msg.sender]));\n    if (msg.sender.balance < stor_6) {\n        v2 = 0x316b((stor_6 - msg.sender.balance) * _sellPrice);\n    }\n    0x361d(varg1, varg0, msg.sender);\n}\n\nfunction totalLockedRewardsOf(address varg0) public nonPayable { \n    return _totalLockedRewardsOf[varg0];\n}\n\nfunction increaseTotalSupply(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    emit Transfer(0, _owner, varg1);\n    emit Transfer(_owner, varg0, varg1);\n}\n\nfunction lockedRewardsOf(address varg0, address varg1) public nonPayable { \n    return _lockedRewardsOf[varg1];\n}\n\nfunction freeze(address varg0, bool varg1) public nonPayable { \n    0x2d66(varg1, varg0);\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    stor_6 = varg0;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    v1 = v2 = 0;\n    require(msg.sender == _owner);\n    _allowance[varg0] = varg1;\n    if (1) {\n        v3 = new array[](v0.length);\n        v4 = v5 = 0;\n        while (v4 < v0.length) {\n            MEM[v3.data + v4] = MEM[v0.data + v4];\n            v4 = v4 + 32;\n        }\n        v6 = v7 = v0.length + v3.data;\n        if (0x1f & v0.length) {\n            MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v8 = varg0.receiveApproval(msg.sender, varg1, address(this), v3).gas(msg.gas - 710);\n        require(v8);\n        v1 = v9 = 1;\n    }\n    return v1;\n}\n\nfunction userRewarders(address varg0, uint32 varg1) public nonPayable { \n    return address(_userRewarders[varg1]);\n}\n\nfunction frozen(address varg0) public nonPayable { \n    return 0xff & _frozen[varg0];\n}\n\nfunction setUsersCanTrade(bool varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _usersCanTrade = varg0;\n}\n\nfunction userRewardCount(address varg0, address varg1) public nonPayable { \n    return uint32(_userRewardCount[varg1]);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    v0 = 0x316b(varg0);\n    return v0;\n}\n\nfunction setICO(bool varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _ico = varg0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0);\n    emit Withdrawn(varg0, varg1);\n}\n\nfunction usersCanUnFreeze(bool varg0) public nonPayable { \n    _usersCanUnfreeze = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x15490ebb == function_selector) {\n            transferReward(address,uint256);\n        } else if (0x15c32297 == function_selector) {\n            setCanTrade(address,bool);\n        } else if (0x1631eb07 == function_selector) {\n            unlockReward(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x40a57cb8 == function_selector) {\n            makeAdmin(address,bool);\n        } else if (0x41282fe0 == function_selector) {\n            usersCanUnfreeze();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x429b62e5 == function_selector) {\n            admins(address);\n        } else if (0x4b0bddd2 == function_selector) {\n            setAdmin(address,bool);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x559f05dc == function_selector) {\n            canTrade(address);\n        } else if (0x5d452201 == function_selector) {\n            ico();\n        } else if (0x5dd4599a == function_selector) {\n            usersCanTrade();\n        } else if (0x63a846f8 == function_selector) {\n            admin(address);\n        } else if (0x6f58659b == function_selector) {\n            totalRewardIssuedOut(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8d60e30b == function_selector) {\n            reward(address,uint256,bool,string);\n        } else if (0x8d995f94 == function_selector) {\n            transferAndFreeze(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa5fb929a == function_selector) {\n            userRewarderCount(address);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xaab60ebc == function_selector) {\n            totalLockedRewardsOf(address);\n        } else if (0xb2aa9f0f == function_selector) {\n            increaseTotalSupply(address,uint256);\n        } else if (0xb5a1a64b == function_selector) {\n            lockedRewardsOf(address,address);\n        } else if (0xbf120ae5 == function_selector) {\n            freeze(address,bool);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xcc5cab33 == function_selector) {\n            userRewarders(address,uint32);\n        } else if (0xd0516650 == function_selector) {\n            frozen(address);\n        } else if (0xd15ee9ff == function_selector) {\n            setUsersCanTrade(bool);\n        } else if (0xd75b363f == function_selector) {\n            userRewardCount(address,address);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xed9beb05 == function_selector) {\n            setICO(bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf58d3321 == function_selector) {\n            usersCanUnFreeze(bool);\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 26.90003514289856,
	"usage": {
		"completion_tokens": 631,
		"prompt_tokens": 5744,
		"total_tokens": 6375
	}
}