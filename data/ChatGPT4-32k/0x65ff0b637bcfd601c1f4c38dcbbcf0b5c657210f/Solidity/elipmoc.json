{
	"address": "0x65ff0b637bcfd601c1f4c38dcbbcf0b5c657210f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity contract for the given decompiled code could be:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract OleCoin {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    uint256 private _comprarTokens;\n    address private _setPrice;\n\n    event tokenComprado(address indexed account);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(uint256 initialSupply) {\n        _totalSupply = initialSupply;\n        _balances[msg.sender] = _totalSupply;\n        _setPrice = msg.sender;\n    }\n\n    function name() public pure returns (string memory) {\n        return 'OleCoin';\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function comprarTokens(uint256 value) public payable {\n        require(value > 0, \"Value must be greater than 0\");\n        require(msg.value == value * _comprarTokens, \"Incorrect value\");\n        require(0xde0b6b3a7640000 * value <= _balances[_setPrice], \"Insufficient balance\");\n        _balances[_setPrice] -= 0xde0b6b3a7640000 * value;\n        require(0xde0b6b3a7640000 * value + _balances[msg.sender] >= _balances[msg.sender], \"Overflow error\");\n        _balances[msg.sender] += 0xde0b6b3a7640000 * value;\n        (bool success, ) = address(this).call{value: msg.value, gas: 2300 * (msg.value == 0 ? 1 : 0)}(\"\");\n        require(success, \"Transfer failed\");\n        emit Transfer(_setPrice, msg.sender, 0xde0b6b3a7640000 * value);\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(amount <= _balances[sender], \"Insufficient balance\");\n        require(amount <= _allowances[msg.sender][sender], \"Insufficient allowance\");\n        require(recipient != address(0), \"Invalid address\");\n        _balances[sender] -= amount;\n        require(amount + _balances[recipient] >= _balances[recipient], \"Overflow error\");\n        _balances[recipient] += amount;\n        _allowances[msg.sender][sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function INITIAL_SUPPLY() public pure returns (uint256) {\n        return 0x7c13bc4b2c133c56000000;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function owner() public view returns (address) {\n        return _setPrice;\n    }\n\n    function setPrice(uint256 price) public {\n        require(msg.sender == _setPrice, \"Only owner can set price\");\n        _comprarTokens = price;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return 'OLE';\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(amount <= _balances[msg.sender], \"Insufficient balance\");\n        require(recipient != address(0), \"Invalid address\");\n        _balances[msg.sender] -= amount;\n        require(amount + _balances[recipient] >= _balances[recipient], \"Overflow error\");\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function saque() public {\n        require(msg.sender == _setPrice, \"Only owner can withdraw\");\n        (bool success, ) = _setPrice.call{value: address(this).balance, gas: 2300 * (address(this).balance == 0 ? 1 : 0)}(\"\");\n        require(success, \"Withdraw failed\");\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _setPrice, \"Only owner can transfer ownership\");\n        require(newOwner != address(0), \"Invalid address\");\n        emit OwnershipTransferred(_setPrice, newOwner);\n        _setPrice = newOwner;\n    }\n\n    fallback() external payable {\n        emit tokenComprado(msg.sender);\n    }\n}\n```\n\nThis Solidity smart contract includes functions for basic ERC20 token functionality like `approve`, `transfer`, and `balanceOf`, along with some additional functionality like `comprarTokens`, `setPrice`, and `saque`. It also has an event `tokenComprado` which is triggered in the fallback function.\n\nPlease note that the original code does not include the constructor function, so it has been added for completeness, as it is typically required to initialize the contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461344,
	"id": "chatcmpl-8R46qOQirbS9vKrbn0H3qZBDNmUdW",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 10:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 _comprarTokens; // STORAGE[0x4]\naddress _setPrice; // STORAGE[0x3] bytes 0 to 19\n\n// Events\ntokenComprado(address);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (7) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & 'OleCoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction comprarTokens(uint256 varg0) public payable { \n    require(varg0 > 0);\n    require(msg.value == varg0 * _comprarTokens);\n    require(0xde0b6b3a7640000 * varg0 <= _balanceOf[_setPrice]);\n    _balanceOf[_setPrice] = _balanceOf[_setPrice] - 0xde0b6b3a7640000 * varg0;\n    require(0xde0b6b3a7640000 * varg0 + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += 0xde0b6b3a7640000 * varg0;\n    v0 = this.call().value(msg.value).gas(2300 * !msg.value);\n    require(v0); // checks call status, propagates error data on error\n    emit Transfer(_setPrice, msg.sender, 0xde0b6b3a7640000 * varg0);\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    require(varg1);\n    require(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    require(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction INITIAL_SUPPLY() public nonPayable { \n    return 0x7c13bc4b2c133c56000000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _setPrice;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _setPrice);\n    _comprarTokens = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4f4c450000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[msg.sender]);\n    require(varg0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    require(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction saque() public nonPayable { \n    require(msg.sender == _setPrice);\n    v0 = _setPrice.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _setPrice);\n    require(varg0);\n    emit OwnershipTransferred(_setPrice, varg0);\n    _setPrice = varg0;\n}\n\nfunction fallback() public payable { \n    emit tokenComprado(msg.sender);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1afd64e2 == function_selector) {\n            comprarTokens(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2ff2e9dc == function_selector) {\n            INITIAL_SUPPLY();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91b7f5ed == function_selector) {\n            setPrice(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbea79e82 == function_selector) {\n            saque();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 10:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 _comprarTokens; // STORAGE[0x4]\naddress _setPrice; // STORAGE[0x3] bytes 0 to 19\n\n// Events\ntokenComprado(address);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (7) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & 'OleCoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction comprarTokens(uint256 varg0) public payable { \n    require(varg0 > 0);\n    require(msg.value == varg0 * _comprarTokens);\n    require(0xde0b6b3a7640000 * varg0 <= _balanceOf[_setPrice]);\n    _balanceOf[_setPrice] = _balanceOf[_setPrice] - 0xde0b6b3a7640000 * varg0;\n    require(0xde0b6b3a7640000 * varg0 + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += 0xde0b6b3a7640000 * varg0;\n    v0 = this.call().value(msg.value).gas(2300 * !msg.value);\n    require(v0); // checks call status, propagates error data on error\n    emit Transfer(_setPrice, msg.sender, 0xde0b6b3a7640000 * varg0);\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    require(varg1);\n    require(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    require(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction INITIAL_SUPPLY() public nonPayable { \n    return 0x7c13bc4b2c133c56000000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _setPrice;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _setPrice);\n    _comprarTokens = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4f4c450000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[msg.sender]);\n    require(varg0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    require(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction saque() public nonPayable { \n    require(msg.sender == _setPrice);\n    v0 = _setPrice.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _setPrice);\n    require(varg0);\n    emit OwnershipTransferred(_setPrice, varg0);\n    _setPrice = varg0;\n}\n\nfunction fallback() public payable { \n    emit tokenComprado(msg.sender);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1afd64e2 == function_selector) {\n            comprarTokens(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2ff2e9dc == function_selector) {\n            INITIAL_SUPPLY();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91b7f5ed == function_selector) {\n            setPrice(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbea79e82 == function_selector) {\n            saque();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 10:01 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256 _comprarTokens; // STORAGE[0x4]\naddress _setPrice; // STORAGE[0x3] bytes 0 to 19\n\n// Events\ntokenComprado(address);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (7) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & 'OleCoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction comprarTokens(uint256 varg0) public payable { \n    require(varg0 > 0);\n    require(msg.value == varg0 * _comprarTokens);\n    require(0xde0b6b3a7640000 * varg0 <= _balanceOf[_setPrice]);\n    _balanceOf[_setPrice] = _balanceOf[_setPrice] - 0xde0b6b3a7640000 * varg0;\n    require(0xde0b6b3a7640000 * varg0 + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += 0xde0b6b3a7640000 * varg0;\n    v0 = this.call().value(msg.value).gas(2300 * !msg.value);\n    require(v0); // checks call status, propagates error data on error\n    emit Transfer(_setPrice, msg.sender, 0xde0b6b3a7640000 * varg0);\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    require(varg1);\n    require(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    require(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction INITIAL_SUPPLY() public nonPayable { \n    return 0x7c13bc4b2c133c56000000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _setPrice;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _setPrice);\n    _comprarTokens = varg0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4f4c450000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[msg.sender]);\n    require(varg0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    require(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction saque() public nonPayable { \n    require(msg.sender == _setPrice);\n    v0 = _setPrice.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _setPrice);\n    require(varg0);\n    emit OwnershipTransferred(_setPrice, varg0);\n    _setPrice = varg0;\n}\n\nfunction fallback() public payable { \n    emit tokenComprado(msg.sender);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1afd64e2 == function_selector) {\n            comprarTokens(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2ff2e9dc == function_selector) {\n            INITIAL_SUPPLY();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91b7f5ed == function_selector) {\n            setPrice(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbea79e82 == function_selector) {\n            saque();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 49.443795919418335,
	"usage": {
		"completion_tokens": 1154,
		"prompt_tokens": 1712,
		"total_tokens": 2866
	}
}