{
	"address": "0x798b1eed1ed90df11adcd688bb42888dd20ca0db",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a simplified Solidity smart contract based on the decompiled code:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract MyContract {\n    mapping (address => uint) public balances;\n    mapping (address => uint) private _feeMake;\n    mapping (address => uint) private _feeTake;\n    mapping (address => uint) private _feeDeposit;\n    mapping (address => uint) private _feeWithdraw;\n    address private _admin;\n    address private _feeAccount;\n\n    event Trade(address indexed _from, address indexed _to, uint _value);\n    event Deposit(address indexed _from, address indexed _to, uint _value);\n    event Withdraw(address indexed _from, address _to, uint _value);\n\n    constructor() public {\n        _admin = msg.sender;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        emit Deposit(msg.sender, address(this), msg.value);\n    }\n\n    function withdraw(uint amount) public {\n        require(amount <= balances[msg.sender]);\n        balances[msg.sender] -= amount;\n        msg.sender.transfer(amount);\n        emit Withdraw(address(this), msg.sender, amount);\n    }\n\n    function setFeeMake(uint fee) public {\n        require(msg.sender == _admin);\n        _feeMake[msg.sender] = fee;\n    }\n\n    function setFeeTake(uint fee) public {\n        require(msg.sender == _admin);\n        _feeTake[msg.sender] = fee;\n    }\n\n    function setFeeDeposit(uint fee) public {\n        require(msg.sender == _admin);\n        _feeDeposit[msg.sender] = fee;\n    }\n\n    function setFeeWithdraw(uint fee) public {\n        require(msg.sender == _admin);\n        _feeWithdraw[msg.sender] = fee;\n    }\n\n    function trade(address to, uint amount) public {\n        require(amount <= balances[msg.sender]);\n        require(amount > 0);\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n        emit Trade(msg.sender, to, amount);\n    }\n}\n```\n\nThis implementation is a simple token contract with deposit and withdraw functions. The trade function allows users to send tokens to others. The contract also allows the admin to set fees for making trades, taking trades, depositing and withdrawing. \n\nPlease note that the provided decompiled code is not complete and does not contain all the necessary logic and function signatures for a fully operational Solidity smart contract. This is a simplified version and some features might not be accurately represented. For example, the contract does not include the logic for _activeTokens, _orderFills, _orders and other variables in the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465622,
	"id": "chatcmpl-8R5DqPAeM4TYe9V5BbdFZiff6YKAm",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 20:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _feeMake; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _feeTake; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _feeDeposit; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _feeWithdraw; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _orders; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _activeTokens; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokensMinAmountBuy; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _tokensMinAmountSell; // STORAGE[0xb]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTrade(address, uint256, address, uint256, address, address);\nOrder(address, uint256, address, uint256, uint256, uint256, address);\nActivateToken(address, string);\nCancel(address, uint256, address, uint256, uint256, uint256, address, uint8, bytes32, bytes32);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\nDeactivateToken(address, string);\n\nfunction availableVolume(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    require(msg.data.length - 4 >= 320);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v5, v6 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v7 = v8 = 0xff & _orders[MEM[MEM[64]]];\n    if (!v8) {\n        MEM[MEM[64]] = 0;\n        v9, v10 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', MEM[MEM[64]]), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n        require(v9); // checks call status, propagates error data on error\n        v7 = v11 = address(MEM[MEM[64] - 32]) == varg6;\n    }\n    if (v7) {\n        v7 = block.number <= varg4;\n    }\n    if (v7) {\n        v12 = v13 = 0x4d2a(MEM[MEM[64]], varg6, varg3, varg2, varg1);\n    } else {\n        v12 = v14 = 0;\n    }\n    return v12;\n}\n\nfunction setTokenFeeMake(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeMake[varg0] = varg1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction trade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10) public nonPayable { \n    require(msg.data.length - 4 >= 352);\n    v0 = v1 = 0x3508(varg0);\n    if (v1) {\n        v0 = v2 = 0x3508(varg2);\n    }\n    require(v0);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v3 = v4 = MEM[64];\n    v5 = v6 = 188;\n    v7 = v8 = 32 + MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v9); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v11 = v12 = 0xff & _orders[varg6];\n    if (!v12) {\n        MEM[MEM[64]] = 0;\n        v13, v14 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v10), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n        require(v13); // checks call status, propagates error data on error\n        v11 = v15 = address(v14) == varg6;\n    }\n    if (v11) {\n        v11 = v16 = block.number <= varg4;\n    }\n    if (v11) {\n        require(_orderFills[varg6] + varg10 >= _orderFills[varg6]);\n        v11 = v17 = _orderFills[varg6] + varg10 <= varg1;\n    }\n    require(v11);\n    v18 = 0x4cca(_feeMake[varg0], varg10);\n    assert(0xde0b6b3a7640000);\n    v19 = 0x4cca(_feeTake[varg0], varg10);\n    assert(0xde0b6b3a7640000);\n    require(varg10 + v19 / 0xde0b6b3a7640000 >= varg10);\n    require(varg10 + v19 / 0xde0b6b3a7640000 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - (varg10 + v19 / 0xde0b6b3a7640000);\n    require(v18 / 0xde0b6b3a7640000 <= varg10);\n    require(_tokens[varg6] + (varg10 - v18 / 0xde0b6b3a7640000) >= _tokens[varg6]);\n    _tokens[varg6] = _tokens[varg6] + (varg10 - v18 / 0xde0b6b3a7640000);\n    require(v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000 >= v18 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + (v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000) >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + (v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000);\n    v20 = 0x4cca(varg10, varg3);\n    v21 = _SafeDiv(varg1, v20);\n    require(v21 <= _tokens[varg6]);\n    _tokens[varg6] = _tokens[varg6] - v21;\n    v22 = 0x4cca(varg10, varg3);\n    v23 = _SafeDiv(varg1, v22);\n    require(_tokens[msg.sender] + v23 >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + v23;\n    require(_orderFills[varg6] + varg10 >= _orderFills[varg6]);\n    _orderFills[varg6] = _orderFills[varg6] + varg10;\n    assert(varg1);\n    emit Trade(varg0, varg10, varg2, varg3 * varg10 / varg1, varg6, msg.sender);\n}\n\nfunction order(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = v1 = 0x3508(varg0);\n    if (v1) {\n        v0 = v2 = 0x3508(varg2);\n    }\n    require(v0);\n    require(varg1 >= _tokensMinAmountBuy[varg0]);\n    require(varg3 >= _tokensMinAmountSell[varg2]);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    v3 = v4 = MEM[64];\n    v5 = v6 = 188;\n    v7 = v8 = 32 + MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v9); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _orders[msg.sender] = 0x1 | ~0xff & _orders[msg.sender];\n    emit Order(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender);\n}\n\nfunction 0x3508(uint256 varg0) private { \n    if (address(varg0) != 0) {\n        v0 = address(varg0);\n        v1 = 0xff & _activeTokens[v0];\n    } else {\n        v1 = v2 = 1;\n    }\n    return v1;\n}\n\nfunction activateToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _activeTokens[varg0] = 0x1 | ~0xff & _activeTokens[varg0];\n    require(varg0.code.size);\n    v0, v1 = varg0.symbol().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v1] <= 0x100000000);\n    require(MEM[v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[v1] + v1] > 0x100000000) | (MEM[v1] + v1 + 32 + MEM[MEM[v1] + v1] > v1 + RETURNDATASIZE())));\n    v2 = new array[](MEM[MEM[v1] + v1]);\n    v3 = v4 = 0;\n    while (v3 < MEM[MEM[v1] + v1]) {\n        MEM[v2.data + v3] = MEM[32 + (MEM[v1] + v1) + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = MEM[MEM[v1] + v1] + v2.data;\n    if (0x1f & MEM[MEM[v1] + v1]) {\n        MEM[v6 - (0x1f & MEM[MEM[v1] + v1])] = ~(256 ** (32 - (0x1f & MEM[MEM[v1] + v1])) - 1) & MEM[v6 - (0x1f & MEM[MEM[v1] + v1])];\n    }\n    emit ActivateToken(varg0, v2);\n}\n\nfunction orderFills(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _orderFills[varg1];\n}\n\nfunction feeTake(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeTake[varg0];\n}\n\nfunction setTokenFeeWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeWithdraw[varg0] = varg1;\n}\n\nfunction 0x4cca(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x4d2a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = address(varg1);\n    v1 = _orderFills[varg0];\n    require(v1 <= varg4);\n    v2 = varg4 - v1;\n    v3 = address(varg3);\n    v4 = address(varg1);\n    v5 = 0x4cca(varg4, _tokens[v4]);\n    v2 = v6 = _SafeDiv(varg2, v5);\n    if (v2 < v6) {\n    }\n    return v2;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction setTokenMinAmountBuy(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _tokensMinAmountBuy[varg0] = varg1;\n}\n\nfunction cancelOrder(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint8 varg6, bytes32 varg7, bytes32 varg8) public nonPayable { \n    require(msg.data.length - 4 >= 288);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = v5 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v6, v7 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v8 = v9 = 0xff & _orders[msg.sender];\n    if (!v9) {\n        MEM[MEM[64]] = 0;\n        v10, v11 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v7), 0xff & (0xff & (0xff & varg6)), varg7, varg8);\n        require(v10); // checks call status, propagates error data on error\n        v8 = v12 = address(v11) == msg.sender;\n    }\n    require(v8);\n    _orderFills[msg.sender] = varg1;\n    emit Cancel(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender, 0xff & (0xff & (0xff & varg6)), varg7, varg8);\n}\n\nfunction setTokenFeeTake(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeTake[varg0] = varg1;\n}\n\nfunction amountFilled(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6) public nonPayable { \n    require(msg.data.length - 4 >= 224);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = v5 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v6, v7 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _orderFills[varg6];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_tokens[msg.sender] >= varg0);\n    v0 = 0x4cca(_feeWithdraw[0], varg0);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= varg0);\n    require(varg0 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg0;\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    v1 = msg.sender.call().value(varg0 - v0 / 0xde0b6b3a7640000).gas(!(varg0 - v0 / 0xde0b6b3a7640000) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Withdraw(0, msg.sender, varg0, _tokens[msg.sender]);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    v0 = 0x3508(varg0);\n    require(v0);\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    v3 = 0x4cca(_feeDeposit[varg0], varg1);\n    assert(0xde0b6b3a7640000);\n    require(v3 / 0xde0b6b3a7640000 <= varg1);\n    require(_tokens[msg.sender] + (varg1 - v3 / 0xde0b6b3a7640000) >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + (varg1 - v3 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + v3 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v3 / 0xde0b6b3a7640000;\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _tokens[varg1];\n}\n\nfunction activeTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _activeTokens[varg0];\n}\n\nfunction setTokenMinAmountSell(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _tokensMinAmountSell[varg0] = varg1;\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction deactivateToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _activeTokens[varg0] = 0x0 | ~0xff & _activeTokens[varg0];\n    require(varg0.code.size);\n    v0, v1 = varg0.symbol().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v1] <= 0x100000000);\n    require(MEM[v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[v1] + v1] > 0x100000000) | (MEM[v1] + v1 + 32 + MEM[MEM[v1] + v1] > v1 + RETURNDATASIZE())));\n    v2 = new array[](MEM[MEM[v1] + v1]);\n    v3 = v4 = 0;\n    while (v3 < MEM[MEM[v1] + v1]) {\n        MEM[v2.data + v3] = MEM[32 + (MEM[v1] + v1) + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = MEM[MEM[v1] + v1] + v2.data;\n    if (0x1f & MEM[MEM[v1] + v1]) {\n        MEM[v6 - (0x1f & MEM[MEM[v1] + v1])] = ~(256 ** (32 - (0x1f & MEM[MEM[v1] + v1])) - 1) & MEM[v6 - (0x1f & MEM[MEM[v1] + v1])];\n    }\n    emit DeactivateToken(varg0, v2);\n}\n\nfunction testTrade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10, address varg11) public nonPayable { \n    require(msg.data.length - 4 >= 384);\n    v0 = 0x3508(varg0);\n    v1 = v2 = !v0;\n    if (v0) {\n        v3 = 0x3508(varg2);\n        v1 = v4 = !v3;\n    }\n    if (!v1) {\n        v5 = v6 = _tokens[varg11] >= varg10;\n        if (v6) {\n            MEM[32 + MEM[64]] = address(this) << 96;\n            MEM[52 + MEM[64]] = varg0 << 96;\n            MEM[72 + MEM[64]] = varg1;\n            MEM[104 + MEM[64]] = varg2 << 96;\n            MEM[124 + MEM[64]] = varg3;\n            MEM[156 + MEM[64]] = varg4;\n            MEM[188 + MEM[64]] = varg5;\n            v7 = v8 = MEM[64];\n            v9 = v10 = 188;\n            v11 = v12 = 32 + MEM[64];\n            while (v9 >= 32) {\n                MEM[v7] = MEM[v11];\n                v7 = v7 + 32;\n                v11 = v11 + 32;\n                v9 = v9 - 32;\n            }\n            MEM[v7] = MEM[v11] & ~(256 ** (32 - v9) - 1) | MEM[v7] & 256 ** (32 - v9) - 1;\n            v13, v14 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v15 = v16 = 0xff & _orders[v14];\n            if (!v16) {\n                MEM[MEM[64]] = 0;\n                v17, v18 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v14), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n                require(v17); // checks call status, propagates error data on error\n                v15 = v19 = address(v18) == varg6;\n            }\n            if (v15) {\n                v15 = v20 = block.number <= varg4;\n            }\n            if (v15) {\n                v21 = v22 = 0x4d2a(v14, varg6, varg3, varg2, varg1);\n            } else {\n                v21 = v23 = 0;\n            }\n            v5 = v24 = v21 >= varg10;\n        }\n        if (v5) {\n            v25 = v26 = 1;\n        } else {\n            v25 = v27 = 0;\n        }\n    } else {\n        v25 = v28 = 0;\n    }\n    return v25;\n}\n\nfunction changeFeeAccount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _feeAccount = varg0;\n}\n\nfunction isTokenActive(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (varg0 != 0) {\n        v0 = 0xff & _activeTokens[varg0];\n    } else {\n        v0 = v1 = 1;\n    }\n    return v0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _admin = varg0;\n}\n\nfunction feeWithdraw(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeWithdraw[varg0];\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    require(_tokens[msg.sender] >= varg1);\n    v0 = 0x4cca(_feeWithdraw[varg0], varg1);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= varg1);\n    require(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    require(varg0.code.size);\n    v1, v2 = varg0.transfer(msg.sender, varg1 - v0 / 0xde0b6b3a7640000).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction orders(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _orders[varg1];\n}\n\nfunction deposit() public payable { \n    v0 = 0x4cca(_feeDeposit[0], msg.value);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= msg.value);\n    require(_tokens[msg.sender] + (msg.value - v0 / 0xde0b6b3a7640000) >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + (msg.value - v0 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    emit Deposit(0, msg.sender, msg.value, _tokens[msg.sender]);\n}\n\nfunction tokensMinAmountBuy(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokensMinAmountBuy[varg0];\n}\n\nfunction tokensMinAmountSell(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokensMinAmountSell[varg0];\n}\n\nfunction setTokenFeeDeposit(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeDeposit[varg0] = varg1;\n}\n\nfunction feeDeposit(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeDeposit[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _tokens[varg1];\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction feeMake(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeMake[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6c86888b > function_selector) {\n            if (0x2a179054 > function_selector) {\n                if (0x1b9bc1b3 > function_selector) {\n                    if (0xa19b14a == function_selector) {\n                        trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256);\n                    } else if (0xb927666 == function_selector) {\n                        order(address,uint256,address,uint256,uint256,uint256);\n                    } else if (0xd1ce2d2 == function_selector) {\n                        activateToken(address);\n                    } else if (0x19774d43 == function_selector) {\n                        orderFills(address,bytes32);\n                    }\n                } else if (0x1b9bc1b3 == function_selector) {\n                    feeTake(address);\n                } else if (0x1e14c48c == function_selector) {\n                    setTokenFeeWithdraw(address,uint256);\n                } else if (0x1f9c381e == function_selector) {\n                    setTokenMinAmountBuy(address,uint256);\n                } else if (0x278b8c0e == function_selector) {\n                    cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32);\n                }\n            } else if (0x508493bc > function_selector) {\n                if (0x2a179054 == function_selector) {\n                    setTokenFeeTake(address,uint256);\n                } else if (0x2d804ca2 == function_selector) {\n                    amountFilled(address,uint256,address,uint256,uint256,uint256,address);\n                } else if (0x2e1a7d4d == function_selector) {\n                    withdraw(uint256);\n                } else if (0x338b5dea == function_selector) {\n                    depositToken(address,uint256);\n                }\n            } else if (0x508493bc == function_selector) {\n                tokens(address,address);\n            } else if (0x5acf6903 == function_selector) {\n                activeTokens(address);\n            } else if (0x5b8d8807 == function_selector) {\n                setTokenMinAmountSell(address,uint256);\n            } else if (0x65e17c9d == function_selector) {\n                feeAccount();\n            } else if (0x68173bcf == function_selector) {\n                deactivateToken(address);\n            }\n        } else if (0xd5a3d9c2 > function_selector) {\n            if (0x998e7a80 > function_selector) {\n                if (0x6c86888b == function_selector) {\n                    testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address);\n                } else if (0x71ffcb16 == function_selector) {\n                    changeFeeAccount(address);\n                } else if (0x895b327e == function_selector) {\n                    isTokenActive(address);\n                } else if (0x8f283970 == function_selector) {\n                    changeAdmin(address);\n                }\n            } else if (0x998e7a80 == function_selector) {\n                feeWithdraw(address);\n            } else if (0x9e281a98 == function_selector) {\n                withdrawToken(address,uint256);\n            } else if (0xbb5f4629 == function_selector) {\n                orders(address,bytes32);\n            } else if (0xd0e30db0 == function_selector) {\n                deposit();\n            }\n        } else if (0xf7888aec > function_selector) {\n            if (0xd5a3d9c2 == function_selector) {\n                tokensMinAmountBuy(address);\n            } else if (0xe190a5c0 == function_selector) {\n                tokensMinAmountSell(address);\n            } else if (0xe41763f2 == function_selector) {\n                setTokenFeeDeposit(address,uint256);\n            } else if (0xec57b730 == function_selector) {\n                feeDeposit(address);\n            }\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfa6416bb == function_selector) {\n            feeMake(address);\n        } else if (0xfb6e155f == function_selector) {\n            availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        } else if (0xfdae6a92 == function_selector) {\n            setTokenFeeMake(address,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 20:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _feeMake; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _feeTake; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _feeDeposit; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _feeWithdraw; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _orders; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _activeTokens; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokensMinAmountBuy; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _tokensMinAmountSell; // STORAGE[0xb]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTrade(address, uint256, address, uint256, address, address);\nOrder(address, uint256, address, uint256, uint256, uint256, address);\nActivateToken(address, string);\nCancel(address, uint256, address, uint256, uint256, uint256, address, uint8, bytes32, bytes32);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\nDeactivateToken(address, string);\n\nfunction availableVolume(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    require(msg.data.length - 4 >= 320);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v5, v6 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v7 = v8 = 0xff & _orders[MEM[MEM[64]]];\n    if (!v8) {\n        MEM[MEM[64]] = 0;\n        v9, v10 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', MEM[MEM[64]]), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n        require(v9); // checks call status, propagates error data on error\n        v7 = v11 = address(MEM[MEM[64] - 32]) == varg6;\n    }\n    if (v7) {\n        v7 = block.number <= varg4;\n    }\n    if (v7) {\n        v12 = v13 = 0x4d2a(MEM[MEM[64]], varg6, varg3, varg2, varg1);\n    } else {\n        v12 = v14 = 0;\n    }\n    return v12;\n}\n\nfunction setTokenFeeMake(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeMake[varg0] = varg1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction trade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10) public nonPayable { \n    require(msg.data.length - 4 >= 352);\n    v0 = v1 = 0x3508(varg0);\n    if (v1) {\n        v0 = v2 = 0x3508(varg2);\n    }\n    require(v0);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v3 = v4 = MEM[64];\n    v5 = v6 = 188;\n    v7 = v8 = 32 + MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v9); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v11 = v12 = 0xff & _orders[varg6];\n    if (!v12) {\n        MEM[MEM[64]] = 0;\n        v13, v14 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v10), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n        require(v13); // checks call status, propagates error data on error\n        v11 = v15 = address(v14) == varg6;\n    }\n    if (v11) {\n        v11 = v16 = block.number <= varg4;\n    }\n    if (v11) {\n        require(_orderFills[varg6] + varg10 >= _orderFills[varg6]);\n        v11 = v17 = _orderFills[varg6] + varg10 <= varg1;\n    }\n    require(v11);\n    v18 = 0x4cca(_feeMake[varg0], varg10);\n    assert(0xde0b6b3a7640000);\n    v19 = 0x4cca(_feeTake[varg0], varg10);\n    assert(0xde0b6b3a7640000);\n    require(varg10 + v19 / 0xde0b6b3a7640000 >= varg10);\n    require(varg10 + v19 / 0xde0b6b3a7640000 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - (varg10 + v19 / 0xde0b6b3a7640000);\n    require(v18 / 0xde0b6b3a7640000 <= varg10);\n    require(_tokens[varg6] + (varg10 - v18 / 0xde0b6b3a7640000) >= _tokens[varg6]);\n    _tokens[varg6] = _tokens[varg6] + (varg10 - v18 / 0xde0b6b3a7640000);\n    require(v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000 >= v18 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + (v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000) >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + (v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000);\n    v20 = 0x4cca(varg10, varg3);\n    v21 = _SafeDiv(varg1, v20);\n    require(v21 <= _tokens[varg6]);\n    _tokens[varg6] = _tokens[varg6] - v21;\n    v22 = 0x4cca(varg10, varg3);\n    v23 = _SafeDiv(varg1, v22);\n    require(_tokens[msg.sender] + v23 >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + v23;\n    require(_orderFills[varg6] + varg10 >= _orderFills[varg6]);\n    _orderFills[varg6] = _orderFills[varg6] + varg10;\n    assert(varg1);\n    emit Trade(varg0, varg10, varg2, varg3 * varg10 / varg1, varg6, msg.sender);\n}\n\nfunction order(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = v1 = 0x3508(varg0);\n    if (v1) {\n        v0 = v2 = 0x3508(varg2);\n    }\n    require(v0);\n    require(varg1 >= _tokensMinAmountBuy[varg0]);\n    require(varg3 >= _tokensMinAmountSell[varg2]);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    v3 = v4 = MEM[64];\n    v5 = v6 = 188;\n    v7 = v8 = 32 + MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v9); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _orders[msg.sender] = 0x1 | ~0xff & _orders[msg.sender];\n    emit Order(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender);\n}\n\nfunction 0x3508(uint256 varg0) private { \n    if (address(varg0) != 0) {\n        v0 = address(varg0);\n        v1 = 0xff & _activeTokens[v0];\n    } else {\n        v1 = v2 = 1;\n    }\n    return v1;\n}\n\nfunction activateToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _activeTokens[varg0] = 0x1 | ~0xff & _activeTokens[varg0];\n    require(varg0.code.size);\n    v0, v1 = varg0.symbol().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v1] <= 0x100000000);\n    require(MEM[v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[v1] + v1] > 0x100000000) | (MEM[v1] + v1 + 32 + MEM[MEM[v1] + v1] > v1 + RETURNDATASIZE())));\n    v2 = new array[](MEM[MEM[v1] + v1]);\n    v3 = v4 = 0;\n    while (v3 < MEM[MEM[v1] + v1]) {\n        MEM[v2.data + v3] = MEM[32 + (MEM[v1] + v1) + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = MEM[MEM[v1] + v1] + v2.data;\n    if (0x1f & MEM[MEM[v1] + v1]) {\n        MEM[v6 - (0x1f & MEM[MEM[v1] + v1])] = ~(256 ** (32 - (0x1f & MEM[MEM[v1] + v1])) - 1) & MEM[v6 - (0x1f & MEM[MEM[v1] + v1])];\n    }\n    emit ActivateToken(varg0, v2);\n}\n\nfunction orderFills(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _orderFills[varg1];\n}\n\nfunction feeTake(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeTake[varg0];\n}\n\nfunction setTokenFeeWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeWithdraw[varg0] = varg1;\n}\n\nfunction 0x4cca(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x4d2a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = address(varg1);\n    v1 = _orderFills[varg0];\n    require(v1 <= varg4);\n    v2 = varg4 - v1;\n    v3 = address(varg3);\n    v4 = address(varg1);\n    v5 = 0x4cca(varg4, _tokens[v4]);\n    v2 = v6 = _SafeDiv(varg2, v5);\n    if (v2 < v6) {\n    }\n    return v2;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction setTokenMinAmountBuy(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _tokensMinAmountBuy[varg0] = varg1;\n}\n\nfunction cancelOrder(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint8 varg6, bytes32 varg7, bytes32 varg8) public nonPayable { \n    require(msg.data.length - 4 >= 288);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = v5 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v6, v7 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v8 = v9 = 0xff & _orders[msg.sender];\n    if (!v9) {\n        MEM[MEM[64]] = 0;\n        v10, v11 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v7), 0xff & (0xff & (0xff & varg6)), varg7, varg8);\n        require(v10); // checks call status, propagates error data on error\n        v8 = v12 = address(v11) == msg.sender;\n    }\n    require(v8);\n    _orderFills[msg.sender] = varg1;\n    emit Cancel(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender, 0xff & (0xff & (0xff & varg6)), varg7, varg8);\n}\n\nfunction setTokenFeeTake(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeTake[varg0] = varg1;\n}\n\nfunction amountFilled(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6) public nonPayable { \n    require(msg.data.length - 4 >= 224);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = v5 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v6, v7 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _orderFills[varg6];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_tokens[msg.sender] >= varg0);\n    v0 = 0x4cca(_feeWithdraw[0], varg0);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= varg0);\n    require(varg0 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg0;\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    v1 = msg.sender.call().value(varg0 - v0 / 0xde0b6b3a7640000).gas(!(varg0 - v0 / 0xde0b6b3a7640000) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Withdraw(0, msg.sender, varg0, _tokens[msg.sender]);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    v0 = 0x3508(varg0);\n    require(v0);\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    v3 = 0x4cca(_feeDeposit[varg0], varg1);\n    assert(0xde0b6b3a7640000);\n    require(v3 / 0xde0b6b3a7640000 <= varg1);\n    require(_tokens[msg.sender] + (varg1 - v3 / 0xde0b6b3a7640000) >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + (varg1 - v3 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + v3 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v3 / 0xde0b6b3a7640000;\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _tokens[varg1];\n}\n\nfunction activeTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _activeTokens[varg0];\n}\n\nfunction setTokenMinAmountSell(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _tokensMinAmountSell[varg0] = varg1;\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction deactivateToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _activeTokens[varg0] = 0x0 | ~0xff & _activeTokens[varg0];\n    require(varg0.code.size);\n    v0, v1 = varg0.symbol().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v1] <= 0x100000000);\n    require(MEM[v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[v1] + v1] > 0x100000000) | (MEM[v1] + v1 + 32 + MEM[MEM[v1] + v1] > v1 + RETURNDATASIZE())));\n    v2 = new array[](MEM[MEM[v1] + v1]);\n    v3 = v4 = 0;\n    while (v3 < MEM[MEM[v1] + v1]) {\n        MEM[v2.data + v3] = MEM[32 + (MEM[v1] + v1) + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = MEM[MEM[v1] + v1] + v2.data;\n    if (0x1f & MEM[MEM[v1] + v1]) {\n        MEM[v6 - (0x1f & MEM[MEM[v1] + v1])] = ~(256 ** (32 - (0x1f & MEM[MEM[v1] + v1])) - 1) & MEM[v6 - (0x1f & MEM[MEM[v1] + v1])];\n    }\n    emit DeactivateToken(varg0, v2);\n}\n\nfunction testTrade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10, address varg11) public nonPayable { \n    require(msg.data.length - 4 >= 384);\n    v0 = 0x3508(varg0);\n    v1 = v2 = !v0;\n    if (v0) {\n        v3 = 0x3508(varg2);\n        v1 = v4 = !v3;\n    }\n    if (!v1) {\n        v5 = v6 = _tokens[varg11] >= varg10;\n        if (v6) {\n            MEM[32 + MEM[64]] = address(this) << 96;\n            MEM[52 + MEM[64]] = varg0 << 96;\n            MEM[72 + MEM[64]] = varg1;\n            MEM[104 + MEM[64]] = varg2 << 96;\n            MEM[124 + MEM[64]] = varg3;\n            MEM[156 + MEM[64]] = varg4;\n            MEM[188 + MEM[64]] = varg5;\n            v7 = v8 = MEM[64];\n            v9 = v10 = 188;\n            v11 = v12 = 32 + MEM[64];\n            while (v9 >= 32) {\n                MEM[v7] = MEM[v11];\n                v7 = v7 + 32;\n                v11 = v11 + 32;\n                v9 = v9 - 32;\n            }\n            MEM[v7] = MEM[v11] & ~(256 ** (32 - v9) - 1) | MEM[v7] & 256 ** (32 - v9) - 1;\n            v13, v14 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v15 = v16 = 0xff & _orders[v14];\n            if (!v16) {\n                MEM[MEM[64]] = 0;\n                v17, v18 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v14), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n                require(v17); // checks call status, propagates error data on error\n                v15 = v19 = address(v18) == varg6;\n            }\n            if (v15) {\n                v15 = v20 = block.number <= varg4;\n            }\n            if (v15) {\n                v21 = v22 = 0x4d2a(v14, varg6, varg3, varg2, varg1);\n            } else {\n                v21 = v23 = 0;\n            }\n            v5 = v24 = v21 >= varg10;\n        }\n        if (v5) {\n            v25 = v26 = 1;\n        } else {\n            v25 = v27 = 0;\n        }\n    } else {\n        v25 = v28 = 0;\n    }\n    return v25;\n}\n\nfunction changeFeeAccount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _feeAccount = varg0;\n}\n\nfunction isTokenActive(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (varg0 != 0) {\n        v0 = 0xff & _activeTokens[varg0];\n    } else {\n        v0 = v1 = 1;\n    }\n    return v0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _admin = varg0;\n}\n\nfunction feeWithdraw(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeWithdraw[varg0];\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    require(_tokens[msg.sender] >= varg1);\n    v0 = 0x4cca(_feeWithdraw[varg0], varg1);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= varg1);\n    require(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    require(varg0.code.size);\n    v1, v2 = varg0.transfer(msg.sender, varg1 - v0 / 0xde0b6b3a7640000).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction orders(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _orders[varg1];\n}\n\nfunction deposit() public payable { \n    v0 = 0x4cca(_feeDeposit[0], msg.value);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= msg.value);\n    require(_tokens[msg.sender] + (msg.value - v0 / 0xde0b6b3a7640000) >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + (msg.value - v0 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    emit Deposit(0, msg.sender, msg.value, _tokens[msg.sender]);\n}\n\nfunction tokensMinAmountBuy(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokensMinAmountBuy[varg0];\n}\n\nfunction tokensMinAmountSell(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokensMinAmountSell[varg0];\n}\n\nfunction setTokenFeeDeposit(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeDeposit[varg0] = varg1;\n}\n\nfunction feeDeposit(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeDeposit[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _tokens[varg1];\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction feeMake(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeMake[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6c86888b > function_selector) {\n            if (0x2a179054 > function_selector) {\n                if (0x1b9bc1b3 > function_selector) {\n                    if (0xa19b14a == function_selector) {\n                        trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256);\n                    } else if (0xb927666 == function_selector) {\n                        order(address,uint256,address,uint256,uint256,uint256);\n                    } else if (0xd1ce2d2 == function_selector) {\n                        activateToken(address);\n                    } else if (0x19774d43 == function_selector) {\n                        orderFills(address,bytes32);\n                    }\n                } else if (0x1b9bc1b3 == function_selector) {\n                    feeTake(address);\n                } else if (0x1e14c48c == function_selector) {\n                    setTokenFeeWithdraw(address,uint256);\n                } else if (0x1f9c381e == function_selector) {\n                    setTokenMinAmountBuy(address,uint256);\n                } else if (0x278b8c0e == function_selector) {\n                    cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32);\n                }\n            } else if (0x508493bc > function_selector) {\n                if (0x2a179054 == function_selector) {\n                    setTokenFeeTake(address,uint256);\n                } else if (0x2d804ca2 == function_selector) {\n                    amountFilled(address,uint256,address,uint256,uint256,uint256,address);\n                } else if (0x2e1a7d4d == function_selector) {\n                    withdraw(uint256);\n                } else if (0x338b5dea == function_selector) {\n                    depositToken(address,uint256);\n                }\n            } else if (0x508493bc == function_selector) {\n                tokens(address,address);\n            } else if (0x5acf6903 == function_selector) {\n                activeTokens(address);\n            } else if (0x5b8d8807 == function_selector) {\n                setTokenMinAmountSell(address,uint256);\n            } else if (0x65e17c9d == function_selector) {\n                feeAccount();\n            } else if (0x68173bcf == function_selector) {\n                deactivateToken(address);\n            }\n        } else if (0xd5a3d9c2 > function_selector) {\n            if (0x998e7a80 > function_selector) {\n                if (0x6c86888b == function_selector) {\n                    testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address);\n                } else if (0x71ffcb16 == function_selector) {\n                    changeFeeAccount(address);\n                } else if (0x895b327e == function_selector) {\n                    isTokenActive(address);\n                } else if (0x8f283970 == function_selector) {\n                    changeAdmin(address);\n                }\n            } else if (0x998e7a80 == function_selector) {\n                feeWithdraw(address);\n            } else if (0x9e281a98 == function_selector) {\n                withdrawToken(address,uint256);\n            } else if (0xbb5f4629 == function_selector) {\n                orders(address,bytes32);\n            } else if (0xd0e30db0 == function_selector) {\n                deposit();\n            }\n        } else if (0xf7888aec > function_selector) {\n            if (0xd5a3d9c2 == function_selector) {\n                tokensMinAmountBuy(address);\n            } else if (0xe190a5c0 == function_selector) {\n                tokensMinAmountSell(address);\n            } else if (0xe41763f2 == function_selector) {\n                setTokenFeeDeposit(address,uint256);\n            } else if (0xec57b730 == function_selector) {\n                feeDeposit(address);\n            }\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfa6416bb == function_selector) {\n            feeMake(address);\n        } else if (0xfb6e155f == function_selector) {\n            availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        } else if (0xfdae6a92 == function_selector) {\n            setTokenFeeMake(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 20:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _feeMake; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _feeTake; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _feeDeposit; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _feeWithdraw; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _orders; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _activeTokens; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokensMinAmountBuy; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _tokensMinAmountSell; // STORAGE[0xb]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTrade(address, uint256, address, uint256, address, address);\nOrder(address, uint256, address, uint256, uint256, uint256, address);\nActivateToken(address, string);\nCancel(address, uint256, address, uint256, uint256, uint256, address, uint8, bytes32, bytes32);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\nDeactivateToken(address, string);\n\nfunction availableVolume(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    require(msg.data.length - 4 >= 320);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v5, v6 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v5); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v7 = v8 = 0xff & _orders[MEM[MEM[64]]];\n    if (!v8) {\n        MEM[MEM[64]] = 0;\n        v9, v10 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', MEM[MEM[64]]), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n        require(v9); // checks call status, propagates error data on error\n        v7 = v11 = address(MEM[MEM[64] - 32]) == varg6;\n    }\n    if (v7) {\n        v7 = block.number <= varg4;\n    }\n    if (v7) {\n        v12 = v13 = 0x4d2a(MEM[MEM[64]], varg6, varg3, varg2, varg1);\n    } else {\n        v12 = v14 = 0;\n    }\n    return v12;\n}\n\nfunction setTokenFeeMake(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeMake[varg0] = varg1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction trade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10) public nonPayable { \n    require(msg.data.length - 4 >= 352);\n    v0 = v1 = 0x3508(varg0);\n    if (v1) {\n        v0 = v2 = 0x3508(varg2);\n    }\n    require(v0);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v3 = v4 = MEM[64];\n    v5 = v6 = 188;\n    v7 = v8 = 32 + MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v9); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v11 = v12 = 0xff & _orders[varg6];\n    if (!v12) {\n        MEM[MEM[64]] = 0;\n        v13, v14 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v10), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n        require(v13); // checks call status, propagates error data on error\n        v11 = v15 = address(v14) == varg6;\n    }\n    if (v11) {\n        v11 = v16 = block.number <= varg4;\n    }\n    if (v11) {\n        require(_orderFills[varg6] + varg10 >= _orderFills[varg6]);\n        v11 = v17 = _orderFills[varg6] + varg10 <= varg1;\n    }\n    require(v11);\n    v18 = 0x4cca(_feeMake[varg0], varg10);\n    assert(0xde0b6b3a7640000);\n    v19 = 0x4cca(_feeTake[varg0], varg10);\n    assert(0xde0b6b3a7640000);\n    require(varg10 + v19 / 0xde0b6b3a7640000 >= varg10);\n    require(varg10 + v19 / 0xde0b6b3a7640000 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - (varg10 + v19 / 0xde0b6b3a7640000);\n    require(v18 / 0xde0b6b3a7640000 <= varg10);\n    require(_tokens[varg6] + (varg10 - v18 / 0xde0b6b3a7640000) >= _tokens[varg6]);\n    _tokens[varg6] = _tokens[varg6] + (varg10 - v18 / 0xde0b6b3a7640000);\n    require(v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000 >= v18 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + (v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000) >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + (v18 / 0xde0b6b3a7640000 + v19 / 0xde0b6b3a7640000);\n    v20 = 0x4cca(varg10, varg3);\n    v21 = _SafeDiv(varg1, v20);\n    require(v21 <= _tokens[varg6]);\n    _tokens[varg6] = _tokens[varg6] - v21;\n    v22 = 0x4cca(varg10, varg3);\n    v23 = _SafeDiv(varg1, v22);\n    require(_tokens[msg.sender] + v23 >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + v23;\n    require(_orderFills[varg6] + varg10 >= _orderFills[varg6]);\n    _orderFills[varg6] = _orderFills[varg6] + varg10;\n    assert(varg1);\n    emit Trade(varg0, varg10, varg2, varg3 * varg10 / varg1, varg6, msg.sender);\n}\n\nfunction order(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    v0 = v1 = 0x3508(varg0);\n    if (v1) {\n        v0 = v2 = 0x3508(varg2);\n    }\n    require(v0);\n    require(varg1 >= _tokensMinAmountBuy[varg0]);\n    require(varg3 >= _tokensMinAmountSell[varg2]);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    v3 = v4 = MEM[64];\n    v5 = v6 = 188;\n    v7 = v8 = 32 + MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v7];\n        v3 = v3 + 32;\n        v7 = v7 + 32;\n        v5 = v5 - 32;\n    }\n    MEM[v3] = MEM[v7] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v9, v10 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v9); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _orders[msg.sender] = 0x1 | ~0xff & _orders[msg.sender];\n    emit Order(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender);\n}\n\nfunction 0x3508(uint256 varg0) private { \n    if (address(varg0) != 0) {\n        v0 = address(varg0);\n        v1 = 0xff & _activeTokens[v0];\n    } else {\n        v1 = v2 = 1;\n    }\n    return v1;\n}\n\nfunction activateToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _activeTokens[varg0] = 0x1 | ~0xff & _activeTokens[varg0];\n    require(varg0.code.size);\n    v0, v1 = varg0.symbol().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v1] <= 0x100000000);\n    require(MEM[v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[v1] + v1] > 0x100000000) | (MEM[v1] + v1 + 32 + MEM[MEM[v1] + v1] > v1 + RETURNDATASIZE())));\n    v2 = new array[](MEM[MEM[v1] + v1]);\n    v3 = v4 = 0;\n    while (v3 < MEM[MEM[v1] + v1]) {\n        MEM[v2.data + v3] = MEM[32 + (MEM[v1] + v1) + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = MEM[MEM[v1] + v1] + v2.data;\n    if (0x1f & MEM[MEM[v1] + v1]) {\n        MEM[v6 - (0x1f & MEM[MEM[v1] + v1])] = ~(256 ** (32 - (0x1f & MEM[MEM[v1] + v1])) - 1) & MEM[v6 - (0x1f & MEM[MEM[v1] + v1])];\n    }\n    emit ActivateToken(varg0, v2);\n}\n\nfunction orderFills(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _orderFills[varg1];\n}\n\nfunction feeTake(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeTake[varg0];\n}\n\nfunction setTokenFeeWithdraw(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeWithdraw[varg0] = varg1;\n}\n\nfunction 0x4cca(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x4d2a(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = address(varg1);\n    v1 = _orderFills[varg0];\n    require(v1 <= varg4);\n    v2 = varg4 - v1;\n    v3 = address(varg3);\n    v4 = address(varg1);\n    v5 = 0x4cca(varg4, _tokens[v4]);\n    v2 = v6 = _SafeDiv(varg2, v5);\n    if (v2 < v6) {\n    }\n    return v2;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    require(varg0 > 0);\n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction setTokenMinAmountBuy(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _tokensMinAmountBuy[varg0] = varg1;\n}\n\nfunction cancelOrder(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint8 varg6, bytes32 varg7, bytes32 varg8) public nonPayable { \n    require(msg.data.length - 4 >= 288);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = v5 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v6, v7 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v8 = v9 = 0xff & _orders[msg.sender];\n    if (!v9) {\n        MEM[MEM[64]] = 0;\n        v10, v11 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v7), 0xff & (0xff & (0xff & varg6)), varg7, varg8);\n        require(v10); // checks call status, propagates error data on error\n        v8 = v12 = address(v11) == msg.sender;\n    }\n    require(v8);\n    _orderFills[msg.sender] = varg1;\n    emit Cancel(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender, 0xff & (0xff & (0xff & varg6)), varg7, varg8);\n}\n\nfunction setTokenFeeTake(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeTake[varg0] = varg1;\n}\n\nfunction amountFilled(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6) public nonPayable { \n    require(msg.data.length - 4 >= 224);\n    MEM[32 + MEM[64]] = address(this) << 96;\n    MEM[52 + MEM[64]] = varg0 << 96;\n    MEM[72 + MEM[64]] = varg1;\n    MEM[104 + MEM[64]] = varg2 << 96;\n    MEM[124 + MEM[64]] = varg3;\n    MEM[156 + MEM[64]] = varg4;\n    MEM[188 + MEM[64]] = varg5;\n    MEM[64] += 220;\n    v0 = v1 = MEM[64];\n    v2 = v3 = 188;\n    v4 = v5 = 32 + MEM[64];\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v0 = v0 + 32;\n        v4 = v4 + 32;\n        v2 = v2 - 32;\n    }\n    MEM[v0] = MEM[v4] & ~(256 ** (32 - v2) - 1) | MEM[v0] & 256 ** (32 - v2) - 1;\n    v6, v7 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _orderFills[varg6];\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_tokens[msg.sender] >= varg0);\n    v0 = 0x4cca(_feeWithdraw[0], varg0);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= varg0);\n    require(varg0 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg0;\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    v1 = msg.sender.call().value(varg0 - v0 / 0xde0b6b3a7640000).gas(!(varg0 - v0 / 0xde0b6b3a7640000) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    emit Withdraw(0, msg.sender, varg0, _tokens[msg.sender]);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    v0 = 0x3508(varg0);\n    require(v0);\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    v3 = 0x4cca(_feeDeposit[varg0], varg1);\n    assert(0xde0b6b3a7640000);\n    require(v3 / 0xde0b6b3a7640000 <= varg1);\n    require(_tokens[msg.sender] + (varg1 - v3 / 0xde0b6b3a7640000) >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + (varg1 - v3 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + v3 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v3 / 0xde0b6b3a7640000;\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _tokens[varg1];\n}\n\nfunction activeTokens(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return 0xff & _activeTokens[varg0];\n}\n\nfunction setTokenMinAmountSell(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _tokensMinAmountSell[varg0] = varg1;\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction deactivateToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _activeTokens[varg0] = 0x0 | ~0xff & _activeTokens[varg0];\n    require(varg0.code.size);\n    v0, v1 = varg0.symbol().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[v1] <= 0x100000000);\n    require(MEM[v1] + v1 + 32 <= v1 + RETURNDATASIZE());\n    require(!((MEM[MEM[v1] + v1] > 0x100000000) | (MEM[v1] + v1 + 32 + MEM[MEM[v1] + v1] > v1 + RETURNDATASIZE())));\n    v2 = new array[](MEM[MEM[v1] + v1]);\n    v3 = v4 = 0;\n    while (v3 < MEM[MEM[v1] + v1]) {\n        MEM[v2.data + v3] = MEM[32 + (MEM[v1] + v1) + v3];\n        v3 = v3 + 32;\n    }\n    v5 = v6 = MEM[MEM[v1] + v1] + v2.data;\n    if (0x1f & MEM[MEM[v1] + v1]) {\n        MEM[v6 - (0x1f & MEM[MEM[v1] + v1])] = ~(256 ** (32 - (0x1f & MEM[MEM[v1] + v1])) - 1) & MEM[v6 - (0x1f & MEM[MEM[v1] + v1])];\n    }\n    emit DeactivateToken(varg0, v2);\n}\n\nfunction testTrade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10, address varg11) public nonPayable { \n    require(msg.data.length - 4 >= 384);\n    v0 = 0x3508(varg0);\n    v1 = v2 = !v0;\n    if (v0) {\n        v3 = 0x3508(varg2);\n        v1 = v4 = !v3;\n    }\n    if (!v1) {\n        v5 = v6 = _tokens[varg11] >= varg10;\n        if (v6) {\n            MEM[32 + MEM[64]] = address(this) << 96;\n            MEM[52 + MEM[64]] = varg0 << 96;\n            MEM[72 + MEM[64]] = varg1;\n            MEM[104 + MEM[64]] = varg2 << 96;\n            MEM[124 + MEM[64]] = varg3;\n            MEM[156 + MEM[64]] = varg4;\n            MEM[188 + MEM[64]] = varg5;\n            v7 = v8 = MEM[64];\n            v9 = v10 = 188;\n            v11 = v12 = 32 + MEM[64];\n            while (v9 >= 32) {\n                MEM[v7] = MEM[v11];\n                v7 = v7 + 32;\n                v11 = v11 + 32;\n                v9 = v9 - 32;\n            }\n            MEM[v7] = MEM[v11] & ~(256 ** (32 - v9) - 1) | MEM[v7] & 256 ** (32 - v9) - 1;\n            v13, v14 = sha256hash(MEM[(MEM[64]) len 188], MEM[(MEM[64]) len 32]);\n            require(v13); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            v15 = v16 = 0xff & _orders[v14];\n            if (!v16) {\n                MEM[MEM[64]] = 0;\n                v17, v18 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v14), 0xff & (0xff & (0xff & varg7)), varg8, varg9);\n                require(v17); // checks call status, propagates error data on error\n                v15 = v19 = address(v18) == varg6;\n            }\n            if (v15) {\n                v15 = v20 = block.number <= varg4;\n            }\n            if (v15) {\n                v21 = v22 = 0x4d2a(v14, varg6, varg3, varg2, varg1);\n            } else {\n                v21 = v23 = 0;\n            }\n            v5 = v24 = v21 >= varg10;\n        }\n        if (v5) {\n            v25 = v26 = 1;\n        } else {\n            v25 = v27 = 0;\n        }\n    } else {\n        v25 = v28 = 0;\n    }\n    return v25;\n}\n\nfunction changeFeeAccount(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _feeAccount = varg0;\n}\n\nfunction isTokenActive(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (varg0 != 0) {\n        v0 = 0xff & _activeTokens[varg0];\n    } else {\n        v0 = v1 = 1;\n    }\n    return v0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _admin);\n    _admin = varg0;\n}\n\nfunction feeWithdraw(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeWithdraw[varg0];\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 != 0);\n    require(_tokens[msg.sender] >= varg1);\n    v0 = 0x4cca(_feeWithdraw[varg0], varg1);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= varg1);\n    require(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    require(varg0.code.size);\n    v1, v2 = varg0.transfer(msg.sender, varg1 - v0 / 0xde0b6b3a7640000).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction orders(address varg0, bytes32 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return 0xff & _orders[varg1];\n}\n\nfunction deposit() public payable { \n    v0 = 0x4cca(_feeDeposit[0], msg.value);\n    assert(0xde0b6b3a7640000);\n    require(v0 / 0xde0b6b3a7640000 <= msg.value);\n    require(_tokens[msg.sender] + (msg.value - v0 / 0xde0b6b3a7640000) >= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] + (msg.value - v0 / 0xde0b6b3a7640000);\n    require(_tokens[_feeAccount] + v0 / 0xde0b6b3a7640000 >= _tokens[_feeAccount]);\n    _tokens[_feeAccount] = _tokens[_feeAccount] + v0 / 0xde0b6b3a7640000;\n    emit Deposit(0, msg.sender, msg.value, _tokens[msg.sender]);\n}\n\nfunction tokensMinAmountBuy(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokensMinAmountBuy[varg0];\n}\n\nfunction tokensMinAmountSell(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokensMinAmountSell[varg0];\n}\n\nfunction setTokenFeeDeposit(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _admin);\n    _feeDeposit[varg0] = varg1;\n}\n\nfunction feeDeposit(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeDeposit[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _tokens[varg1];\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction feeMake(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _feeMake[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6c86888b > function_selector) {\n            if (0x2a179054 > function_selector) {\n                if (0x1b9bc1b3 > function_selector) {\n                    if (0xa19b14a == function_selector) {\n                        trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256);\n                    } else if (0xb927666 == function_selector) {\n                        order(address,uint256,address,uint256,uint256,uint256);\n                    } else if (0xd1ce2d2 == function_selector) {\n                        activateToken(address);\n                    } else if (0x19774d43 == function_selector) {\n                        orderFills(address,bytes32);\n                    }\n                } else if (0x1b9bc1b3 == function_selector) {\n                    feeTake(address);\n                } else if (0x1e14c48c == function_selector) {\n                    setTokenFeeWithdraw(address,uint256);\n                } else if (0x1f9c381e == function_selector) {\n                    setTokenMinAmountBuy(address,uint256);\n                } else if (0x278b8c0e == function_selector) {\n                    cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32);\n                }\n            } else if (0x508493bc > function_selector) {\n                if (0x2a179054 == function_selector) {\n                    setTokenFeeTake(address,uint256);\n                } else if (0x2d804ca2 == function_selector) {\n                    amountFilled(address,uint256,address,uint256,uint256,uint256,address);\n                } else if (0x2e1a7d4d == function_selector) {\n                    withdraw(uint256);\n                } else if (0x338b5dea == function_selector) {\n                    depositToken(address,uint256);\n                }\n            } else if (0x508493bc == function_selector) {\n                tokens(address,address);\n            } else if (0x5acf6903 == function_selector) {\n                activeTokens(address);\n            } else if (0x5b8d8807 == function_selector) {\n                setTokenMinAmountSell(address,uint256);\n            } else if (0x65e17c9d == function_selector) {\n                feeAccount();\n            } else if (0x68173bcf == function_selector) {\n                deactivateToken(address);\n            }\n        } else if (0xd5a3d9c2 > function_selector) {\n            if (0x998e7a80 > function_selector) {\n                if (0x6c86888b == function_selector) {\n                    testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address);\n                } else if (0x71ffcb16 == function_selector) {\n                    changeFeeAccount(address);\n                } else if (0x895b327e == function_selector) {\n                    isTokenActive(address);\n                } else if (0x8f283970 == function_selector) {\n                    changeAdmin(address);\n                }\n            } else if (0x998e7a80 == function_selector) {\n                feeWithdraw(address);\n            } else if (0x9e281a98 == function_selector) {\n                withdrawToken(address,uint256);\n            } else if (0xbb5f4629 == function_selector) {\n                orders(address,bytes32);\n            } else if (0xd0e30db0 == function_selector) {\n                deposit();\n            }\n        } else if (0xf7888aec > function_selector) {\n            if (0xd5a3d9c2 == function_selector) {\n                tokensMinAmountBuy(address);\n            } else if (0xe190a5c0 == function_selector) {\n                tokensMinAmountSell(address);\n            } else if (0xe41763f2 == function_selector) {\n                setTokenFeeDeposit(address,uint256);\n            } else if (0xec57b730 == function_selector) {\n                feeDeposit(address);\n            }\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfa6416bb == function_selector) {\n            feeMake(address);\n        } else if (0xfb6e155f == function_selector) {\n            availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        } else if (0xfdae6a92 == function_selector) {\n            setTokenFeeMake(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 25.090510368347168,
	"usage": {
		"completion_tokens": 538,
		"prompt_tokens": 8862,
		"total_tokens": 9400
	}
}