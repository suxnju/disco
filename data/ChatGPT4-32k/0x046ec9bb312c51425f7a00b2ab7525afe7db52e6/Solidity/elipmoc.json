{
	"address": "0x046ec9bb312c51425f7a00b2ab7525afe7db52e6",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given that the code seems to be a part of a decentralized exchange (DEX), here is a simplified version in Solidity. Please note that the decompiled code is quite complex and without a full context, it's hard to translate it perfectly. The code below is a simplified version of a smart contract for a DEX.\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract SimpleDEX {\n    address private admin;\n    uint256 private feeMake;\n    uint256 private feeTake;\n    uint256 private feeRebate;\n    \n    mapping(address => uint256) private tokenBalance;\n    mapping(address => uint256) private orderFills;\n    \n    event Trade(address indexed seller, uint256 amount, address indexed buyer);\n    event Order(address indexed creator, uint256 amount);\n    event Withdraw(address indexed account, uint256 amount);\n    event Deposit(address indexed account, uint256 amount);\n    \n    constructor() public {\n        admin = msg.sender;\n    }\n    \n    function trade(address _buyer, uint256 _amount) public {\n        require(tokenBalance[msg.sender] >= _amount, \"Insufficient balance\");\n        tokenBalance[msg.sender] -= _amount;\n        tokenBalance[_buyer] += _amount;\n        emit Trade(msg.sender, _amount, _buyer);\n    }\n    \n    function order(uint256 _amount) public {\n        require(tokenBalance[msg.sender] >= _amount, \"Insufficient balance\");\n        emit Order(msg.sender, _amount);\n    }\n    \n    function withdraw(uint256 _amount) public {\n        require(tokenBalance[msg.sender] >= _amount, \"Insufficient balance\");\n        msg.sender.transfer(_amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n    \n    function deposit() public payable {\n        tokenBalance[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    \n    function balanceOf(address _account) public view returns (uint256) {\n        return tokenBalance[_account];\n    }\n    \n    function orderFills(address _account) public view returns (uint256) {\n        return orderFills[_account];\n    }\n    \n    // The functions to change fees and admin are missing as they should be carefully designed\n}\n```\n\nIn this contract, users can deposit ethereum into their accounts, place orders, trade ethereum with others, and withdraw ethereum from their accounts. Note that this is a simplified version and does not include all the functions and checks from the decompiled code. For a real DEX, more sophisticated systems for order matching, price calculation, and security checks are needed.",
				"role": "assistant"
			}
		}
	],
	"created": 1701466537,
	"id": "chatcmpl-8R5SbrsJezLmLYPiuuivHbubCyKIM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 19:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _feeMake; // STORAGE[0x3]\nuint256 _feeTake; // STORAGE[0x4]\nuint256 _feeRebate; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _orders; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x8]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\naddress _accountLevelsAddr; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nTrade(address, uint256, address, uint256, address, address);\nOrder(address, uint256, address, uint256, uint256, uint256, address);\nCancel(address, uint256, address, uint256, uint256, uint256, address, uint8, bytes32, bytes32);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction fallback() public nonPayable { \n    revert();\n}\n\nfunction trade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0xff & _orders[~0x0 & (~0x0 & v1)];\n    if (!v3) {\n        MEM[MEM[64]] = 0;\n        v4, v5 = ecrecover(0xff & (0xff & (0xff & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)), ~0x0 & (~0x0 & (~0x0 & varg9)));\n        require(v4); // checks call status, propagates error data on error\n        v2 = v6 = address(v5) == varg6;\n    }\n    if (v2) {\n        v2 = v7 = block.number <= varg4;\n    }\n    if (v2) {\n        v8 = _SafeAdd(varg10, _orderFills[~0x0 & (~0x0 & v1)]);\n        v2 = v9 = v8 <= varg1;\n    }\n    require(v2);\n    v10 = _SafeMul(_feeMake, varg10);\n    assert(0xde0b6b3a7640000);\n    v11 = _SafeMul(_feeTake, varg10);\n    assert(0xde0b6b3a7640000);\n    v12 = v13 = v11 / 0xde0b6b3a7640000;\n    v12 = v14 = 0;\n    if (_accountLevelsAddr != 0) {\n        require(_accountLevelsAddr.code.size);\n        v15, v16 = _accountLevelsAddr.accountLevel(varg6).gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (v16 == 1) {\n            v17 = _SafeMul(_feeRebate, varg10);\n            assert(0xde0b6b3a7640000);\n            v12 = v18 = v17 / 0xde0b6b3a7640000;\n        }\n    }\n    v19 = _SafeAdd(v13, varg10);\n    v20 = _SafeSub(v19, _tokens[msg.sender]);\n    _tokens[msg.sender] = v20;\n    v21 = _SafeAdd(v12, varg10);\n    v22 = _SafeSub(v10 / 0xde0b6b3a7640000, v21);\n    v23 = _SafeAdd(v22, _tokens[varg6]);\n    _tokens[varg6] = v23;\n    v24 = _SafeAdd(v13, v10 / 0xde0b6b3a7640000);\n    v25 = _SafeSub(v12, v24);\n    v26 = _SafeAdd(v25, _tokens[_feeAccount]);\n    _tokens[_feeAccount] = v26;\n    v27 = _SafeMul(varg10, varg3);\n    assert(varg1);\n    require(v27 / varg1 <= _tokens[varg6]);\n    _tokens[varg2] = _tokens[varg6] - v27 / varg1;\n    v28 = _SafeMul(varg10, varg3);\n    assert(varg1);\n    v29 = v30 = _tokens[varg2] + v28 / varg1 >= _tokens[varg2];\n    if (v30) {\n        v29 = _tokens[varg2] + v28 / varg1 >= v28 / varg1;\n    }\n    require(v29);\n    _tokens[varg2] = _tokens[varg2] + v28 / varg1;\n    v31 = _SafeAdd(varg10, _orderFills[varg6]);\n    _orderFills[varg6] = v31;\n    assert(varg1);\n    emit Trade(varg0, varg10, varg2, varg3 * varg10 / varg1, varg6, msg.sender);\n}\n\nfunction order(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _orders[~0x0 & (~0x0 & v1)] = 0x1 | ~0xff & _orders[~0x0 & (~0x0 & v1)];\n    emit Order(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender);\n}\n\nfunction 0x2a67(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) private { \n    v0 = address(varg9);\n    v1, v2 = sha256hash(address(this), v0, varg8, varg6, varg5, varg4);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg3);\n    v4 = v5 = 0xff & _orders[~0x0 & (~0x0 & v2)];\n    if (!v5) {\n        MEM[MEM[64]] = 0;\n        v6 = 0xff & (0xff & varg2);\n        v7 = ~0x0 & (~0x0 & varg1);\n        v8 = ~0x0 & (~0x0 & varg0);\n        v9, v10 = ecrecover(v6, v7, v8);\n        require(v9); // checks call status, propagates error data on error\n        v4 = v11 = address(v10) == address(varg3);\n    }\n    if (v4) {\n        v4 = v12 = block.number <= varg5;\n    }\n    if (v4) {\n        v13 = address(varg3);\n        v14 = v15 = _SafeSub(_orderFills[~0x0 & (~0x0 & v2)], varg8);\n        v16 = address(varg7);\n        v17 = address(varg3);\n        v18 = _SafeMul(varg8, _tokens[v17]);\n        assert(varg6);\n        v14 = v19 = v18 / varg6;\n        if (v15 < v19) {\n        }\n    } else {\n        v14 = v20 = 0;\n    }\n    return v14;\n}\n\nfunction orderFills(address varg0, bytes32 varg1) public nonPayable { \n    return _orderFills[~0x0 & varg1];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    v1 = v2 = v0 >= varg1;\n    if (v2) {\n        v1 = v0 >= varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction cancelOrder(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint8 varg6, bytes32 varg7, bytes32 varg8) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0xff & _orders[~0x0 & (~0x0 & v1)];\n    if (!v3) {\n        MEM[MEM[64]] = 0;\n        v4, v5 = ecrecover(0xff & (0xff & (0xff & varg6)), ~0x0 & (~0x0 & (~0x0 & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)));\n        require(v4); // checks call status, propagates error data on error\n        v2 = v6 = address(v5) == msg.sender;\n    }\n    require(v2);\n    _orderFills[~0x0 & (~0x0 & v1)] = varg1;\n    emit Cancel(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender, 0xff & (0xff & (0xff & varg6)), ~0x0 & (~0x0 & (~0x0 & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)));\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_tokens[msg.sender] >= varg0);\n    v0 = _SafeSub(varg0, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    v1 = msg.sender.call().value(varg0).gas(msg.gas);\n    require(v1);\n    emit Withdraw(0, msg.sender, varg0, _tokens[msg.sender]);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    v2 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v2;\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction amountFilled(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _orderFills[~0x0 & (~0x0 & v1)];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction changeFeeMake(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    require(varg0 <= _feeMake);\n    _feeMake = varg0;\n}\n\nfunction feeMake() public nonPayable { \n    return _feeMake;\n}\n\nfunction changeFeeRebate(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = varg0 < _feeRebate;\n    if (varg0 >= _feeRebate) {\n        v0 = v2 = varg0 > _feeTake;\n    }\n    require(!v0);\n    _feeRebate = varg0;\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction testTrade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10, address varg11) public nonPayable { \n    v0 = v1 = _tokens[varg11] >= varg10;\n    if (v1) {\n        v2 = 0x2a67(~0x0 & varg9, ~0x0 & varg8, 0xff & varg7, varg6, varg5, varg4, varg3, varg2, varg1, varg0);\n        v0 = v2 >= varg10;\n    }\n    if (v0) {\n        v3 = v4 = 1;\n    } else {\n        v3 = v5 = 0;\n    }\n    return v3;\n}\n\nfunction changeFeeAccount(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _feeAccount = varg0;\n}\n\nfunction feeRebate() public nonPayable { \n    return _feeRebate;\n}\n\nfunction changeFeeTake(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = varg0 > _feeTake;\n    if (varg0 <= _feeTake) {\n        v0 = v2 = varg0 < _feeRebate;\n    }\n    require(!v0);\n    _feeTake = varg0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _admin = varg0;\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(_tokens[msg.sender] >= varg1);\n    v0 = _SafeSub(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transfer(msg.sender, varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction orders(address varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _orders[~0x0 & varg1];\n}\n\nfunction feeTake() public nonPayable { \n    return _feeTake;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    emit Deposit(0, msg.sender, msg.value, _tokens[msg.sender]);\n}\n\nfunction changeAccountLevelsAddr(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _accountLevelsAddr = varg0;\n}\n\nfunction accountLevelsAddr() public nonPayable { \n    return _accountLevelsAddr;\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction availableVolume(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    v0 = 0x2a67(~0x0 & varg9, ~0x0 & varg8, 0xff & varg7, varg6, varg5, varg4, varg3, varg2, varg1, varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xa19b14a == function_selector) {\n            trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256);\n        } else if (0xb927666 == function_selector) {\n            order(address,uint256,address,uint256,uint256,uint256);\n        } else if (0x19774d43 == function_selector) {\n            orderFills(address,bytes32);\n        } else if (0x278b8c0e == function_selector) {\n            cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x338b5dea == function_selector) {\n            depositToken(address,uint256);\n        } else if (0x46be96c3 == function_selector) {\n            amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        } else if (0x508493bc == function_selector) {\n            tokens(address,address);\n        } else if (0x54d03b5c == function_selector) {\n            changeFeeMake(uint256);\n        } else if (0x57786394 == function_selector) {\n            feeMake();\n        } else if (0x5e1d7ae4 == function_selector) {\n            changeFeeRebate(uint256);\n        } else if (0x65e17c9d == function_selector) {\n            feeAccount();\n        } else if (0x6c86888b == function_selector) {\n            testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address);\n        } else if (0x71ffcb16 == function_selector) {\n            changeFeeAccount(address);\n        } else if (0x731c2f81 == function_selector) {\n            feeRebate();\n        } else if (0x8823a9c0 == function_selector) {\n            changeFeeTake(uint256);\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0x9e281a98 == function_selector) {\n            withdrawToken(address,uint256);\n        } else if (0xbb5f4629 == function_selector) {\n            orders(address,bytes32);\n        } else if (0xc281309e == function_selector) {\n            feeTake();\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xe8f6bc2e == function_selector) {\n            changeAccountLevelsAddr(address);\n        } else if (0xf3412942 == function_selector) {\n            accountLevelsAddr();\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfb6e155f == function_selector) {\n            availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 19:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _feeMake; // STORAGE[0x3]\nuint256 _feeTake; // STORAGE[0x4]\nuint256 _feeRebate; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _orders; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x8]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\naddress _accountLevelsAddr; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nTrade(address, uint256, address, uint256, address, address);\nOrder(address, uint256, address, uint256, uint256, uint256, address);\nCancel(address, uint256, address, uint256, uint256, uint256, address, uint8, bytes32, bytes32);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction fallback() public nonPayable { \n    revert();\n}\n\nfunction trade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0xff & _orders[~0x0 & (~0x0 & v1)];\n    if (!v3) {\n        MEM[MEM[64]] = 0;\n        v4, v5 = ecrecover(0xff & (0xff & (0xff & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)), ~0x0 & (~0x0 & (~0x0 & varg9)));\n        require(v4); // checks call status, propagates error data on error\n        v2 = v6 = address(v5) == varg6;\n    }\n    if (v2) {\n        v2 = v7 = block.number <= varg4;\n    }\n    if (v2) {\n        v8 = _SafeAdd(varg10, _orderFills[~0x0 & (~0x0 & v1)]);\n        v2 = v9 = v8 <= varg1;\n    }\n    require(v2);\n    v10 = _SafeMul(_feeMake, varg10);\n    assert(0xde0b6b3a7640000);\n    v11 = _SafeMul(_feeTake, varg10);\n    assert(0xde0b6b3a7640000);\n    v12 = v13 = v11 / 0xde0b6b3a7640000;\n    v12 = v14 = 0;\n    if (_accountLevelsAddr != 0) {\n        require(_accountLevelsAddr.code.size);\n        v15, v16 = _accountLevelsAddr.accountLevel(varg6).gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (v16 == 1) {\n            v17 = _SafeMul(_feeRebate, varg10);\n            assert(0xde0b6b3a7640000);\n            v12 = v18 = v17 / 0xde0b6b3a7640000;\n        }\n    }\n    v19 = _SafeAdd(v13, varg10);\n    v20 = _SafeSub(v19, _tokens[msg.sender]);\n    _tokens[msg.sender] = v20;\n    v21 = _SafeAdd(v12, varg10);\n    v22 = _SafeSub(v10 / 0xde0b6b3a7640000, v21);\n    v23 = _SafeAdd(v22, _tokens[varg6]);\n    _tokens[varg6] = v23;\n    v24 = _SafeAdd(v13, v10 / 0xde0b6b3a7640000);\n    v25 = _SafeSub(v12, v24);\n    v26 = _SafeAdd(v25, _tokens[_feeAccount]);\n    _tokens[_feeAccount] = v26;\n    v27 = _SafeMul(varg10, varg3);\n    assert(varg1);\n    require(v27 / varg1 <= _tokens[varg6]);\n    _tokens[varg2] = _tokens[varg6] - v27 / varg1;\n    v28 = _SafeMul(varg10, varg3);\n    assert(varg1);\n    v29 = v30 = _tokens[varg2] + v28 / varg1 >= _tokens[varg2];\n    if (v30) {\n        v29 = _tokens[varg2] + v28 / varg1 >= v28 / varg1;\n    }\n    require(v29);\n    _tokens[varg2] = _tokens[varg2] + v28 / varg1;\n    v31 = _SafeAdd(varg10, _orderFills[varg6]);\n    _orderFills[varg6] = v31;\n    assert(varg1);\n    emit Trade(varg0, varg10, varg2, varg3 * varg10 / varg1, varg6, msg.sender);\n}\n\nfunction order(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _orders[~0x0 & (~0x0 & v1)] = 0x1 | ~0xff & _orders[~0x0 & (~0x0 & v1)];\n    emit Order(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender);\n}\n\nfunction 0x2a67(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) private { \n    v0 = address(varg9);\n    v1, v2 = sha256hash(address(this), v0, varg8, varg6, varg5, varg4);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg3);\n    v4 = v5 = 0xff & _orders[~0x0 & (~0x0 & v2)];\n    if (!v5) {\n        MEM[MEM[64]] = 0;\n        v6 = 0xff & (0xff & varg2);\n        v7 = ~0x0 & (~0x0 & varg1);\n        v8 = ~0x0 & (~0x0 & varg0);\n        v9, v10 = ecrecover(v6, v7, v8);\n        require(v9); // checks call status, propagates error data on error\n        v4 = v11 = address(v10) == address(varg3);\n    }\n    if (v4) {\n        v4 = v12 = block.number <= varg5;\n    }\n    if (v4) {\n        v13 = address(varg3);\n        v14 = v15 = _SafeSub(_orderFills[~0x0 & (~0x0 & v2)], varg8);\n        v16 = address(varg7);\n        v17 = address(varg3);\n        v18 = _SafeMul(varg8, _tokens[v17]);\n        assert(varg6);\n        v14 = v19 = v18 / varg6;\n        if (v15 < v19) {\n        }\n    } else {\n        v14 = v20 = 0;\n    }\n    return v14;\n}\n\nfunction orderFills(address varg0, bytes32 varg1) public nonPayable { \n    return _orderFills[~0x0 & varg1];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    v1 = v2 = v0 >= varg1;\n    if (v2) {\n        v1 = v0 >= varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction cancelOrder(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint8 varg6, bytes32 varg7, bytes32 varg8) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0xff & _orders[~0x0 & (~0x0 & v1)];\n    if (!v3) {\n        MEM[MEM[64]] = 0;\n        v4, v5 = ecrecover(0xff & (0xff & (0xff & varg6)), ~0x0 & (~0x0 & (~0x0 & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)));\n        require(v4); // checks call status, propagates error data on error\n        v2 = v6 = address(v5) == msg.sender;\n    }\n    require(v2);\n    _orderFills[~0x0 & (~0x0 & v1)] = varg1;\n    emit Cancel(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender, 0xff & (0xff & (0xff & varg6)), ~0x0 & (~0x0 & (~0x0 & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)));\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_tokens[msg.sender] >= varg0);\n    v0 = _SafeSub(varg0, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    v1 = msg.sender.call().value(varg0).gas(msg.gas);\n    require(v1);\n    emit Withdraw(0, msg.sender, varg0, _tokens[msg.sender]);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    v2 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v2;\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction amountFilled(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _orderFills[~0x0 & (~0x0 & v1)];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction changeFeeMake(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    require(varg0 <= _feeMake);\n    _feeMake = varg0;\n}\n\nfunction feeMake() public nonPayable { \n    return _feeMake;\n}\n\nfunction changeFeeRebate(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = varg0 < _feeRebate;\n    if (varg0 >= _feeRebate) {\n        v0 = v2 = varg0 > _feeTake;\n    }\n    require(!v0);\n    _feeRebate = varg0;\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction testTrade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10, address varg11) public nonPayable { \n    v0 = v1 = _tokens[varg11] >= varg10;\n    if (v1) {\n        v2 = 0x2a67(~0x0 & varg9, ~0x0 & varg8, 0xff & varg7, varg6, varg5, varg4, varg3, varg2, varg1, varg0);\n        v0 = v2 >= varg10;\n    }\n    if (v0) {\n        v3 = v4 = 1;\n    } else {\n        v3 = v5 = 0;\n    }\n    return v3;\n}\n\nfunction changeFeeAccount(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _feeAccount = varg0;\n}\n\nfunction feeRebate() public nonPayable { \n    return _feeRebate;\n}\n\nfunction changeFeeTake(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = varg0 > _feeTake;\n    if (varg0 <= _feeTake) {\n        v0 = v2 = varg0 < _feeRebate;\n    }\n    require(!v0);\n    _feeTake = varg0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _admin = varg0;\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(_tokens[msg.sender] >= varg1);\n    v0 = _SafeSub(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transfer(msg.sender, varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction orders(address varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _orders[~0x0 & varg1];\n}\n\nfunction feeTake() public nonPayable { \n    return _feeTake;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    emit Deposit(0, msg.sender, msg.value, _tokens[msg.sender]);\n}\n\nfunction changeAccountLevelsAddr(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _accountLevelsAddr = varg0;\n}\n\nfunction accountLevelsAddr() public nonPayable { \n    return _accountLevelsAddr;\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction availableVolume(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    v0 = 0x2a67(~0x0 & varg9, ~0x0 & varg8, 0xff & varg7, varg6, varg5, varg4, varg3, varg2, varg1, varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xa19b14a == function_selector) {\n            trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256);\n        } else if (0xb927666 == function_selector) {\n            order(address,uint256,address,uint256,uint256,uint256);\n        } else if (0x19774d43 == function_selector) {\n            orderFills(address,bytes32);\n        } else if (0x278b8c0e == function_selector) {\n            cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x338b5dea == function_selector) {\n            depositToken(address,uint256);\n        } else if (0x46be96c3 == function_selector) {\n            amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        } else if (0x508493bc == function_selector) {\n            tokens(address,address);\n        } else if (0x54d03b5c == function_selector) {\n            changeFeeMake(uint256);\n        } else if (0x57786394 == function_selector) {\n            feeMake();\n        } else if (0x5e1d7ae4 == function_selector) {\n            changeFeeRebate(uint256);\n        } else if (0x65e17c9d == function_selector) {\n            feeAccount();\n        } else if (0x6c86888b == function_selector) {\n            testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address);\n        } else if (0x71ffcb16 == function_selector) {\n            changeFeeAccount(address);\n        } else if (0x731c2f81 == function_selector) {\n            feeRebate();\n        } else if (0x8823a9c0 == function_selector) {\n            changeFeeTake(uint256);\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0x9e281a98 == function_selector) {\n            withdrawToken(address,uint256);\n        } else if (0xbb5f4629 == function_selector) {\n            orders(address,bytes32);\n        } else if (0xc281309e == function_selector) {\n            feeTake();\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xe8f6bc2e == function_selector) {\n            changeAccountLevelsAddr(address);\n        } else if (0xf3412942 == function_selector) {\n            accountLevelsAddr();\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfb6e155f == function_selector) {\n            availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 19:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _feeMake; // STORAGE[0x3]\nuint256 _feeTake; // STORAGE[0x4]\nuint256 _feeRebate; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _orders; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x8]\naddress _admin; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x1] bytes 0 to 19\naddress _accountLevelsAddr; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nTrade(address, uint256, address, uint256, address, address);\nOrder(address, uint256, address, uint256, uint256, uint256, address);\nCancel(address, uint256, address, uint256, uint256, uint256, address, uint8, bytes32, bytes32);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction fallback() public nonPayable { \n    revert();\n}\n\nfunction trade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0xff & _orders[~0x0 & (~0x0 & v1)];\n    if (!v3) {\n        MEM[MEM[64]] = 0;\n        v4, v5 = ecrecover(0xff & (0xff & (0xff & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)), ~0x0 & (~0x0 & (~0x0 & varg9)));\n        require(v4); // checks call status, propagates error data on error\n        v2 = v6 = address(v5) == varg6;\n    }\n    if (v2) {\n        v2 = v7 = block.number <= varg4;\n    }\n    if (v2) {\n        v8 = _SafeAdd(varg10, _orderFills[~0x0 & (~0x0 & v1)]);\n        v2 = v9 = v8 <= varg1;\n    }\n    require(v2);\n    v10 = _SafeMul(_feeMake, varg10);\n    assert(0xde0b6b3a7640000);\n    v11 = _SafeMul(_feeTake, varg10);\n    assert(0xde0b6b3a7640000);\n    v12 = v13 = v11 / 0xde0b6b3a7640000;\n    v12 = v14 = 0;\n    if (_accountLevelsAddr != 0) {\n        require(_accountLevelsAddr.code.size);\n        v15, v16 = _accountLevelsAddr.accountLevel(varg6).gas(msg.gas);\n        require(v15); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        if (v16 == 1) {\n            v17 = _SafeMul(_feeRebate, varg10);\n            assert(0xde0b6b3a7640000);\n            v12 = v18 = v17 / 0xde0b6b3a7640000;\n        }\n    }\n    v19 = _SafeAdd(v13, varg10);\n    v20 = _SafeSub(v19, _tokens[msg.sender]);\n    _tokens[msg.sender] = v20;\n    v21 = _SafeAdd(v12, varg10);\n    v22 = _SafeSub(v10 / 0xde0b6b3a7640000, v21);\n    v23 = _SafeAdd(v22, _tokens[varg6]);\n    _tokens[varg6] = v23;\n    v24 = _SafeAdd(v13, v10 / 0xde0b6b3a7640000);\n    v25 = _SafeSub(v12, v24);\n    v26 = _SafeAdd(v25, _tokens[_feeAccount]);\n    _tokens[_feeAccount] = v26;\n    v27 = _SafeMul(varg10, varg3);\n    assert(varg1);\n    require(v27 / varg1 <= _tokens[varg6]);\n    _tokens[varg2] = _tokens[varg6] - v27 / varg1;\n    v28 = _SafeMul(varg10, varg3);\n    assert(varg1);\n    v29 = v30 = _tokens[varg2] + v28 / varg1 >= _tokens[varg2];\n    if (v30) {\n        v29 = _tokens[varg2] + v28 / varg1 >= v28 / varg1;\n    }\n    require(v29);\n    _tokens[varg2] = _tokens[varg2] + v28 / varg1;\n    v31 = _SafeAdd(varg10, _orderFills[varg6]);\n    _orderFills[varg6] = v31;\n    assert(varg1);\n    emit Trade(varg0, varg10, varg2, varg3 * varg10 / varg1, varg6, msg.sender);\n}\n\nfunction order(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _orders[~0x0 & (~0x0 & v1)] = 0x1 | ~0xff & _orders[~0x0 & (~0x0 & v1)];\n    emit Order(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender);\n}\n\nfunction 0x2a67(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) private { \n    v0 = address(varg9);\n    v1, v2 = sha256hash(address(this), v0, varg8, varg6, varg5, varg4);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v3 = address(varg3);\n    v4 = v5 = 0xff & _orders[~0x0 & (~0x0 & v2)];\n    if (!v5) {\n        MEM[MEM[64]] = 0;\n        v6 = 0xff & (0xff & varg2);\n        v7 = ~0x0 & (~0x0 & varg1);\n        v8 = ~0x0 & (~0x0 & varg0);\n        v9, v10 = ecrecover(v6, v7, v8);\n        require(v9); // checks call status, propagates error data on error\n        v4 = v11 = address(v10) == address(varg3);\n    }\n    if (v4) {\n        v4 = v12 = block.number <= varg5;\n    }\n    if (v4) {\n        v13 = address(varg3);\n        v14 = v15 = _SafeSub(_orderFills[~0x0 & (~0x0 & v2)], varg8);\n        v16 = address(varg7);\n        v17 = address(varg3);\n        v18 = _SafeMul(varg8, _tokens[v17]);\n        assert(varg6);\n        v14 = v19 = v18 / varg6;\n        if (v15 < v19) {\n        }\n    } else {\n        v14 = v20 = 0;\n    }\n    return v14;\n}\n\nfunction orderFills(address varg0, bytes32 varg1) public nonPayable { \n    return _orderFills[~0x0 & varg1];\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    v1 = v2 = v0 >= varg1;\n    if (v2) {\n        v1 = v0 >= varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction cancelOrder(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint8 varg6, bytes32 varg7, bytes32 varg8) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = v3 = 0xff & _orders[~0x0 & (~0x0 & v1)];\n    if (!v3) {\n        MEM[MEM[64]] = 0;\n        v4, v5 = ecrecover(0xff & (0xff & (0xff & varg6)), ~0x0 & (~0x0 & (~0x0 & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)));\n        require(v4); // checks call status, propagates error data on error\n        v2 = v6 = address(v5) == msg.sender;\n    }\n    require(v2);\n    _orderFills[~0x0 & (~0x0 & v1)] = varg1;\n    emit Cancel(varg0, varg1, varg2, varg3, varg4, varg5, msg.sender, 0xff & (0xff & (0xff & varg6)), ~0x0 & (~0x0 & (~0x0 & varg7)), ~0x0 & (~0x0 & (~0x0 & varg8)));\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_tokens[msg.sender] >= varg0);\n    v0 = _SafeSub(varg0, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    v1 = msg.sender.call().value(varg0).gas(msg.gas);\n    require(v1);\n    emit Withdraw(0, msg.sender, varg0, _tokens[msg.sender]);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg0.code.size);\n    v0, v1 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    v2 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v2;\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction amountFilled(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    v0, v1 = sha256hash(address(this), varg0, varg1, varg2, varg4, varg5);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _orderFills[~0x0 & (~0x0 & v1)];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction changeFeeMake(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    require(varg0 <= _feeMake);\n    _feeMake = varg0;\n}\n\nfunction feeMake() public nonPayable { \n    return _feeMake;\n}\n\nfunction changeFeeRebate(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = varg0 < _feeRebate;\n    if (varg0 >= _feeRebate) {\n        v0 = v2 = varg0 > _feeTake;\n    }\n    require(!v0);\n    _feeRebate = varg0;\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction testTrade(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9, uint256 varg10, address varg11) public nonPayable { \n    v0 = v1 = _tokens[varg11] >= varg10;\n    if (v1) {\n        v2 = 0x2a67(~0x0 & varg9, ~0x0 & varg8, 0xff & varg7, varg6, varg5, varg4, varg3, varg2, varg1, varg0);\n        v0 = v2 >= varg10;\n    }\n    if (v0) {\n        v3 = v4 = 1;\n    } else {\n        v3 = v5 = 0;\n    }\n    return v3;\n}\n\nfunction changeFeeAccount(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _feeAccount = varg0;\n}\n\nfunction feeRebate() public nonPayable { \n    return _feeRebate;\n}\n\nfunction changeFeeTake(uint256 varg0) public nonPayable { \n    require(msg.sender == _admin);\n    v0 = v1 = varg0 > _feeTake;\n    if (varg0 <= _feeTake) {\n        v0 = v2 = varg0 < _feeRebate;\n    }\n    require(!v0);\n    _feeTake = varg0;\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _admin = varg0;\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(_tokens[msg.sender] >= varg1);\n    v0 = _SafeSub(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transfer(msg.sender, varg1).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2);\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction orders(address varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _orders[~0x0 & varg1];\n}\n\nfunction feeTake() public nonPayable { \n    return _feeTake;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    emit Deposit(0, msg.sender, msg.value, _tokens[msg.sender]);\n}\n\nfunction changeAccountLevelsAddr(address varg0) public nonPayable { \n    require(msg.sender == _admin);\n    _accountLevelsAddr = varg0;\n}\n\nfunction accountLevelsAddr() public nonPayable { \n    return _accountLevelsAddr;\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction admin() public nonPayable { \n    return _admin;\n}\n\nfunction availableVolume(address varg0, uint256 varg1, address varg2, uint256 varg3, uint256 varg4, uint256 varg5, address varg6, uint8 varg7, bytes32 varg8, bytes32 varg9) public nonPayable { \n    v0 = 0x2a67(~0x0 & varg9, ~0x0 & varg8, 0xff & varg7, varg6, varg5, varg4, varg3, varg2, varg1, varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xa19b14a == function_selector) {\n            trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256);\n        } else if (0xb927666 == function_selector) {\n            order(address,uint256,address,uint256,uint256,uint256);\n        } else if (0x19774d43 == function_selector) {\n            orderFills(address,bytes32);\n        } else if (0x278b8c0e == function_selector) {\n            cancelOrder(address,uint256,address,uint256,uint256,uint256,uint8,bytes32,bytes32);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x338b5dea == function_selector) {\n            depositToken(address,uint256);\n        } else if (0x46be96c3 == function_selector) {\n            amountFilled(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        } else if (0x508493bc == function_selector) {\n            tokens(address,address);\n        } else if (0x54d03b5c == function_selector) {\n            changeFeeMake(uint256);\n        } else if (0x57786394 == function_selector) {\n            feeMake();\n        } else if (0x5e1d7ae4 == function_selector) {\n            changeFeeRebate(uint256);\n        } else if (0x65e17c9d == function_selector) {\n            feeAccount();\n        } else if (0x6c86888b == function_selector) {\n            testTrade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256,address);\n        } else if (0x71ffcb16 == function_selector) {\n            changeFeeAccount(address);\n        } else if (0x731c2f81 == function_selector) {\n            feeRebate();\n        } else if (0x8823a9c0 == function_selector) {\n            changeFeeTake(uint256);\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0x9e281a98 == function_selector) {\n            withdrawToken(address,uint256);\n        } else if (0xbb5f4629 == function_selector) {\n            orders(address,bytes32);\n        } else if (0xc281309e == function_selector) {\n            feeTake();\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xe8f6bc2e == function_selector) {\n            changeAccountLevelsAddr(address);\n        } else if (0xf3412942 == function_selector) {\n            accountLevelsAddr();\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        } else if (0xfb6e155f == function_selector) {\n            availableVolume(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 21.521432638168335,
	"usage": {
		"completion_tokens": 520,
		"prompt_tokens": 4833,
		"total_tokens": 5353
	}
}