{
	"address": "0xc0506ceb264b057182a4c3ab8a0b910a545479f0",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code appears to be from a complex Ethereum smart contract, likely representing a token with ICO capabilities. Below is a simplified, Solidity version of the contract. Please note that due to the complexity and lack of certain information from the decompiled code, the following Solidity contract is a simplified approximation and not a perfect reconstruction. It includes the main components such as state variables, events, and a selection of functions.\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract MyToken {\n    // State variables\n    uint256 public _totalSupply;\n    uint256 public _totalSoldTokens;\n    mapping(address => uint256) public _balances;\n    mapping(address => mapping(address => uint256)) public _allowances;\n    bool public _isTransactionsAllowed;\n    address public _owner;\n    address public _bountyFundManager;\n    address public _ethFundManager;\n    string public _name;\n    string public _symbol;\n    string public _standard;\n    uint8 public _decimals;\n\n    // Events\n    event RefundEth(address indexed _from, uint256 _value);\n    event BonusEarned(address indexed _from, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event IcoFinished();\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balances[msg.sender] >= _value);\n        _balances[msg.sender] -= _value;\n        _balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowances[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= _balances[_from]);\n        require(_value <= _allowances[_from][msg.sender]);\n        _balances[_from] -= _value;\n        _balances[_to] += _value;\n        _allowances[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return _balances[_owner];\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return _allowances[_owner][_spender];\n    }\n\n    // Additional functions based on the decompiled code would go here\n}\n```\n\nThe above Solidity contract includes ERC20 token standard functions and events like `transfer`, `approve`, `transferFrom`, `balanceOf`, `allowance`, and corresponding events. It also includes custom variables and events as appeared in the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456296,
	"id": "chatcmpl-8R2nQNminoxiI8Zve4r5WB6F4czMr",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 02:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _standard; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _pRE_ICO_SINCE; // STORAGE[0x7]\nuint256 _pRE_ICO_TILL; // STORAGE[0x8]\nuint256 _iCO_SINCE; // STORAGE[0x9]\nuint256 _iCO_TILL; // STORAGE[0xa]\nuint256 _totalSoldSlogns; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _preIcoEthers; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _icoEthers; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _isTransactionsAllowed; // STORAGE[0xc] bytes 0 to 0\nuint160 _advisoryBoardFundManager; // STORAGE[0x10] bytes 0 to 19\nuint160 _opensourceFundManager; // STORAGE[0x11] bytes 0 to 19\nuint160 _reserveFundManager; // STORAGE[0x12] bytes 0 to 19\naddress _bountyFundManager; // STORAGE[0x13] bytes 0 to 19\naddress _ethFundManager; // STORAGE[0x14] bytes 0 to 19\naddress _owner; // STORAGE[0x15] bytes 0 to 19\n\n// Events\nRefundEth(address, uint256);\nBonusEarned(address, uint256);\nTransfer(address, address, uint256);\nIcoFinished();\n\nfunction 0x11b9(uint256 varg0, uint256 varg1) private { \n    if (!_isTransactionsAllowed) {\n        if (_bountyFundManager != msg.sender) {\n            return 0;\n        }\n    }\n    v0 = 0x16a2(varg0, varg1, msg.sender);\n    return v0;\n}\n\nfunction 0x128e(uint256 varg0) private { \n    v0 = v1 = varg0 >= _pRE_ICO_SINCE;\n    if (v1) {\n        v0 = v2 = varg0 <= _pRE_ICO_TILL;\n    }\n    if (!v0) {\n        v3 = v4 = varg0 >= _iCO_SINCE;\n        if (v4) {\n            v3 = v5 = varg0 <= _iCO_TILL;\n        }\n        if (v3) {\n            if (_totalSoldSlogns >= 0x3635c9adc5dea00000) {\n                v6 = v7 = 2;\n            }\n        }\n        v6 = v8 = 0;\n    } else {\n        v6 = v9 = 1;\n    }\n    return v6;\n}\n\nfunction 0x16a2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 >= _balanceOf[v1]);\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] - varg0;\n    v3 = address(varg1);\n    _balanceOf[v3] += varg0;\n    emit Transfer(v2, v3, varg0);\n    return 1;\n}\n\nfunction reserveFundManager() public payable { \n    assert(!msg.value);\n    return _reserveFundManager;\n}\n\nfunction transferEther(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    if (_ethFundManager == msg.sender) {\n        if (_totalSoldSlogns >= 0x3635c9adc5dea00000) {\n            if ((address(this)).balance >= varg1) {\n                v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n                assert(v0);\n                v1 = v2 = 1;\n            } else {\n                v1 = v3 = 0;\n            }\n        } else {\n            v1 = v4 = 0;\n        }\n    } else {\n        v1 = v5 = 0;\n    }\n    return v1;\n}\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction PRE_ICO_SINCE() public payable { \n    assert(!msg.value);\n    return _pRE_ICO_SINCE;\n}\n\nfunction ICO_BONUS2_RATE() public payable { \n    assert(!msg.value);\n    return 15;\n}\n\nfunction opensourceFundManager() public payable { \n    assert(!msg.value);\n    return _opensourceFundManager;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction ICO_BONUS1_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0x43c33c1937564800000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    if (!_isTransactionsAllowed) {\n        if (_bountyFundManager != varg0) {\n            v0 = v1 = 0;\n        }\n    }\n    return v0;\n    require(varg2 >= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    v0 = 0x16a2(varg2, varg1, varg0);\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction _totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction ICO_TILL() public payable { \n    assert(!msg.value);\n    return _iCO_TILL;\n}\n\nfunction ICO_BONUS1_RATE() public payable { \n    assert(!msg.value);\n    return 30;\n}\n\nfunction ICO_BONUS2_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0xa968163f0a57b400000;\n}\n\nfunction MIN_ICO_SLOGN_COLLECTED() public payable { \n    assert(!msg.value);\n    return 0x3635c9adc5dea00000;\n}\n\nfunction refund() public payable { \n    assert(!msg.value);\n    if (block.timestamp > _pRE_ICO_TILL) {\n        if (_totalSoldSlogns < 0x3635c9adc5dea00000) {\n            if (_preIcoEthers[msg.sender] <= 0) {\n                v0 = v1 = 0;\n            } else {\n                _preIcoEthers[msg.sender] = 0;\n                _preIcoEthers[msg.sender] = 0;\n                v2 = msg.sender.call().value(_preIcoEthers[msg.sender]).gas(2300 * !_preIcoEthers[msg.sender]);\n                assert(v2);\n                emit RefundEth(msg.sender, _preIcoEthers[msg.sender]);\n                v0 = 1;\n            }\n        } else {\n            v0 = v3 = 0;\n        }\n    } else {\n        v0 = v4 = 0;\n    }\n    return v0;\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction CORE_TEAM_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x1969368974c05b000000;\n}\n\nfunction BOUNTY_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x1b1ae4d6e2ef5000000;\n}\n\nfunction advisoryBoardFundManager() public payable { \n    assert(!msg.value);\n    return _advisoryBoardFundManager;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction PRE_ICO_TILL() public payable { \n    assert(!msg.value);\n    return _pRE_ICO_TILL;\n}\n\nfunction setIcoDates(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _iCO_SINCE = varg0;\n    _iCO_TILL = varg1;\n}\n\nfunction preIcoEthers(address varg0) public payable { \n    assert(!msg.value);\n    return _preIcoEthers[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction TOTAL_SUPPLY() public payable { \n    assert(!msg.value);\n    return 0xa968163f0a57b4000000;\n}\n\nfunction calculateBonus(uint8 varg0, uint256 varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    v0 = 0xfce(varg2, varg1, varg0 & 0xff);\n    return v0;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction icoEthers(address varg0) public payable { \n    assert(!msg.value);\n    return _icoEthers[varg0];\n}\n\nfunction NAME() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction buy() public payable { \n    require(msg.value > 0);\n    v0 = 0x128e(block.timestamp);\n    v1 = v2 = 1 == 0xff & v0;\n    if (1 != 0xff & v0) {\n        v1 = 2 == 0xff & v0;\n    }\n    require(v1);\n    v3 = v4 = 1 == 0xff & v0;\n    if (v4) {\n        v3 = _totalSoldSlogns + msg.value > 0x10f0cf064dd59200000;\n    }\n    require(!v3);\n    v5 = 0xfce(msg.value, _totalSoldSlogns, v0);\n    require(_balanceOf[address(this)] >= v5 + msg.value);\n    if (v5 > 0) {\n        emit BonusEarned(msg.sender, v5);\n    }\n    v6 = 0x16a2(msg.value + v5, msg.sender, this);\n    _totalSoldSlogns += msg.value;\n    if (1 == v0 & 0xff) {\n        _preIcoEthers[msg.sender] += msg.value;\n    }\n    if (2 == 0xff & v0) {\n        _icoEthers[msg.sender] += msg.value;\n    }\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    v0 = 0x11b9(varg1, varg0);\n    return v0;\n}\n\nfunction PRECISION() public payable { \n    assert(!msg.value);\n    return 14;\n}\n\nfunction ADVISORY_BOARD_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x28a857425466f800000;\n}\n\nfunction icoFinish() public payable { \n    assert(!msg.value);\n    if (block.timestamp > _iCO_TILL) {\n        if (_totalSoldSlogns < 0x3635c9adc5dea00000) {\n            v0 = v1 = 0;\n        } else {\n            _totalSupply = _totalSupply - _balanceOf[address(this)];\n            _balanceOf[address(this)] = 0;\n            _isTransactionsAllowed = 1;\n            emit IcoFinished();\n            v0 = v2 = 1;\n        }\n    } else {\n        v0 = v3 = 0;\n    }\n    return v0;\n}\n\nfunction STANDARD() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction PRE_ICO_BONUS_RATE() public payable { \n    assert(!msg.value);\n    return 70;\n}\n\nfunction RESERVE_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x878678326eac9000000;\n}\n\nfunction bountyFundManager() public payable { \n    assert(!msg.value);\n    return _bountyFundManager;\n}\n\nfunction totalSoldSlogns() public payable { \n    assert(!msg.value);\n    return _totalSoldSlogns;\n}\n\nfunction getIcoStep(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0x128e(varg0);\n    return v0 & 0xff;\n}\n\nfunction PRE_ICO_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0x10f0cf064dd59200000;\n}\n\nfunction setPreIcoDates(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _pRE_ICO_SINCE = varg0;\n    _pRE_ICO_TILL = varg1;\n}\n\nfunction OPENSOURCE_TOKENS() public payable { \n    assert(!msg.value);\n    return 0xcb49b44ba602d800000;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    return _allowance[varg1];\n}\n\nfunction ICO_SINCE() public payable { \n    assert(!msg.value);\n    return _iCO_SINCE;\n}\n\nfunction setTransactionsAllowed(bool varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _isTransactionsAllowed = varg0;\n}\n\nfunction isTransactionsAllowed() public payable { \n    assert(!msg.value);\n    return _isTransactionsAllowed;\n}\n\nfunction ethFundManager() public payable { \n    assert(!msg.value);\n    return _ethFundManager;\n}\n\nfunction SYMBOL() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (4) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction 0xfce(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (1 != 0xff & varg2) {\n        if (2 != 0xff & varg2) {\n            v0 = v1 = 0;\n        } else if (varg1 <= 0xed2b525841adfc00000) {\n            varg0 = v2 = 0x43c33c1937564800000 - varg1;\n            v0 = v3 = 0;\n            varg0 = v4 = 0;\n            v5 = v6 = v2 > 0;\n            if (v6) {\n                v5 = v7 = v2 <= 0x43c33c1937564800000;\n            }\n            if (v5) {\n                if (varg0 <= v2) {\n                }\n                v0 = v8 = v3 + varg0 / 100 * 30;\n                varg0 = v9 = varg0 - varg0;\n            }\n            varg0 = v10 = 0xed2b525841adfc00000 - varg1 - varg0;\n            v11 = v12 = v10 > 0;\n            if (v12) {\n                v11 = v13 = v10 <= 0xa968163f0a57b400000;\n            }\n            if (v11) {\n                if (varg0 <= v10) {\n                }\n                v0 = v14 = v0 + varg0 / 100 * 15;\n            }\n        } else {\n            v0 = v15 = 0;\n        }\n    } else {\n        v0 = v16 = varg0 / 100 * 70;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x3a3053b) {\n            reserveFundManager();\n        } else if (0x5b1137b == v0) {\n            transferEther(address,uint256);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0x9a7dd17 == v0) {\n            PRE_ICO_SINCE();\n        } else if (0x10b3d502 == v0) {\n            ICO_BONUS2_RATE();\n        } else if (0x1603c521 == v0) {\n            opensourceFundManager();\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x1f3fe8d1 == v0) {\n            ICO_BONUS1_SLGN_LESS();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x3eaaf86b == v0) {\n            _totalSupply();\n        } else if (0x4240a978 == v0) {\n            ICO_TILL();\n        } else if (0x4d392341 == v0) {\n            ICO_BONUS1_RATE();\n        } else if (0x544b9606 == v0) {\n            ICO_BONUS2_SLGN_LESS();\n        } else {\n            if (0x57ce0ec0 != v0) {\n                if (0x590e1ae3 == v0) {\n                    refund();\n                } else if (0x5a3b7e42 == v0) {\n                    standard();\n                } else if (0x5ac49ba1 == v0) {\n                    CORE_TEAM_TOKENS();\n                } else if (0x63f0ca5a == v0) {\n                    BOUNTY_TOKENS();\n                } else if (0x6dc51f1e == v0) {\n                    advisoryBoardFundManager();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x7628e728 == v0) {\n                    PRE_ICO_TILL();\n                } else if (0x7c871d31 == v0) {\n                    setIcoDates(uint256,uint256);\n                } else if (0x89e6359f == v0) {\n                    preIcoEthers(address);\n                } else if (0x8da5cb5b == v0) {\n                    owner();\n                } else if (0x902d55a5 == v0) {\n                    TOTAL_SUPPLY();\n                } else if (0x9379d936 == v0) {\n                    calculateBonus(uint8,uint256,uint256);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x9629e4b9 == v0) {\n                    icoEthers(address);\n                } else if (0xa3f4df7e == v0) {\n                    NAME();\n                } else if (0xa6f2ae3a == v0) {\n                    buy();\n                } else if (0xa9059cbb == v0) {\n                    transfer(address,uint256);\n                } else if (0xaaf5eb68 == v0) {\n                    PRECISION();\n                } else if (0xae63b517 == v0) {\n                    ADVISORY_BOARD_TOKENS();\n                } else if (0xb333ce0d == v0) {\n                    icoFinish();\n                } else if (0xb60cc68b != v0) {\n                    if (0xbcaedade == v0) {\n                        STANDARD();\n                    } else if (0xc0ac3d1c == v0) {\n                        PRE_ICO_BONUS_RATE();\n                    } else if (0xc35d1e01 == v0) {\n                        RESERVE_TOKENS();\n                    } else if (0xc8c0b288 == v0) {\n                        bountyFundManager();\n                    } else if (0xcc198380 == v0) {\n                        totalSoldSlogns();\n                    } else if (0xd45b5f71 == v0) {\n                        getIcoStep(uint256);\n                    } else if (0xd484a285 == v0) {\n                        PRE_ICO_SLGN_LESS();\n                    } else if (0xdadc89eb == v0) {\n                        setPreIcoDates(uint256,uint256);\n                    } else if (0xdc7abeb3 == v0) {\n                        OPENSOURCE_TOKENS();\n                    } else if (0xdd62ed3e == v0) {\n                        allowance(address,address);\n                    } else if (0xe113c6fd == v0) {\n                        ICO_SINCE();\n                    } else if (0xe1b0d4b2 == v0) {\n                        setTransactionsAllowed(bool);\n                    } else if (0xe9668128 == v0) {\n                        isTransactionsAllowed();\n                    } else if (0xee09ae4a == v0) {\n                        ethFundManager();\n                    } else if (0xf76f8d78 == v0) {\n                        SYMBOL();\n                    }\n                }\n            }\n            MIN_ICO_SLOGN_COLLECTED();\n        }\n    }\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 02:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _standard; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _pRE_ICO_SINCE; // STORAGE[0x7]\nuint256 _pRE_ICO_TILL; // STORAGE[0x8]\nuint256 _iCO_SINCE; // STORAGE[0x9]\nuint256 _iCO_TILL; // STORAGE[0xa]\nuint256 _totalSoldSlogns; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _preIcoEthers; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _icoEthers; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _isTransactionsAllowed; // STORAGE[0xc] bytes 0 to 0\nuint160 _advisoryBoardFundManager; // STORAGE[0x10] bytes 0 to 19\nuint160 _opensourceFundManager; // STORAGE[0x11] bytes 0 to 19\nuint160 _reserveFundManager; // STORAGE[0x12] bytes 0 to 19\naddress _bountyFundManager; // STORAGE[0x13] bytes 0 to 19\naddress _ethFundManager; // STORAGE[0x14] bytes 0 to 19\naddress _owner; // STORAGE[0x15] bytes 0 to 19\n\n// Events\nRefundEth(address, uint256);\nBonusEarned(address, uint256);\nTransfer(address, address, uint256);\nIcoFinished();\n\nfunction 0x11b9(uint256 varg0, uint256 varg1) private { \n    if (!_isTransactionsAllowed) {\n        if (_bountyFundManager != msg.sender) {\n            return 0;\n        }\n    }\n    v0 = 0x16a2(varg0, varg1, msg.sender);\n    return v0;\n}\n\nfunction 0x128e(uint256 varg0) private { \n    v0 = v1 = varg0 >= _pRE_ICO_SINCE;\n    if (v1) {\n        v0 = v2 = varg0 <= _pRE_ICO_TILL;\n    }\n    if (!v0) {\n        v3 = v4 = varg0 >= _iCO_SINCE;\n        if (v4) {\n            v3 = v5 = varg0 <= _iCO_TILL;\n        }\n        if (v3) {\n            if (_totalSoldSlogns >= 0x3635c9adc5dea00000) {\n                v6 = v7 = 2;\n            }\n        }\n        v6 = v8 = 0;\n    } else {\n        v6 = v9 = 1;\n    }\n    return v6;\n}\n\nfunction 0x16a2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 >= _balanceOf[v1]);\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] - varg0;\n    v3 = address(varg1);\n    _balanceOf[v3] += varg0;\n    emit Transfer(v2, v3, varg0);\n    return 1;\n}\n\nfunction reserveFundManager() public payable { \n    assert(!msg.value);\n    return _reserveFundManager;\n}\n\nfunction transferEther(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    if (_ethFundManager == msg.sender) {\n        if (_totalSoldSlogns >= 0x3635c9adc5dea00000) {\n            if ((address(this)).balance >= varg1) {\n                v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n                assert(v0);\n                v1 = v2 = 1;\n            } else {\n                v1 = v3 = 0;\n            }\n        } else {\n            v1 = v4 = 0;\n        }\n    } else {\n        v1 = v5 = 0;\n    }\n    return v1;\n}\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction PRE_ICO_SINCE() public payable { \n    assert(!msg.value);\n    return _pRE_ICO_SINCE;\n}\n\nfunction ICO_BONUS2_RATE() public payable { \n    assert(!msg.value);\n    return 15;\n}\n\nfunction opensourceFundManager() public payable { \n    assert(!msg.value);\n    return _opensourceFundManager;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction ICO_BONUS1_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0x43c33c1937564800000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    if (!_isTransactionsAllowed) {\n        if (_bountyFundManager != varg0) {\n            v0 = v1 = 0;\n        }\n    }\n    return v0;\n    require(varg2 >= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    v0 = 0x16a2(varg2, varg1, varg0);\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction _totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction ICO_TILL() public payable { \n    assert(!msg.value);\n    return _iCO_TILL;\n}\n\nfunction ICO_BONUS1_RATE() public payable { \n    assert(!msg.value);\n    return 30;\n}\n\nfunction ICO_BONUS2_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0xa968163f0a57b400000;\n}\n\nfunction MIN_ICO_SLOGN_COLLECTED() public payable { \n    assert(!msg.value);\n    return 0x3635c9adc5dea00000;\n}\n\nfunction refund() public payable { \n    assert(!msg.value);\n    if (block.timestamp > _pRE_ICO_TILL) {\n        if (_totalSoldSlogns < 0x3635c9adc5dea00000) {\n            if (_preIcoEthers[msg.sender] <= 0) {\n                v0 = v1 = 0;\n            } else {\n                _preIcoEthers[msg.sender] = 0;\n                _preIcoEthers[msg.sender] = 0;\n                v2 = msg.sender.call().value(_preIcoEthers[msg.sender]).gas(2300 * !_preIcoEthers[msg.sender]);\n                assert(v2);\n                emit RefundEth(msg.sender, _preIcoEthers[msg.sender]);\n                v0 = 1;\n            }\n        } else {\n            v0 = v3 = 0;\n        }\n    } else {\n        v0 = v4 = 0;\n    }\n    return v0;\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction CORE_TEAM_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x1969368974c05b000000;\n}\n\nfunction BOUNTY_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x1b1ae4d6e2ef5000000;\n}\n\nfunction advisoryBoardFundManager() public payable { \n    assert(!msg.value);\n    return _advisoryBoardFundManager;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction PRE_ICO_TILL() public payable { \n    assert(!msg.value);\n    return _pRE_ICO_TILL;\n}\n\nfunction setIcoDates(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _iCO_SINCE = varg0;\n    _iCO_TILL = varg1;\n}\n\nfunction preIcoEthers(address varg0) public payable { \n    assert(!msg.value);\n    return _preIcoEthers[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction TOTAL_SUPPLY() public payable { \n    assert(!msg.value);\n    return 0xa968163f0a57b4000000;\n}\n\nfunction calculateBonus(uint8 varg0, uint256 varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    v0 = 0xfce(varg2, varg1, varg0 & 0xff);\n    return v0;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction icoEthers(address varg0) public payable { \n    assert(!msg.value);\n    return _icoEthers[varg0];\n}\n\nfunction NAME() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction buy() public payable { \n    require(msg.value > 0);\n    v0 = 0x128e(block.timestamp);\n    v1 = v2 = 1 == 0xff & v0;\n    if (1 != 0xff & v0) {\n        v1 = 2 == 0xff & v0;\n    }\n    require(v1);\n    v3 = v4 = 1 == 0xff & v0;\n    if (v4) {\n        v3 = _totalSoldSlogns + msg.value > 0x10f0cf064dd59200000;\n    }\n    require(!v3);\n    v5 = 0xfce(msg.value, _totalSoldSlogns, v0);\n    require(_balanceOf[address(this)] >= v5 + msg.value);\n    if (v5 > 0) {\n        emit BonusEarned(msg.sender, v5);\n    }\n    v6 = 0x16a2(msg.value + v5, msg.sender, this);\n    _totalSoldSlogns += msg.value;\n    if (1 == v0 & 0xff) {\n        _preIcoEthers[msg.sender] += msg.value;\n    }\n    if (2 == 0xff & v0) {\n        _icoEthers[msg.sender] += msg.value;\n    }\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    v0 = 0x11b9(varg1, varg0);\n    return v0;\n}\n\nfunction PRECISION() public payable { \n    assert(!msg.value);\n    return 14;\n}\n\nfunction ADVISORY_BOARD_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x28a857425466f800000;\n}\n\nfunction icoFinish() public payable { \n    assert(!msg.value);\n    if (block.timestamp > _iCO_TILL) {\n        if (_totalSoldSlogns < 0x3635c9adc5dea00000) {\n            v0 = v1 = 0;\n        } else {\n            _totalSupply = _totalSupply - _balanceOf[address(this)];\n            _balanceOf[address(this)] = 0;\n            _isTransactionsAllowed = 1;\n            emit IcoFinished();\n            v0 = v2 = 1;\n        }\n    } else {\n        v0 = v3 = 0;\n    }\n    return v0;\n}\n\nfunction STANDARD() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction PRE_ICO_BONUS_RATE() public payable { \n    assert(!msg.value);\n    return 70;\n}\n\nfunction RESERVE_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x878678326eac9000000;\n}\n\nfunction bountyFundManager() public payable { \n    assert(!msg.value);\n    return _bountyFundManager;\n}\n\nfunction totalSoldSlogns() public payable { \n    assert(!msg.value);\n    return _totalSoldSlogns;\n}\n\nfunction getIcoStep(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0x128e(varg0);\n    return v0 & 0xff;\n}\n\nfunction PRE_ICO_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0x10f0cf064dd59200000;\n}\n\nfunction setPreIcoDates(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _pRE_ICO_SINCE = varg0;\n    _pRE_ICO_TILL = varg1;\n}\n\nfunction OPENSOURCE_TOKENS() public payable { \n    assert(!msg.value);\n    return 0xcb49b44ba602d800000;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    return _allowance[varg1];\n}\n\nfunction ICO_SINCE() public payable { \n    assert(!msg.value);\n    return _iCO_SINCE;\n}\n\nfunction setTransactionsAllowed(bool varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _isTransactionsAllowed = varg0;\n}\n\nfunction isTransactionsAllowed() public payable { \n    assert(!msg.value);\n    return _isTransactionsAllowed;\n}\n\nfunction ethFundManager() public payable { \n    assert(!msg.value);\n    return _ethFundManager;\n}\n\nfunction SYMBOL() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (4) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction 0xfce(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (1 != 0xff & varg2) {\n        if (2 != 0xff & varg2) {\n            v0 = v1 = 0;\n        } else if (varg1 <= 0xed2b525841adfc00000) {\n            varg0 = v2 = 0x43c33c1937564800000 - varg1;\n            v0 = v3 = 0;\n            varg0 = v4 = 0;\n            v5 = v6 = v2 > 0;\n            if (v6) {\n                v5 = v7 = v2 <= 0x43c33c1937564800000;\n            }\n            if (v5) {\n                if (varg0 <= v2) {\n                }\n                v0 = v8 = v3 + varg0 / 100 * 30;\n                varg0 = v9 = varg0 - varg0;\n            }\n            varg0 = v10 = 0xed2b525841adfc00000 - varg1 - varg0;\n            v11 = v12 = v10 > 0;\n            if (v12) {\n                v11 = v13 = v10 <= 0xa968163f0a57b400000;\n            }\n            if (v11) {\n                if (varg0 <= v10) {\n                }\n                v0 = v14 = v0 + varg0 / 100 * 15;\n            }\n        } else {\n            v0 = v15 = 0;\n        }\n    } else {\n        v0 = v16 = varg0 / 100 * 70;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x3a3053b) {\n            reserveFundManager();\n        } else if (0x5b1137b == v0) {\n            transferEther(address,uint256);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0x9a7dd17 == v0) {\n            PRE_ICO_SINCE();\n        } else if (0x10b3d502 == v0) {\n            ICO_BONUS2_RATE();\n        } else if (0x1603c521 == v0) {\n            opensourceFundManager();\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x1f3fe8d1 == v0) {\n            ICO_BONUS1_SLGN_LESS();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x3eaaf86b == v0) {\n            _totalSupply();\n        } else if (0x4240a978 == v0) {\n            ICO_TILL();\n        } else if (0x4d392341 == v0) {\n            ICO_BONUS1_RATE();\n        } else if (0x544b9606 == v0) {\n            ICO_BONUS2_SLGN_LESS();\n        } else {\n            if (0x57ce0ec0 != v0) {\n                if (0x590e1ae3 == v0) {\n                    refund();\n                } else if (0x5a3b7e42 == v0) {\n                    standard();\n                } else if (0x5ac49ba1 == v0) {\n                    CORE_TEAM_TOKENS();\n                } else if (0x63f0ca5a == v0) {\n                    BOUNTY_TOKENS();\n                } else if (0x6dc51f1e == v0) {\n                    advisoryBoardFundManager();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x7628e728 == v0) {\n                    PRE_ICO_TILL();\n                } else if (0x7c871d31 == v0) {\n                    setIcoDates(uint256,uint256);\n                } else if (0x89e6359f == v0) {\n                    preIcoEthers(address);\n                } else if (0x8da5cb5b == v0) {\n                    owner();\n                } else if (0x902d55a5 == v0) {\n                    TOTAL_SUPPLY();\n                } else if (0x9379d936 == v0) {\n                    calculateBonus(uint8,uint256,uint256);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x9629e4b9 == v0) {\n                    icoEthers(address);\n                } else if (0xa3f4df7e == v0) {\n                    NAME();\n                } else if (0xa6f2ae3a == v0) {\n                    buy();\n                } else if (0xa9059cbb == v0) {\n                    transfer(address,uint256);\n                } else if (0xaaf5eb68 == v0) {\n                    PRECISION();\n                } else if (0xae63b517 == v0) {\n                    ADVISORY_BOARD_TOKENS();\n                } else if (0xb333ce0d == v0) {\n                    icoFinish();\n                } else if (0xb60cc68b != v0) {\n                    if (0xbcaedade == v0) {\n                        STANDARD();\n                    } else if (0xc0ac3d1c == v0) {\n                        PRE_ICO_BONUS_RATE();\n                    } else if (0xc35d1e01 == v0) {\n                        RESERVE_TOKENS();\n                    } else if (0xc8c0b288 == v0) {\n                        bountyFundManager();\n                    } else if (0xcc198380 == v0) {\n                        totalSoldSlogns();\n                    } else if (0xd45b5f71 == v0) {\n                        getIcoStep(uint256);\n                    } else if (0xd484a285 == v0) {\n                        PRE_ICO_SLGN_LESS();\n                    } else if (0xdadc89eb == v0) {\n                        setPreIcoDates(uint256,uint256);\n                    } else if (0xdc7abeb3 == v0) {\n                        OPENSOURCE_TOKENS();\n                    } else if (0xdd62ed3e == v0) {\n                        allowance(address,address);\n                    } else if (0xe113c6fd == v0) {\n                        ICO_SINCE();\n                    } else if (0xe1b0d4b2 == v0) {\n                        setTransactionsAllowed(bool);\n                    } else if (0xe9668128 == v0) {\n                        isTransactionsAllowed();\n                    } else if (0xee09ae4a == v0) {\n                        ethFundManager();\n                    } else if (0xf76f8d78 == v0) {\n                        SYMBOL();\n                    }\n                }\n            }\n            MIN_ICO_SLOGN_COLLECTED();\n        }\n    }\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 02:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _standard; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _pRE_ICO_SINCE; // STORAGE[0x7]\nuint256 _pRE_ICO_TILL; // STORAGE[0x8]\nuint256 _iCO_SINCE; // STORAGE[0x9]\nuint256 _iCO_TILL; // STORAGE[0xa]\nuint256 _totalSoldSlogns; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _preIcoEthers; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _icoEthers; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _isTransactionsAllowed; // STORAGE[0xc] bytes 0 to 0\nuint160 _advisoryBoardFundManager; // STORAGE[0x10] bytes 0 to 19\nuint160 _opensourceFundManager; // STORAGE[0x11] bytes 0 to 19\nuint160 _reserveFundManager; // STORAGE[0x12] bytes 0 to 19\naddress _bountyFundManager; // STORAGE[0x13] bytes 0 to 19\naddress _ethFundManager; // STORAGE[0x14] bytes 0 to 19\naddress _owner; // STORAGE[0x15] bytes 0 to 19\n\n// Events\nRefundEth(address, uint256);\nBonusEarned(address, uint256);\nTransfer(address, address, uint256);\nIcoFinished();\n\nfunction 0x11b9(uint256 varg0, uint256 varg1) private { \n    if (!_isTransactionsAllowed) {\n        if (_bountyFundManager != msg.sender) {\n            return 0;\n        }\n    }\n    v0 = 0x16a2(varg0, varg1, msg.sender);\n    return v0;\n}\n\nfunction 0x128e(uint256 varg0) private { \n    v0 = v1 = varg0 >= _pRE_ICO_SINCE;\n    if (v1) {\n        v0 = v2 = varg0 <= _pRE_ICO_TILL;\n    }\n    if (!v0) {\n        v3 = v4 = varg0 >= _iCO_SINCE;\n        if (v4) {\n            v3 = v5 = varg0 <= _iCO_TILL;\n        }\n        if (v3) {\n            if (_totalSoldSlogns >= 0x3635c9adc5dea00000) {\n                v6 = v7 = 2;\n            }\n        }\n        v6 = v8 = 0;\n    } else {\n        v6 = v9 = 1;\n    }\n    return v6;\n}\n\nfunction 0x16a2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 >= _balanceOf[v1]);\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] - varg0;\n    v3 = address(varg1);\n    _balanceOf[v3] += varg0;\n    emit Transfer(v2, v3, varg0);\n    return 1;\n}\n\nfunction reserveFundManager() public payable { \n    assert(!msg.value);\n    return _reserveFundManager;\n}\n\nfunction transferEther(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    if (_ethFundManager == msg.sender) {\n        if (_totalSoldSlogns >= 0x3635c9adc5dea00000) {\n            if ((address(this)).balance >= varg1) {\n                v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n                assert(v0);\n                v1 = v2 = 1;\n            } else {\n                v1 = v3 = 0;\n            }\n        } else {\n            v1 = v4 = 0;\n        }\n    } else {\n        v1 = v5 = 0;\n    }\n    return v1;\n}\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction PRE_ICO_SINCE() public payable { \n    assert(!msg.value);\n    return _pRE_ICO_SINCE;\n}\n\nfunction ICO_BONUS2_RATE() public payable { \n    assert(!msg.value);\n    return 15;\n}\n\nfunction opensourceFundManager() public payable { \n    assert(!msg.value);\n    return _opensourceFundManager;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction ICO_BONUS1_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0x43c33c1937564800000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    if (!_isTransactionsAllowed) {\n        if (_bountyFundManager != varg0) {\n            v0 = v1 = 0;\n        }\n    }\n    return v0;\n    require(varg2 >= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    v0 = 0x16a2(varg2, varg1, varg0);\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction _totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction ICO_TILL() public payable { \n    assert(!msg.value);\n    return _iCO_TILL;\n}\n\nfunction ICO_BONUS1_RATE() public payable { \n    assert(!msg.value);\n    return 30;\n}\n\nfunction ICO_BONUS2_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0xa968163f0a57b400000;\n}\n\nfunction MIN_ICO_SLOGN_COLLECTED() public payable { \n    assert(!msg.value);\n    return 0x3635c9adc5dea00000;\n}\n\nfunction refund() public payable { \n    assert(!msg.value);\n    if (block.timestamp > _pRE_ICO_TILL) {\n        if (_totalSoldSlogns < 0x3635c9adc5dea00000) {\n            if (_preIcoEthers[msg.sender] <= 0) {\n                v0 = v1 = 0;\n            } else {\n                _preIcoEthers[msg.sender] = 0;\n                _preIcoEthers[msg.sender] = 0;\n                v2 = msg.sender.call().value(_preIcoEthers[msg.sender]).gas(2300 * !_preIcoEthers[msg.sender]);\n                assert(v2);\n                emit RefundEth(msg.sender, _preIcoEthers[msg.sender]);\n                v0 = 1;\n            }\n        } else {\n            v0 = v3 = 0;\n        }\n    } else {\n        v0 = v4 = 0;\n    }\n    return v0;\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction CORE_TEAM_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x1969368974c05b000000;\n}\n\nfunction BOUNTY_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x1b1ae4d6e2ef5000000;\n}\n\nfunction advisoryBoardFundManager() public payable { \n    assert(!msg.value);\n    return _advisoryBoardFundManager;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction PRE_ICO_TILL() public payable { \n    assert(!msg.value);\n    return _pRE_ICO_TILL;\n}\n\nfunction setIcoDates(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _iCO_SINCE = varg0;\n    _iCO_TILL = varg1;\n}\n\nfunction preIcoEthers(address varg0) public payable { \n    assert(!msg.value);\n    return _preIcoEthers[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction TOTAL_SUPPLY() public payable { \n    assert(!msg.value);\n    return 0xa968163f0a57b4000000;\n}\n\nfunction calculateBonus(uint8 varg0, uint256 varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    v0 = 0xfce(varg2, varg1, varg0 & 0xff);\n    return v0;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction icoEthers(address varg0) public payable { \n    assert(!msg.value);\n    return _icoEthers[varg0];\n}\n\nfunction NAME() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (5) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction buy() public payable { \n    require(msg.value > 0);\n    v0 = 0x128e(block.timestamp);\n    v1 = v2 = 1 == 0xff & v0;\n    if (1 != 0xff & v0) {\n        v1 = 2 == 0xff & v0;\n    }\n    require(v1);\n    v3 = v4 = 1 == 0xff & v0;\n    if (v4) {\n        v3 = _totalSoldSlogns + msg.value > 0x10f0cf064dd59200000;\n    }\n    require(!v3);\n    v5 = 0xfce(msg.value, _totalSoldSlogns, v0);\n    require(_balanceOf[address(this)] >= v5 + msg.value);\n    if (v5 > 0) {\n        emit BonusEarned(msg.sender, v5);\n    }\n    v6 = 0x16a2(msg.value + v5, msg.sender, this);\n    _totalSoldSlogns += msg.value;\n    if (1 == v0 & 0xff) {\n        _preIcoEthers[msg.sender] += msg.value;\n    }\n    if (2 == 0xff & v0) {\n        _icoEthers[msg.sender] += msg.value;\n    }\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    v0 = 0x11b9(varg1, varg0);\n    return v0;\n}\n\nfunction PRECISION() public payable { \n    assert(!msg.value);\n    return 14;\n}\n\nfunction ADVISORY_BOARD_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x28a857425466f800000;\n}\n\nfunction icoFinish() public payable { \n    assert(!msg.value);\n    if (block.timestamp > _iCO_TILL) {\n        if (_totalSoldSlogns < 0x3635c9adc5dea00000) {\n            v0 = v1 = 0;\n        } else {\n            _totalSupply = _totalSupply - _balanceOf[address(this)];\n            _balanceOf[address(this)] = 0;\n            _isTransactionsAllowed = 1;\n            emit IcoFinished();\n            v0 = v2 = 1;\n        }\n    } else {\n        v0 = v3 = 0;\n    }\n    return v0;\n}\n\nfunction STANDARD() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction PRE_ICO_BONUS_RATE() public payable { \n    assert(!msg.value);\n    return 70;\n}\n\nfunction RESERVE_TOKENS() public payable { \n    assert(!msg.value);\n    return 0x878678326eac9000000;\n}\n\nfunction bountyFundManager() public payable { \n    assert(!msg.value);\n    return _bountyFundManager;\n}\n\nfunction totalSoldSlogns() public payable { \n    assert(!msg.value);\n    return _totalSoldSlogns;\n}\n\nfunction getIcoStep(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0x128e(varg0);\n    return v0 & 0xff;\n}\n\nfunction PRE_ICO_SLGN_LESS() public payable { \n    assert(!msg.value);\n    return 0x10f0cf064dd59200000;\n}\n\nfunction setPreIcoDates(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _pRE_ICO_SINCE = varg0;\n    _pRE_ICO_TILL = varg1;\n}\n\nfunction OPENSOURCE_TOKENS() public payable { \n    assert(!msg.value);\n    return 0xcb49b44ba602d800000;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    return _allowance[varg1];\n}\n\nfunction ICO_SINCE() public payable { \n    assert(!msg.value);\n    return _iCO_SINCE;\n}\n\nfunction setTransactionsAllowed(bool varg0) public payable { \n    assert(!msg.value);\n    require(_owner == msg.sender);\n    _isTransactionsAllowed = varg0;\n}\n\nfunction isTransactionsAllowed() public payable { \n    assert(!msg.value);\n    return _isTransactionsAllowed;\n}\n\nfunction ethFundManager() public payable { \n    assert(!msg.value);\n    return _ethFundManager;\n}\n\nfunction SYMBOL() public payable { \n    assert(!msg.value);\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length;\n    v4 = v5 = v0.data;\n    v6 = v1.data;\n    if (v3) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v2 <= 32) {\n                break;\n            }\n            v2 = v2 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    if (4) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction 0xfce(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (1 != 0xff & varg2) {\n        if (2 != 0xff & varg2) {\n            v0 = v1 = 0;\n        } else if (varg1 <= 0xed2b525841adfc00000) {\n            varg0 = v2 = 0x43c33c1937564800000 - varg1;\n            v0 = v3 = 0;\n            varg0 = v4 = 0;\n            v5 = v6 = v2 > 0;\n            if (v6) {\n                v5 = v7 = v2 <= 0x43c33c1937564800000;\n            }\n            if (v5) {\n                if (varg0 <= v2) {\n                }\n                v0 = v8 = v3 + varg0 / 100 * 30;\n                varg0 = v9 = varg0 - varg0;\n            }\n            varg0 = v10 = 0xed2b525841adfc00000 - varg1 - varg0;\n            v11 = v12 = v10 > 0;\n            if (v12) {\n                v11 = v13 = v10 <= 0xa968163f0a57b400000;\n            }\n            if (v11) {\n                if (varg0 <= v10) {\n                }\n                v0 = v14 = v0 + varg0 / 100 * 15;\n            }\n        } else {\n            v0 = v15 = 0;\n        }\n    } else {\n        v0 = v16 = varg0 / 100 * 70;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x3a3053b) {\n            reserveFundManager();\n        } else if (0x5b1137b == v0) {\n            transferEther(address,uint256);\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0x9a7dd17 == v0) {\n            PRE_ICO_SINCE();\n        } else if (0x10b3d502 == v0) {\n            ICO_BONUS2_RATE();\n        } else if (0x1603c521 == v0) {\n            opensourceFundManager();\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x1f3fe8d1 == v0) {\n            ICO_BONUS1_SLGN_LESS();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x3eaaf86b == v0) {\n            _totalSupply();\n        } else if (0x4240a978 == v0) {\n            ICO_TILL();\n        } else if (0x4d392341 == v0) {\n            ICO_BONUS1_RATE();\n        } else if (0x544b9606 == v0) {\n            ICO_BONUS2_SLGN_LESS();\n        } else {\n            if (0x57ce0ec0 != v0) {\n                if (0x590e1ae3 == v0) {\n                    refund();\n                } else if (0x5a3b7e42 == v0) {\n                    standard();\n                } else if (0x5ac49ba1 == v0) {\n                    CORE_TEAM_TOKENS();\n                } else if (0x63f0ca5a == v0) {\n                    BOUNTY_TOKENS();\n                } else if (0x6dc51f1e == v0) {\n                    advisoryBoardFundManager();\n                } else if (0x70a08231 == v0) {\n                    balanceOf(address);\n                } else if (0x7628e728 == v0) {\n                    PRE_ICO_TILL();\n                } else if (0x7c871d31 == v0) {\n                    setIcoDates(uint256,uint256);\n                } else if (0x89e6359f == v0) {\n                    preIcoEthers(address);\n                } else if (0x8da5cb5b == v0) {\n                    owner();\n                } else if (0x902d55a5 == v0) {\n                    TOTAL_SUPPLY();\n                } else if (0x9379d936 == v0) {\n                    calculateBonus(uint8,uint256,uint256);\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                } else if (0x9629e4b9 == v0) {\n                    icoEthers(address);\n                } else if (0xa3f4df7e == v0) {\n                    NAME();\n                } else if (0xa6f2ae3a == v0) {\n                    buy();\n                } else if (0xa9059cbb == v0) {\n                    transfer(address,uint256);\n                } else if (0xaaf5eb68 == v0) {\n                    PRECISION();\n                } else if (0xae63b517 == v0) {\n                    ADVISORY_BOARD_TOKENS();\n                } else if (0xb333ce0d == v0) {\n                    icoFinish();\n                } else if (0xb60cc68b != v0) {\n                    if (0xbcaedade == v0) {\n                        STANDARD();\n                    } else if (0xc0ac3d1c == v0) {\n                        PRE_ICO_BONUS_RATE();\n                    } else if (0xc35d1e01 == v0) {\n                        RESERVE_TOKENS();\n                    } else if (0xc8c0b288 == v0) {\n                        bountyFundManager();\n                    } else if (0xcc198380 == v0) {\n                        totalSoldSlogns();\n                    } else if (0xd45b5f71 == v0) {\n                        getIcoStep(uint256);\n                    } else if (0xd484a285 == v0) {\n                        PRE_ICO_SLGN_LESS();\n                    } else if (0xdadc89eb == v0) {\n                        setPreIcoDates(uint256,uint256);\n                    } else if (0xdc7abeb3 == v0) {\n                        OPENSOURCE_TOKENS();\n                    } else if (0xdd62ed3e == v0) {\n                        allowance(address,address);\n                    } else if (0xe113c6fd == v0) {\n                        ICO_SINCE();\n                    } else if (0xe1b0d4b2 == v0) {\n                        setTransactionsAllowed(bool);\n                    } else if (0xe9668128 == v0) {\n                        isTransactionsAllowed();\n                    } else if (0xee09ae4a == v0) {\n                        ethFundManager();\n                    } else if (0xf76f8d78 == v0) {\n                        SYMBOL();\n                    }\n                }\n            }\n            MIN_ICO_SLOGN_COLLECTED();\n        }\n    }\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 31.78235936164856,
	"usage": {
		"completion_tokens": 597,
		"prompt_tokens": 6385,
		"total_tokens": 6982
	}
}