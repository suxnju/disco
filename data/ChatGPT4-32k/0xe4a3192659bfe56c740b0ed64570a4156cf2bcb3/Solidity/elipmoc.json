{
	"address": "0xe4a3192659bfe56c740b0ed64570a4156cf2bcb3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract code based on the decompiled EVM bytecode:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MyContract {\n    mapping (address => uint) private _balanceOf;\n    mapping (address => mapping (address => uint)) private _allowance;\n    uint private _totalSupply;\n    bytes32 private _name;\n    bytes32 private _symbol;\n    uint private _decimals;\n    address private _owner;\n    bool private _isFunding;\n    address private _creator;\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Contribution(address indexed from, uint value);\n\n    constructor(bytes32 name, bytes32 symbol, uint decimals, uint totalSupply) public {\n        _owner = msg.sender;\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n        _isFunding = false;\n        _creator = msg.sender;\n        _balanceOf[msg.sender] = totalSupply;\n    }\n\n    function name() public view returns (bytes32) {\n        return _name;\n    }\n\n    function symbol() public view returns (bytes32) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint) {\n        return _decimals;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint) {\n        return _balanceOf[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint) {\n        return _allowance[owner][spender];\n    }\n\n    function transfer(address to, uint value) public returns (bool) {\n        require(_balanceOf[msg.sender] >= value);\n\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n    }\n    \n    function approve(address spender, uint value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) public returns (bool) {\n        require(_balanceOf[from] >= value);\n        require(_allowance[from][msg.sender] >= value);\n\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n\n        _allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function contribute() public payable {\n        require(msg.value > 0);\n        require(_isFunding);\n\n        _balanceOf[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n\n        emit Contribution(msg.sender, msg.value);\n    }\n}\n```\n\nPlease note that the mappings `_pendingWithdrawals`, `_heldTokens`, and `_heldTimeline` are not used in this contract (they are defined in the decompiled code but not used). Also, there are some functions in the decompiled code that are not clear enough to rewrite them in Solidity (they use unknown variables and opcodes). Therefore, these functions are not included in the Solidity code above.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465855,
	"id": "chatcmpl-8R5Hb0CfvoRVrZjxWbZYxnmmemVNw",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 01:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _pendingWithdrawals; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256[] _name; // STORAGE[0x9]\nuint256[] _symbol; // STORAGE[0xb]\nuint256[] _version; // STORAGE[0xc]\nuint256 _maxMintable; // STORAGE[0xd]\nuint256 _totalMinted; // STORAGE[0xe]\nuint256 _fallback; // STORAGE[0xf]\nuint256 _decimals; // STORAGE[0x10]\nuint256 _endBlock; // STORAGE[0x11]\nuint256 _startBlock; // STORAGE[0x12]\nuint256 _exchangeRate; // STORAGE[0x13]\nuint256 _startTime; // STORAGE[0x14]\nuint256 _heldTotal; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _heldTokens; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _heldTimeline; // STORAGE[0x19]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nmapping (uint256 => [uint256]) owner_1a; // STORAGE[0x1a]\nuint8 _giveReward; // STORAGE[0x4] bytes 0 to 0\nuint8 _isFunding; // STORAGE[0x15] bytes 0 to 0\nuint8 _setup; // STORAGE[0x17] bytes 0 to 0\naddress _eTHWallet; // STORAGE[0x15] bytes 1 to 20\naddress _creator; // STORAGE[0x17] bytes 1 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nReleaseTokens(address, uint256);\nContribution(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1a08(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = _balanceOf[msg.sender] >= varg0;\n    if (v1) {\n        v0 = v2 = varg0 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n        v5 = address(varg1);\n        _balanceOf[v5] = _balanceOf[v5] + varg0;\n        emit Transfer(msg.sender, address(varg1), varg0);\n        v3 = v6 = 1;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    v0 = 0xd89();\n    assert(v0);\n    _fallback = _fallback + msg.value / v0;\n    owner_1a[msg.sender] = owner_1a[msg.sender] + msg.value / v0;\n    emit Transfer(address(this), msg.sender, msg.value / v0);\n}\n\nfunction creator() public nonPayable { \n    return _creator;\n}\n\nfunction heldTimeline(address varg0) public nonPayable { \n    return _heldTimeline[varg0];\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction endBlock() public nonPayable { \n    return _endBlock;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction isFunding() public nonPayable { \n    return _isFunding;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction ETHWallet() public nonPayable { \n    return _eTHWallet;\n}\n\nfunction maxMintable() public nonPayable { \n    return _maxMintable;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = _balanceOf[varg1] + varg2 >= _balanceOf[varg1];\n    }\n    require(v0);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    if (_allowance[msg.sender] < 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    }\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction register(address varg0) public payable { \n}\n\nfunction startBlock() public nonPayable { \n    return _startBlock;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getRate() public nonPayable { \n    v0 = 0xd89();\n    return v0;\n}\n\nfunction updateRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _creator);\n    require(_isFunding);\n    _exchangeRate = varg0;\n}\n\nfunction releaseHeldCoins() public nonPayable { \n    require(!_isFunding);\n    require(_heldTokens[msg.sender] >= 0);\n    require(block.number >= _heldTokens[msg.sender]);\n    _heldTokens[msg.sender] = 0;\n    _heldTokens[msg.sender] = 0;\n    emit ReleaseTokens(msg.sender, _heldTokens[msg.sender]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction changeCreator(address varg0) public nonPayable { \n    require(msg.sender == _creator);\n    _creator = varg0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction create(address varg0) public payable { \n    v0 = msg.value;\n}\n\nfunction totalMinted() public nonPayable { \n    return _totalMinted;\n}\n\nfunction buy() public payable { \n    if (_isFunding) {\n        v0 = 0xd89();\n        assert(v0);\n        _fallback = _fallback + msg.value / v0;\n        owner_1a[msg.sender] = owner_1a[msg.sender] + msg.value / v0;\n        emit Transfer(address(this), msg.sender, msg.value / v0);\n        v1 = 1;\n    } else {\n        v1 = v2 = 1;\n    }\n    return v1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1a08(varg1, varg0);\n    return v0;\n}\n\nfunction heldTotal() public nonPayable { \n    return _heldTotal;\n}\n\nfunction changeTransferStats(bool varg0) public nonPayable { \n    require(msg.sender == _creator);\n}\n\nfunction START() public nonPayable { \n    return 0x1614fbc5c80;\n}\n\nfunction fund(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    return 1;\n}\n\nfunction giveReward(address varg0, uint256 varg1) public payable { \n    assert(_giveReward);\n    v0 = 0x1a08(varg1 / STORAGE[4], varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = msg.value;\n}\n\nfunction contribute() public payable { \n    require(msg.value > 0);\n    require(_isFunding);\n    require(block.number <= _endBlock);\n    require(_totalMinted + msg.value * _exchangeRate <= _maxMintable);\n    _totalMinted = _totalMinted + (_totalMinted + msg.value * _exchangeRate);\n    v0 = _eTHWallet.call().value(msg.value).gas(!msg.value * 2300);\n    require(v0);\n    emit Contribution(msg.sender, msg.value * _exchangeRate);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction heldTokens(address varg0) public nonPayable { \n    return _heldTokens[varg0];\n}\n\nfunction closeSale() public nonPayable { \n    require(msg.sender == _creator);\n    _isFunding = 0;\n}\n\nfunction END() public nonPayable { \n    return 0x1627f5ca200;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction pendingWithdrawals(address varg0) public nonPayable { \n    return _pendingWithdrawals[varg0];\n}\n\nfunction setup(address varg0, uint256 varg1) public nonPayable { \n    require(!_setup);\n    _endBlock = varg1;\n    _setup = 1;\n}\n\nfunction 0xd89() private { \n    if (block.timestamp >= 0x1614fbc5c80) {\n        if (block.timestamp > 0x1614fc44580) {\n            if (block.timestamp > 0x1614fcd8000) {\n                if (block.timestamp > 0x1614fd6ba80) {\n                    if (block.timestamp > 0x1614fe14680) {\n                        v0 = v1 = 0x5ebd3149ccb00;\n                    } else {\n                        v0 = v2 = 0x4ef2fe5845900;\n                    }\n                } else {\n                    v0 = v3 = 0x4bca8d9b6b500;\n                }\n            } else {\n                v0 = v4 = 0x48e04d4520100;\n            }\n        } else {\n            v0 = v5 = 0x462d53d216f00;\n        }\n    } else {\n        v0 = v6 = 0x43abb567267a8;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x2d05d3f == function_selector) {\n            creator();\n        } else if (0x65fe24f == function_selector) {\n            heldTimeline(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x83c6323 == function_selector) {\n            endBlock();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x13b53153 == function_selector) {\n            isFunding();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1a30ec13 == function_selector) {\n            ETHWallet();\n        } else if (0x2154dc39 == function_selector) {\n            maxMintable();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4420e486 == function_selector) {\n            register(address);\n        } else if (0x48cd4cb1 == function_selector) {\n            startBlock();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x679aefce == function_selector) {\n            getRate();\n        } else if (0x69ea1771 == function_selector) {\n            updateRate(uint256);\n        } else if (0x6ce5b3cf == function_selector) {\n            releaseHeldCoins();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x74580e2f == function_selector) {\n            changeCreator(address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91b7f5ed == function_selector) {\n            setPrice(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ed93318 == function_selector) {\n            create(address);\n        } else if (0xa2309ff8 == function_selector) {\n            totalMinted();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb3097a08 == function_selector) {\n            heldTotal();\n        } else if (0xb602a917 == function_selector) {\n            changeTransferStats(bool);\n        } else if (0xba9a061a == function_selector) {\n            START();\n        } else if (0xca1d209d == function_selector) {\n            fund(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xce8ae9f3 == function_selector) {\n            giveReward(address,uint256);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xd7bb99ba == function_selector) {\n            contribute();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xde0099a3 == function_selector) {\n            heldTokens(address);\n        } else if (0xee55efee == function_selector) {\n            closeSale();\n        } else if (0xefe7a504 == function_selector) {\n            END();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3f43703 == function_selector) {\n            pendingWithdrawals(address);\n        } else if (0xf46d1982 == function_selector) {\n            setup(address,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 01:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _pendingWithdrawals; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256[] _name; // STORAGE[0x9]\nuint256[] _symbol; // STORAGE[0xb]\nuint256[] _version; // STORAGE[0xc]\nuint256 _maxMintable; // STORAGE[0xd]\nuint256 _totalMinted; // STORAGE[0xe]\nuint256 _fallback; // STORAGE[0xf]\nuint256 _decimals; // STORAGE[0x10]\nuint256 _endBlock; // STORAGE[0x11]\nuint256 _startBlock; // STORAGE[0x12]\nuint256 _exchangeRate; // STORAGE[0x13]\nuint256 _startTime; // STORAGE[0x14]\nuint256 _heldTotal; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _heldTokens; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _heldTimeline; // STORAGE[0x19]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nmapping (uint256 => [uint256]) owner_1a; // STORAGE[0x1a]\nuint8 _giveReward; // STORAGE[0x4] bytes 0 to 0\nuint8 _isFunding; // STORAGE[0x15] bytes 0 to 0\nuint8 _setup; // STORAGE[0x17] bytes 0 to 0\naddress _eTHWallet; // STORAGE[0x15] bytes 1 to 20\naddress _creator; // STORAGE[0x17] bytes 1 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nReleaseTokens(address, uint256);\nContribution(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1a08(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = _balanceOf[msg.sender] >= varg0;\n    if (v1) {\n        v0 = v2 = varg0 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n        v5 = address(varg1);\n        _balanceOf[v5] = _balanceOf[v5] + varg0;\n        emit Transfer(msg.sender, address(varg1), varg0);\n        v3 = v6 = 1;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    v0 = 0xd89();\n    assert(v0);\n    _fallback = _fallback + msg.value / v0;\n    owner_1a[msg.sender] = owner_1a[msg.sender] + msg.value / v0;\n    emit Transfer(address(this), msg.sender, msg.value / v0);\n}\n\nfunction creator() public nonPayable { \n    return _creator;\n}\n\nfunction heldTimeline(address varg0) public nonPayable { \n    return _heldTimeline[varg0];\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction endBlock() public nonPayable { \n    return _endBlock;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction isFunding() public nonPayable { \n    return _isFunding;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction ETHWallet() public nonPayable { \n    return _eTHWallet;\n}\n\nfunction maxMintable() public nonPayable { \n    return _maxMintable;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = _balanceOf[varg1] + varg2 >= _balanceOf[varg1];\n    }\n    require(v0);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    if (_allowance[msg.sender] < 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    }\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction register(address varg0) public payable { \n}\n\nfunction startBlock() public nonPayable { \n    return _startBlock;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getRate() public nonPayable { \n    v0 = 0xd89();\n    return v0;\n}\n\nfunction updateRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _creator);\n    require(_isFunding);\n    _exchangeRate = varg0;\n}\n\nfunction releaseHeldCoins() public nonPayable { \n    require(!_isFunding);\n    require(_heldTokens[msg.sender] >= 0);\n    require(block.number >= _heldTokens[msg.sender]);\n    _heldTokens[msg.sender] = 0;\n    _heldTokens[msg.sender] = 0;\n    emit ReleaseTokens(msg.sender, _heldTokens[msg.sender]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction changeCreator(address varg0) public nonPayable { \n    require(msg.sender == _creator);\n    _creator = varg0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction create(address varg0) public payable { \n    v0 = msg.value;\n}\n\nfunction totalMinted() public nonPayable { \n    return _totalMinted;\n}\n\nfunction buy() public payable { \n    if (_isFunding) {\n        v0 = 0xd89();\n        assert(v0);\n        _fallback = _fallback + msg.value / v0;\n        owner_1a[msg.sender] = owner_1a[msg.sender] + msg.value / v0;\n        emit Transfer(address(this), msg.sender, msg.value / v0);\n        v1 = 1;\n    } else {\n        v1 = v2 = 1;\n    }\n    return v1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1a08(varg1, varg0);\n    return v0;\n}\n\nfunction heldTotal() public nonPayable { \n    return _heldTotal;\n}\n\nfunction changeTransferStats(bool varg0) public nonPayable { \n    require(msg.sender == _creator);\n}\n\nfunction START() public nonPayable { \n    return 0x1614fbc5c80;\n}\n\nfunction fund(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    return 1;\n}\n\nfunction giveReward(address varg0, uint256 varg1) public payable { \n    assert(_giveReward);\n    v0 = 0x1a08(varg1 / STORAGE[4], varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = msg.value;\n}\n\nfunction contribute() public payable { \n    require(msg.value > 0);\n    require(_isFunding);\n    require(block.number <= _endBlock);\n    require(_totalMinted + msg.value * _exchangeRate <= _maxMintable);\n    _totalMinted = _totalMinted + (_totalMinted + msg.value * _exchangeRate);\n    v0 = _eTHWallet.call().value(msg.value).gas(!msg.value * 2300);\n    require(v0);\n    emit Contribution(msg.sender, msg.value * _exchangeRate);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction heldTokens(address varg0) public nonPayable { \n    return _heldTokens[varg0];\n}\n\nfunction closeSale() public nonPayable { \n    require(msg.sender == _creator);\n    _isFunding = 0;\n}\n\nfunction END() public nonPayable { \n    return 0x1627f5ca200;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction pendingWithdrawals(address varg0) public nonPayable { \n    return _pendingWithdrawals[varg0];\n}\n\nfunction setup(address varg0, uint256 varg1) public nonPayable { \n    require(!_setup);\n    _endBlock = varg1;\n    _setup = 1;\n}\n\nfunction 0xd89() private { \n    if (block.timestamp >= 0x1614fbc5c80) {\n        if (block.timestamp > 0x1614fc44580) {\n            if (block.timestamp > 0x1614fcd8000) {\n                if (block.timestamp > 0x1614fd6ba80) {\n                    if (block.timestamp > 0x1614fe14680) {\n                        v0 = v1 = 0x5ebd3149ccb00;\n                    } else {\n                        v0 = v2 = 0x4ef2fe5845900;\n                    }\n                } else {\n                    v0 = v3 = 0x4bca8d9b6b500;\n                }\n            } else {\n                v0 = v4 = 0x48e04d4520100;\n            }\n        } else {\n            v0 = v5 = 0x462d53d216f00;\n        }\n    } else {\n        v0 = v6 = 0x43abb567267a8;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x2d05d3f == function_selector) {\n            creator();\n        } else if (0x65fe24f == function_selector) {\n            heldTimeline(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x83c6323 == function_selector) {\n            endBlock();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x13b53153 == function_selector) {\n            isFunding();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1a30ec13 == function_selector) {\n            ETHWallet();\n        } else if (0x2154dc39 == function_selector) {\n            maxMintable();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4420e486 == function_selector) {\n            register(address);\n        } else if (0x48cd4cb1 == function_selector) {\n            startBlock();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x679aefce == function_selector) {\n            getRate();\n        } else if (0x69ea1771 == function_selector) {\n            updateRate(uint256);\n        } else if (0x6ce5b3cf == function_selector) {\n            releaseHeldCoins();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x74580e2f == function_selector) {\n            changeCreator(address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91b7f5ed == function_selector) {\n            setPrice(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ed93318 == function_selector) {\n            create(address);\n        } else if (0xa2309ff8 == function_selector) {\n            totalMinted();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb3097a08 == function_selector) {\n            heldTotal();\n        } else if (0xb602a917 == function_selector) {\n            changeTransferStats(bool);\n        } else if (0xba9a061a == function_selector) {\n            START();\n        } else if (0xca1d209d == function_selector) {\n            fund(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xce8ae9f3 == function_selector) {\n            giveReward(address,uint256);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xd7bb99ba == function_selector) {\n            contribute();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xde0099a3 == function_selector) {\n            heldTokens(address);\n        } else if (0xee55efee == function_selector) {\n            closeSale();\n        } else if (0xefe7a504 == function_selector) {\n            END();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3f43703 == function_selector) {\n            pendingWithdrawals(address);\n        } else if (0xf46d1982 == function_selector) {\n            setup(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 01:18 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _pendingWithdrawals; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256[] _name; // STORAGE[0x9]\nuint256[] _symbol; // STORAGE[0xb]\nuint256[] _version; // STORAGE[0xc]\nuint256 _maxMintable; // STORAGE[0xd]\nuint256 _totalMinted; // STORAGE[0xe]\nuint256 _fallback; // STORAGE[0xf]\nuint256 _decimals; // STORAGE[0x10]\nuint256 _endBlock; // STORAGE[0x11]\nuint256 _startBlock; // STORAGE[0x12]\nuint256 _exchangeRate; // STORAGE[0x13]\nuint256 _startTime; // STORAGE[0x14]\nuint256 _heldTotal; // STORAGE[0x16]\nmapping (uint256 => [uint256]) _heldTokens; // STORAGE[0x18]\nmapping (uint256 => [uint256]) _heldTimeline; // STORAGE[0x19]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nmapping (uint256 => [uint256]) owner_1a; // STORAGE[0x1a]\nuint8 _giveReward; // STORAGE[0x4] bytes 0 to 0\nuint8 _isFunding; // STORAGE[0x15] bytes 0 to 0\nuint8 _setup; // STORAGE[0x17] bytes 0 to 0\naddress _eTHWallet; // STORAGE[0x15] bytes 1 to 20\naddress _creator; // STORAGE[0x17] bytes 1 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nReleaseTokens(address, uint256);\nContribution(address, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1a08(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = _balanceOf[msg.sender] >= varg0;\n    if (v1) {\n        v0 = v2 = varg0 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n        v5 = address(varg1);\n        _balanceOf[v5] = _balanceOf[v5] + varg0;\n        emit Transfer(msg.sender, address(varg1), varg0);\n        v3 = v6 = 1;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    v0 = 0xd89();\n    assert(v0);\n    _fallback = _fallback + msg.value / v0;\n    owner_1a[msg.sender] = owner_1a[msg.sender] + msg.value / v0;\n    emit Transfer(address(this), msg.sender, msg.value / v0);\n}\n\nfunction creator() public nonPayable { \n    return _creator;\n}\n\nfunction heldTimeline(address varg0) public nonPayable { \n    return _heldTimeline[varg0];\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction endBlock() public nonPayable { \n    return _endBlock;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction isFunding() public nonPayable { \n    return _isFunding;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction ETHWallet() public nonPayable { \n    return _eTHWallet;\n}\n\nfunction maxMintable() public nonPayable { \n    return _maxMintable;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = _balanceOf[varg1] + varg2 >= _balanceOf[varg1];\n    }\n    require(v0);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    if (_allowance[msg.sender] < 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    }\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction exchangeRate() public nonPayable { \n    return _exchangeRate;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction register(address varg0) public payable { \n}\n\nfunction startBlock() public nonPayable { \n    return _startBlock;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getRate() public nonPayable { \n    v0 = 0xd89();\n    return v0;\n}\n\nfunction updateRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _creator);\n    require(_isFunding);\n    _exchangeRate = varg0;\n}\n\nfunction releaseHeldCoins() public nonPayable { \n    require(!_isFunding);\n    require(_heldTokens[msg.sender] >= 0);\n    require(block.number >= _heldTokens[msg.sender]);\n    _heldTokens[msg.sender] = 0;\n    _heldTokens[msg.sender] = 0;\n    emit ReleaseTokens(msg.sender, _heldTokens[msg.sender]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction changeCreator(address varg0) public nonPayable { \n    require(msg.sender == _creator);\n    _creator = varg0;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setPrice(uint256 varg0) public nonPayable { \n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction create(address varg0) public payable { \n    v0 = msg.value;\n}\n\nfunction totalMinted() public nonPayable { \n    return _totalMinted;\n}\n\nfunction buy() public payable { \n    if (_isFunding) {\n        v0 = 0xd89();\n        assert(v0);\n        _fallback = _fallback + msg.value / v0;\n        owner_1a[msg.sender] = owner_1a[msg.sender] + msg.value / v0;\n        emit Transfer(address(this), msg.sender, msg.value / v0);\n        v1 = 1;\n    } else {\n        v1 = v2 = 1;\n    }\n    return v1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1a08(varg1, varg0);\n    return v0;\n}\n\nfunction heldTotal() public nonPayable { \n    return _heldTotal;\n}\n\nfunction changeTransferStats(bool varg0) public nonPayable { \n    require(msg.sender == _creator);\n}\n\nfunction START() public nonPayable { \n    return 0x1614fbc5c80;\n}\n\nfunction fund(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    return 1;\n}\n\nfunction giveReward(address varg0, uint256 varg1) public payable { \n    assert(_giveReward);\n    v0 = 0x1a08(varg1 / STORAGE[4], varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = msg.value;\n}\n\nfunction contribute() public payable { \n    require(msg.value > 0);\n    require(_isFunding);\n    require(block.number <= _endBlock);\n    require(_totalMinted + msg.value * _exchangeRate <= _maxMintable);\n    _totalMinted = _totalMinted + (_totalMinted + msg.value * _exchangeRate);\n    v0 = _eTHWallet.call().value(msg.value).gas(!msg.value * 2300);\n    require(v0);\n    emit Contribution(msg.sender, msg.value * _exchangeRate);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction heldTokens(address varg0) public nonPayable { \n    return _heldTokens[varg0];\n}\n\nfunction closeSale() public nonPayable { \n    require(msg.sender == _creator);\n    _isFunding = 0;\n}\n\nfunction END() public nonPayable { \n    return 0x1627f5ca200;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction pendingWithdrawals(address varg0) public nonPayable { \n    return _pendingWithdrawals[varg0];\n}\n\nfunction setup(address varg0, uint256 varg1) public nonPayable { \n    require(!_setup);\n    _endBlock = varg1;\n    _setup = 1;\n}\n\nfunction 0xd89() private { \n    if (block.timestamp >= 0x1614fbc5c80) {\n        if (block.timestamp > 0x1614fc44580) {\n            if (block.timestamp > 0x1614fcd8000) {\n                if (block.timestamp > 0x1614fd6ba80) {\n                    if (block.timestamp > 0x1614fe14680) {\n                        v0 = v1 = 0x5ebd3149ccb00;\n                    } else {\n                        v0 = v2 = 0x4ef2fe5845900;\n                    }\n                } else {\n                    v0 = v3 = 0x4bca8d9b6b500;\n                }\n            } else {\n                v0 = v4 = 0x48e04d4520100;\n            }\n        } else {\n            v0 = v5 = 0x462d53d216f00;\n        }\n    } else {\n        v0 = v6 = 0x43abb567267a8;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x2d05d3f == function_selector) {\n            creator();\n        } else if (0x65fe24f == function_selector) {\n            heldTimeline(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x83c6323 == function_selector) {\n            endBlock();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x13b53153 == function_selector) {\n            isFunding();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1a30ec13 == function_selector) {\n            ETHWallet();\n        } else if (0x2154dc39 == function_selector) {\n            maxMintable();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ba0b9a9 == function_selector) {\n            exchangeRate();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4420e486 == function_selector) {\n            register(address);\n        } else if (0x48cd4cb1 == function_selector) {\n            startBlock();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x679aefce == function_selector) {\n            getRate();\n        } else if (0x69ea1771 == function_selector) {\n            updateRate(uint256);\n        } else if (0x6ce5b3cf == function_selector) {\n            releaseHeldCoins();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x74580e2f == function_selector) {\n            changeCreator(address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91b7f5ed == function_selector) {\n            setPrice(uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ed93318 == function_selector) {\n            create(address);\n        } else if (0xa2309ff8 == function_selector) {\n            totalMinted();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb3097a08 == function_selector) {\n            heldTotal();\n        } else if (0xb602a917 == function_selector) {\n            changeTransferStats(bool);\n        } else if (0xba9a061a == function_selector) {\n            START();\n        } else if (0xca1d209d == function_selector) {\n            fund(uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xce8ae9f3 == function_selector) {\n            giveReward(address,uint256);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xd7bb99ba == function_selector) {\n            contribute();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xde0099a3 == function_selector) {\n            heldTokens(address);\n        } else if (0xee55efee == function_selector) {\n            closeSale();\n        } else if (0xefe7a504 == function_selector) {\n            END();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3f43703 == function_selector) {\n            pendingWithdrawals(address);\n        } else if (0xf46d1982 == function_selector) {\n            setup(address,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 40.797043323516846,
	"usage": {
		"completion_tokens": 693,
		"prompt_tokens": 4511,
		"total_tokens": 5204
	}
}