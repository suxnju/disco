{
	"address": "0x792e6c37ae5ced8202794af26671531195418616",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst decimals = 18\nconst totalEthereumBalance = eth.balance(this.address)\n\ndef storage:\n  name is array of uint256 at storage 0\n  symbol is array of uint256 at storage 1\n  createdAt is uint256 at storage 2\n  stor3 is uint8 at storage 3\n  stor3 is address at storage 3\n  stor3 is address at storage 3 offset 8\n  balanceOf is mapping of uint256 at storage 4\n  stor5 is mapping of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  stor7 is mapping of uint256 at storage 7\n  stor8 is mapping of uint256 at storage 8\n  totalSupply is uint256 at storage 9\n  stor10 is uint256 at storage 10\n  blockCreation is uint256 at storage 11\n  stor12 is mapping of uint8 at storage 12\n  I_S is uint256 at storage 13\n  I_R1 is uint256 at storage 14\n  II_S is uint256 at storage 15\n  II_R1 is uint256 at storage 16\n  II_R2 is uint256 at storage 17\n  III_S is uint256 at storage 18\n  III_R1 is uint256 at storage 19\n  III_R2 is uint256 at storage 20\n  III_R3 is uint256 at storage 21\n  IV_S is uint256 at storage 22\n  IV_R1 is uint256 at storage 23\n  IV_R2 is uint256 at storage 24\n  IV_R3 is uint256 at storage 25\n  IV_R4 is uint256 at storage 26\n  V_S is uint256 at storage 27\n  V_R1 is uint256 at storage 28\n  V_R2 is uint256 at storage 29\n  V_R3 is uint256 at storage 30\n  V_R4 is uint256 at storage 31\n  V_R5 is uint256 at storage 32\n  referralProfit is mapping of uint256 at storage 33\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef IV_R4(): # not payable\n  return IV_R4\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef IV_R3(): # not payable\n  return IV_R3\n\ndef started(): # not payable\n  return bool(uint8(stor3.field_0))\n\ndef III_R1(): # not payable\n  return III_R1\n\ndef IV_R2(): # not payable\n  return IV_R2\n\ndef V_R3(): # not payable\n  return V_R3\n\ndef administrators(bytes32 _param1): # not payable\n  return bool(stor12[_param1])\n\ndef III_R2(): # not payable\n  return III_R2\n\ndef IV_S(): # not payable\n  return IV_S\n\ndef V_R2(): # not payable\n  return V_R2\n\ndef V_R5(): # not payable\n  return V_R5\n\ndef I_S(): # not payable\n  return I_S\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef getReferralProfit(address _referredBy, address _referral): # not payable\n  return referralProfit[address(_referredBy)][address(_referral)]\n\ndef II_R2(): # not payable\n  return II_R2\n\ndef V_R4(): # not payable\n  return V_R4\n\ndef V_S(): # not payable\n  return V_S\n\ndef blockCreation(): # not payable\n  return blockCreation\n\ndef IV_R1(): # not payable\n  return IV_R1\n\ndef myTokens(): # not payable\n  return balanceOf[caller]\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef I_R1(): # not payable\n  return I_R1\n\ndef II_R1(): # not payable\n  return II_R1\n\ndef III_S(): # not payable\n  return III_S\n\ndef isAdmin(): # not payable\n  return bool(stor12[caller])\n\ndef createdAt(): # not payable\n  return createdAt\n\ndef V_R1(): # not payable\n  return V_R1\n\ndef II_S(): # not payable\n  return II_S\n\ndef III_R3(): # not payable\n  return III_R3\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef setI_S(uint256 _v): # not payable\n  require stor12[caller]\n  I_S = _v\n\ndef setV_S(uint256 _v): # not payable\n  require stor12[caller]\n  V_S = _v\n\ndef setII_S(uint256 _v): # not payable\n  require stor12[caller]\n  II_S = _v\n\ndef setV_R3(uint256 _v): # not payable\n  require stor12[caller]\n  V_R3 = _v\n\ndef setIV_S(uint256 _v): # not payable\n  require stor12[caller]\n  IV_S = _v\n\ndef setV_R1(uint256 _v): # not payable\n  require stor12[caller]\n  V_R1 = _v\n\ndef setI_R1(uint256 _v): # not payable\n  require stor12[caller]\n  I_R1 = _v\n\ndef setV_R2(uint256 _v): # not payable\n  require stor12[caller]\n  V_R2 = _v\n\ndef setV_R4(uint256 _v): # not payable\n  require stor12[caller]\n  V_R4 = _v\n\ndef setV_R5(uint256 _v): # not payable\n  require stor12[caller]\n  V_R5 = _v\n\ndef setIV_R1(uint256 _v): # not payable\n  require stor12[caller]\n  IV_R1 = _v\n\ndef setIV_R2(uint256 _v): # not payable\n  require stor12[caller]\n  IV_R2 = _v\n\ndef setII_R2(uint256 _v): # not payable\n  require stor12[caller]\n  II_R2 = _v\n\ndef setIII_S(uint256 _v): # not payable\n  require stor12[caller]\n  III_S = _v\n\ndef setIV_R4(uint256 _v): # not payable\n  require stor12[caller]\n  IV_R4 = _v\n\ndef setII_R1(uint256 _v): # not payable\n  require stor12[caller]\n  II_R1 = _v\n\ndef setIV_R3(uint256 _v): # not payable\n  require stor12[caller]\n  IV_R3 = _v\n\ndef setIII_R3(uint256 _v): # not payable\n  require stor12[caller]\n  III_R3 = _v\n\ndef setIII_R2(uint256 _v): # not payable\n  require stor12[caller]\n  III_R2 = _v\n\ndef setIII_R1(uint256 _v): # not payable\n  require stor12[caller]\n  III_R1 = _v\n\ndef setName(string _name): # not payable\n  require stor12[caller]\n  name[] = Array(len=_name.length, data=_name[all])\n\ndef getLifetime(): # not payable\n  if uint8(stor3.field_0):\n      return uint8(block.timestamp - createdAt / 60 / 60 / 24)\n  else:\n      return 0\n\ndef setSymbol(string _symbol): # not payable\n  require stor12[caller]\n  symbol[] = Array(len=_symbol.length, data=_symbol[all])\n\ndef start(): # not payable\n  require not uint8(stor3.field_0)\n  require stor12[caller]\n  uint8(stor3.field_0) = 1\n  createdAt = block.timestamp\n\ndef getSummaryReferralProfit(address _referredBy): # not payable\n  if address(stor3.field_8) != _referredBy:\n      return stor7[address(_referredBy)]\n  else:\n      return 0\n\ndef dividendsOf(address _customerAddress): # not payable\n  return (Mask(192, 64, (balanceOf[address(_customerAddress)] * stor10) - stor6[address(_customerAddress)]) >> 64)\n\ndef setAdministrator(address _identifier, bool _status): # not payable\n  require stor12[caller]\n  if address(stor3.field_8) != _identifier:\n      stor12[_identifier] = uint8(_status)\n\ndef myDividends(bool _includeReferralBonus): # not payable\n  if _includeReferralBonus:\n      return ((Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller])\n  return (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n\ndef dividendsFull(address _customerAddress): # not payable\n  return ((Mask(192, 64, (balanceOf[address(_customerAddress)] * stor10) - stor6[address(_customerAddress)]) >> 64) + stor8[address(_customerAddress)] + stor7[address(_customerAddress)])\n\ndef getExitFee(): # not payable\n  if not uint8(stor3.field_0):\n      return 30\n  if uint8(block.timestamp - createdAt / 60 / 60 / 24) <= 6:\n      return 30\n  if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n      return 6\n  return uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 36)\n\ndef tokensToEthereumAtSupply_(uint256 _tokens, uint256 _atSupply): # not payable\n  if _tokens < 10^10:\n      return 0\n  require 10^10 * (_tokens + 10^18)^2 + -_tokens - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * _tokens) + (10^10 * _atSupply + 10^18 / 10^18 * _tokens)\n  return ((25 * 10^6 * 3600 * _tokens) + (10^10 * _atSupply + 10^18 / 10^18 * _tokens) - (10^10 * (_tokens + 10^18)^2 + -_tokens - 10^18 / 10^18 / 2) / 10^18)\n\ndef calculateEthereumReceived(uint256 _tokensToSell): # not payable\n  require _tokensToSell <= totalSupply\n  if _tokensToSell < 10^10:\n      return 0\n  require 10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * _tokensToSell) + (10^10 * totalSupply + 10^18 / 10^18 * _tokensToSell)\n  return ((25 * 10^6 * 3600 * _tokensToSell) + (10^10 * totalSupply + 10^18 / 10^18 * _tokensToSell) - (10^10 * (_tokensToSell + 10^18)^2 + -_tokensToSell - 10^18 / 10^18 / 2) / 10^18)\n\ndef sellPrice(): # not payable\n  if not totalSupply:\n      return (25 * 10^6 * 3600)\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  if not (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n      if 0 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n          return ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18)\n  else:\n      if 6 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 == 6:\n          if 6 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n              return (((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) - (6 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100))\n  revert\n\ndef sellPriceAt(uint256 _atSupply): # not payable\n  if not _atSupply:\n      return (25 * 10^6 * 3600)\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  if not (10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n      if 0 <= (10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n          return ((10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18)\n  else:\n      if 6 * (10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / (10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 == 6:\n          if 6 * (10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100 <= (10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n              return (((10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) - (6 * (10000000000 * 10^18 * _atSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100))\n  revert\n\ndef buyPrice(): # not payable\n  if not totalSupply:\n      return 11 * 10^10\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  if not (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n      if (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n          return ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18)\n  else:\n      if 12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 == 12:\n          if (12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n              return ((12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18))\n  revert\n\ndef calculateTokensReceived(uint256 _ethereumToSpend): # not payable\n  if not _ethereumToSpend:\n      if 0 <= _ethereumToSpend:\n          s = (2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n          t = (2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n          while s < t:\n              require s\n              s = ((2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n              t = s\n              continue \n          if 100000000000 * 10^18 <= t:\n              return ((t - 100000000000 * 10^18 / 10^10) - totalSupply)\n  else:\n      if 12 * _ethereumToSpend / _ethereumToSpend == 12:\n          if 12 * _ethereumToSpend / 100 <= _ethereumToSpend:\n              s = (2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * 12 * _ethereumToSpend / 100) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n              t = (2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * 12 * _ethereumToSpend / 100) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n              while s < t:\n                  require s\n                  s = ((2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * _ethereumToSpend) + (-20000000000000000000000000000 * 10^18 * 12 * _ethereumToSpend / 100) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n                  t = s\n                  continue \n              if 100000000000 * 10^18 <= t:\n                  return ((t - 100000000000 * 10^18 / 10^10) - totalSupply)\n  revert\n\ndef getLevel(address account): # not payable\n  if balanceOf[address(account)] < 10^10:\n      if 0 >= V_S:\n          return 5\n      if 0 >= IV_S:\n          return 4\n      if 0 >= III_S:\n          return 3\n      if 0 >= II_S:\n          return 2\n      if 0 < I_S:\n          return 0\n  else:\n      require 10^10 * (balanceOf[address(account)] + 10^18)^2 + -balanceOf[address(account)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(account)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(account)])\n      if (25 * 10^6 * 3600 * balanceOf[address(account)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(account)]) - (10^10 * (balanceOf[address(account)] + 10^18)^2 + -balanceOf[address(account)] - 10^18 / 10^18 / 2) / 10^18 >= V_S:\n          return 5\n      if (25 * 10^6 * 3600 * balanceOf[address(account)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(account)]) - (10^10 * (balanceOf[address(account)] + 10^18)^2 + -balanceOf[address(account)] - 10^18 / 10^18 / 2) / 10^18 >= IV_S:\n          return 4\n      if (25 * 10^6 * 3600 * balanceOf[address(account)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(account)]) - (10^10 * (balanceOf[address(account)] + 10^18)^2 + -balanceOf[address(account)] - 10^18 / 10^18 / 2) / 10^18 >= III_S:\n          return 3\n      if (25 * 10^6 * 3600 * balanceOf[address(account)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(account)]) - (10^10 * (balanceOf[address(account)] + 10^18)^2 + -balanceOf[address(account)] - 10^18 / 10^18 / 2) / 10^18 >= II_S:\n          return 2\n      if (25 * 10^6 * 3600 * balanceOf[address(account)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(account)]) - (10^10 * (balanceOf[address(account)] + 10^18)^2 + -balanceOf[address(account)] - 10^18 / 10^18 / 2) / 10^18 < I_S:\n          return 0\n  return 1\n\ndef sell(uint256 amount): # not payable\n  require balanceOf[caller] > 0\n  require amount <= balanceOf[caller]\n  if amount < 10^10:\n      require amount <= totalSupply\n      totalSupply -= amount\n      require amount <= balanceOf[caller]\n      balanceOf[caller] -= amount\n      stor6[caller] += -1 * amount * stor10\n      if not totalSupply:\n          log onTokenSell(\n                address customerAddress=amount,\n                uint256 tokensBurned=0,\n                uint256 ethereumEarned=block.timestamp,\n                uint256 timestamp=11 * 10^10,\n                uint256 price=caller)\n      else:\n          require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n          if not (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n              require (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n              log onTokenSell(\n                    address customerAddress=amount,\n                    uint256 tokensBurned=0,\n                    uint256 ethereumEarned=block.timestamp,\n                    uint256 timestamp=(10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18,\n                    uint256 price=caller)\n          else:\n              require 12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 == 12\n              require (12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n              log onTokenSell(\n                    address customerAddress=amount,\n                    uint256 tokensBurned=0,\n                    uint256 ethereumEarned=block.timestamp,\n                    uint256 timestamp=(12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18),\n                    uint256 price=caller)\n  else:\n      require 10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * amount) + (10^10 * totalSupply + 10^18 / 10^18 * amount)\n      require amount <= totalSupply\n      totalSupply -= amount\n      require amount <= balanceOf[caller]\n      balanceOf[caller] -= amount\n      stor6[caller] = stor6[caller] - ((25 * 10^6 * 3600 * amount) + (10^10 * totalSupply + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18 << 64) - (amount * stor10)\n      if not totalSupply:\n          log onTokenSell(\n                address customerAddress=amount,\n                uint256 tokensBurned=(25 * 10^6 * 3600 * amount) + (10^10 * totalSupply + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18,\n                uint256 ethereumEarned=block.timestamp,\n                uint256 timestamp=11 * 10^10,\n                uint256 price=caller)\n      else:\n          require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n          if not (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n              require (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n              log onTokenSell(\n                    address customerAddress=amount,\n                    uint256 tokensBurned=(25 * 10^6 * 3600 * amount) + (10^10 * totalSupply + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18,\n                    uint256 ethereumEarned=block.timestamp,\n                    uint256 timestamp=(10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18,\n                    uint256 price=caller)\n          else:\n              require 12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 == 12\n              require (12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n              log onTokenSell(\n                    address customerAddress=amount,\n                    uint256 tokensBurned=(25 * 10^6 * 3600 * amount) + (10^10 * totalSupply + 10^18 / 10^18 * amount) - (10^10 * (amount + 10^18)^2 + -amount - 10^18 / 10^18 / 2) / 10^18,\n                    uint256 ethereumEarned=block.timestamp,\n                    uint256 timestamp=(12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18),\n                    uint256 price=caller)\n\ndef reinvest(): # not payable\n  require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n  stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n  stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n  stor5[caller] = 0\n  if not (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller]:\n      require 0 <= (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller]\n      s = (2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor5[caller]) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n      t = (2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor5[caller]) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor5[caller]) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n          t = s\n          continue \n      require 100000000000 * 10^18 <= t\n      require (t - 100000000000 * 10^18 / 10^10) - totalSupply > 0\n      require t - 100000000000 * 10^18 / 10^10 >= (t - 100000000000 * 10^18 / 10^10) - totalSupply\n      require t - 100000000000 * 10^18 / 10^10 > totalSupply\n      if totalSupply <= 0:\n          totalSupply = (t - 100000000000 * 10^18 / 10^10) - totalSupply\n          require (t - 100000000000 * 10^18 / 10^10) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 100000000000 * 10^18 / 10^10) - totalSupply + balanceOf[caller]\n          stor6[caller] = stor6[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (totalSupply * stor10)\n      else:\n          require t - 100000000000 * 10^18 / 10^10 >= totalSupply\n          totalSupply = t - 100000000000 * 10^18 / 10^10\n          require t - 100000000000 * 10^18 / 10^10\n          stor10 += 0 / t - 100000000000 * 10^18 / 10^10\n          require totalSupply\n          require (t - 100000000000 * 10^18 / 10^10) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 100000000000 * 10^18 / 10^10) - totalSupply + balanceOf[caller]\n          stor6[caller] = stor6[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (totalSupply * stor10) - (t - 100000000000 * 10^18 / 10^10 * 0 / totalSupply) + (totalSupply * 0 / totalSupply)\n  else:\n      require (12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] == 12\n      require (12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / 100 <= (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller]\n      s = (2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor5[caller]) + (-20000000000000000000000000000 * 10^18 * (12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / 100) + 0x197d4df19d605767337e9f14d3eec8920e400000000000001 / 2\n      t = (2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor5[caller]) + (-20000000000000000000000000000 * 10^18 * (12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / 100) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000\n      while s < t:\n          require s\n          s = ((2000000000000000000000 * 10^18 * totalSupply) + (100 * 10^18 * totalSupply^2) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (0x380d4bd8a8678c1bb542c80deb4800000000000 * stor5[caller]) + (-20000000000000000000000000000 * 10^18 * (12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / 100) + 0x197d4df19d605767337e9f14d3eec8920e400000000000000 / s) + s / 2\n          t = s\n          continue \n      require 100000000000 * 10^18 <= t\n      require (t - 100000000000 * 10^18 / 10^10) - totalSupply > 0\n      require t - 100000000000 * 10^18 / 10^10 >= (t - 100000000000 * 10^18 / 10^10) - totalSupply\n      require t - 100000000000 * 10^18 / 10^10 > totalSupply\n      if totalSupply <= 0:\n          totalSupply = (t - 100000000000 * 10^18 / 10^10) - totalSupply\n          require (t - 100000000000 * 10^18 / 10^10) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 100000000000 * 10^18 / 10^10) - totalSupply + balanceOf[caller]\n          stor6[caller] = stor6[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (totalSupply * stor10) - ((12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / 100 << 64)\n      else:\n          require t - 100000000000 * 10^18 / 10^10 >= totalSupply\n          totalSupply = t - 100000000000 * 10^18 / 10^10\n          require t - 100000000000 * 10^18 / 10^10\n          stor10 += (12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / 100 << 64 / t - 100000000000 * 10^18 / 10^10\n          require totalSupply\n          require (t - 100000000000 * 10^18 / 10^10) - totalSupply + balanceOf[caller] >= balanceOf[caller]\n          balanceOf[caller] = (t - 100000000000 * 10^18 / 10^10) - totalSupply + balanceOf[caller]\n          stor6[caller] = stor6[caller] + (t - 100000000000 * 10^18 / 10^10 * stor10) - (totalSupply * stor10) - (t - 100000000000 * 10^18 / 10^10 * (12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / 100 << 64 / totalSupply) + (totalSupply * (12 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + (12 * stor5[caller]) / 100 << 64 / totalSupply)\n  if not totalSupply:\n      log onTokenPurchase(\n            address customerAddress=(Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller],\n            uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - totalSupply,\n            uint256 tokensMinted=block.timestamp,\n            uint256 timestamp=11 * 10^10,\n            uint256 price=caller)\n  else:\n      require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n      if not (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n          require (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n          log onTokenPurchase(\n                address customerAddress=(Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller],\n                uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - totalSupply,\n                uint256 tokensMinted=block.timestamp,\n                uint256 timestamp=(10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18,\n                uint256 price=caller)\n      else:\n          require 12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 == 12\n          require (12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n          log onTokenPurchase(\n                address customerAddress=(Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller],\n                uint256 incomingEthereum=(t - 100000000000 * 10^18 / 10^10) - totalSupply,\n                uint256 tokensMinted=block.timestamp,\n                uint256 timestamp=(12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18),\n                uint256 price=caller)\n  log onReinvestment(\n        address customerAddress=((Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller]),\n        uint256 ethereumReinvested=caller)\n\ndef withdraw(): # not payable\n  require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n  stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n  stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n  stor5[caller] = 0\n  if not uint8(stor3.field_0):\n      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              require totalSupply\n              require (0 / totalSupply) + stor10 >= stor10\n              stor10 += 0 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                   gas 2300 * is_zero(value) wei\n          else:\n              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              if address(stor3.field_8) == caller:\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n      else:\n          require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              require totalSupply\n              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n              stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                   gas 2300 * is_zero(value) wei\n          else:\n              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              if address(stor3.field_8) == caller:\n                  require totalSupply\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  require totalSupply\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n  else:\n      if uint8(block.timestamp - createdAt / 60 / 60 / 24) <= 6:\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n          else:\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n      else:\n          if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n          else:\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              else:\n                  require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log onWithdraw(\n        address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n        uint256 ethereumWithdrawn=caller)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require balanceOf[caller] > 0\n  require amount <= balanceOf[caller]\n  if (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0:\n      require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n      stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n      stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n      stor5[caller] = 0\n      if not uint8(stor3.field_0):\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n          else:\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n      else:\n          if uint8(block.timestamp - createdAt / 60 / 60 / 24) <= 6:\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              else:\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n          else:\n              if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n              else:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                  else:\n                      require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n            uint256 ethereumWithdrawn=caller)\n  if not amount:\n      require 0 <= amount\n      require 0 <= totalSupply\n      require amount <= balanceOf[caller]\n      balanceOf[caller] -= amount\n      require amount + balanceOf[recipient] >= balanceOf[recipient]\n      balanceOf[address(recipient)] = amount + balanceOf[recipient]\n      stor6[caller] += -1 * amount * stor10\n      stor6[recipient] += amount * stor10\n      require totalSupply\n      require (0 / totalSupply) + stor10 >= stor10\n      stor10 += 0 / totalSupply\n      log Transfer(\n            address from=amount,\n            address to=caller,\n            uint256 value=recipient)\n  else:\n      require amount / amount == 1\n      require amount / 100 <= amount\n      if amount / 100 < 10^10:\n          require amount / 100 <= totalSupply\n          totalSupply -= amount / 100\n          require amount <= balanceOf[caller]\n          balanceOf[caller] -= amount\n          require amount - (amount / 100) + balanceOf[recipient] >= balanceOf[recipient]\n          balanceOf[address(recipient)] = amount - (amount / 100) + balanceOf[recipient]\n          stor6[caller] += -1 * amount * stor10\n          stor6[recipient] = stor6[recipient] + (amount * stor10) - (amount / 100 * stor10)\n          require totalSupply\n          require (0 / totalSupply) + stor10 >= stor10\n          stor10 += 0 / totalSupply\n      else:\n          require 10^10 * ((amount / 100) + 10^18)^2 + -(amount / 100) - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * amount / 100) + (10^10 * totalSupply + 10^18 / 10^18 * amount / 100)\n          require amount / 100 <= totalSupply\n          totalSupply -= amount / 100\n          require amount <= balanceOf[caller]\n          balanceOf[caller] -= amount\n          require amount - (amount / 100) + balanceOf[recipient] >= balanceOf[recipient]\n          balanceOf[address(recipient)] = amount - (amount / 100) + balanceOf[recipient]\n          stor6[caller] += -1 * amount * stor10\n          stor6[recipient] = stor6[recipient] + (amount * stor10) - (amount / 100 * stor10)\n          require totalSupply\n          require ((25 * 10^6 * 3600 * amount / 100) + (10^10 * totalSupply + 10^18 / 10^18 * amount / 100) - (10^10 * ((amount / 100) + 10^18)^2 + -(amount / 100) - 10^18 / 10^18 / 2) / 10^18 << 64 / totalSupply) + stor10 >= stor10\n          stor10 += (25 * 10^6 * 3600 * amount / 100) + (10^10 * totalSupply + 10^18 / 10^18 * amount / 100) - (10^10 * ((amount / 100) + 10^18)^2 + -(amount / 100) - 10^18 / 10^18 / 2) / 10^18 << 64 / totalSupply\n      log Transfer(\n            address from=(amount - (amount / 100)),\n            address to=caller,\n            uint256 value=recipient)\n  return 1\n\ndef buy(address _r1, address _r2, address _r3, address _r4, address _r5) payable: \n  require uint8(stor3.field_0)\n  if call.value:\n      require 12 * call.value / call.value == 12\n      if not _r1:\n          if not _r2:\n              if not _r3:\n                  if not _r4:\n                      if not _r5:\n                          require 12 * call.value / 100 <= call.value\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if _r5 != caller:\n                  else:\n                      if _r4 == caller:\n                          if _r5:\n                              if _r5 != caller:\n                      else:\n                          if IV_S > balanceOf[address(_r4)]:\n                              if _r5:\n                          else:\n                              if balanceOf[address(_r4)] < 10^10:\n              else:\n                  if _r3 == caller:\n                      if not _r4:\n                          if _r5:\n                              if _r5 != caller:\n                      else:\n                          if _r4 == caller:\n                              if _r5:\n                          else:\n                              if IV_S > balanceOf[address(_r4)]:\n                                  if _r5:\n                              else:\n                                  if balanceOf[address(_r4)] < 10^10:\n                  else:\n                      if III_S <= balanceOf[address(_r3)]:\n                          if balanceOf[address(_r3)] >= 10^10:\n                              if 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)]):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if 0 < V_S:\n                                  if balanceOf[address(_r3)] < 10^10:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if V_R3 * call.value / call.value == V_R3:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      if not _r4:\n                          if _r5:\n                      else:\n                          if _r4 == caller:\n                              if _r5:\n                          else:\n                              if IV_S > balanceOf[address(_r4)]:\n                                  if _r5:\n          else:\n              if _r2 == caller:\n                  if not _r3:\n                      if not _r4:\n                          if _r5:\n                              if _r5 != caller:\n                      else:\n                          if _r4 == caller:\n                              if _r5:\n                          else:\n                              if IV_S > balanceOf[address(_r4)]:\n                                  if _r5:\n                              else:\n                                  if balanceOf[address(_r4)] < 10^10:\n                  else:\n                      if _r3 == caller:\n                          if not _r4:\n                              if _r5:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                      else:\n                          if III_S > balanceOf[address(_r3)]:\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S <= balanceOf[address(_r4)]:\n                          else:\n                              if balanceOf[address(_r3)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 < V_S:\n                                  if balanceOf[address(_r3)] < 10^10:\n                              else:\n                                  if call.value:\n              else:\n                  if II_S <= balanceOf[address(_r2)]:\n                      if balanceOf[address(_r2)] >= 10^10:\n                          require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if 0 >= V_S:\n                          if call.value:\n                              if V_R2 * call.value / call.value == V_R2:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if stor5[address(_r2)] >= stor5[address(_r2)]:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if balanceOf[address(_r2)] >= 10^10:\n                              if 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)]):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if 0 < IV_S:\n                                  if balanceOf[address(_r2)] < 10^10:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if IV_R2 * call.value / call.value == IV_R2:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      revert\n                  if not _r3:\n                      if not _r4:\n                          if _r5:\n                      else:\n                          if _r4 == caller:\n                              if _r5:\n                          else:\n                              if IV_S > balanceOf[address(_r4)]:\n                                  if _r5:\n                  else:\n                      if _r3 == caller:\n                          if not _r4:\n                              if _r5:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                              else:\n                                  if IV_S <= balanceOf[address(_r4)]:\n                      else:\n                          if III_S <= balanceOf[address(_r3)]:\n                              if balanceOf[address(_r3)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 >= V_S:\n                          else:\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 != caller:\n                                      if IV_S <= balanceOf[address(_r4)]:\n      else:\n          if _r1 == caller:\n              if not _r2:\n                  if not _r3:\n                      if not _r4:\n                          if _r5:\n                              if _r5 != caller:\n                      else:\n                          if _r4 == caller:\n                              if _r5:\n                          else:\n                              if IV_S > balanceOf[address(_r4)]:\n                                  if _r5:\n                              else:\n                                  if balanceOf[address(_r4)] < 10^10:\n                  else:\n                      if _r3 == caller:\n                          if not _r4:\n                              if _r5:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                      else:\n                          if III_S > balanceOf[address(_r3)]:\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S <= balanceOf[address(_r4)]:\n                          else:\n                              if balanceOf[address(_r3)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 < V_S:\n                                  if balanceOf[address(_r3)] < 10^10:\n                              else:\n                                  if call.value:\n              else:\n                  if _r2 == caller:\n                      if not _r3:\n                          if not _r4:\n                              if _r5:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                      else:\n                          if _r3 == caller:\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S <= balanceOf[address(_r4)]:\n                          else:\n                              if III_S <= balanceOf[address(_r3)]:\n                                  if balanceOf[address(_r3)] >= 10^10:\n                                      require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if 0 >= V_S:\n                              else:\n                                  if not _r4:\n                                      if _r5:\n                                  else:\n                                      if _r4 != caller:\n                                          if IV_S <= balanceOf[address(_r4)]:\n                  else:\n                      if II_S > balanceOf[address(_r2)]:\n                          if not _r3:\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S <= balanceOf[address(_r4)]:\n                          else:\n                              if _r3 == caller:\n                                  if not _r4:\n                                      if _r5:\n                                  else:\n                                      if _r4 != caller:\n                                          if IV_S <= balanceOf[address(_r4)]:\n                              else:\n                                  if III_S > balanceOf[address(_r3)]:\n                                      if _r4:\n                                          if _r4 != caller:\n                                  else:\n                                      if balanceOf[address(_r3)] < 10^10:\n                                          if 0 >= V_S:\n                      else:\n                          if balanceOf[address(_r2)] >= 10^10:\n                              require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 0 >= V_S:\n                              if call.value:\n                                  require V_R2 * call.value / call.value == V_R2\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if balanceOf[address(_r2)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 < IV_S:\n                                  if balanceOf[address(_r2)] < 10^10:\n                              else:\n                                  if call.value:\n          else:\n              if I_S <= balanceOf[address(_r1)]:\n                  if balanceOf[address(_r1)] >= 10^10:\n                      require 10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)])\n                      if (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)]) - (10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2) / 10^18 < V_S:\n                          if balanceOf[address(_r1)] < 10^10:\n                      else:\n                          if call.value:\n                  else:\n                      if 0 < V_S:\n                          if balanceOf[address(_r1)] >= 10^10:\n                              require 10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)])\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 0 >= IV_S:\n                              if call.value:\n                                  if IV_R1 * call.value / call.value == IV_R1:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if stor5[address(_r1)] >= stor5[address(_r1)]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if balanceOf[address(_r1)] >= 10^10:\n                                  if 10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)]):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if 0 < III_S:\n                                      if balanceOf[address(_r1)] < 10^10:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if III_R1 * call.value / call.value == III_R1:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      if not call.value:\n                          require stor5[address(_r1)] >= stor5[address(_r1)]\n                      else:\n                          require V_R1 * call.value / call.value == V_R1\n                          require (V_R1 * call.value / 1000) + stor5[address(_r1)] >= stor5[address(_r1)]\n                          stor5[address(_r1)] += V_R1 * call.value / 1000\n                          referralProfit[address(_r1)][caller] += V_R1 * call.value / 1000\n                          stor7[address(_r1)] += V_R1 * call.value / 1000\n              else:\n                  if not _r2:\n                      if not _r3:\n                          if not _r4:\n                              if _r5:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                      else:\n                          if _r3 == caller:\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S <= balanceOf[address(_r4)]:\n                          else:\n                              if III_S <= balanceOf[address(_r3)]:\n                                  if balanceOf[address(_r3)] >= 10^10:\n                                      require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if 0 >= V_S:\n                              else:\n                                  if not _r4:\n                                      if _r5:\n                                  else:\n                                      if _r4 != caller:\n                                          if IV_S <= balanceOf[address(_r4)]:\n                  else:\n                      if _r2 == caller:\n                          if not _r3:\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S <= balanceOf[address(_r4)]:\n                          else:\n                              if _r3 == caller:\n                                  if not _r4:\n                                      if _r5:\n                                  else:\n                                      if _r4 != caller:\n                                          if IV_S <= balanceOf[address(_r4)]:\n                              else:\n                                  if III_S > balanceOf[address(_r3)]:\n                                      if _r4:\n                                          if _r4 != caller:\n                                  else:\n                                      if balanceOf[address(_r3)] < 10^10:\n                                          if 0 >= V_S:\n                      else:\n                          if II_S <= balanceOf[address(_r2)]:\n                              if balanceOf[address(_r2)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 >= V_S:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require V_R2 * call.value / call.value == V_R2\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balanceOf[address(_r2)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 >= IV_S:\n                          else:\n                              if not _r3:\n                                  if not _r4:\n                                      if _r5:\n                                  else:\n                                      if _r4 != caller:\n                                          if IV_S <= balanceOf[address(_r4)]:\n                              else:\n                                  if _r3 == caller:\n                                      if _r4:\n                                          if _r4 != caller:\n                                  else:\n                                      if III_S > balanceOf[address(_r3)]:\n                                          if _r4:\n                                              if _r4 != caller:\n                                      else:\n                                          if balanceOf[address(_r3)] < 10^10:\n                                              if 0 < V_S:\n  else:\n      if not _r1:\n          if not _r2:\n              if not _r3:\n                  if not _r4:\n                      if not _r5:\n                          require 0 <= call.value\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if _r5 == caller:\n                          require 0 <= call.value\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if V_S > balanceOf[address(_r5)]:\n                          require 0 <= call.value\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if _r4 == caller:\n                          if not _r5:\n                              require 0 <= call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _r5 == caller:\n                              require 0 <= call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if V_S <= balanceOf[address(_r5)]:\n                      else:\n                          if IV_S > balanceOf[address(_r4)]:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if balanceOf[address(_r4)] < 10^10:\n              else:\n                  if _r3 == caller:\n                      if not _r4:\n                          if not _r5:\n                              require 0 <= call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _r5 == caller:\n                              require 0 <= call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if V_S <= balanceOf[address(_r5)]:\n                      else:\n                          if _r4 == caller:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if IV_S > balanceOf[address(_r4)]:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if balanceOf[address(_r4)] < 10^10:\n                                      if 0 < V_S:\n                  else:\n                      if III_S > balanceOf[address(_r3)]:\n                          if not _r4:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                                  else:\n                                      if balanceOf[address(_r4)] < 10^10:\n                      else:\n                          if balanceOf[address(_r3)] >= 10^10:\n                              require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 0 >= V_S:\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require V_R3 * call.value / call.value == V_R3\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balanceOf[address(_r3)] < 10^10:\n          else:\n              if _r2 == caller:\n                  if not _r3:\n                      if not _r4:\n                          if not _r5:\n                              require 0 <= call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _r5 == caller:\n                              require 0 <= call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if V_S <= balanceOf[address(_r5)]:\n                      else:\n                          if _r4 == caller:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if IV_S > balanceOf[address(_r4)]:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if balanceOf[address(_r4)] < 10^10:\n                                      if 0 < V_S:\n                  else:\n                      if _r3 == caller:\n                          if not _r4:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                                  else:\n                                      if balanceOf[address(_r4)] < 10^10:\n                      else:\n                          if III_S > balanceOf[address(_r3)]:\n                              if not _r4:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                                      else:\n                                          if balanceOf[address(_r4)] < 10^10:\n                          else:\n                              if balanceOf[address(_r3)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 >= V_S:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require V_R3 * call.value / call.value == V_R3\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balanceOf[address(_r3)] < 10^10:\n                                  if 0 < IV_S:\n              else:\n                  if II_S <= balanceOf[address(_r2)]:\n                      if balanceOf[address(_r2)] >= 10^10:\n                          require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                          if (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)]) - (10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2) / 10^18 < V_S:\n                      else:\n                          if 0 >= V_S:\n                              if not call.value:\n                                  if stor5[address(_r2)] >= stor5[address(_r2)]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if V_R2 * call.value / call.value == V_R2:\n                                      if (V_R2 * call.value / 1000) + stor5[address(_r2)] >= stor5[address(_r2)]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              revert\n                          if balanceOf[address(_r2)] >= 10^10:\n                              require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if 0 >= IV_S:\n                              if not call.value:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require IV_R2 * call.value / call.value == IV_R2\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balanceOf[address(_r2)] < 10^10:\n                  else:\n                      if not _r3:\n                          if not _r4:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                                  else:\n                                      if balanceOf[address(_r4)] < 10^10:\n                      else:\n                          if _r3 == caller:\n                              if not _r4:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                                      else:\n                                          if balanceOf[address(_r4)] < 10^10:\n                          else:\n                              if III_S <= balanceOf[address(_r3)]:\n                                  if balanceOf[address(_r3)] >= 10^10:\n                                      if 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)]):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if 0 < V_S:\n                                          if balanceOf[address(_r3)] < 10^10:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if V_R3 * call.value / call.value == V_R3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  revert\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n      else:\n          if _r1 == caller:\n              if not _r2:\n                  if not _r3:\n                      if not _r4:\n                          if not _r5:\n                              require 0 <= call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _r5 == caller:\n                              require 0 <= call.value\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if V_S <= balanceOf[address(_r5)]:\n                      else:\n                          if _r4 == caller:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if IV_S > balanceOf[address(_r4)]:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if balanceOf[address(_r4)] < 10^10:\n                                      if 0 < V_S:\n                  else:\n                      if _r3 == caller:\n                          if not _r4:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                                  else:\n                                      if balanceOf[address(_r4)] < 10^10:\n                      else:\n                          if III_S > balanceOf[address(_r3)]:\n                              if not _r4:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                                      else:\n                                          if balanceOf[address(_r4)] < 10^10:\n                          else:\n                              if balanceOf[address(_r3)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 >= V_S:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require V_R3 * call.value / call.value == V_R3\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balanceOf[address(_r3)] < 10^10:\n                                  if 0 < IV_S:\n              else:\n                  if _r2 == caller:\n                      if not _r3:\n                          if not _r4:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                                  else:\n                                      if balanceOf[address(_r4)] < 10^10:\n                      else:\n                          if _r3 == caller:\n                              if not _r4:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                                      else:\n                                          if balanceOf[address(_r4)] < 10^10:\n                          else:\n                              if III_S <= balanceOf[address(_r3)]:\n                                  if balanceOf[address(_r3)] >= 10^10:\n                                      if 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)]):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if 0 < V_S:\n                                          if balanceOf[address(_r3)] < 10^10:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if V_R3 * call.value / call.value == V_R3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  revert\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                  else:\n                      if II_S > balanceOf[address(_r2)]:\n                          if not _r3:\n                              if not _r4:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                                      else:\n                                          if balanceOf[address(_r4)] < 10^10:\n                          else:\n                              if _r3 == caller:\n                                  if not _r4:\n                                      if _r5:\n                                  else:\n                                      if _r4 == caller:\n                                          if _r5:\n                                      else:\n                                          if IV_S > balanceOf[address(_r4)]:\n                                              if _r5:\n                              else:\n                                  if III_S > balanceOf[address(_r3)]:\n                                      if not _r4:\n                                          if _r5:\n                                      else:\n                                          if _r4 == caller:\n                                              if _r5:\n                                          else:\n                                              if IV_S <= balanceOf[address(_r4)]:\n                                  else:\n                                      if balanceOf[address(_r3)] >= 10^10:\n                                          require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 0 < V_S:\n                                          if balanceOf[address(_r3)] < 10^10:\n                                      else:\n                                          if call.value:\n                      else:\n                          if balanceOf[address(_r2)] >= 10^10:\n                              require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                          else:\n                              if 0 >= V_S:\n                                  if not call.value:\n                                      require stor5[address(_r2)] >= stor5[address(_r2)]\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require V_R2 * call.value / call.value == V_R2\n                              else:\n                                  if balanceOf[address(_r2)] >= 10^10:\n                                      require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if 0 >= IV_S:\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require IV_R2 * call.value / call.value == IV_R2\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balanceOf[address(_r2)] < 10^10:\n                                      if 0 < III_S:\n          else:\n              if I_S <= balanceOf[address(_r1)]:\n                  if balanceOf[address(_r1)] >= 10^10:\n                      require 10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)])\n                      if (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)]) - (10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2) / 10^18 >= V_S:\n                          if not call.value:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require V_R1 * call.value / call.value == V_R1\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if balanceOf[address(_r1)] < 10^10:\n                          if 0 < IV_S:\n                  else:\n                      if 0 < V_S:\n                          if balanceOf[address(_r1)] >= 10^10:\n                              require 10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)])\n                              if (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)]) - (10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2) / 10^18 < IV_S:\n                          else:\n                              if 0 >= IV_S:\n                                  if not call.value:\n                                      if stor5[address(_r1)] >= stor5[address(_r1)]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if IV_R1 * call.value / call.value == IV_R1:\n                                          if (IV_R1 * call.value / 1000) + stor5[address(_r1)] >= stor5[address(_r1)]:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  revert\n                              if balanceOf[address(_r1)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r1)] + 10^18)^2 + -balanceOf[address(_r1)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r1)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r1)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 >= III_S:\n                                  if not call.value:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require III_R1 * call.value / call.value == III_R1\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balanceOf[address(_r1)] < 10^10:\n                      else:\n                          if not call.value:\n                              require stor5[address(_r1)] >= stor5[address(_r1)]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require V_R1 * call.value / call.value == V_R1\n                          require (V_R1 * call.value / 1000) + stor5[address(_r1)] >= stor5[address(_r1)]\n                          stor5[address(_r1)] += V_R1 * call.value / 1000\n                          referralProfit[address(_r1)][caller] += V_R1 * call.value / 1000\n                          stor7[address(_r1)] += V_R1 * call.value / 1000\n              else:\n                  if not _r2:\n                      if not _r3:\n                          if not _r4:\n                              if not _r5:\n                                  require 0 <= call.value\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if _r5 != caller:\n                          else:\n                              if _r4 == caller:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if IV_S > balanceOf[address(_r4)]:\n                                      if _r5:\n                                  else:\n                                      if balanceOf[address(_r4)] < 10^10:\n                      else:\n                          if _r3 == caller:\n                              if not _r4:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                                      else:\n                                          if balanceOf[address(_r4)] < 10^10:\n                          else:\n                              if III_S <= balanceOf[address(_r3)]:\n                                  if balanceOf[address(_r3)] >= 10^10:\n                                      if 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)]):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if 0 < V_S:\n                                          if balanceOf[address(_r3)] < 10^10:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if V_R3 * call.value / call.value == V_R3:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  revert\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                  else:\n                      if _r2 == caller:\n                          if not _r3:\n                              if not _r4:\n                                  if _r5:\n                                      if _r5 != caller:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                                      else:\n                                          if balanceOf[address(_r4)] < 10^10:\n                          else:\n                              if _r3 == caller:\n                                  if not _r4:\n                                      if _r5:\n                                  else:\n                                      if _r4 == caller:\n                                          if _r5:\n                                      else:\n                                          if IV_S > balanceOf[address(_r4)]:\n                                              if _r5:\n                              else:\n                                  if III_S > balanceOf[address(_r3)]:\n                                      if not _r4:\n                                          if _r5:\n                                      else:\n                                          if _r4 == caller:\n                                              if _r5:\n                                          else:\n                                              if IV_S <= balanceOf[address(_r4)]:\n                                  else:\n                                      if balanceOf[address(_r3)] >= 10^10:\n                                          require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 0 < V_S:\n                                          if balanceOf[address(_r3)] < 10^10:\n                                      else:\n                                          if call.value:\n                      else:\n                          if II_S <= balanceOf[address(_r2)]:\n                              if balanceOf[address(_r2)] >= 10^10:\n                                  require 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)])\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if 0 >= V_S:\n                                  if call.value:\n                                      if V_R2 * call.value / call.value == V_R2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if stor5[address(_r2)] >= stor5[address(_r2)]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if balanceOf[address(_r2)] >= 10^10:\n                                      if 10^10 * (balanceOf[address(_r2)] + 10^18)^2 + -balanceOf[address(_r2)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r2)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r2)]):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if 0 < IV_S:\n                                          if balanceOf[address(_r2)] < 10^10:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not call.value:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if IV_R2 * call.value / call.value == IV_R2:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              revert\n                          if not _r3:\n                              if not _r4:\n                                  if _r5:\n                              else:\n                                  if _r4 == caller:\n                                      if _r5:\n                                  else:\n                                      if IV_S > balanceOf[address(_r4)]:\n                                          if _r5:\n                          else:\n                              if _r3 == caller:\n                                  if not _r4:\n                                      if _r5:\n                                  else:\n                                      if _r4 == caller:\n                                          if _r5:\n                                      else:\n                                          if IV_S <= balanceOf[address(_r4)]:\n                              else:\n                                  if III_S <= balanceOf[address(_r3)]:\n                                      if balanceOf[address(_r3)] >= 10^10:\n                                          require 10^10 * (balanceOf[address(_r3)] + 10^18)^2 + -balanceOf[address(_r3)] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[address(_r3)]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[address(_r3)])\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if 0 >= V_S:\n                                  else:\n                                      if not _r4:\n                                          if _r5:\n                                      else:\n                                          if _r4 != caller:\n                                              if IV_S <= balanceOf[address(_r4)]:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef exit(): # not payable\n  if balanceOf[caller] <= 0:\n      require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n      stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n      stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n      stor5[caller] = 0\n      if not uint8(stor3.field_0):\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n          else:\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n      else:\n          if uint8(block.timestamp - createdAt / 60 / 60 / 24) <= 6:\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              else:\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n          else:\n              if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n              else:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                  else:\n                      require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n            uint256 ethereumWithdrawn=caller)\n      stop\n  require balanceOf[caller] > 0\n  require balanceOf[caller] <= balanceOf[caller]\n  if balanceOf[caller] >= 10^10:\n      require 10^10 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2 <= (25 * 10^6 * 3600 * balanceOf[caller]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[caller])\n      require balanceOf[caller] <= totalSupply\n      totalSupply -= balanceOf[caller]\n      require balanceOf[caller] <= balanceOf[caller]\n      balanceOf[caller] -= balanceOf[caller]\n      stor6[caller] = stor6[caller] - ((25 * 10^6 * 3600 * balanceOf[caller]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[caller]) - (10^10 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18 << 64) - (balanceOf[caller] * stor10)\n      if totalSupply:\n          require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n          if (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n              require 12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 == 12\n              require (12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n              log onTokenSell(\n                    address customerAddress=balanceOf[caller],\n                    uint256 tokensBurned=(25 * 10^6 * 3600 * balanceOf[caller]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[caller]) - (10^10 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18,\n                    uint256 ethereumEarned=block.timestamp,\n                    uint256 timestamp=(12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18),\n                    uint256 price=caller)\n              require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n              stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n              stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n              stor5[caller] = 0\n              if uint8(stor3.field_0):\n                  if uint8(block.timestamp - createdAt / 60 / 60 / 24) > 6:\n                      if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n                          if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                                  require totalSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                              require 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                              if address(stor3.field_8) != caller:\n                                  stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                  stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                              require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n                              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                  require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                                  require totalSupply\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                              if address(stor3.field_8) != caller:\n                                  stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                  stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      ('iszero', ('add', ('stor', ('map', ('mask_shl', 160, 0, 0, 'caller'), ('name', 'stor5', 5))), ('mask_shl', 192, 64, -64, ('add', ('mul', ('stor', ('map', ('mask_shl', 160, 0, 0, 'caller'), ('name', 'balanceOf', 4))), ('stor', ('name', 'stor10', 10))), ('mul', -1, ('stor', ('map', ('mask_shl', 160, 0, 0, 'caller'), ('name', 'stor6', 6))))))))\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          if 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                              if totalSupply:\n                                  if (0 / totalSupply) + stor10 >= stor10:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3:\n                              if (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                  if address(stor3.field_8) != caller:\n                                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                  if totalSupply:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      revert\n                  if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) != caller:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  else:\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) != caller:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n              else:\n                  if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) != caller:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                  else:\n                      if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) != caller:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      log onWithdraw(\n                            address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                            uint256 ethereumWithdrawn=caller)\n          else:\n              require (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n              log onTokenSell(\n                    address customerAddress=balanceOf[caller],\n                    uint256 tokensBurned=(25 * 10^6 * 3600 * balanceOf[caller]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[caller]) - (10^10 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18,\n                    uint256 ethereumEarned=block.timestamp,\n                    uint256 timestamp=(10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18,\n                    uint256 price=caller)\n              require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n              stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n              stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n              stor5[caller] = 0\n              if uint8(stor3.field_0):\n                  if uint8(block.timestamp - createdAt / 60 / 60 / 24) > 6:\n                      if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n                          if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                  if (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                      if totalSupply:\n                                          if ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3:\n                                      if 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                          if address(stor3.field_8) != caller:\n                                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                          if totalSupply:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              revert\n                      else:\n                          if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                              require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n                              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                  if (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                      if totalSupply:\n                                          if ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3:\n                                      if ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                                          if address(stor3.field_8) != caller:\n                                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                          if totalSupply:\n                                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              revert\n                      ('iszero', ('add', ('stor', ('map', ('mask_shl', 160, 0, 0, 'caller'), ('name', 'stor5', 5))), ('mask_shl', 192, 64, -64, ('add', ('mul', ('stor', ('map', ('mask_shl', 160, 0, 0, 'caller'), ('name', 'balanceOf', 4))), ('stor', ('name', 'stor10', 10))), ('mul', -1, ('stor', ('map', ('mask_shl', 160, 0, 0, 'caller'), ('name', 'stor6', 6))))))))\n                      if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) != caller:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                              require totalSupply\n                              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) != caller:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                      else:\n                          if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                              if address(stor3.field_8) != caller:\n                                  stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                                  stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          log onWithdraw(\n                                address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                                uint256 ethereumWithdrawn=caller)\n              else:\n                  if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                      if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) != caller:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          log onWithdraw(\n                                address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                                uint256 ethereumWithdrawn=caller)\n                          stop\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  log onWithdraw(\n                        address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                        uint256 ethereumWithdrawn=caller)\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      log onTokenSell(\n            address customerAddress=balanceOf[caller],\n            uint256 tokensBurned=(25 * 10^6 * 3600 * balanceOf[caller]) + (10^10 * totalSupply + 10^18 / 10^18 * balanceOf[caller]) - (10^10 * (balanceOf[caller] + 10^18)^2 + -balanceOf[caller] - 10^18 / 10^18 / 2) / 10^18,\n            uint256 ethereumEarned=block.timestamp,\n            uint256 timestamp=11 * 10^10,\n            uint256 price=caller)\n      require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n      stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n      stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n      stor5[caller] = 0\n      if not uint8(stor3.field_0):\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n          else:\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n      else:\n          if uint8(block.timestamp - createdAt / 60 / 60 / 24) <= 6:\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              else:\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n          else:\n              if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n              else:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                  else:\n                      require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n            uint256 ethereumWithdrawn=caller)\n      stop\n  require balanceOf[caller] <= totalSupply\n  totalSupply -= balanceOf[caller]\n  require balanceOf[caller] <= balanceOf[caller]\n  balanceOf[caller] -= balanceOf[caller]\n  stor6[caller] += -1 * balanceOf[caller] * stor10\n  if not totalSupply:\n      log onTokenSell(\n            address customerAddress=balanceOf[caller],\n            uint256 tokensBurned=0,\n            uint256 ethereumEarned=block.timestamp,\n            uint256 timestamp=11 * 10^10,\n            uint256 price=caller)\n      require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n      stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n      stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n      stor5[caller] = 0\n      if not uint8(stor3.field_0):\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n          else:\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n      else:\n          if uint8(block.timestamp - createdAt / 60 / 60 / 24) <= 6:\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              else:\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n          else:\n              if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n              else:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require (0 / totalSupply) + stor10 >= stor10\n                              stor10 += 0 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                  else:\n                      require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) == caller:\n                              require totalSupply\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n                          else:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              require totalSupply\n                              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                              stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                              call caller with:\n                                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                                   gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n            uint256 ethereumWithdrawn=caller)\n      stop\n  require 1999999999999999999 * 10^10 <= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + (25000000 * 10^18 * 3600)\n  if (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18:\n      require 12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 == 12\n      require (12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18) >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n      log onTokenSell(\n            address customerAddress=balanceOf[caller],\n            uint256 tokensBurned=0,\n            uint256 ethereumEarned=block.timestamp,\n            uint256 timestamp=(12 * (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 / 100) + ((10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18),\n            uint256 price=caller)\n      require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n      stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n      stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n      stor5[caller] = 0\n      if not uint8(stor3.field_0):\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              log onWithdraw(\n                    address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                    uint256 ethereumWithdrawn=caller)\n              stop\n          require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              require totalSupply\n              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n              stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              log onWithdraw(\n                    address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                    uint256 ethereumWithdrawn=caller)\n              stop\n          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n          if address(stor3.field_8) == caller:\n              require totalSupply\n              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n              stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                   gas 2300 * is_zero(value) wei\n          else:\n              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n              require totalSupply\n              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n              stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                   gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          log onWithdraw(\n                address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                uint256 ethereumWithdrawn=caller)\n      else:\n          if uint8(block.timestamp - createdAt / 60 / 60 / 24) <= 6:\n              if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      log onWithdraw(\n                            address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                            uint256 ethereumWithdrawn=caller)\n                  else:\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              else:\n                  if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      log onWithdraw(\n                            address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                            uint256 ethereumWithdrawn=caller)\n                      stop\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  log onWithdraw(\n                        address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                        uint256 ethereumWithdrawn=caller)\n          else:\n              if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n                  if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) != caller:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          log onWithdraw(\n                                address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                                uint256 ethereumWithdrawn=caller)\n                          stop\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              else:\n                  if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                      require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n                      if stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          if address(stor3.field_8) != caller:\n                              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      require totalSupply\n                      require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                          require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          log onWithdraw(\n                                address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                                uint256 ethereumWithdrawn=caller)\n                          stop\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                      require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                      if address(stor3.field_8) == caller:\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                               gas 2300 * is_zero(value) wei\n                      else:\n                          stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                          require totalSupply\n                          require (0 / totalSupply) + stor10 >= stor10\n                          stor10 += 0 / totalSupply\n                          call caller with:\n                             value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                               gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              log onWithdraw(\n                    address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                    uint256 ethereumWithdrawn=caller)\n  else:\n      require (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18 >= (10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18\n      log onTokenSell(\n            address customerAddress=balanceOf[caller],\n            uint256 tokensBurned=0,\n            uint256 ethereumEarned=block.timestamp,\n            uint256 timestamp=(10000000000 * 10^18 * totalSupply + 10^18 / 10^18) + 7000000000000000001 * 10^10 / 10^18,\n            uint256 price=caller)\n      require (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) + stor5[caller] > 0\n      stor8[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64\n      stor6[caller] += Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller])\n      stor5[caller] = 0\n      if not uint8(stor3.field_0):\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require (0 / totalSupply) + stor10 >= stor10\n                      stor10 += 0 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n          else:\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n                  require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  if address(stor3.field_8) == caller:\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n                  else:\n                      stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                      require totalSupply\n                      require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                      stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                      call caller with:\n                         value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                           gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          log onWithdraw(\n                address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                uint256 ethereumWithdrawn=caller)\n          stop\n      if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              require 0 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              require totalSupply\n              require (0 / totalSupply) + stor10 >= stor10\n              stor10 += 0 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                   gas 2300 * is_zero(value) wei\n          else:\n              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              if address(stor3.field_8) == caller:\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  require totalSupply\n                  require (0 / totalSupply) + stor10 >= stor10\n                  stor10 += 0 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          log onWithdraw(\n                address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                uint256 ethereumWithdrawn=caller)\n          stop\n      if uint8(block.timestamp - createdAt / 60 / 60 / 24) <= 6:\n          require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 27\n          if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n              require (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              require totalSupply\n              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n              stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              log onWithdraw(\n                    address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                    uint256 ethereumWithdrawn=caller)\n              stop\n          require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n          require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n          if address(stor3.field_8) == caller:\n              require totalSupply\n              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n              stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                   gas 2300 * is_zero(value) wei\n          else:\n              stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n              stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n              require totalSupply\n              require ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n              stor10 += (27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n              call caller with:\n                 value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((27 * stor5[caller]) + (27 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                   gas 2300 * is_zero(value) wei\n      else:\n          if uint8(block.timestamp - createdAt / 60 / 60 / 24) >= 30:\n              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  log onWithdraw(\n                        address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                        uint256 ethereumWithdrawn=caller)\n                  stop\n              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n              require 2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              if address(stor3.field_8) == caller:\n                  require totalSupply\n                  require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) + stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  require totalSupply\n                  require ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - (2 * (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n          else:\n              require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)\n              if not stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64):\n                  require (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n                  require totalSupply\n                  require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                       gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  log onWithdraw(\n                        address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n                        uint256 ethereumWithdrawn=caller)\n                  stop\n              require (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) == 3\n              require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) + ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) <= stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)\n              if address(stor3.field_8) == caller:\n                  require totalSupply\n                  require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) wei\n                       gas 2300 * is_zero(value) wei\n              else:\n                  stor5[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  stor7[address(stor3.field_0)] += (3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100\n                  require totalSupply\n                  require ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply) + stor10 >= stor10\n                  stor10 += (stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100 << 64 / totalSupply\n                  call caller with:\n                     value stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) - ((stor5[caller] * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64 * uint8(-uint8(block.timestamp - createdAt / 60 / 60 / 24) + 33)) / 100) - ((3 * stor5[caller]) + (3 * Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64) / 100) wei\n                       gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      log onWithdraw(\n            address customerAddress=(stor5[caller] + (Mask(192, 64, (balanceOf[caller] * stor10) - stor6[caller]) >> 64)),\n            uint256 ethereumWithdrawn=caller)\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 93451 tokens. Please reduce the length of the messages."
}