{
	"address": "0x0c7126b0c7e79c1ea6930bed8499fedb87cd2006",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Based on the decompiled code, here is the Solidity source code:\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract AdContract {\n    \n    uint256[] private _adMessage; \n    uint256[] private _adUrl; \n    uint256 private _purchaseTimestamp; \n    uint256 private _purchaseSeconds; \n    uint256 private _adPriceWeek; \n    uint256 private _adPriceMonth; \n    address private _setAdPriceWeek;\n\n    event NewAd(address indexed buyer, uint256 value, string message, string url, uint256 purchaseSeconds, uint256 purchaseTimestamp);\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function purchaseTimestamp() public view returns (uint256) {\n        return _purchaseTimestamp;\n    }\n\n    function withdraw() public {\n        require(msg.sender == _setAdPriceWeek);\n        _setAdPriceWeek.transfer(address(this).balance);\n    }\n\n    function adPriceMonth() public view returns (uint256) {\n        return _adPriceMonth;\n    }\n\n    function adMessage() public view returns (uint256[]) {\n        return _adMessage;\n    }\n\n    function setAdPriceWeek(uint256 price) public {\n        require(msg.sender == _setAdPriceWeek);\n        _adPriceWeek = price;\n    }\n\n    function getPurchaseTimestampEnds() public view returns (uint256) {\n        require(_purchaseSeconds + _purchaseTimestamp >= _purchaseTimestamp);\n        return _purchaseSeconds + _purchaseTimestamp;\n    }\n\n    function setAdPriceMonth(uint256 price) public {\n        require(msg.sender == _setAdPriceWeek);\n        _adPriceMonth = price;\n    }\n\n    function adUrl() public view returns (uint256[]) {\n        return _adUrl;\n    }\n\n    function adPriceWeek() public view returns (uint256) {\n        return _adPriceWeek;\n    }\n\n    function contractOwner() public view returns (address) {\n        return _setAdPriceWeek;\n    }\n\n    function purchaseSeconds() public view returns (uint256) {\n        return _purchaseSeconds;\n    }\n\n    function updateAd(string memory message, string memory url) public payable {\n        require(msg.value >= _adPriceWeek);\n        require(block.timestamp > _purchaseSeconds + _purchaseTimestamp);\n        if (msg.value < _adPriceMonth) {\n            _purchaseSeconds = 0x93a80;\n        } else {\n            _purchaseSeconds = 0x278d00;\n        }\n        // TODO: Add logic to set _adMessage and _adUrl based on message and url\n        _purchaseTimestamp = block.timestamp;\n        emit NewAd(msg.sender, msg.value, message, url, _purchaseSeconds, _purchaseTimestamp);\n    }\n\n    function() external payable {\n        revert();\n    }\n}\n```\n\nPlease note that this code is a rough re-creation of the given decompiled code and may not compile or work as expected without further modification. The logic to convert the string inputs into `uint256[]` for `_adMessage` and `_adUrl` is not provided in the decompiled code and should be implemented.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711534690,
	"id": "chatcmpl-97KeAVefJ7qWbL67oLzZZmHB1efff",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.04 19:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _adMessage; // STORAGE[0x0]\nuint256[] _adUrl; // STORAGE[0x1]\nuint256 _purchaseTimestamp; // STORAGE[0x2]\nuint256 _purchaseSeconds; // STORAGE[0x3]\nuint256 _adPriceWeek; // STORAGE[0x4]\nuint256 _adPriceMonth; // STORAGE[0x5]\nuint256 _setAdPriceWeek; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nnewAd(address, uint256, string, string, uint256, uint256);\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction purchaseTimestamp() public nonPayable { \n    return _purchaseTimestamp;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    v0 = _setAdPriceWeek.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction adPriceMonth() public nonPayable { \n    return _adPriceMonth;\n}\n\nfunction adMessage() public nonPayable { \n    v0 = new bytes[]((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) {\n        if (31 < (_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _adMessage.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setAdPriceWeek(uint256 varg0) public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    _adPriceWeek = varg0;\n}\n\nfunction getPurchaseTimestampEnds() public nonPayable { \n    assert(_purchaseSeconds + _purchaseTimestamp >= _purchaseTimestamp);\n    return _purchaseSeconds + _purchaseTimestamp;\n}\n\nfunction setAdPriceMonth(uint256 varg0) public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    _adPriceMonth = varg0;\n}\n\nfunction adUrl() public nonPayable { \n    v0 = new bytes[]((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) {\n        if (31 < (_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _adUrl.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction adPriceWeek() public nonPayable { \n    return _adPriceWeek;\n}\n\nfunction contractOwner() public nonPayable { \n    return _setAdPriceWeek;\n}\n\nfunction purchaseSeconds() public nonPayable { \n    return _purchaseSeconds;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction updateAd(string varg0, string varg1) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    require(msg.value >= _adPriceWeek);\n    assert(_purchaseSeconds + _purchaseTimestamp >= _purchaseTimestamp);\n    require(block.timestamp > _purchaseSeconds + _purchaseTimestamp);\n    if (msg.value < _adPriceMonth) {\n        _purchaseSeconds = 0x93a80;\n    } else {\n        _purchaseSeconds = 0x278d00;\n    }\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _adMessage.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _adMessage.length = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + _adMessage.length >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = v8 = v2.data;\n    if (31 < v2.length) {\n        _adUrl.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v8 + v2.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _adUrl.length = v2.length + v2.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _adUrl.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n    _purchaseTimestamp = block.timestamp;\n    v11 = new array[](_adMessage.length);\n    v12 = v13 = v11.data;\n    if (_adMessage.length) {\n        if (31 < _adMessage.length) {\n            do {\n                MEM[v12] = STORAGE[v14];\n                v14 += 1;\n                v12 += 32;\n            } while (v13 + _adMessage.length <= v12);\n        } else {\n            MEM[v13] = _adMessage.length >> 8 << 8;\n        }\n    }\n    v12 = new array[]((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1);\n    v15 = v16 = v12.data;\n    if ((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v15] = STORAGE[v17];\n                v17 += 1;\n                v15 += 32;\n            } while (v16 + ((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) <= v15);\n        } else {\n            MEM[v16] = _adUrl.length >> 8 << 8;\n        }\n    }\n    emit newAd(msg.sender, msg.value, v11, v12, _purchaseSeconds, _purchaseTimestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x77ca11d) {\n            updateAd(string,string);\n        } else if (0x12065fe0 == uint32(function_selector >> 224)) {\n            getBalance();\n        } else if (0x25d3d0e3 == uint32(function_selector >> 224)) {\n            purchaseTimestamp();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x4c4ef642 == uint32(function_selector >> 224)) {\n            adPriceMonth();\n        } else if (0x6418f985 == uint32(function_selector >> 224)) {\n            adMessage();\n        } else if (0x8237b6d0 == uint32(function_selector >> 224)) {\n            setAdPriceWeek(uint256);\n        } else if (0x8cc4ab11 == uint32(function_selector >> 224)) {\n            getPurchaseTimestampEnds();\n        } else if (0xc1496913 == uint32(function_selector >> 224)) {\n            setAdPriceMonth(uint256);\n        } else if (0xc7de6e69 == uint32(function_selector >> 224)) {\n            adUrl();\n        } else if (0xcbe211ec == uint32(function_selector >> 224)) {\n            adPriceWeek();\n        } else if (0xce606ee0 == uint32(function_selector >> 224)) {\n            contractOwner();\n        } else if (0xe2954a14 == uint32(function_selector >> 224)) {\n            purchaseSeconds();\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 19:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _adMessage; // STORAGE[0x0]\nuint256[] _adUrl; // STORAGE[0x1]\nuint256 _purchaseTimestamp; // STORAGE[0x2]\nuint256 _purchaseSeconds; // STORAGE[0x3]\nuint256 _adPriceWeek; // STORAGE[0x4]\nuint256 _adPriceMonth; // STORAGE[0x5]\nuint256 _setAdPriceWeek; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nnewAd(address, uint256, string, string, uint256, uint256);\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction purchaseTimestamp() public nonPayable { \n    return _purchaseTimestamp;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    v0 = _setAdPriceWeek.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction adPriceMonth() public nonPayable { \n    return _adPriceMonth;\n}\n\nfunction adMessage() public nonPayable { \n    v0 = new bytes[]((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) {\n        if (31 < (_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _adMessage.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setAdPriceWeek(uint256 varg0) public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    _adPriceWeek = varg0;\n}\n\nfunction getPurchaseTimestampEnds() public nonPayable { \n    assert(_purchaseSeconds + _purchaseTimestamp >= _purchaseTimestamp);\n    return _purchaseSeconds + _purchaseTimestamp;\n}\n\nfunction setAdPriceMonth(uint256 varg0) public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    _adPriceMonth = varg0;\n}\n\nfunction adUrl() public nonPayable { \n    v0 = new bytes[]((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) {\n        if (31 < (_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _adUrl.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction adPriceWeek() public nonPayable { \n    return _adPriceWeek;\n}\n\nfunction contractOwner() public nonPayable { \n    return _setAdPriceWeek;\n}\n\nfunction purchaseSeconds() public nonPayable { \n    return _purchaseSeconds;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction updateAd(string varg0, string varg1) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    require(msg.value >= _adPriceWeek);\n    assert(_purchaseSeconds + _purchaseTimestamp >= _purchaseTimestamp);\n    require(block.timestamp > _purchaseSeconds + _purchaseTimestamp);\n    if (msg.value < _adPriceMonth) {\n        _purchaseSeconds = 0x93a80;\n    } else {\n        _purchaseSeconds = 0x278d00;\n    }\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _adMessage.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _adMessage.length = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + _adMessage.length >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = v8 = v2.data;\n    if (31 < v2.length) {\n        _adUrl.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v8 + v2.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _adUrl.length = v2.length + v2.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _adUrl.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n    _purchaseTimestamp = block.timestamp;\n    v11 = new array[](_adMessage.length);\n    v12 = v13 = v11.data;\n    if (_adMessage.length) {\n        if (31 < _adMessage.length) {\n            do {\n                MEM[v12] = STORAGE[v14];\n                v14 += 1;\n                v12 += 32;\n            } while (v13 + _adMessage.length <= v12);\n        } else {\n            MEM[v13] = _adMessage.length >> 8 << 8;\n        }\n    }\n    v12 = new array[]((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1);\n    v15 = v16 = v12.data;\n    if ((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v15] = STORAGE[v17];\n                v17 += 1;\n                v15 += 32;\n            } while (v16 + ((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) <= v15);\n        } else {\n            MEM[v16] = _adUrl.length >> 8 << 8;\n        }\n    }\n    emit newAd(msg.sender, msg.value, v11, v12, _purchaseSeconds, _purchaseTimestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x77ca11d) {\n            updateAd(string,string);\n        } else if (0x12065fe0 == uint32(function_selector >> 224)) {\n            getBalance();\n        } else if (0x25d3d0e3 == uint32(function_selector >> 224)) {\n            purchaseTimestamp();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x4c4ef642 == uint32(function_selector >> 224)) {\n            adPriceMonth();\n        } else if (0x6418f985 == uint32(function_selector >> 224)) {\n            adMessage();\n        } else if (0x8237b6d0 == uint32(function_selector >> 224)) {\n            setAdPriceWeek(uint256);\n        } else if (0x8cc4ab11 == uint32(function_selector >> 224)) {\n            getPurchaseTimestampEnds();\n        } else if (0xc1496913 == uint32(function_selector >> 224)) {\n            setAdPriceMonth(uint256);\n        } else if (0xc7de6e69 == uint32(function_selector >> 224)) {\n            adUrl();\n        } else if (0xcbe211ec == uint32(function_selector >> 224)) {\n            adPriceWeek();\n        } else if (0xce606ee0 == uint32(function_selector >> 224)) {\n            contractOwner();\n        } else if (0xe2954a14 == uint32(function_selector >> 224)) {\n            purchaseSeconds();\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 19:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _adMessage; // STORAGE[0x0]\nuint256[] _adUrl; // STORAGE[0x1]\nuint256 _purchaseTimestamp; // STORAGE[0x2]\nuint256 _purchaseSeconds; // STORAGE[0x3]\nuint256 _adPriceWeek; // STORAGE[0x4]\nuint256 _adPriceMonth; // STORAGE[0x5]\nuint256 _setAdPriceWeek; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nnewAd(address, uint256, string, string, uint256, uint256);\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction purchaseTimestamp() public nonPayable { \n    return _purchaseTimestamp;\n}\n\nfunction withdraw() public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    v0 = _setAdPriceWeek.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction adPriceMonth() public nonPayable { \n    return _adPriceMonth;\n}\n\nfunction adMessage() public nonPayable { \n    v0 = new bytes[]((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) {\n        if (31 < (_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_adMessage.length & ~0 + (!(_adMessage.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _adMessage.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setAdPriceWeek(uint256 varg0) public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    _adPriceWeek = varg0;\n}\n\nfunction getPurchaseTimestampEnds() public nonPayable { \n    assert(_purchaseSeconds + _purchaseTimestamp >= _purchaseTimestamp);\n    return _purchaseSeconds + _purchaseTimestamp;\n}\n\nfunction setAdPriceMonth(uint256 varg0) public nonPayable { \n    require(msg.sender == _setAdPriceWeek);\n    _adPriceMonth = varg0;\n}\n\nfunction adUrl() public nonPayable { \n    v0 = new bytes[]((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) {\n        if (31 < (_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_adUrl.length & ~0 + (!(0x1 & _adUrl.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _adUrl.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v7 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v7 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction adPriceWeek() public nonPayable { \n    return _adPriceWeek;\n}\n\nfunction contractOwner() public nonPayable { \n    return _setAdPriceWeek;\n}\n\nfunction purchaseSeconds() public nonPayable { \n    return _purchaseSeconds;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction updateAd(string varg0, string varg1) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v2 = new bytes[](varg1.length);\n    CALLDATACOPY(v2.data, 36 + varg1, varg1.length);\n    require(msg.value >= _adPriceWeek);\n    assert(_purchaseSeconds + _purchaseTimestamp >= _purchaseTimestamp);\n    require(block.timestamp > _purchaseSeconds + _purchaseTimestamp);\n    if (msg.value < _adPriceMonth) {\n        _purchaseSeconds = 0x93a80;\n    } else {\n        _purchaseSeconds = 0x278d00;\n    }\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _adMessage.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _adMessage.length = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + _adMessage.length >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = v8 = v2.data;\n    if (31 < v2.length) {\n        _adUrl.length = 1 + (v2.length + v2.length);\n        if (v2.length) {\n            while (v8 + v2.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _adUrl.length = v2.length + v2.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _adUrl.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n    _purchaseTimestamp = block.timestamp;\n    v11 = new array[](_adMessage.length);\n    v12 = v13 = v11.data;\n    if (_adMessage.length) {\n        if (31 < _adMessage.length) {\n            do {\n                MEM[v12] = STORAGE[v14];\n                v14 += 1;\n                v12 += 32;\n            } while (v13 + _adMessage.length <= v12);\n        } else {\n            MEM[v13] = _adMessage.length >> 8 << 8;\n        }\n    }\n    v12 = new array[]((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1);\n    v15 = v16 = v12.data;\n    if ((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v15] = STORAGE[v17];\n                v17 += 1;\n                v15 += 32;\n            } while (v16 + ((_adUrl.length & (!(_adUrl.length & 0x1) << 8) + ~0) >> 1) <= v15);\n        } else {\n            MEM[v16] = _adUrl.length >> 8 << 8;\n        }\n    }\n    emit newAd(msg.sender, msg.value, v11, v12, _purchaseSeconds, _purchaseTimestamp);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x77ca11d) {\n            updateAd(string,string);\n        } else if (0x12065fe0 == uint32(function_selector >> 224)) {\n            getBalance();\n        } else if (0x25d3d0e3 == uint32(function_selector >> 224)) {\n            purchaseTimestamp();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x4c4ef642 == uint32(function_selector >> 224)) {\n            adPriceMonth();\n        } else if (0x6418f985 == uint32(function_selector >> 224)) {\n            adMessage();\n        } else if (0x8237b6d0 == uint32(function_selector >> 224)) {\n            setAdPriceWeek(uint256);\n        } else if (0x8cc4ab11 == uint32(function_selector >> 224)) {\n            getPurchaseTimestampEnds();\n        } else if (0xc1496913 == uint32(function_selector >> 224)) {\n            setAdPriceMonth(uint256);\n        } else if (0xc7de6e69 == uint32(function_selector >> 224)) {\n            adUrl();\n        } else if (0xcbe211ec == uint32(function_selector >> 224)) {\n            adPriceWeek();\n        } else if (0xce606ee0 == uint32(function_selector >> 224)) {\n            contractOwner();\n        } else if (0xe2954a14 == uint32(function_selector >> 224)) {\n            purchaseSeconds();\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 101.44526791572571,
	"usage": {
		"completion_tokens": 652,
		"prompt_tokens": 2436,
		"total_tokens": 3088
	}
}