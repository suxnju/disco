{
	"address": "0xeac3cf28cc9bf82915804325ef9e05ac65de79e3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code based on the provided decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract ContractLibrary {\n    mapping (address => uint256) public _balanceOf;\n    uint256 public _totalSupply;\n    mapping (address => uint256) public _allowance;\n    uint256 public _incomeFees;\n    address public _owner;\n    bool public _paused;\n    address public _cfoAddress;\n\n    event Buy(address indexed buyer, uint256 amount, uint256 total);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Unpause();\n    event Pause();\n    event Sell(address indexed seller, uint256 amount, uint256 total);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        _owner = msg.sender;\n        _cfoAddress = msg.sender;\n    }\n\n    function fallback() public payable {\n        require(!_paused);\n        require(msg.value > 0);\n        uint256 v0 = 10000 * msg.value;\n        _totalSupply += v0;\n        _balanceOf[msg.sender] += v0;\n        emit Buy(msg.sender, msg.value, v0);\n        emit Transfer(address(0), msg.sender, v0);\n    }\n\n    function cfoAddress() public view returns (address) {\n        return _cfoAddress;\n    }\n\n    function name() public pure returns (string memory) {\n        return \"BLOCK JOY\";\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(_allowance[from] >= value);\n        require(_balanceOf[from] >= value);\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function incomeFees() public view returns (uint256) {\n        return _incomeFees;\n    }\n\n    function unpause() public {\n        require(_owner == msg.sender);\n        require(_paused);\n        _paused = false;\n        emit Unpause();\n    }\n\n    function exchangeRatio() public pure returns (uint256) {\n        return 10000;\n    }\n\n    function setCFO(address newCFO) public {\n        require(_owner == msg.sender);\n        require(newCFO != address(0));\n        _cfoAddress = newCFO;\n    }\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    function withdrawFees(uint256 amount) public {\n        require(_cfoAddress == msg.sender);\n        require(amount <= _incomeFees);\n        _incomeFees -= amount;\n        payable(_cfoAddress).transfer(amount);\n    }\n\n    function sellCut() public pure returns (uint256) {\n        return 1000;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function pause() public {\n        require(_owner == msg.sender);\n        require(!_paused);\n        _paused = true;\n        emit Pause();\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"JOY\";\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(_balanceOf[msg.sender] >= value);\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function increaseApproval(address spender, uint256 addedValue) public returns (bool) {\n        _allowance[spender] += addedValue;\n        emit Approval(msg.sender, spender, _allowance[spender]);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[spender];\n    }\n\n    function sell(uint256 amount) public {\n        require(amount > 0);\n        require(amount <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= amount;\n        _totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n        emit Sell(msg.sender, amount, amount - amount / 1000);\n        _incomeFees += amount / 1000;\n        payable(msg.sender).transfer(amount - amount / 1000);\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(_owner == msg.sender);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n```\n\nNote: In Solidity, there is no fallback function that is called when no other function matches the call data. Instead, the fallback function is called in case the contract was sent Ether without any data. If the contract does not have a fallback function, it will throw an exception. In this case, I used the fallback function to emulate the described behavior.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456597,
	"id": "chatcmpl-8R2sHyD71Hg4M2pS7hbOecsafDdFt",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 07:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x3]\nuint256 _incomeFees; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _cfoAddress; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nBuy(address, uint256, uint256);\nApproval(address, address, uint256);\nUnpause();\nPause();\nSell(address, uint256, uint256);\nOwnershipTransferred(address, address);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    require(!_paused);\n    require(msg.value > 0);\n    if (msg.value) {\n        v0 = v1 = 10000 * msg.value;\n        assert(msg.value);\n        assert(v1 / msg.value == 10000);\n    } else {\n        v0 = v2 = 0;\n    }\n    v3 = _SafeAdd(v0, _totalSupply);\n    _totalSupply = v3;\n    v4 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v4;\n    emit Buy(msg.sender, msg.value, v0);\n    emit Transfer(0, msg.sender, v0);\n}\n\nfunction cfoAddress() public nonPayable { \n    return _cfoAddress;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (9) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & 'BLOCK JOY';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = _SafeAdd(varg1, _allowance[varg0]);\n    _allowance[varg0] = v1;\n    emit Approval(msg.sender, varg0, v1);\n    v2 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v3.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v4 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.call(v3.data).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x92a(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction incomeFees() public nonPayable { \n    return _incomeFees;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction exchangeRatio() public nonPayable { \n    return 10000;\n}\n\nfunction setCFO(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _cfoAddress = varg0;\n}\n\nfunction approve(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = 0;\n    while (v1 < v0.length) {\n        MEM[v1 + v2.data] = MEM[v0.data + v1];\n        v1 += 32;\n    }\n    v3 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    v4 = varg0.call(v2.data).gas(msg.gas - 25710);\n    require(v4);\n    return 1;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction withdrawFees(uint256 varg0) public nonPayable { \n    require(_cfoAddress == msg.sender);\n    require(varg0 <= _incomeFees);\n    assert(varg0 <= _incomeFees);\n    _incomeFees = _incomeFees - varg0;\n    v0 = _cfoAddress.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xc3c(varg1, varg0);\n    return v0;\n}\n\nfunction sellCut() public nonPayable { \n    return 1000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = 0xc3c(varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg0.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4a4f590000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xe4e(varg1, varg0);\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg3 + 36, (?).length);\n    require(varg1 != address(this));\n    v1 = 0x92a(varg2, varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg1.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = 0xe4e(varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg0.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _allowance[varg0]);\n    _allowance[varg0] = v0;\n    emit Approval(msg.sender, varg0, v0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(varg0 > 0);\n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Transfer(msg.sender, 0, varg0);\n    assert(10000);\n    assert(1000);\n    assert(varg0 / 1000 <= varg0);\n    emit Sell(msg.sender, varg0, varg0 - varg0 / 1000);\n    if (varg0 / 1000 > 0) {\n        v0 = _SafeAdd(varg0 / 1000, _incomeFees);\n        _incomeFees = v0;\n    }\n    if (varg0 - varg0 / 1000 > 0) {\n        v1 = msg.sender.call().value(varg0 - varg0 / 1000).gas(2300 * !(varg0 - varg0 / 1000));\n        require(v1);\n    }\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x92a(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v2 = address(varg2);\n    assert(varg0 <= _balanceOf[v2]);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v2] - varg0;\n    v4 = address(varg1);\n    v5 = _SafeAdd(varg0, _balanceOf[v4]);\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    v7 = address(varg2);\n    assert(varg0 <= _allowance[msg.sender]);\n    v8 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    emit Transfer(v8, address(varg1), varg0);\n    return 1;\n}\n\nfunction 0xc3c(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    if (varg0 <= _allowance[v0]) {\n        assert(varg0 <= _allowance[v0]);\n        v1 = address(varg1);\n        _allowance[v1] = _allowance[v0] - varg0;\n    } else {\n        v2 = address(varg1);\n        _allowance[v2] = 0;\n    }\n    v3 = address(varg1);\n    emit Approval(msg.sender, v3, _allowance[v3]);\n    return 1;\n}\n\nfunction 0xe4e(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = address(varg1);\n    v1 = _SafeAdd(varg0, _balanceOf[v0]);\n    v2 = address(varg1);\n    _balanceOf[v2] = v1;\n    emit Transfer(msg.sender, v2, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x519ce79) {\n            cfoAddress();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x16ca3b63 == function_selector) {\n            increaseApproval(address,uint256,bytes);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3318d4a5 == function_selector) {\n            incomeFees();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x4006ccc5 == function_selector) {\n            exchangeRatio();\n        } else if (0x4e0a3379 == function_selector) {\n            setCFO(address);\n        } else if (0x5c17f9f4 == function_selector) {\n            approve(address,uint256,bytes);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x5e318e07 == function_selector) {\n            withdrawFees(uint256);\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x68f169e1 == function_selector) {\n            sellCut();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7272ad49 == function_selector) {\n            decreaseApproval(address,uint256,bytes);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab67aa58 == function_selector) {\n            transferFrom(address,address,uint256,bytes);\n        } else if (0xbe45fd62 == function_selector) {\n            transfer(address,uint256,bytes);\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 07:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x3]\nuint256 _incomeFees; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _cfoAddress; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nBuy(address, uint256, uint256);\nApproval(address, address, uint256);\nUnpause();\nPause();\nSell(address, uint256, uint256);\nOwnershipTransferred(address, address);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    require(!_paused);\n    require(msg.value > 0);\n    if (msg.value) {\n        v0 = v1 = 10000 * msg.value;\n        assert(msg.value);\n        assert(v1 / msg.value == 10000);\n    } else {\n        v0 = v2 = 0;\n    }\n    v3 = _SafeAdd(v0, _totalSupply);\n    _totalSupply = v3;\n    v4 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v4;\n    emit Buy(msg.sender, msg.value, v0);\n    emit Transfer(0, msg.sender, v0);\n}\n\nfunction cfoAddress() public nonPayable { \n    return _cfoAddress;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (9) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & 'BLOCK JOY';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = _SafeAdd(varg1, _allowance[varg0]);\n    _allowance[varg0] = v1;\n    emit Approval(msg.sender, varg0, v1);\n    v2 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v3.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v4 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.call(v3.data).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x92a(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction incomeFees() public nonPayable { \n    return _incomeFees;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction exchangeRatio() public nonPayable { \n    return 10000;\n}\n\nfunction setCFO(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _cfoAddress = varg0;\n}\n\nfunction approve(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = 0;\n    while (v1 < v0.length) {\n        MEM[v1 + v2.data] = MEM[v0.data + v1];\n        v1 += 32;\n    }\n    v3 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    v4 = varg0.call(v2.data).gas(msg.gas - 25710);\n    require(v4);\n    return 1;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction withdrawFees(uint256 varg0) public nonPayable { \n    require(_cfoAddress == msg.sender);\n    require(varg0 <= _incomeFees);\n    assert(varg0 <= _incomeFees);\n    _incomeFees = _incomeFees - varg0;\n    v0 = _cfoAddress.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xc3c(varg1, varg0);\n    return v0;\n}\n\nfunction sellCut() public nonPayable { \n    return 1000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = 0xc3c(varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg0.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4a4f590000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xe4e(varg1, varg0);\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg3 + 36, (?).length);\n    require(varg1 != address(this));\n    v1 = 0x92a(varg2, varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg1.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = 0xe4e(varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg0.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _allowance[varg0]);\n    _allowance[varg0] = v0;\n    emit Approval(msg.sender, varg0, v0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(varg0 > 0);\n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Transfer(msg.sender, 0, varg0);\n    assert(10000);\n    assert(1000);\n    assert(varg0 / 1000 <= varg0);\n    emit Sell(msg.sender, varg0, varg0 - varg0 / 1000);\n    if (varg0 / 1000 > 0) {\n        v0 = _SafeAdd(varg0 / 1000, _incomeFees);\n        _incomeFees = v0;\n    }\n    if (varg0 - varg0 / 1000 > 0) {\n        v1 = msg.sender.call().value(varg0 - varg0 / 1000).gas(2300 * !(varg0 - varg0 / 1000));\n        require(v1);\n    }\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x92a(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v2 = address(varg2);\n    assert(varg0 <= _balanceOf[v2]);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v2] - varg0;\n    v4 = address(varg1);\n    v5 = _SafeAdd(varg0, _balanceOf[v4]);\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    v7 = address(varg2);\n    assert(varg0 <= _allowance[msg.sender]);\n    v8 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    emit Transfer(v8, address(varg1), varg0);\n    return 1;\n}\n\nfunction 0xc3c(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    if (varg0 <= _allowance[v0]) {\n        assert(varg0 <= _allowance[v0]);\n        v1 = address(varg1);\n        _allowance[v1] = _allowance[v0] - varg0;\n    } else {\n        v2 = address(varg1);\n        _allowance[v2] = 0;\n    }\n    v3 = address(varg1);\n    emit Approval(msg.sender, v3, _allowance[v3]);\n    return 1;\n}\n\nfunction 0xe4e(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = address(varg1);\n    v1 = _SafeAdd(varg0, _balanceOf[v0]);\n    v2 = address(varg1);\n    _balanceOf[v2] = v1;\n    emit Transfer(msg.sender, v2, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x519ce79) {\n            cfoAddress();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x16ca3b63 == function_selector) {\n            increaseApproval(address,uint256,bytes);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3318d4a5 == function_selector) {\n            incomeFees();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x4006ccc5 == function_selector) {\n            exchangeRatio();\n        } else if (0x4e0a3379 == function_selector) {\n            setCFO(address);\n        } else if (0x5c17f9f4 == function_selector) {\n            approve(address,uint256,bytes);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x5e318e07 == function_selector) {\n            withdrawFees(uint256);\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x68f169e1 == function_selector) {\n            sellCut();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7272ad49 == function_selector) {\n            decreaseApproval(address,uint256,bytes);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab67aa58 == function_selector) {\n            transferFrom(address,address,uint256,bytes);\n        } else if (0xbe45fd62 == function_selector) {\n            transfer(address,uint256,bytes);\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 07:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x3]\nuint256 _incomeFees; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _cfoAddress; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nBuy(address, uint256, uint256);\nApproval(address, address, uint256);\nUnpause();\nPause();\nSell(address, uint256, uint256);\nOwnershipTransferred(address, address);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    require(!_paused);\n    require(msg.value > 0);\n    if (msg.value) {\n        v0 = v1 = 10000 * msg.value;\n        assert(msg.value);\n        assert(v1 / msg.value == 10000);\n    } else {\n        v0 = v2 = 0;\n    }\n    v3 = _SafeAdd(v0, _totalSupply);\n    _totalSupply = v3;\n    v4 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v4;\n    emit Buy(msg.sender, msg.value, v0);\n    emit Transfer(0, msg.sender, v0);\n}\n\nfunction cfoAddress() public nonPayable { \n    return _cfoAddress;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (9) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffff & 'BLOCK JOY';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = _SafeAdd(varg1, _allowance[varg0]);\n    _allowance[varg0] = v1;\n    emit Approval(msg.sender, varg0, v1);\n    v2 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v3.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v4 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.call(v3.data).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x92a(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction incomeFees() public nonPayable { \n    return _incomeFees;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction exchangeRatio() public nonPayable { \n    return 10000;\n}\n\nfunction setCFO(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    _cfoAddress = varg0;\n}\n\nfunction approve(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = 0;\n    while (v1 < v0.length) {\n        MEM[v1 + v2.data] = MEM[v0.data + v1];\n        v1 += 32;\n    }\n    v3 = v0.length + v2.data;\n    if (0x1f & v0.length) {\n        MEM[v3 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v3 - (0x1f & v0.length)];\n    }\n    v4 = varg0.call(v2.data).gas(msg.gas - 25710);\n    require(v4);\n    return 1;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction withdrawFees(uint256 varg0) public nonPayable { \n    require(_cfoAddress == msg.sender);\n    require(varg0 <= _incomeFees);\n    assert(varg0 <= _incomeFees);\n    _incomeFees = _incomeFees - varg0;\n    v0 = _cfoAddress.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xc3c(varg1, varg0);\n    return v0;\n}\n\nfunction sellCut() public nonPayable { \n    return 1000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = 0xc3c(varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg0.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4a4f590000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xe4e(varg1, varg0);\n    return v0;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2, bytes varg3) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg3 + 36, (?).length);\n    require(varg1 != address(this));\n    v1 = 0x92a(varg2, varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg1.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    require(varg0 != address(this));\n    v1 = 0xe4e(varg1, varg0);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        MEM[v2 + v4.data] = MEM[v0.data + v2];\n        v2 += 32;\n    }\n    v5 = v6 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v6 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v6 - (0x1f & v0.length)];\n    }\n    v7 = varg0.call(v4.data).gas(msg.gas - 25710);\n    require(v7);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _allowance[varg0]);\n    _allowance[varg0] = v0;\n    emit Approval(msg.sender, varg0, v0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(varg0 > 0);\n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Transfer(msg.sender, 0, varg0);\n    assert(10000);\n    assert(1000);\n    assert(varg0 / 1000 <= varg0);\n    emit Sell(msg.sender, varg0, varg0 - varg0 / 1000);\n    if (varg0 / 1000 > 0) {\n        v0 = _SafeAdd(varg0 / 1000, _incomeFees);\n        _incomeFees = v0;\n    }\n    if (varg0 - varg0 / 1000 > 0) {\n        v1 = msg.sender.call().value(varg0 - varg0 / 1000).gas(2300 * !(varg0 - varg0 / 1000));\n        require(v1);\n    }\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x92a(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg2);\n    require(varg0 <= _allowance[msg.sender]);\n    v2 = address(varg2);\n    assert(varg0 <= _balanceOf[v2]);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v2] - varg0;\n    v4 = address(varg1);\n    v5 = _SafeAdd(varg0, _balanceOf[v4]);\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    v7 = address(varg2);\n    assert(varg0 <= _allowance[msg.sender]);\n    v8 = address(varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n    emit Transfer(v8, address(varg1), varg0);\n    return 1;\n}\n\nfunction 0xc3c(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    if (varg0 <= _allowance[v0]) {\n        assert(varg0 <= _allowance[v0]);\n        v1 = address(varg1);\n        _allowance[v1] = _allowance[v0] - varg0;\n    } else {\n        v2 = address(varg1);\n        _allowance[v2] = 0;\n    }\n    v3 = address(varg1);\n    emit Approval(msg.sender, v3, _allowance[v3]);\n    return 1;\n}\n\nfunction 0xe4e(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = address(varg1);\n    v1 = _SafeAdd(varg0, _balanceOf[v0]);\n    v2 = address(varg1);\n    _balanceOf[v2] = v1;\n    emit Transfer(msg.sender, v2, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x519ce79) {\n            cfoAddress();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x16ca3b63 == function_selector) {\n            increaseApproval(address,uint256,bytes);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3318d4a5 == function_selector) {\n            incomeFees();\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x4006ccc5 == function_selector) {\n            exchangeRatio();\n        } else if (0x4e0a3379 == function_selector) {\n            setCFO(address);\n        } else if (0x5c17f9f4 == function_selector) {\n            approve(address,uint256,bytes);\n        } else if (0x5c975abb == function_selector) {\n            paused();\n        } else if (0x5e318e07 == function_selector) {\n            withdrawFees(uint256);\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x68f169e1 == function_selector) {\n            sellCut();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7272ad49 == function_selector) {\n            decreaseApproval(address,uint256,bytes);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab67aa58 == function_selector) {\n            transferFrom(address,address,uint256,bytes);\n        } else if (0xbe45fd62 == function_selector) {\n            transfer(address,uint256,bytes);\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 71.98711395263672,
	"usage": {
		"completion_tokens": 1146,
		"prompt_tokens": 4077,
		"total_tokens": 5223
	}
}