{
	"address": "0xaa1ac1c849df066704f76b190af24724f6fa247c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "With the provided decompiled code, the Solidity contract can be reconstructed as follows:\n\n```solidity\npragma solidity ^0.8.6;\n\ncontract SwapContract {\n    uint256 private _minSwapAmount;\n    uint256 private _maxSwapAmount;\n    uint256 private _paymentDetailsHash;\n    address private _owner;\n    address private _swapsContract;\n    uint8 private _isActive;\n    uint16 private _aSSET_TYPE;\n\n    event ReceivedFunds(address, uint256);\n    event IsActiveChanged(bool);\n    event OwnerChanged(address, address);\n    event LimitsChanged(uint256, uint256);\n    event SwapsContractChanged(address, address);\n\n    function returnSwap(address varg0, address varg1, bytes memory varg2, bytes32 varg3) public {\n        require(msg.sender == _owner, 'only the owner can call this');\n    }\n\n    function isActive() public view returns (bool) {\n        return _isActive == 1;\n    }\n\n    function setIsActive(bool varg0) public {\n        require(msg.sender == _owner, 'only the owner can call this');\n        _isActive = varg0 ? 1 : 0;\n        emit IsActiveChanged(varg0);\n    }\n\n    function withdrawAllFunds(address payable varg0) public {\n        require(msg.sender == _owner, 'only the owner can call this');\n        varg0.transfer(address(this).balance);\n    }\n\n    function minSwapAmount() public view returns (uint256) {\n        return _minSwapAmount;\n    }\n\n    function paymentDetailsHash() public view returns (uint256) {\n        return _paymentDetailsHash;\n    }\n\n    function availableFunds() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function sendFundsToSwap(uint256 varg0) public {\n        require(_isActive == 1, 'contract is stopped');\n        require(msg.sender == _swapsContract, 'only the swaps contract can call this');\n        require(varg0 >= _minSwapAmount && varg0 <= _maxSwapAmount, 'amount outside swap limits');\n        payable(_swapsContract).transfer(varg0);\n    }\n\n    function ASSET_TYPE() public view returns (uint16) {\n        return _aSSET_TYPE;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function changeOwner(address varg0) public {\n        require(msg.sender == _owner, 'only the owner can call this');\n        _owner = varg0;\n        emit OwnerChanged(msg.sender, varg0);\n    }\n\n    function withdrawFunds(address payable varg0, uint256 varg1) public {\n        require(msg.sender == _owner, 'only the owner can call this');\n        varg0.transfer(varg1);\n    }\n\n    function setLimits(uint256 varg0, uint256 varg1) public {\n        require(msg.sender == _owner, 'only the owner can call this');\n        _minSwapAmount = varg0;\n        _maxSwapAmount = varg1;\n        emit LimitsChanged(varg0, varg1);\n    }\n\n    function maxSwapAmount() public view returns (uint256) {\n        return _maxSwapAmount;\n    }\n\n    function setSwapsContract(address varg0) public {\n        require(msg.sender == _owner, 'only the owner can call this');\n        _swapsContract = varg0;\n        emit SwapsContractChanged(_swapsContract, varg0);\n    }\n\n    function swapsContract() public view returns (address) {\n        return _swapsContract;\n    }\n\n    function releaseSwap(address varg0, address varg1, bytes memory varg2, bytes32 varg3) public {\n        require(msg.sender == _owner, 'only the owner can call this');\n    }\n\n    fallback() external payable {\n        if (msg.sender != _swapsContract) {\n            emit ReceivedFunds(msg.sender, msg.value);\n        }\n    }\n}\n```\nPlease note that the original contract might have additional checks or functionality that aren't fully captured by the decompiled code. The reconstructed contract is a best effort attempt to mimic the functionality based on the provided decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457565,
	"id": "chatcmpl-8R37t63Z2x9zZhRh7m9X0O1qJhp3E",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 19:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minSwapAmount; // STORAGE[0x2]\nuint256 _maxSwapAmount; // STORAGE[0x3]\nuint256 _paymentDetailsHash; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _swapsContract; // STORAGE[0x1] bytes 0 to 19\nuint8 _isActive; // STORAGE[0x0] bytes 20 to 20\nuint16 _aSSET_TYPE; // STORAGE[0x0] bytes 23 to 24\n\n// Events\nReceivedFunds(address, uint256);\nIsActiveChanged(bool);\nOwnerChanged(address, address);\nLimitsChanged(uint256, uint256);\nSwapsContractChanged(address, address);\n\nfunction returnSwap(address varg0, address varg1, bytes varg2, bytes32 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg2.length > 0x100000000) | (36 + varg2 + varg2.length > 4 + (msg.data.length - 4))));\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = new array[](varg2.length);\n    MEM[v0.data + varg2.length] = 0;\n    require(_swapsContract.code.size);\n    v1 = _swapsContract.returnFunds(this, varg0, varg1, v0, varg3).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction isActive() public nonPayable { \n    return _isActive;\n}\n\nfunction setIsActive(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    if (varg0 != _isActive) {\n        _isActive = varg0;\n        emit IsActiveChanged(varg0);\n    }\n}\n\nfunction withdrawAllFunds(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = varg0.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction minSwapAmount() public nonPayable { \n    return _minSwapAmount;\n}\n\nfunction paymentDetailsHash() public nonPayable { \n    return _paymentDetailsHash;\n}\n\nfunction availableFunds() public nonPayable { \n    return this.balance;\n}\n\nfunction sendFundsToSwap(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_isActive, 'contract is stopped');\n    require(msg.sender == _swapsContract, 'only the swaps contract can call this');\n    v0 = v1 = varg0 >= _minSwapAmount;\n    if (v1) {\n        v0 = v2 = varg0 <= _maxSwapAmount;\n    }\n    require(v0, 'amount outside swap limits');\n    v3 = _swapsContract.call().value(varg0).gas(2300 * !varg0);\n    require(v3); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction ASSET_TYPE() public nonPayable { \n    return _aSSET_TYPE;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    _owner = varg0;\n    emit OwnerChanged(msg.sender, varg0);\n}\n\nfunction withdrawFunds(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction setLimits(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(varg0 <= varg1, 'min limit over max limit');\n    require(varg1 <= 0x1000000000000000000000000000000000000000000000000000000000000, 'maxAmount too high');\n    _minSwapAmount = varg0;\n    _maxSwapAmount = varg1;\n    emit LimitsChanged(varg0, varg1);\n}\n\nfunction maxSwapAmount() public nonPayable { \n    return _maxSwapAmount;\n}\n\nfunction setSwapsContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(varg0, 'null swaps contract address');\n    require(varg0.code.size);\n    v0, v1 = varg0.ASSET_TYPE().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(uint16(v1) == _aSSET_TYPE, \"pool asset type doesn't match swap contract\");\n    _swapsContract = varg0;\n    emit SwapsContractChanged(_swapsContract, varg0);\n}\n\nfunction swapsContract() public nonPayable { \n    return _swapsContract;\n}\n\nfunction releaseSwap(address varg0, address varg1, bytes varg2, bytes32 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg2.length > 0x100000000) | (36 + varg2 + varg2.length > 4 + (msg.data.length - 4))));\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = new array[](varg2.length);\n    MEM[v0.data + varg2.length] = 0;\n    require(_swapsContract.code.size);\n    v1 = _swapsContract.release(this, varg0, varg1, v0, varg3).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction fallback() public payable { \n    require(!msg.data.length, 'invalid pool function called');\n    if (msg.sender != _swapsContract) {\n        emit ReceivedFunds(msg.sender, msg.value);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8815eb39 > function_selector >> 224) {\n            if (0x338246e2 > function_selector >> 224) {\n                if (0x1952e39c == function_selector >> 224) {\n                    returnSwap(address,address,bytes,bytes32);\n                } else if (0x22f3e2d4 == function_selector >> 224) {\n                    isActive();\n                } else if (0x2750fc78 == function_selector >> 224) {\n                    setIsActive(bool);\n                } else if (0x32dee40b == function_selector >> 224) {\n                    withdrawAllFunds(address);\n                }\n            } else if (0x338246e2 == function_selector >> 224) {\n                minSwapAmount();\n            } else if (0x428eecf0 == function_selector >> 224) {\n                paymentDetailsHash();\n            } else if (0x46fcff4c == function_selector >> 224) {\n                availableFunds();\n            } else if (0x81fd3f0b == function_selector >> 224) {\n                sendFundsToSwap(uint256);\n            }\n        } else if (0xc4590d3f > function_selector >> 224) {\n            if (0x8815eb39 == function_selector >> 224) {\n                ASSET_TYPE();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0xa6f9dae1 == function_selector >> 224) {\n                changeOwner(address);\n            } else if (0xc1075329 == function_selector >> 224) {\n                withdrawFunds(address,uint256);\n            }\n        } else if (0xc4590d3f == function_selector >> 224) {\n            setLimits(uint256,uint256);\n        } else if (0xcce987d4 == function_selector >> 224) {\n            maxSwapAmount();\n        } else if (0xd950f365 == function_selector >> 224) {\n            setSwapsContract(address);\n        } else if (0xfa5d5429 == function_selector >> 224) {\n            swapsContract();\n        } else if (0xfdc5d522 == function_selector >> 224) {\n            releaseSwap(address,address,bytes,bytes32);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 19:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minSwapAmount; // STORAGE[0x2]\nuint256 _maxSwapAmount; // STORAGE[0x3]\nuint256 _paymentDetailsHash; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _swapsContract; // STORAGE[0x1] bytes 0 to 19\nuint8 _isActive; // STORAGE[0x0] bytes 20 to 20\nuint16 _aSSET_TYPE; // STORAGE[0x0] bytes 23 to 24\n\n// Events\nReceivedFunds(address, uint256);\nIsActiveChanged(bool);\nOwnerChanged(address, address);\nLimitsChanged(uint256, uint256);\nSwapsContractChanged(address, address);\n\nfunction returnSwap(address varg0, address varg1, bytes varg2, bytes32 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg2.length > 0x100000000) | (36 + varg2 + varg2.length > 4 + (msg.data.length - 4))));\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = new array[](varg2.length);\n    MEM[v0.data + varg2.length] = 0;\n    require(_swapsContract.code.size);\n    v1 = _swapsContract.returnFunds(this, varg0, varg1, v0, varg3).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction isActive() public nonPayable { \n    return _isActive;\n}\n\nfunction setIsActive(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    if (varg0 != _isActive) {\n        _isActive = varg0;\n        emit IsActiveChanged(varg0);\n    }\n}\n\nfunction withdrawAllFunds(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = varg0.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction minSwapAmount() public nonPayable { \n    return _minSwapAmount;\n}\n\nfunction paymentDetailsHash() public nonPayable { \n    return _paymentDetailsHash;\n}\n\nfunction availableFunds() public nonPayable { \n    return this.balance;\n}\n\nfunction sendFundsToSwap(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_isActive, 'contract is stopped');\n    require(msg.sender == _swapsContract, 'only the swaps contract can call this');\n    v0 = v1 = varg0 >= _minSwapAmount;\n    if (v1) {\n        v0 = v2 = varg0 <= _maxSwapAmount;\n    }\n    require(v0, 'amount outside swap limits');\n    v3 = _swapsContract.call().value(varg0).gas(2300 * !varg0);\n    require(v3); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction ASSET_TYPE() public nonPayable { \n    return _aSSET_TYPE;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    _owner = varg0;\n    emit OwnerChanged(msg.sender, varg0);\n}\n\nfunction withdrawFunds(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction setLimits(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(varg0 <= varg1, 'min limit over max limit');\n    require(varg1 <= 0x1000000000000000000000000000000000000000000000000000000000000, 'maxAmount too high');\n    _minSwapAmount = varg0;\n    _maxSwapAmount = varg1;\n    emit LimitsChanged(varg0, varg1);\n}\n\nfunction maxSwapAmount() public nonPayable { \n    return _maxSwapAmount;\n}\n\nfunction setSwapsContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(varg0, 'null swaps contract address');\n    require(varg0.code.size);\n    v0, v1 = varg0.ASSET_TYPE().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(uint16(v1) == _aSSET_TYPE, \"pool asset type doesn't match swap contract\");\n    _swapsContract = varg0;\n    emit SwapsContractChanged(_swapsContract, varg0);\n}\n\nfunction swapsContract() public nonPayable { \n    return _swapsContract;\n}\n\nfunction releaseSwap(address varg0, address varg1, bytes varg2, bytes32 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg2.length > 0x100000000) | (36 + varg2 + varg2.length > 4 + (msg.data.length - 4))));\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = new array[](varg2.length);\n    MEM[v0.data + varg2.length] = 0;\n    require(_swapsContract.code.size);\n    v1 = _swapsContract.release(this, varg0, varg1, v0, varg3).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction fallback() public payable { \n    require(!msg.data.length, 'invalid pool function called');\n    if (msg.sender != _swapsContract) {\n        emit ReceivedFunds(msg.sender, msg.value);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8815eb39 > function_selector >> 224) {\n            if (0x338246e2 > function_selector >> 224) {\n                if (0x1952e39c == function_selector >> 224) {\n                    returnSwap(address,address,bytes,bytes32);\n                } else if (0x22f3e2d4 == function_selector >> 224) {\n                    isActive();\n                } else if (0x2750fc78 == function_selector >> 224) {\n                    setIsActive(bool);\n                } else if (0x32dee40b == function_selector >> 224) {\n                    withdrawAllFunds(address);\n                }\n            } else if (0x338246e2 == function_selector >> 224) {\n                minSwapAmount();\n            } else if (0x428eecf0 == function_selector >> 224) {\n                paymentDetailsHash();\n            } else if (0x46fcff4c == function_selector >> 224) {\n                availableFunds();\n            } else if (0x81fd3f0b == function_selector >> 224) {\n                sendFundsToSwap(uint256);\n            }\n        } else if (0xc4590d3f > function_selector >> 224) {\n            if (0x8815eb39 == function_selector >> 224) {\n                ASSET_TYPE();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0xa6f9dae1 == function_selector >> 224) {\n                changeOwner(address);\n            } else if (0xc1075329 == function_selector >> 224) {\n                withdrawFunds(address,uint256);\n            }\n        } else if (0xc4590d3f == function_selector >> 224) {\n            setLimits(uint256,uint256);\n        } else if (0xcce987d4 == function_selector >> 224) {\n            maxSwapAmount();\n        } else if (0xd950f365 == function_selector >> 224) {\n            setSwapsContract(address);\n        } else if (0xfa5d5429 == function_selector >> 224) {\n            swapsContract();\n        } else if (0xfdc5d522 == function_selector >> 224) {\n            releaseSwap(address,address,bytes,bytes32);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 19:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _minSwapAmount; // STORAGE[0x2]\nuint256 _maxSwapAmount; // STORAGE[0x3]\nuint256 _paymentDetailsHash; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _swapsContract; // STORAGE[0x1] bytes 0 to 19\nuint8 _isActive; // STORAGE[0x0] bytes 20 to 20\nuint16 _aSSET_TYPE; // STORAGE[0x0] bytes 23 to 24\n\n// Events\nReceivedFunds(address, uint256);\nIsActiveChanged(bool);\nOwnerChanged(address, address);\nLimitsChanged(uint256, uint256);\nSwapsContractChanged(address, address);\n\nfunction returnSwap(address varg0, address varg1, bytes varg2, bytes32 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg2.length > 0x100000000) | (36 + varg2 + varg2.length > 4 + (msg.data.length - 4))));\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = new array[](varg2.length);\n    MEM[v0.data + varg2.length] = 0;\n    require(_swapsContract.code.size);\n    v1 = _swapsContract.returnFunds(this, varg0, varg1, v0, varg3).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction isActive() public nonPayable { \n    return _isActive;\n}\n\nfunction setIsActive(bool varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    if (varg0 != _isActive) {\n        _isActive = varg0;\n        emit IsActiveChanged(varg0);\n    }\n}\n\nfunction withdrawAllFunds(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = varg0.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction minSwapAmount() public nonPayable { \n    return _minSwapAmount;\n}\n\nfunction paymentDetailsHash() public nonPayable { \n    return _paymentDetailsHash;\n}\n\nfunction availableFunds() public nonPayable { \n    return this.balance;\n}\n\nfunction sendFundsToSwap(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_isActive, 'contract is stopped');\n    require(msg.sender == _swapsContract, 'only the swaps contract can call this');\n    v0 = v1 = varg0 >= _minSwapAmount;\n    if (v1) {\n        v0 = v2 = varg0 <= _maxSwapAmount;\n    }\n    require(v0, 'amount outside swap limits');\n    v3 = _swapsContract.call().value(varg0).gas(2300 * !varg0);\n    require(v3); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction ASSET_TYPE() public nonPayable { \n    return _aSSET_TYPE;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    _owner = varg0;\n    emit OwnerChanged(msg.sender, varg0);\n}\n\nfunction withdrawFunds(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction setLimits(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(varg0 <= varg1, 'min limit over max limit');\n    require(varg1 <= 0x1000000000000000000000000000000000000000000000000000000000000, 'maxAmount too high');\n    _minSwapAmount = varg0;\n    _maxSwapAmount = varg1;\n    emit LimitsChanged(varg0, varg1);\n}\n\nfunction maxSwapAmount() public nonPayable { \n    return _maxSwapAmount;\n}\n\nfunction setSwapsContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _owner, 'only the owner can call this');\n    require(varg0, 'null swaps contract address');\n    require(varg0.code.size);\n    v0, v1 = varg0.ASSET_TYPE().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(uint16(v1) == _aSSET_TYPE, \"pool asset type doesn't match swap contract\");\n    _swapsContract = varg0;\n    emit SwapsContractChanged(_swapsContract, varg0);\n}\n\nfunction swapsContract() public nonPayable { \n    return _swapsContract;\n}\n\nfunction releaseSwap(address varg0, address varg1, bytes varg2, bytes32 varg3) public nonPayable { \n    require(msg.data.length - 4 >= 128);\n    require(varg2 <= 0x100000000);\n    require(4 + varg2 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg2.length > 0x100000000) | (36 + varg2 + varg2.length > 4 + (msg.data.length - 4))));\n    require(msg.sender == _owner, 'only the owner can call this');\n    v0 = new array[](varg2.length);\n    MEM[v0.data + varg2.length] = 0;\n    require(_swapsContract.code.size);\n    v1 = _swapsContract.release(this, varg0, varg1, v0, varg3).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction fallback() public payable { \n    require(!msg.data.length, 'invalid pool function called');\n    if (msg.sender != _swapsContract) {\n        emit ReceivedFunds(msg.sender, msg.value);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8815eb39 > function_selector >> 224) {\n            if (0x338246e2 > function_selector >> 224) {\n                if (0x1952e39c == function_selector >> 224) {\n                    returnSwap(address,address,bytes,bytes32);\n                } else if (0x22f3e2d4 == function_selector >> 224) {\n                    isActive();\n                } else if (0x2750fc78 == function_selector >> 224) {\n                    setIsActive(bool);\n                } else if (0x32dee40b == function_selector >> 224) {\n                    withdrawAllFunds(address);\n                }\n            } else if (0x338246e2 == function_selector >> 224) {\n                minSwapAmount();\n            } else if (0x428eecf0 == function_selector >> 224) {\n                paymentDetailsHash();\n            } else if (0x46fcff4c == function_selector >> 224) {\n                availableFunds();\n            } else if (0x81fd3f0b == function_selector >> 224) {\n                sendFundsToSwap(uint256);\n            }\n        } else if (0xc4590d3f > function_selector >> 224) {\n            if (0x8815eb39 == function_selector >> 224) {\n                ASSET_TYPE();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0xa6f9dae1 == function_selector >> 224) {\n                changeOwner(address);\n            } else if (0xc1075329 == function_selector >> 224) {\n                withdrawFunds(address,uint256);\n            }\n        } else if (0xc4590d3f == function_selector >> 224) {\n            setLimits(uint256,uint256);\n        } else if (0xcce987d4 == function_selector >> 224) {\n            maxSwapAmount();\n        } else if (0xd950f365 == function_selector >> 224) {\n            setSwapsContract(address);\n        } else if (0xfa5d5429 == function_selector >> 224) {\n            swapsContract();\n        } else if (0xfdc5d522 == function_selector >> 224) {\n            releaseSwap(address,address,bytes,bytes32);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 37.884401082992554,
	"usage": {
		"completion_tokens": 881,
		"prompt_tokens": 2233,
		"total_tokens": 3114
	}
}