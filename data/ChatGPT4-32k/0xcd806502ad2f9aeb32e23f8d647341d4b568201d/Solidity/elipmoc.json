{
	"address": "0xcd806502ad2f9aeb32e23f8d647341d4b568201d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the solidity code based on the decompiled code:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract Crowdsale {\n    uint256 private _fundsRaised;\n    uint256 private _activeStage;\n    uint256 private stor_11;\n    uint256 private stor_12;\n    uint256 private stor_17;\n    uint256 private stor_18;\n    address private _owner;\n    uint256 private stor_19;\n    uint256 private _withdrawCoreTeamTokens;\n    uint256 private _vestedAdvisors;\n    uint256 private _startTime;\n    uint256 private _endTime;\n    mapping (uint256 => uint256) private _whitelist;\n    mapping (address => uint256) private _weiBalances;\n    bool private _softCapReached;\n    bool private _hardCapReached;\n    bool private _saleSuccessfullyFinished;\n    bool private _refundAllowed;\n    address private _token;\n    bool private _paused;\n    address payable private _wallet;\n    address payable private _walletCoreTeam;\n    address payable private _walletPlatform;\n    address payable private _walletBountyAndAdvisors;\n\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n    event StageOpened(uint256 stage);\n    event Unpause();\n    event Pause();\n    event Whitelisted(address beneficiary, uint256 amount);\n    event Finalized(bool success);\n    event OwnershipTransferred(address previousOwner, address newOwner);\n    event SoftCapReached();\n    event HardCapReached();\n    event StageClosed(uint256 stage);\n\n    constructor() public {\n        _owner = msg.sender;\n        // Initialize other state variables as needed\n    }\n\n    // Implement the functions based on the decompiled code here...\n\n    function _SafeAdd(uint256 varg0, uint256 varg1) private pure returns (uint256) { \n        uint256 v0 = varg0 + varg1;\n        assert(v0 >= varg1);\n        return v0;\n    }\n\n    function activateNextStage() public { \n        require(_owner == msg.sender);\n        assert(_activeStage < 5);\n        require(_fundsRaised >= _activeStage + 4);\n        require(_activeStage + 1 < 5);\n        _activeStage = _activeStage + 1;\n        emit StageOpened(_activeStage + 2);\n    }\n\n    // Add other functions like softCapReached, endTime, canContribute, HARD_CAP, withdraw, walletBountyAndAdvisors, etc.\n\n    // Implement the fallback function\n    function() external payable {\n        buyTokens(msg.sender);\n    }\n\n    function buyTokens(address beneficiary) public payable {\n        require(!_paused);\n        require(beneficiary != address(0));\n        // implement the token purchase logic here...\n    }\n\n    // Implement other functions like hasEnded, withdrawCoreTeamTokens, transferOwnership, token, CROWDSALE_ALLOCATION, addWhitelistBulk etc.\n}\n```\nPlease note that the above code is a basic structure and it needs to be completed based on the decompiled code. Also, the version of solidity may need to be changed based on the version that was used in the original contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039839,
	"id": "chatcmpl-8Ci1HRlHnCbC1yjXdj4sTTu2wxBv7",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 21:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundsRaised; // STORAGE[0x2]\nuint256 _activeStage; // STORAGE[0xe]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_17; // STORAGE[0x17]\nuint256 stor_18; // STORAGE[0x18]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_19; // STORAGE[0x19]\nuint256 _withdrawCoreTeamTokens; // STORAGE[0x1a]\nuint256 _vestedAdvisors; // STORAGE[0x1b]\nuint256 _startTime; // STORAGE[0x20]\nuint256 _endTime; // STORAGE[0x21]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x22]\nmapping (uint256 => [uint256]) _weiBalances; // STORAGE[0x23]\nuint8 _softCapReached; // STORAGE[0x3] bytes 0 to 0\nuint8 _hardCapReached; // STORAGE[0x3] bytes 1 to 1\nuint8 _saleSuccessfullyFinished; // STORAGE[0x3] bytes 2 to 2\nuint8 _refundAllowed; // STORAGE[0xf] bytes 0 to 0\naddress _token; // STORAGE[0x1] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _wallet; // STORAGE[0x1c] bytes 0 to 19\nuint160 _walletCoreTeam; // STORAGE[0x1d] bytes 0 to 19\nuint160 _walletPlatform; // STORAGE[0x1e] bytes 0 to 19\nuint160 _walletBountyAndAdvisors; // STORAGE[0x1f] bytes 0 to 19\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nStageOpened(uint256);\nUnpause();\nPause();\nWhitelisted(address, uint256);\nFinalized(bool);\nOwnershipTransferred(address, address);\nSoftCapReached();\nHardCapReached();\nStageClosed(uint256);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x66b(msg.sender);\n}\n\nfunction activateNextStage() public nonPayable { \n    require(_owner == msg.sender);\n    assert(_activeStage < 5);\n    require(_fundsRaised >= STORAGE[_activeStage + 4]);\n    require(_activeStage + 1 < 5);\n    _activeStage = _activeStage + 1;\n    emit StageOpened(_activeStage + 2);\n}\n\nfunction softCapReached() public nonPayable { \n    return _softCapReached;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction canContribute(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x9a2(varg1, varg0);\n    return v0;\n}\n\nfunction HARD_CAP() public nonPayable { \n    return 0x28a857425466f800000;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    require(_softCapReached);\n    require((address(this)).balance > 0);\n    v0 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction walletBountyAndAdvisors() public nonPayable { \n    return _walletBountyAndAdvisors;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction refundAllowed() public nonPayable { \n    return _refundAllowed;\n}\n\nfunction hasStarted() public nonPayable { \n    return block.timestamp >= _startTime;\n}\n\nfunction activeStage() public nonPayable { \n    return _activeStage;\n}\n\nfunction stageCaps(uint256 varg0) public nonPayable { \n    assert(varg0 < 5);\n    return STORAGE[varg0 + 4];\n}\n\nfunction MIN_INVESTMENT() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction refund() public nonPayable { \n    require(_refundAllowed);\n    require(!_softCapReached);\n    require(_weiBalances[msg.sender] > 0);\n    _weiBalances[msg.sender] = 0;\n    v0 = msg.sender.call().value(_weiBalances[msg.sender]).gas(2300 * !_weiBalances[msg.sender]);\n    require(v0);\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction fundsRaised() public nonPayable { \n    return _fundsRaised;\n}\n\nfunction walletCoreTeam() public nonPayable { \n    return _walletCoreTeam;\n}\n\nfunction weiBalances(address varg0) public nonPayable { \n    return _weiBalances[varg0];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(varg0).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction walletPlatform() public nonPayable { \n    return _walletPlatform;\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction MIN_INVESTMENT_PHASE1() public nonPayable { \n    return 0x4563918244f40000;\n}\n\nfunction saleSuccessfullyFinished() public nonPayable { \n    return _saleSuccessfullyFinished;\n}\n\nfunction hardCapReached() public nonPayable { \n    return _hardCapReached;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return _whitelist[varg0];\n}\n\nfunction varTokenAllocation(uint256 varg0) public nonPayable { \n    assert(varg0 < 3);\n    return STORAGE[varg0 + 16];\n}\n\nfunction withdrawAdvisorTokens() public nonPayable { \n    require(_owner == msg.sender);\n    require(_saleSuccessfullyFinished);\n    v0 = v1 = block.timestamp > 0xed4e00 + _startTime;\n    if (v1) {\n        v0 = _vestedAdvisors > 0;\n    }\n    if (v0) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v2, v3 = _token.transfer(_walletBountyAndAdvisors, _vestedAdvisors).gas(msg.gas - 710);\n        require(v2);\n        _vestedAdvisors = 0;\n        goto 0x2090x4ad;\n    }\n}\n\nfunction addWhitelist(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xe57(varg1, varg0);\n    return v0;\n}\n\nfunction SOFT_CAP() public nonPayable { \n    return 0xa2a15d09519be00000;\n}\n\nfunction finishCrowdsale() public nonPayable { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v0 = v4 = 0;\n    require(msg.sender == _owner);\n    v5 = v6 = block.timestamp >= _endTime;\n    if (block.timestamp < _endTime) {\n        v5 = _fundsRaised >= 0x28a857425466f800000;\n    }\n    require(v5);\n    v7 = v8 = !_saleSuccessfullyFinished;\n    if (!_saleSuccessfullyFinished) {\n        v7 = !_refundAllowed;\n    }\n    require(v7);\n    if (!_softCapReached) {\n        _refundAllowed = 1;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v9, v10 = _token.endMinting(0).gas(msg.gas - 710);\n        require(v9);\n        emit Finalized(0);\n        v11 = 0;\n    } else {\n        v12 = v13 = 60;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v14, v15 = _token.totalSupply().gas(msg.gas - 710);\n        require(v14);\n        v16 = v17 = 4136;\n        v18 = v19 = 4124;\n        v20 = v21 = 16;\n        v0 = v22 = 0;\n        while (1) {\n            if (v15) {\n                v23 = v24 = STORAGE[v0 + v20] * v15;\n                assert(v15);\n                assert(v24 / v15 == STORAGE[v0 + v20]);\n            } else {\n                v23 = v25 = 0;\n            }\n            while (!v12) {\n                assert(v12);\n                v0 = v26 = v23 / v12;\n                goto {'0x1028B0x500', '0x104cB0x500', '0x103aB0x500', '0x107eB0x500'};\n                v16 = v27 = 4154;\n                if (v15) {\n                    v23 = v28 = stor_11 * v15;\n                    assert(v15);\n                    assert(v28 / v15 == stor_11);\n                } else {\n                    v23 = v29 = 0;\n                }\n                goto 0x101cB0x500;\n                v16 = v30 = 4172;\n                if (v15) {\n                    v23 = v31 = stor_12 * v15;\n                    assert(v15);\n                    assert(v31 / v15 == stor_12);\n                } else {\n                    v23 = v32 = 0;\n                }\n                goto 0x101cB0x500;\n            }\n            _vestedAdvisors = v0;\n            v0 = v33 = 0;\n            v0 = v34 = 4;\n            if (v0 >= v0) {\n                break;\n            }\n            if (v0 >= v0) {\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v35, v36 = _token.mint(_walletBountyAndAdvisors, v0).gas(msg.gas - 710);\n                require(v35);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v37, v38 = _token.mint(_walletPlatform, v0).gas(msg.gas - 710);\n                require(v37);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v39, v40 = _token.mint(address(this), v0).gas(msg.gas - 710);\n                require(v39);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v41, v42 = _token.mint(address(this), v0).gas(msg.gas - 710);\n                require(v41);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v43, v44 = _token.endMinting(1).gas(msg.gas - 710);\n                require(v43);\n                _saleSuccessfullyFinished = 1;\n                emit Finalized(1);\n                v11 = v45 = 1;\n            }\n            v16 = v46 = 4222;\n            v18 = v47 = 4124;\n            v20 = v48 = 19;\n            assert(v0 < 4);\n            assert(v0 < 4);\n            STORAGE[v0 + 23] = v26;\n            v0 = _SafeAdd(v26, v0);\n            v0 += 1;\n            goto 0x1062B0x500;\n        }\n    }\n    return v11;\n}\n\nfunction stageTokenMul(uint256 varg0) public nonPayable { \n    assert(varg0 < 5);\n    return STORAGE[varg0 + 9];\n}\n\nfunction vestedAdvisors() public nonPayable { \n    return _vestedAdvisors;\n}\n\nfunction teamTokenAllocation(uint256 varg0) public nonPayable { \n    assert(varg0 < 4);\n    return STORAGE[varg0 + 19];\n}\n\nfunction vestedTeam(uint256 varg0) public nonPayable { \n    assert(varg0 < 4);\n    return STORAGE[varg0 + 23];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x66b(varg0);\n}\n\nfunction hasEnded() public nonPayable { \n    v0 = v1 = block.timestamp >= _endTime;\n    if (block.timestamp < _endTime) {\n        v0 = _fundsRaised >= 0x28a857425466f800000;\n    }\n    return v0;\n}\n\nfunction withdrawCoreTeamTokens() public nonPayable { \n    require(_owner == msg.sender);\n    require(_saleSuccessfullyFinished);\n    v0 = v1 = block.timestamp > 0x3b53800 + _startTime;\n    if (v1) {\n        v0 = _withdrawCoreTeamTokens > 0;\n    }\n    if (v0) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v2, v3 = _token.transfer(_walletCoreTeam, _withdrawCoreTeamTokens).gas(msg.gas - 710);\n        require(v2);\n        _withdrawCoreTeamTokens = 0;\n    }\n    v4 = v5 = block.timestamp > 0x3170400 + _startTime;\n    if (v5) {\n        v4 = stor_19 > 0;\n    }\n    if (v4) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v6, v7 = _token.transfer(_walletCoreTeam, stor_19).gas(msg.gas - 710);\n        require(v6);\n        stor_19 = 0;\n    }\n    v8 = v9 = block.timestamp > 0x278d000 + _startTime;\n    if (v9) {\n        v8 = stor_18 > 0;\n    }\n    if (v8) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v10, v11 = _token.transfer(_walletCoreTeam, stor_18).gas(msg.gas - 710);\n        require(v10);\n        stor_18 = 0;\n    }\n    v12 = v13 = block.timestamp > 0x1da9c00 + _startTime;\n    if (v13) {\n        v12 = stor_17 > 0;\n    }\n    if (v12) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v14, v15 = _token.transfer(_walletCoreTeam, stor_17).gas(msg.gas - 710);\n        require(v14);\n        stor_17 = 0;\n        goto 0x2090x584;\n    }\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction CROWDSALE_ALLOCATION() public nonPayable { \n    return 60;\n}\n\nfunction addWhitelistBulk(address[] varg0, uint256[] varg1) public nonPayable { \n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length << 5);\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg1, (?).length << 5);\n    require(_owner == msg.sender);\n    v2 = v3 = block.timestamp < _endTime;\n    if (v3) {\n        v2 = v4 = _fundsRaised < 0x28a857425466f800000;\n    }\n    require(v2);\n    require(v0.length == v1.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        assert(v5 < v0.length);\n        assert(v5 < v1.length);\n        v7 = 0xe57(v1[v5], v0[v5]);\n        require(v7);\n        v5 += 1;\n    }\n    return 1;\n}\n\nfunction 0x66b(uint256 varg0) private { \n    require(!_paused);\n    v0 = v1 = block.timestamp < _endTime;\n    if (v1) {\n        v0 = v2 = _fundsRaised < 0x28a857425466f800000;\n    }\n    require(v0);\n    v3 = v4 = 0;\n    v5 = v6 = msg.value;\n    assert(_activeStage < 5);\n    require(_fundsRaised < STORAGE[_activeStage + 4]);\n    v7 = v8 = block.timestamp <= 0x30d40 + _startTime;\n    if (v8) {\n        v7 = msg.value < 0x4563918244f40000;\n    }\n    if (!v7) {\n        v9 = v10 = block.timestamp >= _startTime;\n        if (v10) {\n            v9 = block.timestamp <= _endTime;\n        }\n        v9 = v11 = msg.value >= 0x16345785d8a0000;\n    } else {\n        v9 = v12 = 0;\n    }\n    require(v9);\n    v13 = 0x9a2(v6, varg0);\n    require(v13);\n    assert(_fundsRaised <= STORAGE[_activeStage + 4]);\n    v5 = STORAGE[_activeStage + 4] - _fundsRaised;\n    if (v5 < v6) {\n        assert(v5 <= msg.value);\n        v3 = msg.value - v5;\n    }\n    assert(_activeStage < 5);\n    if (v5) {\n        v14 = STORAGE[_activeStage + 9] * v5;\n        assert(v5);\n        assert(v14 / v5 == STORAGE[_activeStage + 9]);\n    } else {\n        v14 = v15 = 0;\n    }\n    v16 = address(varg0);\n    assert(v5 <= _whitelist[v16]);\n    v17 = address(varg0);\n    _whitelist[v17] = _whitelist[v16] - v5;\n    v18 = _SafeAdd(v5, _weiBalances[v17]);\n    v19 = address(varg0);\n    _weiBalances[v19] = v18;\n    v20 = _SafeAdd(v5, _fundsRaised);\n    _fundsRaised = v20;\n    MEM[32 + MEM[64]] = 0;\n    v21 = address(varg0);\n    require(_token.code.size);\n    v22, v23 = _token.mint(v21, v14).gas(msg.gas - 710);\n    require(v22);\n    if (v3 > 0) {\n        v24 = msg.sender.call().value(v3).gas(2300 * !v3);\n        require(v24);\n    }\n    emit TokenPurchase(0, address(varg0), v5, v14);\n    if (_fundsRaised >= STORAGE[_activeStage + 4]) {\n        if (_activeStage) {\n            if (_activeStage == 4) {\n                _hardCapReached = 1;\n                emit HardCapReached();\n            }\n        } else {\n            _softCapReached = 1;\n            emit SoftCapReached();\n        }\n        emit StageClosed(1 + _activeStage);\n        goto 0x8fd;\n    }\n    return ;\n}\n\nfunction 0x9a2(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    require(varg0 > 0);\n    v0 = address(varg1);\n    return _whitelist[v0] >= varg0;\n}\n\nfunction 0xe57(uint256 varg0, uint256 varg1) private { \n    require(_owner == msg.sender);\n    require(address(varg1));\n    require(varg0 > 0);\n    v0 = address(varg1);\n    _whitelist[v0] = varg0;\n    emit Whitelisted(v0, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1ff858d0) {\n            activateNextStage();\n        } else if (0x2b9edee9 == v0) {\n            softCapReached();\n        } else if (0x3197cbb6 == v0) {\n            endTime();\n        } else if (0x378b6a89 == v0) {\n            canContribute(address,uint256);\n        } else if (0x3a03171c == v0) {\n            HARD_CAP();\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3e9744da == v0) {\n            walletBountyAndAdvisors();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x3fa911ae == v0) {\n            refundAllowed();\n        } else if (0x44691f7e == v0) {\n            hasStarted();\n        } else if (0x4864d8d9 == v0) {\n            activeStage();\n        } else if (0x4c46fb73 == v0) {\n            stageCaps(uint256);\n        } else if (0x4ef8ff33 == v0) {\n            MIN_INVESTMENT();\n        } else if (0x521eb273 == v0) {\n            wallet();\n        } else if (0x590e1ae3 == v0) {\n            refund();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6681b9fd == v0) {\n            fundsRaised();\n        } else if (0x6a41ade3 == v0) {\n            walletCoreTeam();\n        } else if (0x6ef9e145 == v0) {\n            weiBalances(address);\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x7f86f7f4 == v0) {\n            walletPlatform();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x94d453db == v0) {\n            MIN_INVESTMENT_PHASE1();\n        } else if (0x96eecf95 == v0) {\n            saleSuccessfullyFinished();\n        } else if (0x9762f802 == v0) {\n            hardCapReached();\n        } else if (0x9b19251a == v0) {\n            whitelist(address);\n        } else if (0xa53bfcf5 == v0) {\n            varTokenAllocation(uint256);\n        } else if (0xa7aac32d == v0) {\n            withdrawAdvisorTokens();\n        } else if (0xb39d9009 == v0) {\n            addWhitelist(address,uint256);\n        } else if (0xb652dc2f == v0) {\n            SOFT_CAP();\n        } else if (0xb80cdcf6 == v0) {\n            finishCrowdsale();\n        } else if (0xc25c22ee == v0) {\n            stageTokenMul(uint256);\n        } else if (0xcd69859e == v0) {\n            vestedAdvisors();\n        } else if (0xd792b356 == v0) {\n            teamTokenAllocation(uint256);\n        } else if (0xe6d1092d == v0) {\n            vestedTeam(uint256);\n        } else if (0xec8ac4d8 == v0) {\n            buyTokens(address);\n        } else if (0xecb70fb7 == v0) {\n            hasEnded();\n        } else if (0xf00648b8 == v0) {\n            withdrawCoreTeamTokens();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == v0) {\n            token();\n        } else if (0xfd09d013 == v0) {\n            CROWDSALE_ALLOCATION();\n        } else if (0xfd4ff437 == v0) {\n            addWhitelistBulk(address[],uint256[]);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 21:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundsRaised; // STORAGE[0x2]\nuint256 _activeStage; // STORAGE[0xe]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_17; // STORAGE[0x17]\nuint256 stor_18; // STORAGE[0x18]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_19; // STORAGE[0x19]\nuint256 _withdrawCoreTeamTokens; // STORAGE[0x1a]\nuint256 _vestedAdvisors; // STORAGE[0x1b]\nuint256 _startTime; // STORAGE[0x20]\nuint256 _endTime; // STORAGE[0x21]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x22]\nmapping (uint256 => [uint256]) _weiBalances; // STORAGE[0x23]\nuint8 _softCapReached; // STORAGE[0x3] bytes 0 to 0\nuint8 _hardCapReached; // STORAGE[0x3] bytes 1 to 1\nuint8 _saleSuccessfullyFinished; // STORAGE[0x3] bytes 2 to 2\nuint8 _refundAllowed; // STORAGE[0xf] bytes 0 to 0\naddress _token; // STORAGE[0x1] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _wallet; // STORAGE[0x1c] bytes 0 to 19\nuint160 _walletCoreTeam; // STORAGE[0x1d] bytes 0 to 19\nuint160 _walletPlatform; // STORAGE[0x1e] bytes 0 to 19\nuint160 _walletBountyAndAdvisors; // STORAGE[0x1f] bytes 0 to 19\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nStageOpened(uint256);\nUnpause();\nPause();\nWhitelisted(address, uint256);\nFinalized(bool);\nOwnershipTransferred(address, address);\nSoftCapReached();\nHardCapReached();\nStageClosed(uint256);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x66b(msg.sender);\n}\n\nfunction activateNextStage() public nonPayable { \n    require(_owner == msg.sender);\n    assert(_activeStage < 5);\n    require(_fundsRaised >= STORAGE[_activeStage + 4]);\n    require(_activeStage + 1 < 5);\n    _activeStage = _activeStage + 1;\n    emit StageOpened(_activeStage + 2);\n}\n\nfunction softCapReached() public nonPayable { \n    return _softCapReached;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction canContribute(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x9a2(varg1, varg0);\n    return v0;\n}\n\nfunction HARD_CAP() public nonPayable { \n    return 0x28a857425466f800000;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    require(_softCapReached);\n    require((address(this)).balance > 0);\n    v0 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction walletBountyAndAdvisors() public nonPayable { \n    return _walletBountyAndAdvisors;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction refundAllowed() public nonPayable { \n    return _refundAllowed;\n}\n\nfunction hasStarted() public nonPayable { \n    return block.timestamp >= _startTime;\n}\n\nfunction activeStage() public nonPayable { \n    return _activeStage;\n}\n\nfunction stageCaps(uint256 varg0) public nonPayable { \n    assert(varg0 < 5);\n    return STORAGE[varg0 + 4];\n}\n\nfunction MIN_INVESTMENT() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction refund() public nonPayable { \n    require(_refundAllowed);\n    require(!_softCapReached);\n    require(_weiBalances[msg.sender] > 0);\n    _weiBalances[msg.sender] = 0;\n    v0 = msg.sender.call().value(_weiBalances[msg.sender]).gas(2300 * !_weiBalances[msg.sender]);\n    require(v0);\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction fundsRaised() public nonPayable { \n    return _fundsRaised;\n}\n\nfunction walletCoreTeam() public nonPayable { \n    return _walletCoreTeam;\n}\n\nfunction weiBalances(address varg0) public nonPayable { \n    return _weiBalances[varg0];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(varg0).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction walletPlatform() public nonPayable { \n    return _walletPlatform;\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction MIN_INVESTMENT_PHASE1() public nonPayable { \n    return 0x4563918244f40000;\n}\n\nfunction saleSuccessfullyFinished() public nonPayable { \n    return _saleSuccessfullyFinished;\n}\n\nfunction hardCapReached() public nonPayable { \n    return _hardCapReached;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return _whitelist[varg0];\n}\n\nfunction varTokenAllocation(uint256 varg0) public nonPayable { \n    assert(varg0 < 3);\n    return STORAGE[varg0 + 16];\n}\n\nfunction withdrawAdvisorTokens() public nonPayable { \n    require(_owner == msg.sender);\n    require(_saleSuccessfullyFinished);\n    v0 = v1 = block.timestamp > 0xed4e00 + _startTime;\n    if (v1) {\n        v0 = _vestedAdvisors > 0;\n    }\n    if (v0) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v2, v3 = _token.transfer(_walletBountyAndAdvisors, _vestedAdvisors).gas(msg.gas - 710);\n        require(v2);\n        _vestedAdvisors = 0;\n        goto 0x2090x4ad;\n    }\n}\n\nfunction addWhitelist(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xe57(varg1, varg0);\n    return v0;\n}\n\nfunction SOFT_CAP() public nonPayable { \n    return 0xa2a15d09519be00000;\n}\n\nfunction finishCrowdsale() public nonPayable { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v0 = v4 = 0;\n    require(msg.sender == _owner);\n    v5 = v6 = block.timestamp >= _endTime;\n    if (block.timestamp < _endTime) {\n        v5 = _fundsRaised >= 0x28a857425466f800000;\n    }\n    require(v5);\n    v7 = v8 = !_saleSuccessfullyFinished;\n    if (!_saleSuccessfullyFinished) {\n        v7 = !_refundAllowed;\n    }\n    require(v7);\n    if (!_softCapReached) {\n        _refundAllowed = 1;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v9, v10 = _token.endMinting(0).gas(msg.gas - 710);\n        require(v9);\n        emit Finalized(0);\n        v11 = 0;\n    } else {\n        v12 = v13 = 60;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v14, v15 = _token.totalSupply().gas(msg.gas - 710);\n        require(v14);\n        v16 = v17 = 4136;\n        v18 = v19 = 4124;\n        v20 = v21 = 16;\n        v0 = v22 = 0;\n        while (1) {\n            if (v15) {\n                v23 = v24 = STORAGE[v0 + v20] * v15;\n                assert(v15);\n                assert(v24 / v15 == STORAGE[v0 + v20]);\n            } else {\n                v23 = v25 = 0;\n            }\n            while (!v12) {\n                assert(v12);\n                v0 = v26 = v23 / v12;\n                goto {'0x1028B0x500', '0x104cB0x500', '0x103aB0x500', '0x107eB0x500'};\n                v16 = v27 = 4154;\n                if (v15) {\n                    v23 = v28 = stor_11 * v15;\n                    assert(v15);\n                    assert(v28 / v15 == stor_11);\n                } else {\n                    v23 = v29 = 0;\n                }\n                goto 0x101cB0x500;\n                v16 = v30 = 4172;\n                if (v15) {\n                    v23 = v31 = stor_12 * v15;\n                    assert(v15);\n                    assert(v31 / v15 == stor_12);\n                } else {\n                    v23 = v32 = 0;\n                }\n                goto 0x101cB0x500;\n            }\n            _vestedAdvisors = v0;\n            v0 = v33 = 0;\n            v0 = v34 = 4;\n            if (v0 >= v0) {\n                break;\n            }\n            if (v0 >= v0) {\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v35, v36 = _token.mint(_walletBountyAndAdvisors, v0).gas(msg.gas - 710);\n                require(v35);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v37, v38 = _token.mint(_walletPlatform, v0).gas(msg.gas - 710);\n                require(v37);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v39, v40 = _token.mint(address(this), v0).gas(msg.gas - 710);\n                require(v39);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v41, v42 = _token.mint(address(this), v0).gas(msg.gas - 710);\n                require(v41);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v43, v44 = _token.endMinting(1).gas(msg.gas - 710);\n                require(v43);\n                _saleSuccessfullyFinished = 1;\n                emit Finalized(1);\n                v11 = v45 = 1;\n            }\n            v16 = v46 = 4222;\n            v18 = v47 = 4124;\n            v20 = v48 = 19;\n            assert(v0 < 4);\n            assert(v0 < 4);\n            STORAGE[v0 + 23] = v26;\n            v0 = _SafeAdd(v26, v0);\n            v0 += 1;\n            goto 0x1062B0x500;\n        }\n    }\n    return v11;\n}\n\nfunction stageTokenMul(uint256 varg0) public nonPayable { \n    assert(varg0 < 5);\n    return STORAGE[varg0 + 9];\n}\n\nfunction vestedAdvisors() public nonPayable { \n    return _vestedAdvisors;\n}\n\nfunction teamTokenAllocation(uint256 varg0) public nonPayable { \n    assert(varg0 < 4);\n    return STORAGE[varg0 + 19];\n}\n\nfunction vestedTeam(uint256 varg0) public nonPayable { \n    assert(varg0 < 4);\n    return STORAGE[varg0 + 23];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x66b(varg0);\n}\n\nfunction hasEnded() public nonPayable { \n    v0 = v1 = block.timestamp >= _endTime;\n    if (block.timestamp < _endTime) {\n        v0 = _fundsRaised >= 0x28a857425466f800000;\n    }\n    return v0;\n}\n\nfunction withdrawCoreTeamTokens() public nonPayable { \n    require(_owner == msg.sender);\n    require(_saleSuccessfullyFinished);\n    v0 = v1 = block.timestamp > 0x3b53800 + _startTime;\n    if (v1) {\n        v0 = _withdrawCoreTeamTokens > 0;\n    }\n    if (v0) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v2, v3 = _token.transfer(_walletCoreTeam, _withdrawCoreTeamTokens).gas(msg.gas - 710);\n        require(v2);\n        _withdrawCoreTeamTokens = 0;\n    }\n    v4 = v5 = block.timestamp > 0x3170400 + _startTime;\n    if (v5) {\n        v4 = stor_19 > 0;\n    }\n    if (v4) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v6, v7 = _token.transfer(_walletCoreTeam, stor_19).gas(msg.gas - 710);\n        require(v6);\n        stor_19 = 0;\n    }\n    v8 = v9 = block.timestamp > 0x278d000 + _startTime;\n    if (v9) {\n        v8 = stor_18 > 0;\n    }\n    if (v8) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v10, v11 = _token.transfer(_walletCoreTeam, stor_18).gas(msg.gas - 710);\n        require(v10);\n        stor_18 = 0;\n    }\n    v12 = v13 = block.timestamp > 0x1da9c00 + _startTime;\n    if (v13) {\n        v12 = stor_17 > 0;\n    }\n    if (v12) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v14, v15 = _token.transfer(_walletCoreTeam, stor_17).gas(msg.gas - 710);\n        require(v14);\n        stor_17 = 0;\n        goto 0x2090x584;\n    }\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction CROWDSALE_ALLOCATION() public nonPayable { \n    return 60;\n}\n\nfunction addWhitelistBulk(address[] varg0, uint256[] varg1) public nonPayable { \n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length << 5);\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg1, (?).length << 5);\n    require(_owner == msg.sender);\n    v2 = v3 = block.timestamp < _endTime;\n    if (v3) {\n        v2 = v4 = _fundsRaised < 0x28a857425466f800000;\n    }\n    require(v2);\n    require(v0.length == v1.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        assert(v5 < v0.length);\n        assert(v5 < v1.length);\n        v7 = 0xe57(v1[v5], v0[v5]);\n        require(v7);\n        v5 += 1;\n    }\n    return 1;\n}\n\nfunction 0x66b(uint256 varg0) private { \n    require(!_paused);\n    v0 = v1 = block.timestamp < _endTime;\n    if (v1) {\n        v0 = v2 = _fundsRaised < 0x28a857425466f800000;\n    }\n    require(v0);\n    v3 = v4 = 0;\n    v5 = v6 = msg.value;\n    assert(_activeStage < 5);\n    require(_fundsRaised < STORAGE[_activeStage + 4]);\n    v7 = v8 = block.timestamp <= 0x30d40 + _startTime;\n    if (v8) {\n        v7 = msg.value < 0x4563918244f40000;\n    }\n    if (!v7) {\n        v9 = v10 = block.timestamp >= _startTime;\n        if (v10) {\n            v9 = block.timestamp <= _endTime;\n        }\n        v9 = v11 = msg.value >= 0x16345785d8a0000;\n    } else {\n        v9 = v12 = 0;\n    }\n    require(v9);\n    v13 = 0x9a2(v6, varg0);\n    require(v13);\n    assert(_fundsRaised <= STORAGE[_activeStage + 4]);\n    v5 = STORAGE[_activeStage + 4] - _fundsRaised;\n    if (v5 < v6) {\n        assert(v5 <= msg.value);\n        v3 = msg.value - v5;\n    }\n    assert(_activeStage < 5);\n    if (v5) {\n        v14 = STORAGE[_activeStage + 9] * v5;\n        assert(v5);\n        assert(v14 / v5 == STORAGE[_activeStage + 9]);\n    } else {\n        v14 = v15 = 0;\n    }\n    v16 = address(varg0);\n    assert(v5 <= _whitelist[v16]);\n    v17 = address(varg0);\n    _whitelist[v17] = _whitelist[v16] - v5;\n    v18 = _SafeAdd(v5, _weiBalances[v17]);\n    v19 = address(varg0);\n    _weiBalances[v19] = v18;\n    v20 = _SafeAdd(v5, _fundsRaised);\n    _fundsRaised = v20;\n    MEM[32 + MEM[64]] = 0;\n    v21 = address(varg0);\n    require(_token.code.size);\n    v22, v23 = _token.mint(v21, v14).gas(msg.gas - 710);\n    require(v22);\n    if (v3 > 0) {\n        v24 = msg.sender.call().value(v3).gas(2300 * !v3);\n        require(v24);\n    }\n    emit TokenPurchase(0, address(varg0), v5, v14);\n    if (_fundsRaised >= STORAGE[_activeStage + 4]) {\n        if (_activeStage) {\n            if (_activeStage == 4) {\n                _hardCapReached = 1;\n                emit HardCapReached();\n            }\n        } else {\n            _softCapReached = 1;\n            emit SoftCapReached();\n        }\n        emit StageClosed(1 + _activeStage);\n        goto 0x8fd;\n    }\n    return ;\n}\n\nfunction 0x9a2(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    require(varg0 > 0);\n    v0 = address(varg1);\n    return _whitelist[v0] >= varg0;\n}\n\nfunction 0xe57(uint256 varg0, uint256 varg1) private { \n    require(_owner == msg.sender);\n    require(address(varg1));\n    require(varg0 > 0);\n    v0 = address(varg1);\n    _whitelist[v0] = varg0;\n    emit Whitelisted(v0, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1ff858d0) {\n            activateNextStage();\n        } else if (0x2b9edee9 == v0) {\n            softCapReached();\n        } else if (0x3197cbb6 == v0) {\n            endTime();\n        } else if (0x378b6a89 == v0) {\n            canContribute(address,uint256);\n        } else if (0x3a03171c == v0) {\n            HARD_CAP();\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3e9744da == v0) {\n            walletBountyAndAdvisors();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x3fa911ae == v0) {\n            refundAllowed();\n        } else if (0x44691f7e == v0) {\n            hasStarted();\n        } else if (0x4864d8d9 == v0) {\n            activeStage();\n        } else if (0x4c46fb73 == v0) {\n            stageCaps(uint256);\n        } else if (0x4ef8ff33 == v0) {\n            MIN_INVESTMENT();\n        } else if (0x521eb273 == v0) {\n            wallet();\n        } else if (0x590e1ae3 == v0) {\n            refund();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6681b9fd == v0) {\n            fundsRaised();\n        } else if (0x6a41ade3 == v0) {\n            walletCoreTeam();\n        } else if (0x6ef9e145 == v0) {\n            weiBalances(address);\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x7f86f7f4 == v0) {\n            walletPlatform();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x94d453db == v0) {\n            MIN_INVESTMENT_PHASE1();\n        } else if (0x96eecf95 == v0) {\n            saleSuccessfullyFinished();\n        } else if (0x9762f802 == v0) {\n            hardCapReached();\n        } else if (0x9b19251a == v0) {\n            whitelist(address);\n        } else if (0xa53bfcf5 == v0) {\n            varTokenAllocation(uint256);\n        } else if (0xa7aac32d == v0) {\n            withdrawAdvisorTokens();\n        } else if (0xb39d9009 == v0) {\n            addWhitelist(address,uint256);\n        } else if (0xb652dc2f == v0) {\n            SOFT_CAP();\n        } else if (0xb80cdcf6 == v0) {\n            finishCrowdsale();\n        } else if (0xc25c22ee == v0) {\n            stageTokenMul(uint256);\n        } else if (0xcd69859e == v0) {\n            vestedAdvisors();\n        } else if (0xd792b356 == v0) {\n            teamTokenAllocation(uint256);\n        } else if (0xe6d1092d == v0) {\n            vestedTeam(uint256);\n        } else if (0xec8ac4d8 == v0) {\n            buyTokens(address);\n        } else if (0xecb70fb7 == v0) {\n            hasEnded();\n        } else if (0xf00648b8 == v0) {\n            withdrawCoreTeamTokens();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == v0) {\n            token();\n        } else if (0xfd09d013 == v0) {\n            CROWDSALE_ALLOCATION();\n        } else if (0xfd4ff437 == v0) {\n            addWhitelistBulk(address[],uint256[]);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 21:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundsRaised; // STORAGE[0x2]\nuint256 _activeStage; // STORAGE[0xe]\nuint256 stor_11; // STORAGE[0x11]\nuint256 stor_12; // STORAGE[0x12]\nuint256 stor_17; // STORAGE[0x17]\nuint256 stor_18; // STORAGE[0x18]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_19; // STORAGE[0x19]\nuint256 _withdrawCoreTeamTokens; // STORAGE[0x1a]\nuint256 _vestedAdvisors; // STORAGE[0x1b]\nuint256 _startTime; // STORAGE[0x20]\nuint256 _endTime; // STORAGE[0x21]\nmapping (uint256 => [uint256]) _whitelist; // STORAGE[0x22]\nmapping (uint256 => [uint256]) _weiBalances; // STORAGE[0x23]\nuint8 _softCapReached; // STORAGE[0x3] bytes 0 to 0\nuint8 _hardCapReached; // STORAGE[0x3] bytes 1 to 1\nuint8 _saleSuccessfullyFinished; // STORAGE[0x3] bytes 2 to 2\nuint8 _refundAllowed; // STORAGE[0xf] bytes 0 to 0\naddress _token; // STORAGE[0x1] bytes 0 to 19\nuint8 _paused; // STORAGE[0x0] bytes 20 to 20\naddress _wallet; // STORAGE[0x1c] bytes 0 to 19\nuint160 _walletCoreTeam; // STORAGE[0x1d] bytes 0 to 19\nuint160 _walletPlatform; // STORAGE[0x1e] bytes 0 to 19\nuint160 _walletBountyAndAdvisors; // STORAGE[0x1f] bytes 0 to 19\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nStageOpened(uint256);\nUnpause();\nPause();\nWhitelisted(address, uint256);\nFinalized(bool);\nOwnershipTransferred(address, address);\nSoftCapReached();\nHardCapReached();\nStageClosed(uint256);\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x66b(msg.sender);\n}\n\nfunction activateNextStage() public nonPayable { \n    require(_owner == msg.sender);\n    assert(_activeStage < 5);\n    require(_fundsRaised >= STORAGE[_activeStage + 4]);\n    require(_activeStage + 1 < 5);\n    _activeStage = _activeStage + 1;\n    emit StageOpened(_activeStage + 2);\n}\n\nfunction softCapReached() public nonPayable { \n    return _softCapReached;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\nfunction canContribute(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x9a2(varg1, varg0);\n    return v0;\n}\n\nfunction HARD_CAP() public nonPayable { \n    return 0x28a857425466f800000;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    require(_softCapReached);\n    require((address(this)).balance > 0);\n    v0 = _wallet.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v0);\n}\n\nfunction walletBountyAndAdvisors() public nonPayable { \n    return _walletBountyAndAdvisors;\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction refundAllowed() public nonPayable { \n    return _refundAllowed;\n}\n\nfunction hasStarted() public nonPayable { \n    return block.timestamp >= _startTime;\n}\n\nfunction activeStage() public nonPayable { \n    return _activeStage;\n}\n\nfunction stageCaps(uint256 varg0) public nonPayable { \n    assert(varg0 < 5);\n    return STORAGE[varg0 + 4];\n}\n\nfunction MIN_INVESTMENT() public nonPayable { \n    return 0x16345785d8a0000;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction refund() public nonPayable { \n    require(_refundAllowed);\n    require(!_softCapReached);\n    require(_weiBalances[msg.sender] > 0);\n    _weiBalances[msg.sender] = 0;\n    v0 = msg.sender.call().value(_weiBalances[msg.sender]).gas(2300 * !_weiBalances[msg.sender]);\n    require(v0);\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction fundsRaised() public nonPayable { \n    return _fundsRaised;\n}\n\nfunction walletCoreTeam() public nonPayable { \n    return _walletCoreTeam;\n}\n\nfunction weiBalances(address varg0) public nonPayable { \n    return _weiBalances[varg0];\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(varg0).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction walletPlatform() public nonPayable { \n    return _walletPlatform;\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction MIN_INVESTMENT_PHASE1() public nonPayable { \n    return 0x4563918244f40000;\n}\n\nfunction saleSuccessfullyFinished() public nonPayable { \n    return _saleSuccessfullyFinished;\n}\n\nfunction hardCapReached() public nonPayable { \n    return _hardCapReached;\n}\n\nfunction whitelist(address varg0) public nonPayable { \n    return _whitelist[varg0];\n}\n\nfunction varTokenAllocation(uint256 varg0) public nonPayable { \n    assert(varg0 < 3);\n    return STORAGE[varg0 + 16];\n}\n\nfunction withdrawAdvisorTokens() public nonPayable { \n    require(_owner == msg.sender);\n    require(_saleSuccessfullyFinished);\n    v0 = v1 = block.timestamp > 0xed4e00 + _startTime;\n    if (v1) {\n        v0 = _vestedAdvisors > 0;\n    }\n    if (v0) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v2, v3 = _token.transfer(_walletBountyAndAdvisors, _vestedAdvisors).gas(msg.gas - 710);\n        require(v2);\n        _vestedAdvisors = 0;\n        goto 0x2090x4ad;\n    }\n}\n\nfunction addWhitelist(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xe57(varg1, varg0);\n    return v0;\n}\n\nfunction SOFT_CAP() public nonPayable { \n    return 0xa2a15d09519be00000;\n}\n\nfunction finishCrowdsale() public nonPayable { \n    v0 = v1 = 0;\n    v0 = v2 = 0;\n    v0 = v3 = 0;\n    v0 = v4 = 0;\n    require(msg.sender == _owner);\n    v5 = v6 = block.timestamp >= _endTime;\n    if (block.timestamp < _endTime) {\n        v5 = _fundsRaised >= 0x28a857425466f800000;\n    }\n    require(v5);\n    v7 = v8 = !_saleSuccessfullyFinished;\n    if (!_saleSuccessfullyFinished) {\n        v7 = !_refundAllowed;\n    }\n    require(v7);\n    if (!_softCapReached) {\n        _refundAllowed = 1;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v9, v10 = _token.endMinting(0).gas(msg.gas - 710);\n        require(v9);\n        emit Finalized(0);\n        v11 = 0;\n    } else {\n        v12 = v13 = 60;\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v14, v15 = _token.totalSupply().gas(msg.gas - 710);\n        require(v14);\n        v16 = v17 = 4136;\n        v18 = v19 = 4124;\n        v20 = v21 = 16;\n        v0 = v22 = 0;\n        while (1) {\n            if (v15) {\n                v23 = v24 = STORAGE[v0 + v20] * v15;\n                assert(v15);\n                assert(v24 / v15 == STORAGE[v0 + v20]);\n            } else {\n                v23 = v25 = 0;\n            }\n            while (!v12) {\n                assert(v12);\n                v0 = v26 = v23 / v12;\n                goto {'0x1028B0x500', '0x104cB0x500', '0x103aB0x500', '0x107eB0x500'};\n                v16 = v27 = 4154;\n                if (v15) {\n                    v23 = v28 = stor_11 * v15;\n                    assert(v15);\n                    assert(v28 / v15 == stor_11);\n                } else {\n                    v23 = v29 = 0;\n                }\n                goto 0x101cB0x500;\n                v16 = v30 = 4172;\n                if (v15) {\n                    v23 = v31 = stor_12 * v15;\n                    assert(v15);\n                    assert(v31 / v15 == stor_12);\n                } else {\n                    v23 = v32 = 0;\n                }\n                goto 0x101cB0x500;\n            }\n            _vestedAdvisors = v0;\n            v0 = v33 = 0;\n            v0 = v34 = 4;\n            if (v0 >= v0) {\n                break;\n            }\n            if (v0 >= v0) {\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v35, v36 = _token.mint(_walletBountyAndAdvisors, v0).gas(msg.gas - 710);\n                require(v35);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v37, v38 = _token.mint(_walletPlatform, v0).gas(msg.gas - 710);\n                require(v37);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v39, v40 = _token.mint(address(this), v0).gas(msg.gas - 710);\n                require(v39);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v41, v42 = _token.mint(address(this), v0).gas(msg.gas - 710);\n                require(v41);\n                MEM[32 + MEM[64]] = 0;\n                require(_token.code.size);\n                v43, v44 = _token.endMinting(1).gas(msg.gas - 710);\n                require(v43);\n                _saleSuccessfullyFinished = 1;\n                emit Finalized(1);\n                v11 = v45 = 1;\n            }\n            v16 = v46 = 4222;\n            v18 = v47 = 4124;\n            v20 = v48 = 19;\n            assert(v0 < 4);\n            assert(v0 < 4);\n            STORAGE[v0 + 23] = v26;\n            v0 = _SafeAdd(v26, v0);\n            v0 += 1;\n            goto 0x1062B0x500;\n        }\n    }\n    return v11;\n}\n\nfunction stageTokenMul(uint256 varg0) public nonPayable { \n    assert(varg0 < 5);\n    return STORAGE[varg0 + 9];\n}\n\nfunction vestedAdvisors() public nonPayable { \n    return _vestedAdvisors;\n}\n\nfunction teamTokenAllocation(uint256 varg0) public nonPayable { \n    assert(varg0 < 4);\n    return STORAGE[varg0 + 19];\n}\n\nfunction vestedTeam(uint256 varg0) public nonPayable { \n    assert(varg0 < 4);\n    return STORAGE[varg0 + 23];\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x66b(varg0);\n}\n\nfunction hasEnded() public nonPayable { \n    v0 = v1 = block.timestamp >= _endTime;\n    if (block.timestamp < _endTime) {\n        v0 = _fundsRaised >= 0x28a857425466f800000;\n    }\n    return v0;\n}\n\nfunction withdrawCoreTeamTokens() public nonPayable { \n    require(_owner == msg.sender);\n    require(_saleSuccessfullyFinished);\n    v0 = v1 = block.timestamp > 0x3b53800 + _startTime;\n    if (v1) {\n        v0 = _withdrawCoreTeamTokens > 0;\n    }\n    if (v0) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v2, v3 = _token.transfer(_walletCoreTeam, _withdrawCoreTeamTokens).gas(msg.gas - 710);\n        require(v2);\n        _withdrawCoreTeamTokens = 0;\n    }\n    v4 = v5 = block.timestamp > 0x3170400 + _startTime;\n    if (v5) {\n        v4 = stor_19 > 0;\n    }\n    if (v4) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v6, v7 = _token.transfer(_walletCoreTeam, stor_19).gas(msg.gas - 710);\n        require(v6);\n        stor_19 = 0;\n    }\n    v8 = v9 = block.timestamp > 0x278d000 + _startTime;\n    if (v9) {\n        v8 = stor_18 > 0;\n    }\n    if (v8) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v10, v11 = _token.transfer(_walletCoreTeam, stor_18).gas(msg.gas - 710);\n        require(v10);\n        stor_18 = 0;\n    }\n    v12 = v13 = block.timestamp > 0x1da9c00 + _startTime;\n    if (v13) {\n        v12 = stor_17 > 0;\n    }\n    if (v12) {\n        MEM[32 + MEM[64]] = 0;\n        require(_token.code.size);\n        v14, v15 = _token.transfer(_walletCoreTeam, stor_17).gas(msg.gas - 710);\n        require(v14);\n        stor_17 = 0;\n        goto 0x2090x584;\n    }\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction CROWDSALE_ALLOCATION() public nonPayable { \n    return 60;\n}\n\nfunction addWhitelistBulk(address[] varg0, uint256[] varg1) public nonPayable { \n    v0 = new uint256[]((?).length);\n    CALLDATACOPY(v0.data, varg0 + 36, (?).length << 5);\n    v1 = new uint256[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg1, (?).length << 5);\n    require(_owner == msg.sender);\n    v2 = v3 = block.timestamp < _endTime;\n    if (v3) {\n        v2 = v4 = _fundsRaised < 0x28a857425466f800000;\n    }\n    require(v2);\n    require(v0.length == v1.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        assert(v5 < v0.length);\n        assert(v5 < v1.length);\n        v7 = 0xe57(v1[v5], v0[v5]);\n        require(v7);\n        v5 += 1;\n    }\n    return 1;\n}\n\nfunction 0x66b(uint256 varg0) private { \n    require(!_paused);\n    v0 = v1 = block.timestamp < _endTime;\n    if (v1) {\n        v0 = v2 = _fundsRaised < 0x28a857425466f800000;\n    }\n    require(v0);\n    v3 = v4 = 0;\n    v5 = v6 = msg.value;\n    assert(_activeStage < 5);\n    require(_fundsRaised < STORAGE[_activeStage + 4]);\n    v7 = v8 = block.timestamp <= 0x30d40 + _startTime;\n    if (v8) {\n        v7 = msg.value < 0x4563918244f40000;\n    }\n    if (!v7) {\n        v9 = v10 = block.timestamp >= _startTime;\n        if (v10) {\n            v9 = block.timestamp <= _endTime;\n        }\n        v9 = v11 = msg.value >= 0x16345785d8a0000;\n    } else {\n        v9 = v12 = 0;\n    }\n    require(v9);\n    v13 = 0x9a2(v6, varg0);\n    require(v13);\n    assert(_fundsRaised <= STORAGE[_activeStage + 4]);\n    v5 = STORAGE[_activeStage + 4] - _fundsRaised;\n    if (v5 < v6) {\n        assert(v5 <= msg.value);\n        v3 = msg.value - v5;\n    }\n    assert(_activeStage < 5);\n    if (v5) {\n        v14 = STORAGE[_activeStage + 9] * v5;\n        assert(v5);\n        assert(v14 / v5 == STORAGE[_activeStage + 9]);\n    } else {\n        v14 = v15 = 0;\n    }\n    v16 = address(varg0);\n    assert(v5 <= _whitelist[v16]);\n    v17 = address(varg0);\n    _whitelist[v17] = _whitelist[v16] - v5;\n    v18 = _SafeAdd(v5, _weiBalances[v17]);\n    v19 = address(varg0);\n    _weiBalances[v19] = v18;\n    v20 = _SafeAdd(v5, _fundsRaised);\n    _fundsRaised = v20;\n    MEM[32 + MEM[64]] = 0;\n    v21 = address(varg0);\n    require(_token.code.size);\n    v22, v23 = _token.mint(v21, v14).gas(msg.gas - 710);\n    require(v22);\n    if (v3 > 0) {\n        v24 = msg.sender.call().value(v3).gas(2300 * !v3);\n        require(v24);\n    }\n    emit TokenPurchase(0, address(varg0), v5, v14);\n    if (_fundsRaised >= STORAGE[_activeStage + 4]) {\n        if (_activeStage) {\n            if (_activeStage == 4) {\n                _hardCapReached = 1;\n                emit HardCapReached();\n            }\n        } else {\n            _softCapReached = 1;\n            emit SoftCapReached();\n        }\n        emit StageClosed(1 + _activeStage);\n        goto 0x8fd;\n    }\n    return ;\n}\n\nfunction 0x9a2(uint256 varg0, uint256 varg1) private { \n    require(address(varg1));\n    require(varg0 > 0);\n    v0 = address(varg1);\n    return _whitelist[v0] >= varg0;\n}\n\nfunction 0xe57(uint256 varg0, uint256 varg1) private { \n    require(_owner == msg.sender);\n    require(address(varg1));\n    require(varg0 > 0);\n    v0 = address(varg1);\n    _whitelist[v0] = varg0;\n    emit Whitelisted(v0, varg0);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1ff858d0) {\n            activateNextStage();\n        } else if (0x2b9edee9 == v0) {\n            softCapReached();\n        } else if (0x3197cbb6 == v0) {\n            endTime();\n        } else if (0x378b6a89 == v0) {\n            canContribute(address,uint256);\n        } else if (0x3a03171c == v0) {\n            HARD_CAP();\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3e9744da == v0) {\n            walletBountyAndAdvisors();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x3fa911ae == v0) {\n            refundAllowed();\n        } else if (0x44691f7e == v0) {\n            hasStarted();\n        } else if (0x4864d8d9 == v0) {\n            activeStage();\n        } else if (0x4c46fb73 == v0) {\n            stageCaps(uint256);\n        } else if (0x4ef8ff33 == v0) {\n            MIN_INVESTMENT();\n        } else if (0x521eb273 == v0) {\n            wallet();\n        } else if (0x590e1ae3 == v0) {\n            refund();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x6681b9fd == v0) {\n            fundsRaised();\n        } else if (0x6a41ade3 == v0) {\n            walletCoreTeam();\n        } else if (0x6ef9e145 == v0) {\n            weiBalances(address);\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x7f86f7f4 == v0) {\n            walletPlatform();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x94d453db == v0) {\n            MIN_INVESTMENT_PHASE1();\n        } else if (0x96eecf95 == v0) {\n            saleSuccessfullyFinished();\n        } else if (0x9762f802 == v0) {\n            hardCapReached();\n        } else if (0x9b19251a == v0) {\n            whitelist(address);\n        } else if (0xa53bfcf5 == v0) {\n            varTokenAllocation(uint256);\n        } else if (0xa7aac32d == v0) {\n            withdrawAdvisorTokens();\n        } else if (0xb39d9009 == v0) {\n            addWhitelist(address,uint256);\n        } else if (0xb652dc2f == v0) {\n            SOFT_CAP();\n        } else if (0xb80cdcf6 == v0) {\n            finishCrowdsale();\n        } else if (0xc25c22ee == v0) {\n            stageTokenMul(uint256);\n        } else if (0xcd69859e == v0) {\n            vestedAdvisors();\n        } else if (0xd792b356 == v0) {\n            teamTokenAllocation(uint256);\n        } else if (0xe6d1092d == v0) {\n            vestedTeam(uint256);\n        } else if (0xec8ac4d8 == v0) {\n            buyTokens(address);\n        } else if (0xecb70fb7 == v0) {\n            hasEnded();\n        } else if (0xf00648b8 == v0) {\n            withdrawCoreTeamTokens();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == v0) {\n            token();\n        } else if (0xfd09d013 == v0) {\n            CROWDSALE_ALLOCATION();\n        } else if (0xfd4ff437 == v0) {\n            addWhitelistBulk(address[],uint256[]);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 32.39052176475525,
	"usage": {
		"completion_tokens": 663,
		"prompt_tokens": 5705,
		"total_tokens": 6368
	}
}