{
	"address": "0xd216153c06e857cd7f72665e0af1d7d82172f494",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code provided, here is a potential Solidity smart contract. Please note that due to the complexity of the decompiled code, some parts may not be perfectly translated and the names of the functions and variables cannot be accurately retrieved.\n\n```solidity\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Contract {\n    mapping(address => uint256) nonce;\n    mapping(address => uint256) balanceOf;\n    mapping(address => Relay) relay;\n    uint256[] version;\n\n    struct Relay {\n        uint256 field_0;\n        uint256 field_256;\n        uint256 field_512;\n        address field_768;\n        uint256 field_928;\n    }\n\n    function getNonce(address _addr) public view returns (uint256) {\n        return nonce[_addr];\n    }\n\n    function version() public view returns (uint256[] memory) {\n        return version;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balanceOf[_owner];\n    }\n\n    function getRelay(address _param1) public view returns (uint256, uint256, uint256, address, uint256) {\n        require(relay[_param1].field_928 <= 3);\n        return (relay[_param1].field_0, relay[_param1].field_256, relay[_param1].field_512, relay[_param1].field_768, relay[_param1].field_928);\n    }\n\n    fallback() external payable {\n        revert();\n    }\n\n    function requiredGas(uint256 _param1) public pure returns (uint256) {\n        return (_param1 + 398204);\n    }\n\n    function maxPossibleCharge(uint256 _param1, uint256 _param2, uint256 _param3) public pure returns (uint256) {\n        return ((39820400 * _param2) + (398204 * _param3 * _param2) + (100 * _param1 * _param2) + (_param3 * _param1 * _param2) / 100);\n    }\n\n    function depositFor(address _address) public payable {\n        require(msg.value > 2 * 10**18, 'deposit too big');\n        require(msg.value + balanceOf[_address] < balanceOf[_address], 'SafeMath: addition overflow');\n        balanceOf[_address] += msg.value;\n        emit Log(msg.value, _address, msg.sender);\n    }\n\n    // ... rest of the functions\n\n    event Log(uint256 indexed value, address indexed _address, address indexed caller);\n}\n```\n\nPlease note this is a partial implementation of the smart contract as the decompiled code is incomplete and some functions are very lengthy and complex. Some assumptions had to be made regarding function and event names (e.g., `Log`) as their original names were not available. Also, due to the nature of EVM bytecode decompilation, the exact Solidity code may vary and may not be perfectly translated.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471184,
	"id": "chatcmpl-8MuWWAJ90eiYNLXTm8QQzBrODtyWi",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n#\n#  I failed with these: \n#  - unknown2b601747(?)\n#  - unknowna8cd9572(?)\n#  All the rest is below.\n#\n\ndef storage:\n  nonce is mapping of uint256 at storage 0\n  relay is mapping of struct at storage 1\n  balanceOf is mapping of uint256 at storage 2\n  version is array of uint256 at storage 3\n\ndef getNonce(address _addr): # not payable\n  require calldata.size - 4 >= 32\n  return nonce[addr(_addr)]\n\ndef version(): # not payable\n  return version[0 len version.length]\n\ndef balanceOf(address _owner): # not payable\n  require calldata.size - 4 >= 32\n  return balanceOf[addr(_owner)]\n\ndef getRelay(address _param1): # not payable\n  require calldata.size - 4 >= 32\n  require relay[addr(_param1)].field_928 <= 3\n  return relay[addr(_param1)].field_0, \n         relay[addr(_param1)].field_256,\n         relay[addr(_param1)].field_512,\n         relay[addr(_param1)].field_768,\n         relay[addr(_param1)].field_928\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef requiredGas(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return (_param1 + 398204)\n\ndef maxPossibleCharge(uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require calldata.size - 4 >= 96\n  return ((39820400 * _param2) + (398204 * _param3 * _param2) + (100 * _param1 * _param2) + (_param3 * _param1 * _param2) / 100)\n\ndef unknown85f4498b(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  if not relay[addr(_param1)].field_512:\n      return bool(relay[addr(_param1)].field_512)\n  return block.timestamp >= relay[addr(_param1)].field_512\n\ndef depositFor(address _address) payable: \n  require calldata.size - 4 >= 32\n  if call.value > 2 * 10^18:\n      revert with 0, 'deposit too big'\n  if call.value + balanceOf[addr(_address)] < balanceOf[addr(_address)]:\n      revert with 0, 'SafeMath: addition overflow'\n  balanceOf[addr(_address)] += call.value\n  log 0x8752a472: call.value, _address, caller\n\ndef withdraw(uint256 _amount, address _recepient): # not payable\n  require calldata.size - 4 >= 64\n  if _amount > balanceOf[caller]:\n      revert with 0, 'insufficient funds'\n  balanceOf[caller] -= _amount\n  call _recepient with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log Withdrawn(\n        address investor=_amount,\n        address beneficiary=caller,\n        uint256 weiAmount=_recepient)\n\ndef removeRelayByOwner(address _param1): # not payable\n  require calldata.size - 4 >= 32\n  if relay[addr(_param1)].field_768 != caller:\n      revert with 0, 'not owner'\n  require relay[addr(_param1)].field_928 <= 3\n  if relay[addr(_param1)].field_928 != 1:\n      require relay[addr(_param1)].field_928 <= 3\n      if relay[addr(_param1)].field_928 != 2:\n          revert with 0, 'already removed'\n  relay[addr(_param1)].field_512 = block.timestamp + relay[addr(_param1)].field_256\n  relay[addr(_param1)].field_928 = 3\n  log 0x5490afc1: (block.timestamp + relay[addr(_param1)].field_256), _param1\n\ndef unstake(address _whitelistAddress): # not payable\n  require calldata.size - 4 >= 32\n  if not relay[addr(_whitelistAddress)].field_512:\n      revert with 0, 'canUnstake failed'\n  if block.timestamp < relay[addr(_whitelistAddress)].field_512:\n      revert with 0, 'canUnstake failed'\n  if relay[addr(_whitelistAddress)].field_768 != caller:\n      revert with 0, 'not owner'\n  relay[addr(_whitelistAddress)].field_0 = 0\n  relay[addr(_whitelistAddress)].field_256 = 0\n  relay[addr(_whitelistAddress)].field_512 = 0\n  relay[addr(_whitelistAddress)].field_768 = 0\n  call caller with:\n     value relay[addr(_whitelistAddress)].field_0 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log 0xf5bb8217: relay[addr(_whitelistAddress)].field_0, _whitelistAddress\n\ndef unknown1166073a(uint256 _param1, array _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  if tx.origin != caller:\n      revert with 0, \n                  32,\n                  35,\n                  0x44436f6e7472616374732063616e6e6f742072656769737465722061732072656c6179,\n                  mem[ceil32(_param2.length) + 231 len 29]\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 1:\n      require relay[caller].field_928 <= 3\n      if relay[caller].field_928 != 2:\n          revert with 0, 'wrong state for stake'\n  if eth.balance(caller) < 10^17:\n      revert with 0, 'balance lower than minimum'\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 2:\n      relay[caller].field_928 = 2\n  mem[ceil32(_param2.length) + 128] = _param1\n  mem[ceil32(_param2.length) + 160] = relay[caller].field_0\n  log 0x85b3ae3a: Mask(8 * -ceil32(_param2.length) + _param2.length + 32, 0, 0), mem[_param2.length + 160 len ceil32(_param2.length) + -_param2.length + 32], relay[caller].field_256, Array(len=_param2.length, data=_param2[all]), caller, relay[caller].field_768\n\ndef relayCall(address _param1, address _param2, bytes _param3, uint256 _param4, uint256 _param5, uint256 _param6, uint256 _param7, bytes _param8, bytes _param9): # not payable\n  require calldata.size - 4 >= 288\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + _param3.length + 36 <= calldata.size\n  require _param8 <= 4294967296\n  require _param8 + 36 <= calldata.size\n  require _param8.length <= 4294967296 and _param8 + _param8.length + 36 <= calldata.size\n  require _param9 <= 4294967296\n  require _param9 + 36 <= calldata.size\n  require _param9.length <= 4294967296 and _param9 + _param9.length + 36 <= calldata.size\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 2:\n      revert with 0, 'Unknown relay'\n  if _param5 > block.gasprice:\n      revert with 0, 'Invalid gas price'\n  if 48204 > _param6 + 398204:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if gas_remaining < _param6 + 350000:\n      revert with 0, 'Not enough gasleft()'\n  if (39820400 * _param5) + (398204 * _param4 * _param5) + (100 * _param6 * _param5) + (_param4 * _param6 * _param5) / 100 > balanceOf[addr(_param2)]:\n      revert with 0, 'Recipient balance too low'\n  if _param3.length < 4:\n      revert with 0, \n                  32,\n                  37,\n                  0x44475245415445525f4f525f455155414c5f544f5f345f4c454e4754485f52455155495245,\n                  mem[ceil32(_param3.length) + ceil32(_param8.length) + ceil32(_param9.length) + 297 len 27]\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef stake(address _param1, uint256 _param2) payable: \n  require calldata.size - 4 >= 64\n  require relay[addr(_param1)].field_928 <= 3\n  if not relay[addr(_param1)].field_928:\n      if _param1 == caller:\n          revert with 0, 'relay cannot stake for itself'\n      relay[addr(_param1)].field_768 = caller\n      relay[addr(_param1)].field_928 = 1\n      relay[addr(_param1)].field_936 = Mask(88, 168, caller) >> 168\n  else:\n      require relay[addr(_param1)].field_928 <= 3\n      if relay[addr(_param1)].field_928 != 1:\n          require relay[addr(_param1)].field_928 <= 3\n          if relay[addr(_param1)].field_928 != 2:\n              revert with 0, 'wrong state for stake'\n      if relay[addr(_param1)].field_768 != caller:\n          revert with 0, 'not owner'\n  relay[addr(_param1)].field_0 += call.value\n  if 10^18 > call.value + relay[addr(_param1)].field_0:\n      revert with 0, 'stake lower than minimum'\n  if _param2 < 168 * 24 * 3600:\n      revert with 0, 'delay lower than minimum'\n  if _param2 > 2016 * 24 * 3600:\n      revert with 0, 'delay higher than maximum'\n  if _param2 < relay[addr(_param1)].field_256:\n      revert with 0, 'unstakeDelay cannot be decreased'\n  relay[addr(_param1)].field_256 = _param2\n  log Staked(\n        address to=relay[addr(_param1)].field_0,\n        uint256 value=_param2,\n        uint256 tokenId=_param1)\n\ndef unknown39002432(array _param1, array _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param1 <= 4294967296\n  require _param1 + 36 <= calldata.size\n  require _param1.length <= 4294967296 and _param1 + _param1.length + 36 <= calldata.size\n  mem[128 len _param1.length] = _param1[all]\n  mem[_param1.length + 128] = 0\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[ceil32(_param1.length) + 128] = _param2.length\n  if _param1.length:\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 < 192:\n          revert with 0, 'isList failed'\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 128:\n          if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 184:\n              if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 192:\n                  if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 248:\n  else:\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 < 192:\n          revert with 0, 'isList failed'\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 128:\n          if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 184:\n              if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 192:\n                  if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 248:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown2ca70eba(addr _param1, array _param2, uint256 _param3, uint256 _param4, uint256 _param5, uint256 _param6, array _param7): # not payable\n  require calldata.size - 4 >= 224\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  require _param7 <= 4294967296\n  require _param7 + 36 <= calldata.size\n  require _param7.length <= 4294967296 and _param7 + _param7.length + 36 <= calldata.size\n  mem[96] = gas_remaining\n  if caller != this.address:\n      revert with 0, 32, 39, 0xfe4f6e6c792052656c61794875622073686f756c642063616c6c20746869732066756e6374696f, mem[331 len 25]\n  mem[0] = _param1\n  mem[32] = 2\n  mem[128] = balanceOf[addr(_param1)]\n  mem[260] = 32\n  mem[292] = _param7.length\n  mem[324 len _param7.length] = _param7[all]\n  mem[_param7.length + 324] = 0\n  mem[224] = ceil32(_param7.length) + 68\n  mem[260 len 28] = 0\n  mem[256 len 4] = preRelayedCall(bytes param1)\n  mem[ceil32(_param7.length) + 324 len floor32(ceil32(_param7.length) + 68)] = preRelayedCall(bytes param1), 0, 0, mem[292 len floor32(ceil32(_param7.length) + 68) - 36]\n  mem[ceil32(_param7.length) + floor32(ceil32(_param7.length) + 68) + -(ceil32(_param7.length) + 68 % 32) + 356 len ceil32(_param7.length) + 68 % 32] = mem[(2 * floor32(ceil32(_param7.length) + 68)) + -(ceil32(_param7.length) + 68 % 32) + -ceil32(_param7.length) + 188 len ceil32(_param7.length) + 68 % 32]\n  call _param1.mem[floor32(ceil32(_param7.length) + 68) + 224 len 4] with:\n       gas 100000 wei\n      args Mask(8 * -ceil32(_param7.length) + _param7.length + 28, 0, 0), mem[_param7.length + 356 len (2 * ceil32(_param7.length)) + -_param7.length + 36]\n  if return_data.size:\n      mem[ceil32(_param7.length) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]\n      if not ext_call.success:\n          revert with 2\n      require return_data.size >= 32\n      mem[160] = mem[ceil32(_param7.length) + 356]\n      mem[ceil32(_param7.length) + ceil32(return_data.size) + 325 len _param2.length] = _param2[all]\n      call _param1 with:\n           gas _param5 wei\n          args _param2[all]\n      if not return_data.size:\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 457] = mem[160]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 489] = _param7.length\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 521 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + _param7.length + 521] = 0\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 521 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, mem[160], mem[ceil32(_param7.length) + ceil32(return_data.size) + 489 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 553 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + 325 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 525 len (6 * ceil32(_param7.length)) + 160]\n      else:\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 458] = mem[160]\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 490] = _param7.length\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 522 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + _param7.length + 522] = 0\n          mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + 522 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, mem[160], mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 490 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 554 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + floor32(ceil32(_param7.length) + 164) + 326 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + 526 len (6 * ceil32(_param7.length)) + 160]\n  else:\n      if not ext_call.success:\n          mem[ceil32(_param7.length) + 356] = 2\n          mem[ceil32(_param7.length) + 324] = 32\n          revert with memory\n            from ceil32(_param7.length) + 356\n             len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]\n      require gas_remaining >= 32\n      mem[160] = balanceOf[addr(_param1)]\n      mem[ceil32(_param7.length) + 324 len _param2.length] = _param2[all]\n      call _param1 with:\n           gas _param5 wei\n          args _param2[all]\n      if return_data.size:\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 457] = balanceOf[addr(_param1)]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 489] = _param7.length\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 521 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + _param7.length + 521] = 0\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 521 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, balanceOf[addr(_param1)], mem[ceil32(_param7.length) + ceil32(return_data.size) + 489 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 553 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + 325 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 525 len (6 * ceil32(_param7.length)) + 160]\n      else:\n          mem[192] = bool(ext_call.success)\n          mem[ceil32(_param7.length) + 392] = bool(ext_call.success)\n          mem[ceil32(_param7.length) + 424] = (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100\n          mem[ceil32(_param7.length) + 456] = balanceOf[addr(_param1)]\n          mem[ceil32(_param7.length) + 360] = 128\n          mem[ceil32(_param7.length) + 488] = _param7.length\n          mem[ceil32(_param7.length) + 520 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + _param7.length + 520] = 0\n          mem[ceil32(_param7.length) + 324] = ceil32(_param7.length) + 164\n          mem[64] = (2 * ceil32(_param7.length)) + 520\n          mem[ceil32(_param7.length) + 356 len 4] = postRelayedCall(bytes param1, bool param2, uint256 param3, bytes32 param4)\n          mem[(2 * ceil32(_param7.length)) + 520 len floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)])] = mem[ceil32(_param7.length) + 356 len floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)])]\n          mem[(2 * ceil32(_param7.length)) + floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]) + -(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32) + 552 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32] = mem[ceil32(_param7.length) + floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]) + -(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32) + 388 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32]\n          call _param1.mem[(2 * ceil32(_param7.length)) + 520 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + 524 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] + (4 * ceil32(_param7.length)) - 4]\n  if not ext_call.success:\n      revert with 3\n  if balanceOf[addr(_param1)] < balanceOf[addr(_param1)]:\n      revert with 4\n  if ext_call.success:\n      return 0\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n#\n#  I failed with these: \n#  - unknown2b601747(?)\n#  - unknowna8cd9572(?)\n#  All the rest is below.\n#\n\ndef storage:\n  nonce is mapping of uint256 at storage 0\n  relay is mapping of struct at storage 1\n  balanceOf is mapping of uint256 at storage 2\n  version is array of uint256 at storage 3\n\ndef getNonce(address _addr): # not payable\n  require calldata.size - 4 >= 32\n  return nonce[addr(_addr)]\n\ndef version(): # not payable\n  return version[0 len version.length]\n\ndef balanceOf(address _owner): # not payable\n  require calldata.size - 4 >= 32\n  return balanceOf[addr(_owner)]\n\ndef getRelay(address _param1): # not payable\n  require calldata.size - 4 >= 32\n  require relay[addr(_param1)].field_928 <= 3\n  return relay[addr(_param1)].field_0, \n         relay[addr(_param1)].field_256,\n         relay[addr(_param1)].field_512,\n         relay[addr(_param1)].field_768,\n         relay[addr(_param1)].field_928\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef requiredGas(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return (_param1 + 398204)\n\ndef maxPossibleCharge(uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require calldata.size - 4 >= 96\n  return ((39820400 * _param2) + (398204 * _param3 * _param2) + (100 * _param1 * _param2) + (_param3 * _param1 * _param2) / 100)\n\ndef unknown85f4498b(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  if not relay[addr(_param1)].field_512:\n      return bool(relay[addr(_param1)].field_512)\n  return block.timestamp >= relay[addr(_param1)].field_512\n\ndef depositFor(address _address) payable: \n  require calldata.size - 4 >= 32\n  if call.value > 2 * 10^18:\n      revert with 0, 'deposit too big'\n  if call.value + balanceOf[addr(_address)] < balanceOf[addr(_address)]:\n      revert with 0, 'SafeMath: addition overflow'\n  balanceOf[addr(_address)] += call.value\n  log 0x8752a472: call.value, _address, caller\n\ndef withdraw(uint256 _amount, address _recepient): # not payable\n  require calldata.size - 4 >= 64\n  if _amount > balanceOf[caller]:\n      revert with 0, 'insufficient funds'\n  balanceOf[caller] -= _amount\n  call _recepient with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log Withdrawn(\n        address investor=_amount,\n        address beneficiary=caller,\n        uint256 weiAmount=_recepient)\n\ndef removeRelayByOwner(address _param1): # not payable\n  require calldata.size - 4 >= 32\n  if relay[addr(_param1)].field_768 != caller:\n      revert with 0, 'not owner'\n  require relay[addr(_param1)].field_928 <= 3\n  if relay[addr(_param1)].field_928 != 1:\n      require relay[addr(_param1)].field_928 <= 3\n      if relay[addr(_param1)].field_928 != 2:\n          revert with 0, 'already removed'\n  relay[addr(_param1)].field_512 = block.timestamp + relay[addr(_param1)].field_256\n  relay[addr(_param1)].field_928 = 3\n  log 0x5490afc1: (block.timestamp + relay[addr(_param1)].field_256), _param1\n\ndef unstake(address _whitelistAddress): # not payable\n  require calldata.size - 4 >= 32\n  if not relay[addr(_whitelistAddress)].field_512:\n      revert with 0, 'canUnstake failed'\n  if block.timestamp < relay[addr(_whitelistAddress)].field_512:\n      revert with 0, 'canUnstake failed'\n  if relay[addr(_whitelistAddress)].field_768 != caller:\n      revert with 0, 'not owner'\n  relay[addr(_whitelistAddress)].field_0 = 0\n  relay[addr(_whitelistAddress)].field_256 = 0\n  relay[addr(_whitelistAddress)].field_512 = 0\n  relay[addr(_whitelistAddress)].field_768 = 0\n  call caller with:\n     value relay[addr(_whitelistAddress)].field_0 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log 0xf5bb8217: relay[addr(_whitelistAddress)].field_0, _whitelistAddress\n\ndef unknown1166073a(uint256 _param1, array _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  if tx.origin != caller:\n      revert with 0, \n                  32,\n                  35,\n                  0x44436f6e7472616374732063616e6e6f742072656769737465722061732072656c6179,\n                  mem[ceil32(_param2.length) + 231 len 29]\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 1:\n      require relay[caller].field_928 <= 3\n      if relay[caller].field_928 != 2:\n          revert with 0, 'wrong state for stake'\n  if eth.balance(caller) < 10^17:\n      revert with 0, 'balance lower than minimum'\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 2:\n      relay[caller].field_928 = 2\n  mem[ceil32(_param2.length) + 128] = _param1\n  mem[ceil32(_param2.length) + 160] = relay[caller].field_0\n  log 0x85b3ae3a: Mask(8 * -ceil32(_param2.length) + _param2.length + 32, 0, 0), mem[_param2.length + 160 len ceil32(_param2.length) + -_param2.length + 32], relay[caller].field_256, Array(len=_param2.length, data=_param2[all]), caller, relay[caller].field_768\n\ndef relayCall(address _param1, address _param2, bytes _param3, uint256 _param4, uint256 _param5, uint256 _param6, uint256 _param7, bytes _param8, bytes _param9): # not payable\n  require calldata.size - 4 >= 288\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + _param3.length + 36 <= calldata.size\n  require _param8 <= 4294967296\n  require _param8 + 36 <= calldata.size\n  require _param8.length <= 4294967296 and _param8 + _param8.length + 36 <= calldata.size\n  require _param9 <= 4294967296\n  require _param9 + 36 <= calldata.size\n  require _param9.length <= 4294967296 and _param9 + _param9.length + 36 <= calldata.size\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 2:\n      revert with 0, 'Unknown relay'\n  if _param5 > block.gasprice:\n      revert with 0, 'Invalid gas price'\n  if 48204 > _param6 + 398204:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if gas_remaining < _param6 + 350000:\n      revert with 0, 'Not enough gasleft()'\n  if (39820400 * _param5) + (398204 * _param4 * _param5) + (100 * _param6 * _param5) + (_param4 * _param6 * _param5) / 100 > balanceOf[addr(_param2)]:\n      revert with 0, 'Recipient balance too low'\n  if _param3.length < 4:\n      revert with 0, \n                  32,\n                  37,\n                  0x44475245415445525f4f525f455155414c5f544f5f345f4c454e4754485f52455155495245,\n                  mem[ceil32(_param3.length) + ceil32(_param8.length) + ceil32(_param9.length) + 297 len 27]\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef stake(address _param1, uint256 _param2) payable: \n  require calldata.size - 4 >= 64\n  require relay[addr(_param1)].field_928 <= 3\n  if not relay[addr(_param1)].field_928:\n      if _param1 == caller:\n          revert with 0, 'relay cannot stake for itself'\n      relay[addr(_param1)].field_768 = caller\n      relay[addr(_param1)].field_928 = 1\n      relay[addr(_param1)].field_936 = Mask(88, 168, caller) >> 168\n  else:\n      require relay[addr(_param1)].field_928 <= 3\n      if relay[addr(_param1)].field_928 != 1:\n          require relay[addr(_param1)].field_928 <= 3\n          if relay[addr(_param1)].field_928 != 2:\n              revert with 0, 'wrong state for stake'\n      if relay[addr(_param1)].field_768 != caller:\n          revert with 0, 'not owner'\n  relay[addr(_param1)].field_0 += call.value\n  if 10^18 > call.value + relay[addr(_param1)].field_0:\n      revert with 0, 'stake lower than minimum'\n  if _param2 < 168 * 24 * 3600:\n      revert with 0, 'delay lower than minimum'\n  if _param2 > 2016 * 24 * 3600:\n      revert with 0, 'delay higher than maximum'\n  if _param2 < relay[addr(_param1)].field_256:\n      revert with 0, 'unstakeDelay cannot be decreased'\n  relay[addr(_param1)].field_256 = _param2\n  log Staked(\n        address to=relay[addr(_param1)].field_0,\n        uint256 value=_param2,\n        uint256 tokenId=_param1)\n\ndef unknown39002432(array _param1, array _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param1 <= 4294967296\n  require _param1 + 36 <= calldata.size\n  require _param1.length <= 4294967296 and _param1 + _param1.length + 36 <= calldata.size\n  mem[128 len _param1.length] = _param1[all]\n  mem[_param1.length + 128] = 0\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[ceil32(_param1.length) + 128] = _param2.length\n  if _param1.length:\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 < 192:\n          revert with 0, 'isList failed'\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 128:\n          if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 184:\n              if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 192:\n                  if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 248:\n  else:\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 < 192:\n          revert with 0, 'isList failed'\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 128:\n          if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 184:\n              if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 192:\n                  if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 248:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown2ca70eba(addr _param1, array _param2, uint256 _param3, uint256 _param4, uint256 _param5, uint256 _param6, array _param7): # not payable\n  require calldata.size - 4 >= 224\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  require _param7 <= 4294967296\n  require _param7 + 36 <= calldata.size\n  require _param7.length <= 4294967296 and _param7 + _param7.length + 36 <= calldata.size\n  mem[96] = gas_remaining\n  if caller != this.address:\n      revert with 0, 32, 39, 0xfe4f6e6c792052656c61794875622073686f756c642063616c6c20746869732066756e6374696f, mem[331 len 25]\n  mem[0] = _param1\n  mem[32] = 2\n  mem[128] = balanceOf[addr(_param1)]\n  mem[260] = 32\n  mem[292] = _param7.length\n  mem[324 len _param7.length] = _param7[all]\n  mem[_param7.length + 324] = 0\n  mem[224] = ceil32(_param7.length) + 68\n  mem[260 len 28] = 0\n  mem[256 len 4] = preRelayedCall(bytes param1)\n  mem[ceil32(_param7.length) + 324 len floor32(ceil32(_param7.length) + 68)] = preRelayedCall(bytes param1), 0, 0, mem[292 len floor32(ceil32(_param7.length) + 68) - 36]\n  mem[ceil32(_param7.length) + floor32(ceil32(_param7.length) + 68) + -(ceil32(_param7.length) + 68 % 32) + 356 len ceil32(_param7.length) + 68 % 32] = mem[(2 * floor32(ceil32(_param7.length) + 68)) + -(ceil32(_param7.length) + 68 % 32) + -ceil32(_param7.length) + 188 len ceil32(_param7.length) + 68 % 32]\n  call _param1.mem[floor32(ceil32(_param7.length) + 68) + 224 len 4] with:\n       gas 100000 wei\n      args Mask(8 * -ceil32(_param7.length) + _param7.length + 28, 0, 0), mem[_param7.length + 356 len (2 * ceil32(_param7.length)) + -_param7.length + 36]\n  if return_data.size:\n      mem[ceil32(_param7.length) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]\n      if not ext_call.success:\n          revert with 2\n      require return_data.size >= 32\n      mem[160] = mem[ceil32(_param7.length) + 356]\n      mem[ceil32(_param7.length) + ceil32(return_data.size) + 325 len _param2.length] = _param2[all]\n      call _param1 with:\n           gas _param5 wei\n          args _param2[all]\n      if not return_data.size:\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 457] = mem[160]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 489] = _param7.length\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 521 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + _param7.length + 521] = 0\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 521 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, mem[160], mem[ceil32(_param7.length) + ceil32(return_data.size) + 489 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 553 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + 325 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 525 len (6 * ceil32(_param7.length)) + 160]\n      else:\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 458] = mem[160]\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 490] = _param7.length\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 522 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + _param7.length + 522] = 0\n          mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + 522 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, mem[160], mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 490 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 554 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + floor32(ceil32(_param7.length) + 164) + 326 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + 526 len (6 * ceil32(_param7.length)) + 160]\n  else:\n      if not ext_call.success:\n          mem[ceil32(_param7.length) + 356] = 2\n          mem[ceil32(_param7.length) + 324] = 32\n          revert with memory\n            from ceil32(_param7.length) + 356\n             len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]\n      require gas_remaining >= 32\n      mem[160] = balanceOf[addr(_param1)]\n      mem[ceil32(_param7.length) + 324 len _param2.length] = _param2[all]\n      call _param1 with:\n           gas _param5 wei\n          args _param2[all]\n      if return_data.size:\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 457] = balanceOf[addr(_param1)]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 489] = _param7.length\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 521 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + _param7.length + 521] = 0\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 521 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, balanceOf[addr(_param1)], mem[ceil32(_param7.length) + ceil32(return_data.size) + 489 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 553 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + 325 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 525 len (6 * ceil32(_param7.length)) + 160]\n      else:\n          mem[192] = bool(ext_call.success)\n          mem[ceil32(_param7.length) + 392] = bool(ext_call.success)\n          mem[ceil32(_param7.length) + 424] = (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100\n          mem[ceil32(_param7.length) + 456] = balanceOf[addr(_param1)]\n          mem[ceil32(_param7.length) + 360] = 128\n          mem[ceil32(_param7.length) + 488] = _param7.length\n          mem[ceil32(_param7.length) + 520 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + _param7.length + 520] = 0\n          mem[ceil32(_param7.length) + 324] = ceil32(_param7.length) + 164\n          mem[64] = (2 * ceil32(_param7.length)) + 520\n          mem[ceil32(_param7.length) + 356 len 4] = postRelayedCall(bytes param1, bool param2, uint256 param3, bytes32 param4)\n          mem[(2 * ceil32(_param7.length)) + 520 len floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)])] = mem[ceil32(_param7.length) + 356 len floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)])]\n          mem[(2 * ceil32(_param7.length)) + floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]) + -(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32) + 552 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32] = mem[ceil32(_param7.length) + floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]) + -(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32) + 388 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32]\n          call _param1.mem[(2 * ceil32(_param7.length)) + 520 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + 524 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] + (4 * ceil32(_param7.length)) - 4]\n  if not ext_call.success:\n      revert with 3\n  if balanceOf[addr(_param1)] < balanceOf[addr(_param1)]:\n      revert with 4\n  if ext_call.success:\n      return 0\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n#\n#  I failed with these: \n#  - unknown2b601747(?)\n#  - unknowna8cd9572(?)\n#  All the rest is below.\n#\n\ndef storage:\n  nonce is mapping of uint256 at storage 0\n  relay is mapping of struct at storage 1\n  balanceOf is mapping of uint256 at storage 2\n  version is array of uint256 at storage 3\n\ndef getNonce(address _addr): # not payable\n  require calldata.size - 4 >= 32\n  return nonce[addr(_addr)]\n\ndef version(): # not payable\n  return version[0 len version.length]\n\ndef balanceOf(address _owner): # not payable\n  require calldata.size - 4 >= 32\n  return balanceOf[addr(_owner)]\n\ndef getRelay(address _param1): # not payable\n  require calldata.size - 4 >= 32\n  require relay[addr(_param1)].field_928 <= 3\n  return relay[addr(_param1)].field_0, \n         relay[addr(_param1)].field_256,\n         relay[addr(_param1)].field_512,\n         relay[addr(_param1)].field_768,\n         relay[addr(_param1)].field_928\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  revert\n\ndef requiredGas(uint256 _param1): # not payable\n  require calldata.size - 4 >= 32\n  return (_param1 + 398204)\n\ndef maxPossibleCharge(uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require calldata.size - 4 >= 96\n  return ((39820400 * _param2) + (398204 * _param3 * _param2) + (100 * _param1 * _param2) + (_param3 * _param1 * _param2) / 100)\n\ndef unknown85f4498b(addr _param1): # not payable\n  require calldata.size - 4 >= 32\n  if not relay[addr(_param1)].field_512:\n      return bool(relay[addr(_param1)].field_512)\n  return block.timestamp >= relay[addr(_param1)].field_512\n\ndef depositFor(address _address) payable: \n  require calldata.size - 4 >= 32\n  if call.value > 2 * 10^18:\n      revert with 0, 'deposit too big'\n  if call.value + balanceOf[addr(_address)] < balanceOf[addr(_address)]:\n      revert with 0, 'SafeMath: addition overflow'\n  balanceOf[addr(_address)] += call.value\n  log 0x8752a472: call.value, _address, caller\n\ndef withdraw(uint256 _amount, address _recepient): # not payable\n  require calldata.size - 4 >= 64\n  if _amount > balanceOf[caller]:\n      revert with 0, 'insufficient funds'\n  balanceOf[caller] -= _amount\n  call _recepient with:\n     value _amount wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log Withdrawn(\n        address investor=_amount,\n        address beneficiary=caller,\n        uint256 weiAmount=_recepient)\n\ndef removeRelayByOwner(address _param1): # not payable\n  require calldata.size - 4 >= 32\n  if relay[addr(_param1)].field_768 != caller:\n      revert with 0, 'not owner'\n  require relay[addr(_param1)].field_928 <= 3\n  if relay[addr(_param1)].field_928 != 1:\n      require relay[addr(_param1)].field_928 <= 3\n      if relay[addr(_param1)].field_928 != 2:\n          revert with 0, 'already removed'\n  relay[addr(_param1)].field_512 = block.timestamp + relay[addr(_param1)].field_256\n  relay[addr(_param1)].field_928 = 3\n  log 0x5490afc1: (block.timestamp + relay[addr(_param1)].field_256), _param1\n\ndef unstake(address _whitelistAddress): # not payable\n  require calldata.size - 4 >= 32\n  if not relay[addr(_whitelistAddress)].field_512:\n      revert with 0, 'canUnstake failed'\n  if block.timestamp < relay[addr(_whitelistAddress)].field_512:\n      revert with 0, 'canUnstake failed'\n  if relay[addr(_whitelistAddress)].field_768 != caller:\n      revert with 0, 'not owner'\n  relay[addr(_whitelistAddress)].field_0 = 0\n  relay[addr(_whitelistAddress)].field_256 = 0\n  relay[addr(_whitelistAddress)].field_512 = 0\n  relay[addr(_whitelistAddress)].field_768 = 0\n  call caller with:\n     value relay[addr(_whitelistAddress)].field_0 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log 0xf5bb8217: relay[addr(_whitelistAddress)].field_0, _whitelistAddress\n\ndef unknown1166073a(uint256 _param1, array _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  if tx.origin != caller:\n      revert with 0, \n                  32,\n                  35,\n                  0x44436f6e7472616374732063616e6e6f742072656769737465722061732072656c6179,\n                  mem[ceil32(_param2.length) + 231 len 29]\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 1:\n      require relay[caller].field_928 <= 3\n      if relay[caller].field_928 != 2:\n          revert with 0, 'wrong state for stake'\n  if eth.balance(caller) < 10^17:\n      revert with 0, 'balance lower than minimum'\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 2:\n      relay[caller].field_928 = 2\n  mem[ceil32(_param2.length) + 128] = _param1\n  mem[ceil32(_param2.length) + 160] = relay[caller].field_0\n  log 0x85b3ae3a: Mask(8 * -ceil32(_param2.length) + _param2.length + 32, 0, 0), mem[_param2.length + 160 len ceil32(_param2.length) + -_param2.length + 32], relay[caller].field_256, Array(len=_param2.length, data=_param2[all]), caller, relay[caller].field_768\n\ndef relayCall(address _param1, address _param2, bytes _param3, uint256 _param4, uint256 _param5, uint256 _param6, uint256 _param7, bytes _param8, bytes _param9): # not payable\n  require calldata.size - 4 >= 288\n  require _param3 <= 4294967296\n  require _param3 + 36 <= calldata.size\n  require _param3.length <= 4294967296 and _param3 + _param3.length + 36 <= calldata.size\n  require _param8 <= 4294967296\n  require _param8 + 36 <= calldata.size\n  require _param8.length <= 4294967296 and _param8 + _param8.length + 36 <= calldata.size\n  require _param9 <= 4294967296\n  require _param9 + 36 <= calldata.size\n  require _param9.length <= 4294967296 and _param9 + _param9.length + 36 <= calldata.size\n  require relay[caller].field_928 <= 3\n  if relay[caller].field_928 != 2:\n      revert with 0, 'Unknown relay'\n  if _param5 > block.gasprice:\n      revert with 0, 'Invalid gas price'\n  if 48204 > _param6 + 398204:\n      revert with 0, 'SafeMath: subtraction overflow'\n  if gas_remaining < _param6 + 350000:\n      revert with 0, 'Not enough gasleft()'\n  if (39820400 * _param5) + (398204 * _param4 * _param5) + (100 * _param6 * _param5) + (_param4 * _param6 * _param5) / 100 > balanceOf[addr(_param2)]:\n      revert with 0, 'Recipient balance too low'\n  if _param3.length < 4:\n      revert with 0, \n                  32,\n                  37,\n                  0x44475245415445525f4f525f455155414c5f544f5f345f4c454e4754485f52455155495245,\n                  mem[ceil32(_param3.length) + ceil32(_param8.length) + ceil32(_param9.length) + 297 len 27]\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef stake(address _param1, uint256 _param2) payable: \n  require calldata.size - 4 >= 64\n  require relay[addr(_param1)].field_928 <= 3\n  if not relay[addr(_param1)].field_928:\n      if _param1 == caller:\n          revert with 0, 'relay cannot stake for itself'\n      relay[addr(_param1)].field_768 = caller\n      relay[addr(_param1)].field_928 = 1\n      relay[addr(_param1)].field_936 = Mask(88, 168, caller) >> 168\n  else:\n      require relay[addr(_param1)].field_928 <= 3\n      if relay[addr(_param1)].field_928 != 1:\n          require relay[addr(_param1)].field_928 <= 3\n          if relay[addr(_param1)].field_928 != 2:\n              revert with 0, 'wrong state for stake'\n      if relay[addr(_param1)].field_768 != caller:\n          revert with 0, 'not owner'\n  relay[addr(_param1)].field_0 += call.value\n  if 10^18 > call.value + relay[addr(_param1)].field_0:\n      revert with 0, 'stake lower than minimum'\n  if _param2 < 168 * 24 * 3600:\n      revert with 0, 'delay lower than minimum'\n  if _param2 > 2016 * 24 * 3600:\n      revert with 0, 'delay higher than maximum'\n  if _param2 < relay[addr(_param1)].field_256:\n      revert with 0, 'unstakeDelay cannot be decreased'\n  relay[addr(_param1)].field_256 = _param2\n  log Staked(\n        address to=relay[addr(_param1)].field_0,\n        uint256 value=_param2,\n        uint256 tokenId=_param1)\n\ndef unknown39002432(array _param1, array _param2): # not payable\n  require calldata.size - 4 >= 64\n  require _param1 <= 4294967296\n  require _param1 + 36 <= calldata.size\n  require _param1.length <= 4294967296 and _param1 + _param1.length + 36 <= calldata.size\n  mem[128 len _param1.length] = _param1[all]\n  mem[_param1.length + 128] = 0\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  mem[ceil32(_param1.length) + 128] = _param2.length\n  if _param1.length:\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 < 192:\n          revert with 0, 'isList failed'\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 128:\n          if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 184:\n              if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 192:\n                  if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 128, 32))), 0) - 256 >= 248:\n  else:\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 < 192:\n          revert with 0, 'isList failed'\n      if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 128:\n          if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 184:\n              if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 192:\n                  if Mask(8, -(('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) + 256, 0) << (('mask_shl', 256, 0, -3, ('mem', ('range', 0, 32))), 0) - 256 >= 248:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef unknown2ca70eba(addr _param1, array _param2, uint256 _param3, uint256 _param4, uint256 _param5, uint256 _param6, array _param7): # not payable\n  require calldata.size - 4 >= 224\n  require _param2 <= 4294967296\n  require _param2 + 36 <= calldata.size\n  require _param2.length <= 4294967296 and _param2 + _param2.length + 36 <= calldata.size\n  require _param7 <= 4294967296\n  require _param7 + 36 <= calldata.size\n  require _param7.length <= 4294967296 and _param7 + _param7.length + 36 <= calldata.size\n  mem[96] = gas_remaining\n  if caller != this.address:\n      revert with 0, 32, 39, 0xfe4f6e6c792052656c61794875622073686f756c642063616c6c20746869732066756e6374696f, mem[331 len 25]\n  mem[0] = _param1\n  mem[32] = 2\n  mem[128] = balanceOf[addr(_param1)]\n  mem[260] = 32\n  mem[292] = _param7.length\n  mem[324 len _param7.length] = _param7[all]\n  mem[_param7.length + 324] = 0\n  mem[224] = ceil32(_param7.length) + 68\n  mem[260 len 28] = 0\n  mem[256 len 4] = preRelayedCall(bytes param1)\n  mem[ceil32(_param7.length) + 324 len floor32(ceil32(_param7.length) + 68)] = preRelayedCall(bytes param1), 0, 0, mem[292 len floor32(ceil32(_param7.length) + 68) - 36]\n  mem[ceil32(_param7.length) + floor32(ceil32(_param7.length) + 68) + -(ceil32(_param7.length) + 68 % 32) + 356 len ceil32(_param7.length) + 68 % 32] = mem[(2 * floor32(ceil32(_param7.length) + 68)) + -(ceil32(_param7.length) + 68 % 32) + -ceil32(_param7.length) + 188 len ceil32(_param7.length) + 68 % 32]\n  call _param1.mem[floor32(ceil32(_param7.length) + 68) + 224 len 4] with:\n       gas 100000 wei\n      args Mask(8 * -ceil32(_param7.length) + _param7.length + 28, 0, 0), mem[_param7.length + 356 len (2 * ceil32(_param7.length)) + -_param7.length + 36]\n  if return_data.size:\n      mem[ceil32(_param7.length) + 356 len return_data.size] = ext_call.return_data[0 len return_data.size]\n      if not ext_call.success:\n          revert with 2\n      require return_data.size >= 32\n      mem[160] = mem[ceil32(_param7.length) + 356]\n      mem[ceil32(_param7.length) + ceil32(return_data.size) + 325 len _param2.length] = _param2[all]\n      call _param1 with:\n           gas _param5 wei\n          args _param2[all]\n      if not return_data.size:\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 457] = mem[160]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 489] = _param7.length\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 521 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + _param7.length + 521] = 0\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 521 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, mem[160], mem[ceil32(_param7.length) + ceil32(return_data.size) + 489 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 553 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + 325 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 525 len (6 * ceil32(_param7.length)) + 160]\n      else:\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 458] = mem[160]\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 490] = _param7.length\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 522 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + _param7.length + 522] = 0\n          mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + 522 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, mem[160], mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + 490 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 554 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + (2 * ceil32(return_data.size)) + floor32(ceil32(_param7.length) + 164) + 326 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + (2 * ceil32(return_data.size)) + 526 len (6 * ceil32(_param7.length)) + 160]\n  else:\n      if not ext_call.success:\n          mem[ceil32(_param7.length) + 356] = 2\n          mem[ceil32(_param7.length) + 324] = 32\n          revert with memory\n            from ceil32(_param7.length) + 356\n             len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]\n      require gas_remaining >= 32\n      mem[160] = balanceOf[addr(_param1)]\n      mem[ceil32(_param7.length) + 324 len _param2.length] = _param2[all]\n      call _param1 with:\n           gas _param5 wei\n          args _param2[all]\n      if return_data.size:\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 457] = balanceOf[addr(_param1)]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 489] = _param7.length\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + 521 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + ceil32(return_data.size) + _param7.length + 521] = 0\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 521 len floor32(ceil32(_param7.length) + 164)] = 0, 128, bool(ext_call.success), (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100, balanceOf[addr(_param1)], mem[ceil32(_param7.length) + ceil32(return_data.size) + 489 len floor32(ceil32(_param7.length) + 164) - 132]\n          mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + -(ceil32(_param7.length) + 164 % 32) + 553 len ceil32(_param7.length) + 164 % 32] = Mask(8 * ceil32(_param7.length) + 164 % 32, -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256, 0) >> -(8 * floor32(ceil32(_param7.length) + 164) + -_param7.length - 132) + 256\n          call _param1.mem[ceil32(_param7.length) + ceil32(return_data.size) + floor32(ceil32(_param7.length) + 164) + 325 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + ceil32(return_data.size) + 525 len (6 * ceil32(_param7.length)) + 160]\n      else:\n          mem[192] = bool(ext_call.success)\n          mem[ceil32(_param7.length) + 392] = bool(ext_call.success)\n          mem[ceil32(_param7.length) + 424] = (15320400 * _param4) + (153204 * _param3 * _param4) + (100 * _param6 * _param4) + (_param3 * _param6 * _param4) + (100 * gas_remaining * _param4) + (_param3 * gas_remaining * _param4) - (100 * gas_remaining * _param4) - (_param3 * gas_remaining * _param4) / 100\n          mem[ceil32(_param7.length) + 456] = balanceOf[addr(_param1)]\n          mem[ceil32(_param7.length) + 360] = 128\n          mem[ceil32(_param7.length) + 488] = _param7.length\n          mem[ceil32(_param7.length) + 520 len _param7.length] = _param7[all]\n          mem[ceil32(_param7.length) + _param7.length + 520] = 0\n          mem[ceil32(_param7.length) + 324] = ceil32(_param7.length) + 164\n          mem[64] = (2 * ceil32(_param7.length)) + 520\n          mem[ceil32(_param7.length) + 356 len 4] = postRelayedCall(bytes param1, bool param2, uint256 param3, bytes32 param4)\n          mem[(2 * ceil32(_param7.length)) + 520 len floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)])] = mem[ceil32(_param7.length) + 356 len floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)])]\n          mem[(2 * ceil32(_param7.length)) + floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]) + -(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32) + 552 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32] = mem[ceil32(_param7.length) + floor32(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)]) + -(Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32) + 388 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] % 32]\n          call _param1.mem[(2 * ceil32(_param7.length)) + 520 len 4] with:\n               gas 100000 wei\n              args mem[(2 * ceil32(_param7.length)) + 524 len Mask(8 * -ceil32(_param7.length) + _param7.length + 32, 0, 0), mem[_param7.length + 356 len -_param7.length + ceil32(_param7.length)] + (4 * ceil32(_param7.length)) - 4]\n  if not ext_call.success:\n      revert with 3\n  if balanceOf[addr(_param1)] < balanceOf[addr(_param1)]:\n      revert with 4\n  if ext_call.success:\n      return 0\n  return 1\n\n.",
	"status": "1",
	"time_cost": 31.31885600090027,
	"usage": {
		"completion_tokens": 620,
		"prompt_tokens": 7338,
		"total_tokens": 7958
	}
}