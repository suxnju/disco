{
	"address": "0xa9ab8efd9b3ea455d0b3e80773c0dd78bc258160",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract DecompiledContract {\n    uint256 private _price;\n    uint256 private stor_2;\n    mapping (uint256 => uint256[]) private _getMessages;\n    uint256 private _messageCount;\n    address private _ownerAccount;\n    uint256[] private _storage_;\n    address private stor_0_0_19;\n    address payable private _ownerWithdraw;\n\n    event StillKicking(uint256 _ownerAccount);\n\n    function price() public view returns (uint256) {\n        return _price;\n    }\n\n    function getMessages(uint256 index) public view returns (uint256[] memory) {\n        return _getMessages[index];\n    }\n\n    function storage_() public view returns (uint256[] memory) {\n        return _storage_;\n    }\n\n    function ownerAccount() public view returns (address) {\n        return _ownerAccount;\n    }\n\n    function _SafeMul(uint256 a, uint256 b) private pure returns (uint256) {\n        uint256 c = a * b;\n        require(b == 0 || c / b == a);\n        return c;\n    }\n\n    fallback() external payable {\n        revert();\n    }\n\n    function messageCount() public view returns (uint256) {\n        return _messageCount;\n    }\n\n    function ownerWithdraw() public {\n        require(msg.sender == _ownerWithdraw);\n        _ownerAccount = 0;\n        require(_ownerWithdraw.send(_ownerAccount));\n        emit StillKicking(_ownerAccount);\n    }\n\n    function buyMessage(string memory _message) public payable {\n        require(msg.value >= _price);\n        uint256 priceIncrease;\n        if (_price <= 0x2386f26fc10000) {\n            require(stor_2 <= _price);\n            priceIncrease = _price - stor_2;\n        } else {\n            require(stor_2 <= _price);\n            priceIncrease = _SafeMul(50, _price - stor_2) / 100;\n        }\n        require(_ownerAccount + priceIncrease >= _ownerAccount);\n        _ownerAccount += priceIncrease;\n        if (_price > 0x2386f26fc10000) {\n            require(stor_0_0_19.send(priceIncrease + stor_2));\n        }\n        stor_2 = _price;\n        _price = _SafeMul(_price, 125) / 100;\n        stor_0_0_19 = msg.sender;\n        bytes memory messageBytes = bytes(_message);\n        _storage_.push(uint256(messageBytes.length));\n        _getMessages[_messageCount] = _storage_;\n        _messageCount += 1;\n    }\n}\n```\n\nPlease note that the function `__function_selector__` is not a standard Solidity feature, and it's not possible to convert it directly to Solidity. It seems to be a part of the custom system for handling calls to this contract. In Solidity, this would typically be managed by the fallback function and the function modifiers such as `view`, `pure`, and `payable`.",
				"role": "assistant"
			}
		}
	],
	"created": 1701467669,
	"id": "chatcmpl-8R5krnUQpCG6jMlTUC8WMHVihXEVV",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 06:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _price; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getMessages; // STORAGE[0x4]\nuint256 _messageCount; // STORAGE[0x5]\nuint256 _ownerAccount; // STORAGE[0x6]\nuint256[] _storage_; // STORAGE[0x7]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\naddress _ownerWithdraw; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nstillKicking(uint256);\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction getMessages(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _getMessages[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction storage_() public nonPayable { \n    v0 = new bytes[](_storage_.length);\n    v1 = v2 = v0.data;\n    if (_storage_.length) {\n        if (31 < _storage_.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _storage_.length <= v1);\n        } else {\n            MEM[v2] = _storage_.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction ownerAccount() public nonPayable { \n    return _ownerAccount;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction messageCount() public nonPayable { \n    return _messageCount;\n}\n\nfunction ownerWithdraw() public nonPayable { \n    require(msg.sender == _ownerWithdraw);\n    _ownerAccount = 0;\n    v0 = _ownerWithdraw.call().value(_ownerAccount).gas(!_ownerAccount * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit stillKicking(_ownerAccount);\n}\n\nfunction buyMessage(string varg0) public payable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(msg.value >= _price);\n    if (_price <= 0x2386f26fc10000) {\n        assert(stor_2 <= _price);\n        v1 = v2 = _price - stor_2;\n        v1 = v3 = 0;\n    } else {\n        assert(stor_2 <= _price);\n        v4 = _SafeMul(50, _price - stor_2);\n        assert(100);\n        v1 = v4 / 100;\n    }\n    assert(_ownerAccount + v1 >= _ownerAccount);\n    _ownerAccount = _ownerAccount + v1;\n    if (_price > 0x2386f26fc10000) {\n        v5 = stor_0_0_19.call().value(v1 + stor_2).gas(!(v1 + stor_2) * 2300);\n        require(v5); // checks call status, propagates error data on error\n    }\n    stor_2 = _price;\n    v6 = _SafeMul(_price, 125);\n    assert(100);\n    _price = v6 / 100;\n    stor_0_0_19 = msg.sender;\n    v7 = v8 = v0.data;\n    if (31 < v0.length) {\n        _storage_.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v8 + v0.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _storage_.length = v0.length + v0.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _storage_.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n    v11 = v12 = v0.data;\n    if (31 < v0.length) {\n        _getMessages[_messageCount] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v12 + v0.length > v11) {\n                STORAGE[v13] = MEM[v11];\n                v11 += 32;\n                v13 += 1;\n            }\n        }\n    } else {\n        _getMessages[_messageCount] = v0.length + v0.length | ~0xff & MEM[v12];\n    }\n    while (v14 + (31 + (((!(0x1 & _getMessages[_messageCount]) << 8) - 1 & _getMessages[_messageCount]) >> 1) >> 5) > v13) {\n        STORAGE[v13] = 0;\n        v13 += 1;\n    }\n    _messageCount = _messageCount + 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x3dbcc8d1 == function_selector) {\n            messageCount();\n        } else if (0x4311de8f == function_selector) {\n            ownerWithdraw();\n        } else if (0x57c468e4 == function_selector) {\n            buyMessage(string);\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xae36853d == function_selector) {\n            getMessages(uint256);\n        } else if (0xc57b13b2 == function_selector) {\n            storage_();\n        } else if (0xea47cb24 == function_selector) {\n            ownerAccount();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 06:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _price; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getMessages; // STORAGE[0x4]\nuint256 _messageCount; // STORAGE[0x5]\nuint256 _ownerAccount; // STORAGE[0x6]\nuint256[] _storage_; // STORAGE[0x7]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\naddress _ownerWithdraw; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nstillKicking(uint256);\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction getMessages(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _getMessages[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction storage_() public nonPayable { \n    v0 = new bytes[](_storage_.length);\n    v1 = v2 = v0.data;\n    if (_storage_.length) {\n        if (31 < _storage_.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _storage_.length <= v1);\n        } else {\n            MEM[v2] = _storage_.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction ownerAccount() public nonPayable { \n    return _ownerAccount;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction messageCount() public nonPayable { \n    return _messageCount;\n}\n\nfunction ownerWithdraw() public nonPayable { \n    require(msg.sender == _ownerWithdraw);\n    _ownerAccount = 0;\n    v0 = _ownerWithdraw.call().value(_ownerAccount).gas(!_ownerAccount * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit stillKicking(_ownerAccount);\n}\n\nfunction buyMessage(string varg0) public payable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(msg.value >= _price);\n    if (_price <= 0x2386f26fc10000) {\n        assert(stor_2 <= _price);\n        v1 = v2 = _price - stor_2;\n        v1 = v3 = 0;\n    } else {\n        assert(stor_2 <= _price);\n        v4 = _SafeMul(50, _price - stor_2);\n        assert(100);\n        v1 = v4 / 100;\n    }\n    assert(_ownerAccount + v1 >= _ownerAccount);\n    _ownerAccount = _ownerAccount + v1;\n    if (_price > 0x2386f26fc10000) {\n        v5 = stor_0_0_19.call().value(v1 + stor_2).gas(!(v1 + stor_2) * 2300);\n        require(v5); // checks call status, propagates error data on error\n    }\n    stor_2 = _price;\n    v6 = _SafeMul(_price, 125);\n    assert(100);\n    _price = v6 / 100;\n    stor_0_0_19 = msg.sender;\n    v7 = v8 = v0.data;\n    if (31 < v0.length) {\n        _storage_.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v8 + v0.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _storage_.length = v0.length + v0.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _storage_.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n    v11 = v12 = v0.data;\n    if (31 < v0.length) {\n        _getMessages[_messageCount] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v12 + v0.length > v11) {\n                STORAGE[v13] = MEM[v11];\n                v11 += 32;\n                v13 += 1;\n            }\n        }\n    } else {\n        _getMessages[_messageCount] = v0.length + v0.length | ~0xff & MEM[v12];\n    }\n    while (v14 + (31 + (((!(0x1 & _getMessages[_messageCount]) << 8) - 1 & _getMessages[_messageCount]) >> 1) >> 5) > v13) {\n        STORAGE[v13] = 0;\n        v13 += 1;\n    }\n    _messageCount = _messageCount + 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x3dbcc8d1 == function_selector) {\n            messageCount();\n        } else if (0x4311de8f == function_selector) {\n            ownerWithdraw();\n        } else if (0x57c468e4 == function_selector) {\n            buyMessage(string);\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xae36853d == function_selector) {\n            getMessages(uint256);\n        } else if (0xc57b13b2 == function_selector) {\n            storage_();\n        } else if (0xea47cb24 == function_selector) {\n            ownerAccount();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 06:09 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _price; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _getMessages; // STORAGE[0x4]\nuint256 _messageCount; // STORAGE[0x5]\nuint256 _ownerAccount; // STORAGE[0x6]\nuint256[] _storage_; // STORAGE[0x7]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\naddress _ownerWithdraw; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nstillKicking(uint256);\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction getMessages(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _getMessages[varg0]) << 8) - 1 & _getMessages[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _getMessages[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction storage_() public nonPayable { \n    v0 = new bytes[](_storage_.length);\n    v1 = v2 = v0.data;\n    if (_storage_.length) {\n        if (31 < _storage_.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _storage_.length <= v1);\n        } else {\n            MEM[v2] = _storage_.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction ownerAccount() public nonPayable { \n    return _ownerAccount;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction messageCount() public nonPayable { \n    return _messageCount;\n}\n\nfunction ownerWithdraw() public nonPayable { \n    require(msg.sender == _ownerWithdraw);\n    _ownerAccount = 0;\n    v0 = _ownerWithdraw.call().value(_ownerAccount).gas(!_ownerAccount * 2300);\n    require(v0); // checks call status, propagates error data on error\n    emit stillKicking(_ownerAccount);\n}\n\nfunction buyMessage(string varg0) public payable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(msg.value >= _price);\n    if (_price <= 0x2386f26fc10000) {\n        assert(stor_2 <= _price);\n        v1 = v2 = _price - stor_2;\n        v1 = v3 = 0;\n    } else {\n        assert(stor_2 <= _price);\n        v4 = _SafeMul(50, _price - stor_2);\n        assert(100);\n        v1 = v4 / 100;\n    }\n    assert(_ownerAccount + v1 >= _ownerAccount);\n    _ownerAccount = _ownerAccount + v1;\n    if (_price > 0x2386f26fc10000) {\n        v5 = stor_0_0_19.call().value(v1 + stor_2).gas(!(v1 + stor_2) * 2300);\n        require(v5); // checks call status, propagates error data on error\n    }\n    stor_2 = _price;\n    v6 = _SafeMul(_price, 125);\n    assert(100);\n    _price = v6 / 100;\n    stor_0_0_19 = msg.sender;\n    v7 = v8 = v0.data;\n    if (31 < v0.length) {\n        _storage_.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v8 + v0.length > v7) {\n                STORAGE[v9] = MEM[v7];\n                v7 += 32;\n                v9 += 1;\n            }\n        }\n    } else {\n        _storage_.length = v0.length + v0.length | ~0xff & MEM[v8];\n    }\n    while (v10 + (31 + _storage_.length >> 5) > v9) {\n        STORAGE[v9] = 0;\n        v9 += 1;\n    }\n    v11 = v12 = v0.data;\n    if (31 < v0.length) {\n        _getMessages[_messageCount] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v12 + v0.length > v11) {\n                STORAGE[v13] = MEM[v11];\n                v11 += 32;\n                v13 += 1;\n            }\n        }\n    } else {\n        _getMessages[_messageCount] = v0.length + v0.length | ~0xff & MEM[v12];\n    }\n    while (v14 + (31 + (((!(0x1 & _getMessages[_messageCount]) << 8) - 1 & _getMessages[_messageCount]) >> 1) >> 5) > v13) {\n        STORAGE[v13] = 0;\n        v13 += 1;\n    }\n    _messageCount = _messageCount + 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x3dbcc8d1 == function_selector) {\n            messageCount();\n        } else if (0x4311de8f == function_selector) {\n            ownerWithdraw();\n        } else if (0x57c468e4 == function_selector) {\n            buyMessage(string);\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xae36853d == function_selector) {\n            getMessages(uint256);\n        } else if (0xc57b13b2 == function_selector) {\n            storage_();\n        } else if (0xea47cb24 == function_selector) {\n            ownerAccount();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 23.17804741859436,
	"usage": {
		"completion_tokens": 641,
		"prompt_tokens": 1975,
		"total_tokens": 2616
	}
}