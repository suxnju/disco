{
	"address": "0xcafe1a77e84698c83ca8931f54a755176ef75f2c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code:\n\n```solidity\npragma solidity ^0.5.2;\n\ncontract Wallet {\n    uint constant MAX_OWNER_COUNT = 50;\n\n    mapping (address => bool) private _isOwner;\n    address[] private _owners;\n    uint private _required;\n    uint private _transactionCount;\n\n    // Event definitions\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event Confirmation(address indexed sender, uint transactionId);\n    event Revocation(address indexed sender, uint transactionId);\n    event Submission(uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event RequirementChange(uint required);\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    mapping (uint => Transaction) private _transactions;\n    mapping (uint => mapping (address => bool)) private _confirmations;\n\n    // Function definitions\n    function owners(uint ownerIndex) public view returns (address) {\n        return _owners[ownerIndex];\n    }\n\n    function removeOwner(address owner) public {\n        require(_isOwner[owner]);\n        _isOwner[owner] = false;\n        for (uint i=0; i<_owners.length - 1; i++)\n            if (_owners[i] == owner) {\n                _owners[i] = _owners[_owners.length - 1];\n                break;\n            }\n        _owners.length -= 1;\n        if (_required > _owners.length)\n            changeRequirement(_owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    function revokeConfirmation(uint transactionId) public {\n        require(_isOwner[msg.sender]);\n        require(_confirmations[transactionId][msg.sender]);\n        _confirmations[transactionId][msg.sender] = false;\n        emit Revocation(msg.sender, transactionId);\n    }\n\n    function isOwner(address owner) public view returns (bool) {\n        return _isOwner[owner];\n    }\n\n    function confirmations(uint transactionId, address owner) public view returns (bool) {\n        return _confirmations[transactionId][owner];\n    }\n\n    function addOwner(address owner) public {\n        require(!_isOwner[owner]);\n        require(owner != address(0));\n        require(!isOwner(owner));\n        require(_owners.length + 1 <= MAX_OWNER_COUNT);\n        _isOwner[owner] = true;\n        _owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    function required() public view returns (uint) {\n        return _required;\n    }\n\n    function replaceOwner(address oldOwner, address newOwner) public {\n        require(_isOwner[oldOwner]);\n        require(!_isOwner[newOwner]);\n        for (uint i=0; i<_owners.length; i++)\n            if (_owners[i] == oldOwner) {\n                _owners[i] = newOwner;\n                break;\n            }\n        _isOwner[oldOwner] = false;\n        _isOwner[newOwner] = true;\n        emit OwnerRemoval(oldOwner);\n        emit OwnerAddition(newOwner);\n    }\n\n    function changeRequirement(uint required) public {\n        require(required <= _owners.length);\n        require(required != 0);\n        require(required != _required);\n        _required = required;\n        emit RequirementChange(_required);\n    }\n\n    function confirmTransaction(uint transactionId) public {\n        require(_isOwner[msg.sender]);\n        _confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n    }\n\n    function submitTransaction(address destination, uint value, bytes memory data) public returns (uint transactionId) {\n        require(destination != address(0));\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    function addTransaction(address destination, uint value, bytes memory data) internal returns (uint transactionId) {\n        transactionId = _transactionCount;\n        _transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        _transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    function executeTransaction(uint transactionId) public {\n        require(_confirmations[transactionId][msg.sender]);\n        require(_transactions[transactionId].executed == false);\n        if (isConfirmed(transactionId)) {\n            _transactions[transactionId].executed = true;\n            (bool success,) = _transactions[transactionId].destination.call.value(_transactions[transactionId].value)(_transactions[transactionId].data);\n            if (success)\n                emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                _transactions[transactionId].executed = false;\n            }\n        }\n    }\n\n    function isConfirmed(uint transactionId) public view returns (bool) {\n        uint count = 0;\n        for (uint i=0; i<_owners.length; i++) {\n            if (_confirmations[transactionId][_owners[i]])\n                count += 1;\n            if (count == _required)\n                return true;\n        }\n    }\n\n    function() external payable {\n        if (msg.value > 0)\n            emit Deposit(msg.sender, msg.value);\n    }\n}\n```",
				"role": "assistant"
			}
		}
	],
	"created": 1698038578,
	"id": "chatcmpl-8ChgwcofuIl9ZkC92p62ekog9yx9T",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 23:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x1600(uint256 varg0) private { \n    assert(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 0;\n    }\n    if (!v0) {\n        v0 = v4 = _owners.length == 0;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x16b5(uint256 varg0) private { \n    assert(0xff & _isOwner[msg.sender]);\n    assert(address(_transactions[varg0][0]) != 0);\n    assert(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1bde(varg0);\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1bde(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][3]));\n    v0 = 0xfaa(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (!_owners.length <= _owners.length - 1) {\n        v2 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x1600(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    assert(varg0 != 0);\n    v0 = v1 = _owners.length + 1 > 50;\n    if (_owners.length + 1 <= 50) {\n        v0 = v2 = _required > _owners.length + 1;\n    }\n    if (!v0) {\n        v0 = v3 = _required == 0;\n    }\n    if (!v0) {\n        v0 = _owners.length + 1 == 0;\n    }\n    assert(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length += 1;\n    if (!_owners.length <= 1 + _owners.length) {\n        v4 = keccak256(3) + (1 + _owners.length);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xfaa(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v0, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = new uint256[](_owners.length);\n    v1 = v2 = v0.data;\n    if (_owners.length) {\n        do {\n            MEM[v1] = address(STORAGE[v3]);\n            v1 += 32;\n            v3 += 1;\n        } while (v2 + (_owners.length << 5) <= v1);\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = v0.length << 5;\n    if (v10 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v7];\n            if (v9 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v7 = v7 + 32;\n            v9 = v9 - 32;\n        }\n    }\n    return v4;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new uint256[](_transactionCount);\n    }\n    v3 = new uint256[](_transactionCount);\n    v6 = v7 = 0;\n    v8 = v9 = 0;\n    while (v8 < _transactionCount) {\n        if (v1) {\n            v0 = v10 = !(0xff & _transactions[v8][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v8][3];\n            }\n        }\n        if (v0) {\n            assert(v6 < v3.length);\n            v5[v6] = v8;\n            v6 = v6 + 1;\n        }\n        v8 += 1;\n    }\n    v11 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v11 = v13 = new uint256[](varg1 - varg0);\n    }\n    v11 = new uint256[](varg1 - varg0);\n    while (v14 < varg1) {\n        assert(v14 < v3.length);\n        assert(v14 - varg0 < v11.length);\n        v13[v14 - varg0] = v5[v14];\n        v14 += 1;\n    }\n    v15 = new array[](v11.length);\n    v16 = v17 = v15.data;\n    v18 = v19 = v13.data;\n    v20 = v21 = v11.length << 5;\n    if (v21 != 0) {\n        while (1) {\n            MEM[v16] = MEM[v18];\n            if (v20 <= 32) {\n                break;\n            }\n            v16 = v16 + 32;\n            v18 = v18 + 32;\n            v20 = v20 - 32;\n        }\n    }\n    return v15;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    if (MSIZE() >= v1) {\n        v0 = v2 = new uint256[](_owners.length);\n    }\n    v0 = new uint256[](_owners.length);\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _owners.length) {\n        assert(v5 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v5]), keccak256(varg0, 1))]) {\n            assert(v5 < _owners.length);\n            assert(v3 < v0.length);\n            v2[v3] = address(_owners[v5]);\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    v7 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v7 = v9 = new uint256[](v3);\n    }\n    v7 = new uint256[](v3);\n    v10 = v11 = 0;\n    while (v10 < v3) {\n        assert(v10 < v0.length);\n        assert(v10 < v7.length);\n        v9[v10] = address(v2[v10]);\n        v10 += 1;\n    }\n    v12 = new array[](v7.length);\n    v13 = v14 = v12.data;\n    v15 = v16 = v9.data;\n    v17 = v18 = v7.length << 5;\n    if (v18 != 0) {\n        while (1) {\n            MEM[v13] = MEM[v15];\n            if (v17 <= 32) {\n                break;\n            }\n            v13 = v13 + 32;\n            v15 = v15 + 32;\n            v17 = v17 - 32;\n        }\n    }\n    return v12;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1600(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x16b5(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    assert(varg0 != 0);\n    MEM[64] = MEM[64] + 128;\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x16b5(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    assert(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1bde(varg0);\n}\n\nfunction 0xfaa(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x25e7c27 == function_selector) {\n            owners(uint256);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == function_selector) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3411c81c == function_selector) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == function_selector) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x784547a7 == function_selector) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == function_selector) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == function_selector) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == function_selector) {\n            getOwners();\n        } else if (0xa8abe69a == function_selector) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == function_selector) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == function_selector) {\n            transactionCount();\n        } else if (0xba51a6df == function_selector) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == function_selector) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == function_selector) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == function_selector) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == function_selector) {\n            required();\n        } else if (0xe20056e6 == function_selector) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == function_selector) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 23:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x1600(uint256 varg0) private { \n    assert(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 0;\n    }\n    if (!v0) {\n        v0 = v4 = _owners.length == 0;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x16b5(uint256 varg0) private { \n    assert(0xff & _isOwner[msg.sender]);\n    assert(address(_transactions[varg0][0]) != 0);\n    assert(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1bde(varg0);\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1bde(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][3]));\n    v0 = 0xfaa(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (!_owners.length <= _owners.length - 1) {\n        v2 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x1600(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    assert(varg0 != 0);\n    v0 = v1 = _owners.length + 1 > 50;\n    if (_owners.length + 1 <= 50) {\n        v0 = v2 = _required > _owners.length + 1;\n    }\n    if (!v0) {\n        v0 = v3 = _required == 0;\n    }\n    if (!v0) {\n        v0 = _owners.length + 1 == 0;\n    }\n    assert(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length += 1;\n    if (!_owners.length <= 1 + _owners.length) {\n        v4 = keccak256(3) + (1 + _owners.length);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xfaa(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v0, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = new uint256[](_owners.length);\n    v1 = v2 = v0.data;\n    if (_owners.length) {\n        do {\n            MEM[v1] = address(STORAGE[v3]);\n            v1 += 32;\n            v3 += 1;\n        } while (v2 + (_owners.length << 5) <= v1);\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = v0.length << 5;\n    if (v10 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v7];\n            if (v9 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v7 = v7 + 32;\n            v9 = v9 - 32;\n        }\n    }\n    return v4;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new uint256[](_transactionCount);\n    }\n    v3 = new uint256[](_transactionCount);\n    v6 = v7 = 0;\n    v8 = v9 = 0;\n    while (v8 < _transactionCount) {\n        if (v1) {\n            v0 = v10 = !(0xff & _transactions[v8][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v8][3];\n            }\n        }\n        if (v0) {\n            assert(v6 < v3.length);\n            v5[v6] = v8;\n            v6 = v6 + 1;\n        }\n        v8 += 1;\n    }\n    v11 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v11 = v13 = new uint256[](varg1 - varg0);\n    }\n    v11 = new uint256[](varg1 - varg0);\n    while (v14 < varg1) {\n        assert(v14 < v3.length);\n        assert(v14 - varg0 < v11.length);\n        v13[v14 - varg0] = v5[v14];\n        v14 += 1;\n    }\n    v15 = new array[](v11.length);\n    v16 = v17 = v15.data;\n    v18 = v19 = v13.data;\n    v20 = v21 = v11.length << 5;\n    if (v21 != 0) {\n        while (1) {\n            MEM[v16] = MEM[v18];\n            if (v20 <= 32) {\n                break;\n            }\n            v16 = v16 + 32;\n            v18 = v18 + 32;\n            v20 = v20 - 32;\n        }\n    }\n    return v15;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    if (MSIZE() >= v1) {\n        v0 = v2 = new uint256[](_owners.length);\n    }\n    v0 = new uint256[](_owners.length);\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _owners.length) {\n        assert(v5 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v5]), keccak256(varg0, 1))]) {\n            assert(v5 < _owners.length);\n            assert(v3 < v0.length);\n            v2[v3] = address(_owners[v5]);\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    v7 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v7 = v9 = new uint256[](v3);\n    }\n    v7 = new uint256[](v3);\n    v10 = v11 = 0;\n    while (v10 < v3) {\n        assert(v10 < v0.length);\n        assert(v10 < v7.length);\n        v9[v10] = address(v2[v10]);\n        v10 += 1;\n    }\n    v12 = new array[](v7.length);\n    v13 = v14 = v12.data;\n    v15 = v16 = v9.data;\n    v17 = v18 = v7.length << 5;\n    if (v18 != 0) {\n        while (1) {\n            MEM[v13] = MEM[v15];\n            if (v17 <= 32) {\n                break;\n            }\n            v13 = v13 + 32;\n            v15 = v15 + 32;\n            v17 = v17 - 32;\n        }\n    }\n    return v12;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1600(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x16b5(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    assert(varg0 != 0);\n    MEM[64] = MEM[64] + 128;\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x16b5(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    assert(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1bde(varg0);\n}\n\nfunction 0xfaa(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x25e7c27 == function_selector) {\n            owners(uint256);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == function_selector) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3411c81c == function_selector) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == function_selector) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x784547a7 == function_selector) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == function_selector) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == function_selector) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == function_selector) {\n            getOwners();\n        } else if (0xa8abe69a == function_selector) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == function_selector) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == function_selector) {\n            transactionCount();\n        } else if (0xba51a6df == function_selector) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == function_selector) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == function_selector) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == function_selector) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == function_selector) {\n            required();\n        } else if (0xe20056e6 == function_selector) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == function_selector) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 23:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x1600(uint256 varg0) private { \n    assert(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = varg0 == 0;\n    }\n    if (!v0) {\n        v0 = v4 = _owners.length == 0;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x16b5(uint256 varg0) private { \n    assert(0xff & _isOwner[msg.sender]);\n    assert(address(_transactions[varg0][0]) != 0);\n    assert(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1bde(varg0);\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1bde(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][3]));\n    v0 = 0xfaa(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (!_owners.length <= _owners.length - 1) {\n        v2 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x1600(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    assert(varg0 != 0);\n    v0 = v1 = _owners.length + 1 > 50;\n    if (_owners.length + 1 <= 50) {\n        v0 = v2 = _required > _owners.length + 1;\n    }\n    if (!v0) {\n        v0 = v3 = _required == 0;\n    }\n    if (!v0) {\n        v0 = _owners.length + 1 == 0;\n    }\n    assert(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length += 1;\n    if (!_owners.length <= 1 + _owners.length) {\n        v4 = keccak256(3) + (1 + _owners.length);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xfaa(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new array[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v0, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = new uint256[](_owners.length);\n    v1 = v2 = v0.data;\n    if (_owners.length) {\n        do {\n            MEM[v1] = address(STORAGE[v3]);\n            v1 += 32;\n            v3 += 1;\n        } while (v2 + (_owners.length << 5) <= v1);\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = v0.length << 5;\n    if (v10 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v7];\n            if (v9 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v7 = v7 + 32;\n            v9 = v9 - 32;\n        }\n    }\n    return v4;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new uint256[](_transactionCount);\n    }\n    v3 = new uint256[](_transactionCount);\n    v6 = v7 = 0;\n    v8 = v9 = 0;\n    while (v8 < _transactionCount) {\n        if (v1) {\n            v0 = v10 = !(0xff & _transactions[v8][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v8][3];\n            }\n        }\n        if (v0) {\n            assert(v6 < v3.length);\n            v5[v6] = v8;\n            v6 = v6 + 1;\n        }\n        v8 += 1;\n    }\n    v11 = v12 = MEM[64];\n    if (MSIZE() >= v12) {\n        v11 = v13 = new uint256[](varg1 - varg0);\n    }\n    v11 = new uint256[](varg1 - varg0);\n    while (v14 < varg1) {\n        assert(v14 < v3.length);\n        assert(v14 - varg0 < v11.length);\n        v13[v14 - varg0] = v5[v14];\n        v14 += 1;\n    }\n    v15 = new array[](v11.length);\n    v16 = v17 = v15.data;\n    v18 = v19 = v13.data;\n    v20 = v21 = v11.length << 5;\n    if (v21 != 0) {\n        while (1) {\n            MEM[v16] = MEM[v18];\n            if (v20 <= 32) {\n                break;\n            }\n            v16 = v16 + 32;\n            v18 = v18 + 32;\n            v20 = v20 - 32;\n        }\n    }\n    return v15;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    if (MSIZE() >= v1) {\n        v0 = v2 = new uint256[](_owners.length);\n    }\n    v0 = new uint256[](_owners.length);\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _owners.length) {\n        assert(v5 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v5]), keccak256(varg0, 1))]) {\n            assert(v5 < _owners.length);\n            assert(v3 < v0.length);\n            v2[v3] = address(_owners[v5]);\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    v7 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v7 = v9 = new uint256[](v3);\n    }\n    v7 = new uint256[](v3);\n    v10 = v11 = 0;\n    while (v10 < v3) {\n        assert(v10 < v0.length);\n        assert(v10 < v7.length);\n        v9[v10] = address(v2[v10]);\n        v10 += 1;\n    }\n    v12 = new array[](v7.length);\n    v13 = v14 = v12.data;\n    v15 = v16 = v9.data;\n    v17 = v18 = v7.length << 5;\n    if (v18 != 0) {\n        while (1) {\n            MEM[v13] = MEM[v15];\n            if (v17 <= 32) {\n                break;\n            }\n            v13 = v13 + 32;\n            v15 = v15 + 32;\n            v17 = v17 - 32;\n        }\n    }\n    return v12;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1600(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x16b5(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    assert(varg0 != 0);\n    MEM[64] = MEM[64] + 128;\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x16b5(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    assert(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1bde(varg0);\n}\n\nfunction 0xfaa(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x25e7c27 == function_selector) {\n            owners(uint256);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == function_selector) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3411c81c == function_selector) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == function_selector) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x784547a7 == function_selector) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == function_selector) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == function_selector) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == function_selector) {\n            getOwners();\n        } else if (0xa8abe69a == function_selector) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == function_selector) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == function_selector) {\n            transactionCount();\n        } else if (0xba51a6df == function_selector) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == function_selector) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == function_selector) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == function_selector) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == function_selector) {\n            required();\n        } else if (0xe20056e6 == function_selector) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == function_selector) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
	"status": "1",
	"time_cost": 47.694581031799316,
	"usage": {
		"completion_tokens": 1091,
		"prompt_tokens": 4941,
		"total_tokens": 6032
	}
}