{
	"address": "0xf08f56e84c86f37022030d7103fde0365338688f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity version of the decompiled code would look something like this:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Contract {\n\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping(address => uint256)) private _allowance;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    string private _version;\n    uint256 private _unitsOneEthCanBuy;\n    uint256 private _totalEthInWei;\n    uint8 private _decimals;\n    address payable private _fundsWallet;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function fundsWallet() public view returns (address) {\n        return _fundsWallet;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(_balanceOf[from] >= value);\n        require(_allowance[from][msg.sender] >= value);\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function version() public view returns (string memory) {\n        return _version;\n    }\n\n    function unitsOneEthCanBuy() public view returns (uint256) {\n        return _unitsOneEthCanBuy;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function totalEthInWei() public view returns (uint256) {\n        return _totalEthInWei;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(_balanceOf[msg.sender] >= value);\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approveAndCall(address spender, uint256 value, bytes memory extraData) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        // Call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        (bool success,) = spender.call(abi.encodeWithSignature(\"receiveApproval(address,uint256,address,bytes)\", msg.sender, value, address(this), extraData));\n        require(success);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256 remaining) {\n        return _allowance[owner][spender];\n    }\n\n    receive() external payable {\n        _totalEthInWei = _totalEthInWei + msg.value;\n        uint256 amount = msg.value * _unitsOneEthCanBuy;\n        require(_balanceOf[_fundsWallet] >= amount);\n        _balanceOf[_fundsWallet] -= amount;\n        _balanceOf[msg.sender] += amount;\n        emit Transfer(_fundsWallet, msg.sender, amount);\n        _fundsWallet.transfer(msg.value);\n    }\n}\n```\n\nPlease note that this code doesn't include the initialization of the contract's state variables (like `_name`, `_symbol`, `_decimals`, etc.) which presumably happens in the contract's constructor (which is not shown in the provided decompiled code). Furthermore, this code assumes that all variables are of the correct type and that no overflow or underflow can occur.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465928,
	"id": "chatcmpl-8R5Im3iJN17CFguiKfAwokhYmnanP",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 18:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x5]\nuint256[] _version; // STORAGE[0x6]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x7]\nuint256 _totalEthInWei; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\nuint160 _fundsWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas);\n    require(v5);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_balanceOf[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _balanceOf[_fundsWallet] = _balanceOf[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = 0x8dfe62c6aa08ac49c2c537b7806e6439822e17f0.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 18:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x5]\nuint256[] _version; // STORAGE[0x6]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x7]\nuint256 _totalEthInWei; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\nuint160 _fundsWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas);\n    require(v5);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_balanceOf[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _balanceOf[_fundsWallet] = _balanceOf[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = 0x8dfe62c6aa08ac49c2c537b7806e6439822e17f0.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 18:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x5]\nuint256[] _version; // STORAGE[0x6]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x7]\nuint256 _totalEthInWei; // STORAGE[0x8]\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\nuint160 _fundsWallet; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = varg2 > 0;\n    }\n    if (!v0) {\n        v3 = v4 = 0;\n    } else {\n        _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n        _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n        emit Transfer(varg0, varg1, varg2);\n        v3 = 1;\n    }\n    return v3;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[](_version.length);\n    v1 = v2 = v0.data;\n    if (_version.length) {\n        if (31 < _version.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _version.length <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas);\n    require(v5);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_balanceOf[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _balanceOf[_fundsWallet] = _balanceOf[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = 0x8dfe62c6aa08ac49c2c537b7806e6439822e17f0.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 38.44759678840637,
	"usage": {
		"completion_tokens": 872,
		"prompt_tokens": 2410,
		"total_tokens": 3282
	}
}