{
	"address": "0x3e22bb2279d6bea3cfe57f3ed608fc3b1deadadf",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The equivalent Solidity contract code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract GameContract {\n    uint256 stor_0;\n    uint256 stor_1;\n    uint256 stor_2;\n    uint256 _registrationFee_;\n    uint256 _rID_;\n    mapping(uint256 => uint256[]) _pIDxAddr_;\n    mapping(uint256 => uint256[]) _pIDxName_;\n    mapping(uint256 => uint256[]) _getPlayerLAff;\n    mapping(uint256 => uint256[]) _plyrRnds_;\n    mapping(uint256 => uint256[]) _plyrNames_;\n    mapping(uint256 => uint256[]) _round_;\n    mapping(uint256 => uint256[]) _rndTmEth_;\n    mapping(uint256 => uint256[]) _fees_;\n    mapping(uint256 => uint256[]) _potSplit_;\n    uint256 _activated_;\n\n    event onBuyAndDistribute(address indexed buyer, bytes32 playerName, uint256 ethSpent, uint256 timeStamp, uint256 roundID, address indexed winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount, uint256 potAmount);\n    event onNewName(uint256 indexed playerID, address indexed playerAddress, bytes32 playerName, bool isNewPlayer, uint256 affiliateID, address indexed affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp);\n    event onWithdrawAndDistribute(address indexed playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp, uint256 roundID, address indexed winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount);\n    event onWithdraw(uint256 indexed playerID, address indexed playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp);\n    event onReLoadAndDistribute(address indexed playerAddress, bytes32 playerName, uint256 ethIn, uint256 timeStamp, uint256 roundID, address indexed winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount);\n    event onEndTx(uint256 roundID, uint256 winningVault, bytes32 winningName, address winningAddr, uint256 winnerEth, uint256 amountWon, address playerAddress, bytes32 playerName, uint256 ethIn, uint256 timeStamp, uint256 newPot, uint256 genAmount);\n\n    function buyXid(uint256 _affCode, uint256 _team) public payable { }\n    function buyXaddr(address _affCode, uint256 _team) public payable { }\n    function buyXname(bytes32 _affCode, uint256 _team) public payable { }\n    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) public nonPayable { }\n    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) public nonPayable { }\n    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) public nonPayable { }\n    function withdraw() public nonPayable { }\n    function registerNameXID(string memory _nameString, uint256 _affCode) public payable { }\n    function registerNameXaddr(string memory _nameString, address _affCode) public payable { }\n    function registerNameXname(string memory _nameString, bytes32 _affCode) public payable { }\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode) public nonPayable { }\n    function checkIfNameValid(string memory _nameStr) public view returns (bool) { }\n    function getBuyPrice() public view returns (uint256) { }\n    function iWantXKeys(uint256 _keys) public view returns (uint256) { }\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) public view returns (uint256) { }\n    function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns (uint256) { }\n    function getTimeLeft() public view returns (uint256) { }\n    function getPlayerVaults(uint256 _pID) public view returns (uint256 ,uint256 ,uint256) { }\n    function getPlayerInfoByAddress(address _addr) public view returns (uint256 ,bytes32 ,uint256 ,uint256 ,uint256 ,uint256) { }\n    function getCurrentRoundInfo() public view returns (uint256 ,uint256 ,uint256 ,address ,bytes32 ,uint256 ,uint256 ,uint256 ,uint256 ,uint256) { }\n    function potSwap() external payable { }\n    function activate() public nonPayable { }\n    function endRound() private { }\n    function getWinningVault() private view returns (uint256) { }\n    function airdrop() private view returns (bool) { }\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, uint256 _keys, address _affCode, bool _isCom, uint256 _distMask, uint256 _potAmount) private { }\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _keys, uint256 _gen, uint256 _aff, uint256 _distMask, uint256 _potAmount) private { }\n    function updateGenVault(uint256 _pID, uint256 _rIDlast) private { }\n    function managePlayer(uint256 _pID, address _addr, uint256 _affID, uint256 _keys, uint256 _eth, uint256 _team, address _affCode, bool _isCom) private { }\n    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, address _affCode, bool _isCom) private { }\n}\n```\nNote: This is a simplified version of the contract, and may not contain all the functions and events.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039784,
	"id": "chatcmpl-8Ci0OJ7K2HMAuxAWfDsQIRc5Rqzly",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.01.25 14:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 _registrationFee_; // STORAGE[0x3]\nuint256 _rID_; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pIDxAddr_; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _pIDxName_; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _getPlayerLAff; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _plyrRnds_; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _plyrNames_; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _round_; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _rndTmEth_; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _fees_; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _potSplit_; // STORAGE[0xd]\nuint256 _activated_; // STORAGE[0xe] bytes 0 to 0\n\n// Events\nonBuyAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonNewName(uint256, address, bytes32, bool, uint256, address, bytes32, uint256, uint256);\nonWithdrawAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonWithdraw(uint256, address, bytes32, uint256, uint256);\nonReLoadAndDistribute(address, bytes32, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonEndTx(uint256, uint256, bytes32, address, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\n\nfunction 0x131a(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    v1 = v2 = 0;\n    require(!msg.sender.code.size, 'sorry humans only');\n    v3 = v4 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v3 = v5 = !_pIDxAddr_[msg.sender];\n    }\n    require(v3, 'already has name');\n    v6 = 0x3462(varg1);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v7 = 0x2388(msg.sender);\n    v8 = 0x970(v0);\n    v9 = 0x2aec(msg.sender);\n    v10 = !address(varg0);\n    v11 = v12 = address(varg0);\n    if (address(varg0)) {\n        v11 = v13 = address(varg0) != msg.sender;\n    }\n    if (v11) {\n        v14 = address(varg0);\n        v1 = v15 = _pIDxAddr_[v14];\n        if (v15 != _getPlayerLAff[v9][6]) {\n            _getPlayerLAff[v9][6] = v15;\n            0x3c75(v6, v9);\n        }\n    }\n    0x3c75(v6, v9);\n    emit onNewName(v9, msg.sender, v6, v7, v1, address(_getPlayerLAff[v1]), _getPlayerLAff[v1][1], msg.value, block.timestamp);\n    return ;\n}\n\nfunction 0x1561(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !v3;\n    if (v3) {\n        v1 = v4 = v3 == _pIDxAddr_[msg.sender];\n    }\n    if (!v1) {\n        if (v3 != _getPlayerLAff[_pIDxAddr_[msg.sender]][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v3;\n        }\n    } else {\n        v3 = v5 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v6 = 0x326e(varg1);\n    0x3292(v0, varg0, v6, v3);\n    return ;\n}\n\nfunction 0x1747() private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    v1 = v2 = block.timestamp > _round_[msg.sender][2];\n    if (v2) {\n        v1 = v3 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v1) {\n        v1 = v4 = _round_[_rID_];\n    }\n    if (!v1) {\n        v5 = 0x3dca(_pIDxAddr_[msg.sender]);\n        if (v5 > 0) {\n            v6 = address(_getPlayerLAff[_pIDxAddr_[msg.sender]]).call().value(v5).gas(2300 * !v5);\n            require(v6); // checks call status, propagates error data on error\n        }\n        emit onWithdraw(_pIDxAddr_[msg.sender], msg.sender, _getPlayerLAff[_pIDxAddr_[msg.sender]][1], v5, block.timestamp);\n    } else {\n        _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n        v7 = 0x2e46();\n        v8 = 0x3dca(v0);\n        if (v8 > 0) {\n            v9 = address(_getPlayerLAff[v0]).call().value(v8).gas(2300 * !v8);\n            require(v9); // checks call status, propagates error data on error\n        }\n        MEM[0 + v7] = MEM[0 + v7] + 0;\n        MEM[32 + v7] = MEM[32 + v7] + v0;\n        emit onWithdrawAndDistribute(msg.sender, ~0x0 & (~0x0 & _getPlayerLAff[v0][0x1]), v8, MEM[0 + v7], MEM[32 + v7], address(MEM[64 + v7]), ~0x0 & (~0x0 & MEM[96 + v7]), MEM[128 + v7], MEM[160 + v7], MEM[192 + v7]);\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    0x9f1(v1, 2);\n}\n\nfunction 0x1d13(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !address(v3);\n    if (address(v3)) {\n        v1 = v4 = msg.sender == address(v3);\n    }\n    if (!v1) {\n        v5 = address(v3);\n        v6 = v7 = _pIDxAddr_[v5];\n        if (v7 != _getPlayerLAff[v5][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v7;\n            v8 = v9 = 0x326e(varg1);\n        }\n    } else {\n        v6 = v10 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v8 = v11 = 0x326e(varg1);\n    0x3292(v0, varg0, v8, v6);\n    return ;\n}\n\nfunction 0x1f0f(uint256 varg0) private { \n    return _getPlayerLAff[varg0][1];\n}\n\nfunction 0x1f27(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = v3 = !v4;\n    if (v4) {\n        v2 = v5 = v4 == _pIDxAddr_[msg.sender];\n    }\n    if (!v2) {\n        if (v4 != _getPlayerLAff[_pIDxAddr_[msg.sender]][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v4;\n        }\n    } else {\n        v4 = v6 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v7 = 0x326e(varg0);\n    0x9f1(v1, v7);\n    return ;\n}\n\nfunction 0x2145(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = 0x326e(varg0);\n    v3 = v4 = !address(v5);\n    if (address(v5)) {\n        v3 = v6 = msg.sender == address(v5);\n    }\n    if (!v3) {\n        v7 = address(v5);\n        v8 = v9 = _pIDxAddr_[v7];\n        if (v9 != _getPlayerLAff[v7][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v9;\n        }\n    } else {\n        v8 = v10 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    0x9f1(v1, v2);\n    return ;\n}\n\nfunction 0x2388(uint256 varg0) private { \n    v0 = address(varg0);\n    if (_pIDxAddr_[v0]) {\n        v1 = v2 = 0;\n        goto 0x1f220x2388;\n    } else {\n        v1 = v3 = 1;\n    }\n    return v1;\n}\n\nfunction 0x23b7(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = v3 = !v4;\n    if (v4) {\n        v2 = v5 = v4 == _getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v2) {\n        v6 = v7 = _pIDxName_[v4];\n        if (v7 != _pIDxName_[v4][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v7;\n        }\n    } else {\n        v6 = v8 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v9 = 0x326e(varg0);\n    0x9f1(v1, v9);\n    return ;\n}\n\nfunction 0x25da() private { \n    if (block.timestamp >= _round_[_rID_][2]) {\n        v0 = v1 = 0;\n    } else {\n        if (block.timestamp <= _round_[_rID_][4] + stor_2) {\n            v0 = v2 = _SafeSub(block.timestamp, stor_2 + _round_[_rID_][4]);\n        } else {\n            v0 = v3 = _SafeSub(block.timestamp, _round_[_rID_][2]);\n        }\n        goto 0xc980x25da;\n    }\n    return v0;\n}\n\nfunction 0x2669(uint256 varg0) private { \n    v0 = v1 = block.timestamp > _round_[v2][4] + stor_2;\n    if (v1) {\n        v0 = v3 = block.timestamp <= _round_[v2][2];\n        if (block.timestamp > _round_[v2][2]) {\n            v0 = v4 = block.timestamp > _round_[v2][2];\n            if (v4) {\n                v0 = v5 = !_round_[v2];\n            }\n        }\n    }\n    if (!v0) {\n        v6 = v7 = 0x4083(varg0);\n    } else {\n        v6 = v8, v9, v10, v11 = 0x4062(varg0);\n    }\n    return v6;\n}\n\nfunction 0x2711(uint256 varg0) private { \n    v0 = v1 = block.timestamp > stor_2 + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = 0x40fb(varg0);\n    } else {\n        v7 = _SafeAdd(varg0, _round_[_rID_][5]);\n        v5 = v8 = 0x3241(varg0, v7);\n    }\n    return v5;\n}\n\nfunction 0x28fc(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(!msg.sender.code.size, 'sorry humans only');\n    v1 = v2 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v1 = v3 = !_pIDxAddr_[msg.sender];\n    }\n    require(v1, 'already has name');\n    v4 = 0x3462(varg1);\n    v5 = 0x2388(msg.sender);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v6 = 0x970(v0);\n    v7 = 0x2aec(msg.sender);\n    v8 = !varg0;\n    v9 = v10 = varg0;\n    if (varg0) {\n        v9 = v11 = varg0 != _getPlayerLAff[v7][6];\n    }\n    if (v9) {\n        v9 = v12 = varg0 != v7;\n    }\n    if (!v9) {\n        if (varg0 == v7) {\n            varg0 = v13 = 0;\n            0x3c75(v4, v7);\n        }\n    } else {\n        _getPlayerLAff[v7][6] = varg0;\n    }\n    0x3c75(v4, v7);\n    emit onNewName(v7, msg.sender, v4, v5, varg0, address(_getPlayerLAff[varg0]), _getPlayerLAff[varg0][1], msg.value, block.timestamp);\n    return ;\n}\n\nfunction 0x2aec(uint256 varg0) private { \n    v0 = address(varg0);\n    if (_pIDxAddr_[v0]) {\n        v1 = address(varg0);\n        v2 = v3 = _pIDxAddr_[v1];\n        goto 0x1f220x2aec;\n    } else {\n        v2 = v4 = 1 + stor_0;\n        stor_0 = v4;\n        v5 = address(varg0);\n        _pIDxAddr_[v5] = v4;\n    }\n    return v2;\n}\n\nfunction 0x2b53(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    varg2 = v0 = 0;\n    if (!_plyrRnds_[v1][1]) {\n        varg2 = v2 = 0x4168(varg0, varg4);\n    }\n    v3 = v4 = 0x56bc75e2d63100000 > _round_[v1][6];\n    if (v4) {\n        v5 = _SafeAdd(varg3, _plyrRnds_[v1]);\n        v3 = v6 = v5 > 0xde0b6b3a7640000;\n    }\n    if (v3) {\n        varg2 = v7 = _SafeSub(_plyrRnds_[v1], 0xde0b6b3a7640000);\n        varg2 = v8 = _SafeSub(v7, varg3);\n        v9 = _SafeAdd(v8, _getPlayerLAff[varg4][3]);\n        _getPlayerLAff[varg4][3] = v9;\n    }\n    if (varg2 > 0x3b9aca00) {\n        varg2 = v10 = 11414;\n        varg2 = v11, v12, varg2 = v13, varg2 = v14 = 0x4062(varg2);\n        if (v11 >= 0xde0b6b3a7640000) {\n            varg2 = v15 = 11441;\n            varg2 = v16 = 0;\n            varg2 = v17 = block.timestamp;\n            v18 = v19 = v17 > _round_[varg1][2];\n            if (v19) {\n                v18 = v20 = !_round_[varg1];\n            }\n            if (!v18) {\n                varg2 = v21 = _round_[varg1][2];\n                varg2 = v22 = 16965;\n                varg2 = v23 = 0x3f51(v11, 0xde0b6b3a7640000, 30);\n            } else {\n                varg2 = v24 = 16916;\n                varg2 = v25 = 0x3f51(v11, 0xde0b6b3a7640000, 30);\n            }\n        }\n        varg2 = v26 = _SafeAdd(varg2, varg2);\n        v27 = varg2 + varg2;\n        require(v27 >= varg2, 'SafeMath add failed');\n        _plyrRnds_[varg2][2] = v27;\n        varg2 = v28 = 18835;\n        v29 = 0x3e5d(_round_[varg2][5], varg2);\n        assert(0xde0b6b3a7640000);\n        varg2 = v29 / 0xde0b6b3a7640000;\n        while (varg2 > varg2) {\n            varg2 = varg2 - varg2;\n            goto {'0x4993', '0x3e1b0x2b53', '0x44f2', '0x1bd10x2b53'};\n            continue;\n            varg2 = _SafeSub(varg2, varg2);\n            varg2 = v30 = 17682;\n            varg2 = v31 = 0;\n            v32 = 0x3e5d(0xde0b6b3a7640000, varg2);\n            assert(_round_[varg2][5]);\n            varg2 = v32 / _round_[varg2][5];\n            v33 = _SafeAdd(_round_[varg2][8], varg2);\n            _round_[varg2][8] = v33;\n            v34 = 0x3e5d(varg2, varg2);\n            assert(0xde0b6b3a7640000);\n            varg2 = v35 = _plyrRnds_[varg2][2];\n            varg2 = v34 / 0xde0b6b3a7640000;\n            varg2 = v36 = 18739;\n            varg2 = v37 = 15899;\n            v38 = 0x3e5d(varg2, _round_[varg2][8]);\n            assert(0xde0b6b3a7640000);\n            varg2 = v38 / 0xde0b6b3a7640000;\n        }\n        revert('SafeMath sub failed');\n        if (varg2 > 0) {\n            varg2 = _SafeSub(varg2, varg2);\n        }\n        require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n        v39 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(varg2).gas(msg.gas);\n        if (v39) {\n            varg2 = v40 = _round_[varg2][7];\n            varg2 = v41 = 17858;\n            varg2 = v42 = _SafeAdd(varg2, varg2);\n        } else {\n            RETURNDATACOPY(0, 0, RETURNDATASIZE());\n            revert(0, RETURNDATASIZE());\n        }\n        v43 = _SafeAdd(varg2, 0x15180);\n        if (varg2 >= v43) {\n            v44 = _SafeAdd(varg2, 0x15180);\n            _round_[varg2][2] = v44;\n        } else {\n            _round_[varg2][2] = varg2;\n        }\n        if (varg2 != _round_[varg2]) {\n            _round_[varg2] = varg2;\n        }\n        if (varg2 != _round_[varg2][1]) {\n            _round_[varg2][1] = varg2;\n        }\n        MEM[varg2] += 100;\n        _round_[varg2][7] = varg2;\n        v45 = _SafeAdd(MEM[varg2 + 192], varg2);\n        MEM[varg2 + 192] = v45;\n        MEM[varg2 + 224] = varg2;\n        MEM[0 + varg2] = MEM[0 + varg2] + 0xde0b6b3a7640000 * block.timestamp + 0x1431e0fae6d7217caa0000000 * varg2;\n        MEM[32 + varg2] = MEM[32 + varg2] + varg2 + 0x1aba4714957d300d0e549208b31adb10000000000000 * _rID_;\n        emit onEndTx(MEM[0 + varg2], MEM[32 + varg2], ~0x0 & (~0x0 & _getPlayerLAff[varg2][0x1]), msg.sender, varg2, varg2, address(MEM[64 + varg2]), ~0x0 & (~0x0 & MEM[96 + varg2]), MEM[128 + varg2], MEM[160 + varg2], MEM[192 + varg2], MEM[224 + varg2]);\n        goto 0xed30x2b53;\n        v46 = _SafeAdd(_plyrRnds_[varg2][1], varg2);\n        _plyrRnds_[varg2][1] = v46;\n        v47 = _SafeAdd(_plyrRnds_[varg2], varg2);\n        _plyrRnds_[varg2] = v47;\n        v48 = _SafeAdd(_round_[varg2][5], varg2);\n        _round_[varg2][5] = v48;\n        v49 = _SafeAdd(_round_[varg2][6], varg2);\n        _round_[varg2][6] = v49;\n        v50 = _SafeAdd(_rndTmEth_[varg2], varg2);\n        _rndTmEth_[varg2] = v50;\n        v51 = 0x499e();\n        v52 = v53 = varg2 / 10;\n        v54 = 0x3e5d(3, varg2);\n        assert(100);\n        if (_getPlayerLAff[varg2][6]) {\n            v55 = v56 = _getPlayerLAff[varg2][6] != varg2;\n            if (v56) {\n                v55 = v57 = _getPlayerLAff[_getPlayerLAff[varg2][6]][1];\n            }\n            if (!v55) {\n                v52 = v58 = _SafeAdd(v54 / 100, v53);\n            } else {\n                v59 = _SafeAdd(_getPlayerLAff[_getPlayerLAff[varg2][6]][4], v54 / 100);\n                _getPlayerLAff[_getPlayerLAff[varg2][6]][4] = v59;\n            }\n        } else {\n            v52 = v60 = _SafeAdd(v54 / 100, v53);\n        }\n        v61 = v62 = varg2 != varg2;\n        if (v62) {\n            v61 = v63 = _getPlayerLAff[varg2][1];\n        }\n        if (!v61) {\n            require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n            v64 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(v52).gas(msg.gas);\n            if (!v64) {\n                RETURNDATACOPY(0, 0, RETURNDATASIZE());\n                revert(0, RETURNDATASIZE());\n            }\n        } else {\n            v65 = _SafeAdd(_getPlayerLAff[varg2][4], v52);\n            _getPlayerLAff[varg2][4] = v65;\n        }\n        varg2 = v66 = 11831;\n        varg2 = v67 = 0x499e();\n        varg2 = v68 = 0;\n        v69 = 0x3e5d(_fees_[varg2][1], varg2);\n        assert(100);\n        varg2 = v69 / 100;\n        v70 = 0x3e5d(_fees_[varg2][2], varg2);\n        assert(100);\n        varg2 = v70 / 100;\n        varg2 = v71 = 17650;\n        varg2 = v72 = 7121;\n        v73 = 0x3e5d(13, varg2);\n        assert(100);\n        varg2 = v73 / 100;\n    }\n    return ;\n}\n\nfunction 0x2e46() private { \n    v0 = v1 = 0x499e();\n    v0 = v2 = _rID_;\n    v0 = v3 = 0;\n    v0 = v4 = _round_[v2];\n    v0 = v5 = _round_[v2][1];\n    v0 = v6 = _round_[v2][7];\n    v7 = 0x3e5d(48, v6);\n    assert(100);\n    v0 = v8 = v7 / 100;\n    v0 = v9 = v6 / 50;\n    v10 = 0x3e5d(_potSplit_[v5][1], v6);\n    assert(100);\n    v0 = v11 = v10 / 100;\n    v0 = v12 = 12002;\n    v0 = v13 = 7121;\n    v14 = v15 = _SafeSub(v8, v6);\n    while (1) {\n        v14 = _SafeSub(v0, v14);\n    }\n    v16 = 0x3e5d(0xde0b6b3a7640000, v0);\n    assert(_round_[v0][5]);\n    v17 = 0x3e5d(_round_[v0][5], v16 / _round_[v0][5]);\n    assert(0xde0b6b3a7640000);\n    require(v17 / 0xde0b6b3a7640000 <= v0, 'SafeMath sub failed');\n    if (v0 - v17 / 0xde0b6b3a7640000 > 0) {\n        v0 = v18 = _SafeSub(v0 - v17 / 0xde0b6b3a7640000, v0);\n        v14 = v19 = _SafeAdd(v0 - v17 / 0xde0b6b3a7640000, v14);\n    }\n    v20 = _SafeAdd(_getPlayerLAff[v0][2], v0);\n    _getPlayerLAff[v0][2] = v20;\n    require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n    v21 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(v0).gas(msg.gas);\n    require(v21); // checks call status, propagates error data on error\n    v22 = _SafeAdd(_round_[v0][8], v16 / _round_[v0][5]);\n    _round_[v0][8] = v22;\n    MEM[0 + v2] = MEM[0 + v2] + 0xf4240 * _round_[v0][2];\n    MEM[32 + v2] = MEM[32 + v2] + 0x52b7d2dcc80cd2e4000000 * v0 + 0x16345785d8a0000 * v0;\n    MEM[64 + v2] = address(_round_[v0][0]);\n    MEM[96 + v2] = ~0x0 & (~0x0 & _round_[v0][0x1]);\n    MEM[128 + v2] = v0;\n    MEM[192 + v2] = v0;\n    MEM[160 + v2] = v14;\n    _rID_ += 1;\n    _round_[v0][4] = block.timestamp;\n    v23 = _SafeAdd(36000, block.timestamp);\n    _round_[1 + v0][2] = v23;\n    _round_[1 + v0][7] = v14;\n    return v2;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, 'SafeMath add failed');\n    return v0;\n}\n\nfunction 0x3241(uint256 varg0, uint256 varg1) private { \n    v0 = _SafeSub(varg0, varg1);\n    v1 = 0x40fb(v0);\n    v2 = 0x40fb(varg1);\n    v3 = _SafeSub(v1, v2);\n    return v3;\n}\n\nfunction 0x326e(uint256 varg0) private { \n    v0 = v1 = varg0 < 0;\n    if (varg0 >= 0) {\n        v0 = v2 = varg0 > 3;\n    }\n    if (!v0) {\n        goto 0x1f220x326e;\n    } else {\n        varg0 = v3 = 2;\n    }\n    return varg0;\n}\n\nfunction 0x3292(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + stor_2;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8 = 0x2e46();\n            MEM[v8] += varg0 * 0xde0b6b3a7640000;\n            MEM[v8 + 32] += varg2;\n            v9 = _getPlayerLAff[varg2][1];\n            emit onReLoadAndDistribute(msg.sender, v9, MEM[v8], MEM[v8 + 32], address(MEM[v8 + 64]), MEM[v8 + 96], MEM[v8 + 128], MEM[v8 + 160], MEM[v8 + 192]);\n            return ;\n        }\n    } else {\n        v10 = 0x3dca(v11);\n        v12 = _SafeSub(varg1, v10);\n        _getPlayerLAff[v11][3] = v12;\n        0x2b53(varg0, varg2, varg3, varg1, v11);\n        goto 0x1ab30x3292;\n    }\n    return ;\n}\n\nfunction getBuyPrice() public nonPayable { \n    v0 = 0xbda();\n    return v0;\n}\n\nfunction 0x3462(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0.length <= 32;\n    if (varg0.length <= 32) {\n        v2 = v4 = varg0.length > 0;\n    }\n    require(v2, 'string must be between 1 and 32 characters');\n    assert(0 < varg0.length);\n    v5 = v6 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248;\n    if (v6) {\n        assert(varg0.length - 1 < varg0.length);\n        v5 = v7 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (varg0.length - 1)] >> 248 << 248;\n    }\n    require(v5, 'string cannot start or end with space');\n    assert(0 < varg0.length);\n    if (0x3000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        require(0x7800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0x');\n        assert(1 < varg0.length);\n        require(0x5800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0X');\n    }\n    v8 = v9 = 0;\n    while (v8 < varg0.length) {\n        if (v8 < varg0.length) {\n            break;\n        }\n        assert(v8 < varg0.length);\n        v10 = v11 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x4000000000000000000000000000000000000000000000000000000000000000;\n        if (v11) {\n            assert(v8 < varg0.length);\n            v10 = v12 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x5b00000000000000000000000000000000000000000000000000000000000000;\n        }\n        if (!v10) {\n            assert(v8 < varg0.length);\n            v13 = v14 = 0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248;\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(v8 < varg0.length);\n                v13 = v15 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x6000000000000000000000000000000000000000000000000000000000000000;\n                if (v15) {\n                    assert(v8 < varg0.length);\n                    v13 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x7b00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (!v13) {\n                assert(v8 < varg0.length);\n                v13 = v17 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x2f00000000000000000000000000000000000000000000000000000000000000;\n                if (v17) {\n                    assert(v8 < varg0.length);\n                    v13 = v18 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3a00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            require(v13, 'string contains invalid characters');\n            assert(v8 < varg0.length);\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(1 + v8 < varg0.length);\n                require(0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (1 + v8)] >> 248 << 248, 'string cannot contain consecutive spaces');\n            }\n            v19 = v20 = !v0;\n            if (v20) {\n                assert(v8 < varg0.length);\n                v19 = v21 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3000000000000000000000000000000000000000000000000000000000000000;\n                if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 >= 0x3000000000000000000000000000000000000000000000000000000000000000) {\n                    assert(v8 < varg0.length);\n                    v19 = v22 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x3900000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (v19) {\n                v0 = v23 = 1;\n            }\n        } else {\n            assert(v8 < varg0.length);\n            assert(v8 < varg0.length);\n            MEM8[varg0.data + v8] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 32 + (MEM[varg0.data + v8] >> 248 << 248 >> 248) << 248, 0x0)) & 0xFF;\n            if (!v0) {\n                v0 = v24 = 1;\n            }\n        }\n        v8 = v8 + 1;\n    }\n    require(v0 == 1, 'string cannot be only numbers');\n    return MEM[varg0.data];\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction 0x3c75(uint256 varg0, uint256 varg1) private { \n    if (_pIDxName_[varg0]) {\n        require(1 == 0xff & _plyrNames_[varg1], 'sorry that names already taken');\n    }\n    _getPlayerLAff[varg1][1] = varg0;\n    _pIDxName_[varg1] = varg1;\n    if (!(0xff & _plyrNames_[varg1])) {\n        _plyrNames_[varg1] = 0x1 | ~0xff & _plyrNames_[varg1];\n    }\n    require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n    v0 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(msg.value).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x3dca(uint256 varg0) private { \n    0x4759(_getPlayerLAff[varg0][5], varg0);\n    v0 = _SafeAdd(_getPlayerLAff[varg0][3], _getPlayerLAff[varg0][2]);\n    v1 = _SafeAdd(_getPlayerLAff[varg0][4], v0);\n    if (v1 > 0) {\n        _getPlayerLAff[varg0][2] = 0;\n        _getPlayerLAff[varg0][3] = 0;\n        _getPlayerLAff[varg0][4] = 0;\n    }\n    return v1;\n}\n\nfunction 0x3e5d(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath mul failed');\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0x3ed4(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = _plyrRnds_[varg0][1];\n    varg0 = v3 = _round_[varg0][5];\n    v4 = _round_[varg0][1];\n    varg0 = v5 = 0xde0b6b3a7640000;\n    v0 = v6 = 16275;\n    v0 = v7 = 16263;\n    v0 = v8 = 16222;\n    v9 = 0x3e5d(_round_[varg0][1], _round_[varg0][7]);\n    assert(100);\n    v10 = v9 / 100;\n    while (1) {\n        if (v10) {\n            goto 0x3e6e0x3ed4;\n        }\n        v10 = v11 = 0;\n        while (1) {\n            goto {'0x3f870x3ed4', '0x3f5e', '0x3f93'};\n            if (varg0) {\n                break;\n            }\n            assert(varg0);\n            v12 = _round_[varg0][8];\n            v10 = v10 / varg0 + v12;\n            require(v10 >= v12, 'SafeMath add failed');\n        }\n        continue;\n        v10 *= varg0;\n        assert(v10);\n        require(v10 / v10 == varg0, 'SafeMath mul failed');\n    }\n    assert(varg0);\n    return v10 / varg0, v0, varg0, v0;\n}\n\nfunction reLoadXname(bytes32 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    0xcd4(varg2, varg1);\n}\n\nfunction 0x3f51(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    if (v0) {\n        v1 = varg2 * v0;\n        assert(v0);\n        require(v1 / v0 == varg2, 'SafeMath mul failed');\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1, 'SafeMath sub failed');\n    return varg1 - varg0;\n}\n\nfunction 0x4004(uint256 varg0, uint256 varg1) private { \n    v0 = _plyrRnds_[varg0][2];\n    v1 = 0x3e5d(_plyrRnds_[varg0][1], _round_[varg0][8]);\n    assert(0xde0b6b3a7640000);\n    require(v0 <= v1 / 0xde0b6b3a7640000, 'SafeMath sub failed');\n    return v1 / 0xde0b6b3a7640000 - v0;\n}\n\nfunction 0x4062(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = 12903;\n    v0 = v3 = 0x4083(v0);\n    varg0 = v4 = 7121;\n    v0 = v5 = varg0 + v0;\n    require(v5 >= v0, 'SafeMath add failed');\n    varg0 = v6 = 0;\n    v0 = v7 = 0x9502f90;\n    varg0 = v8 = 16619;\n    v0 = v9 = 0x3b2a1d15167e7c5699bfde00000;\n    v10 = 0x3e5d(0xde0b6b3a7640000, v5);\n    v11 = 0x3e5d(0x1027e72f1f1281308800000, v10);\n    v12 = _SafeAdd(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000, v11);\n    v0 = v13 = 0x47f0(v12);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        assert(v0);\n        v0 = v0 / v0;\n        goto 0x1bd10x4062;\n    }\n    require(v0 <= v0, 'SafeMath sub failed');\n    return v0 - v0, v0, varg0, v0;\n}\n\nfunction 0x4083(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0x9502f90;\n    v0 = v4 = 16619;\n    v5 = v6 = 0x3b2a1d15167e7c5699bfde00000;\n    v7 = 0x3e5d(0xde0b6b3a7640000, varg0);\n    v8 = 0x3e5d(0x1027e72f1f1281308800000, v7);\n    v9 = _SafeAdd(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000, v8);\n    v2 = v10 = 0x47f0(v9);\n    v5 = v11 = _SafeSub(v6, v10);\n    require(v5 <= v2, 'SafeMath sub failed');\n    while (1) {\n        goto 0x32670x4083;\n    }\n    assert(v2);\n    return v5 / v2;\n}\n\nfunction registerNameXname(string varg0, bytes32 varg1) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    0xede(varg1, v0);\n}\n\nfunction 0x40fb(uint256 varg0) private { \n    v0 = 0x4843(0xde0b6b3a7640000);\n    v1 = 0x3e5d(0xde0b6b3a7640000, varg0);\n    v2 = 0x3e5d(v1, 0x886c8f673070);\n    assert(2);\n    v3 = 0x4843(varg0);\n    v4 = 0x3e5d(v3, 0x4a817c8);\n    require((v2 >> 1) + v4 >= v4, 'SafeMath add failed');\n    assert(v0);\n    return ((v2 >> 1) + v4) / v0;\n}\n\nfunction 0x4168(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    if (_getPlayerLAff[varg1][5]) {\n        0x4759(_getPlayerLAff[varg1][5], varg1);\n    }\n    _getPlayerLAff[varg1][5] = _rID_;\n    MEM[varg0] += 10;\n    return varg0;\n}\n\nfunction activate() public nonPayable { \n    require(msg.sender == 0x701b5b2f6bc3f74eb15daebacfc65e6eadfbb0da, 'only team just can activate');\n    require(!_activated_, 'Star3d already activated');\n    _activated_ = 1;\n    _rID_ = 1;\n    MEM[0] = 1;\n    MEM[32] = 10;\n    STORAGE[0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bcb] = block.timestamp;\n    STORAGE[0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bc9] = 36000 + (stor_1 + block.timestamp);\n}\n\nfunction pIDxAddr_(address varg0) public nonPayable { \n    return _pIDxAddr_[varg0];\n}\n\nfunction 0x4759(uint256 varg0, uint256 varg1) private { \n    v0 = 0x4004(varg0, varg1);\n    if (v0 > 0) {\n        v1 = _SafeAdd(_getPlayerLAff[varg1][3], v0);\n        _getPlayerLAff[varg1][3] = v1;\n        v2 = _SafeAdd(_plyrRnds_[varg1][2], v0);\n        _plyrRnds_[varg1][2] = v2;\n    }\n    return ;\n}\n\nfunction 0x47f0(uint256 varg0) private { \n    v0 = _SafeAdd(1, varg0);\n    assert(2);\n    varg0 = v1 = v0 >> 1;\n    while (varg0 < varg0) {\n        if (varg0) {\n            break;\n        }\n        assert(varg0);\n        v2 = varg0 / varg0;\n        if (varg0 + v2 >= v2) {\n            break;\n        }\n        require(varg0 + v2 >= v2, 'SafeMath add failed');\n        assert(2);\n        varg0 = varg0 + v2 >> 1;\n    }\n    return varg0;\n}\n\nfunction 0x4843(uint256 varg0) private { \n    v0 = 0x3e5d(varg0, varg0);\n    return v0;\n}\n\nfunction registrationFee_() public nonPayable { \n    return _registrationFee_;\n}\n\nfunction 0x499e() private { \n    MEM[64] = MEM[64] + 256;\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    return MEM[64];\n}\n\nfunction round_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _round_[varg0][2];\n    MEM[MEM[64] + 96] = _round_[varg0][0x3] & 0xff;\n    return _round_[varg0], _round_[varg0][1], v1, v1, _round_[varg0][4], _round_[varg0][5], _round_[varg0][6], _round_[varg0][7], _round_[varg0][8], _round_[varg0][9], _round_[varg0][10];\n}\n\nfunction plyrNames_(uint256 varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _plyrNames_[varg1];\n}\n\nfunction registerNameXaddr(string _nameString, address _affCode) public payable { \n    v0 = new bytes[](_nameString.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + _nameString, _nameString.length);\n    0x131a(_affCode, v0);\n}\n\nfunction fees_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _fees_[varg0][2];\n    MEM[MEM[64] + 96] = _fees_[varg0][3];\n    return _fees_[varg0], _fees_[varg0][1];\n}\n\nfunction pIDxName_(bytes32 varg0) public nonPayable { \n    return _pIDxName_[varg0];\n}\n\nfunction reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) public nonPayable { \n    0x1561(_eth, _team);\n}\n\nfunction withdraw() public nonPayable { \n    0x1747();\n}\n\nfunction rndTmEth_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _rndTmEth_[varg1];\n}\n\nfunction rID_() public nonPayable { \n    return _rID_;\n}\n\nfunction getPlayerVaults(uint256 _pID) public nonPayable { \n    v0 = v1 = 1644;\n    v2 = v3 = _rID_;\n    v0 = v4 = 0;\n    v5 = v6 = block.timestamp > _round_[v3][2];\n    if (v6) {\n        v5 = v7 = !(0xff & _round_[v3][0x3]);\n    }\n    if (v5) {\n        v5 = v8 = _round_[v3];\n    }\n    if (!v5) {\n        v9 = v10 = _getPlayerLAff[_pID][2];\n        v11 = v12 = 7163;\n        v13 = v14 = 0x4004(_getPlayerLAff[_pID][5], _pID);\n    } else {\n        if (_pID != _round_[v3]) {\n            v15 = _getPlayerLAff[_pID][2];\n            v16 = _plyrRnds_[v3][2];\n            v9 = v17 = 7121;\n            v18 = v19, v20 = v21, v22 = v23, v11 = v24 = 0x3ed4(v3);\n        } else {\n            v25 = 0x3e5d(48, _round_[v3][7]);\n            assert(100);\n            require(v25 / 100 + _getPlayerLAff[_pID][2] >= _getPlayerLAff[_pID][2], 'SafeMath add failed');\n            v26 = _plyrRnds_[v3][2];\n            v9 = v27 = 7121;\n            v18 = v28, v20 = v29, v22 = v30, v11 = v31 = 0x3ed4(v3);\n        }\n        v13 = v32 = _SafeSub(v20, v18);\n    }\n    v33 = _SafeAdd(v13, _getPlayerLAff[v2][3]);\n    MEM[v34.data] = _getPlayerLAff[v2][4];\n    return v9, v33;\n}\n\nfunction getCurrentRoundInfo() public nonPayable { \n    MEM[v0.data] = _round_[_rID_][2];\n    MEM[MEM[64] + 96] = _round_[_rID_][4];\n    return _rID_, _round_[_rID_][5], v1, v1, _round_[_rID_][7], _round_[_rID_][1] + 10 * _round_[_rID_], address(_round_[_round_[_rID_]]), _round_[_round_[_rID_]][1], _rndTmEth_[_round_[_rID_]], _rndTmEth_[1], _rndTmEth_[1], _rndTmEth_[3];\n}\n\nfunction reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) public nonPayable { \n    0x1d13(_eth, _team);\n}\n\nfunction getPlayerName(uint256 _pID) public nonPayable { \n    v0 = 0x1f0f(_pID);\n    return v0;\n}\n\nfunction buyXid(uint256 _affCode, uint256 _team) public payable { \n    0x1f27(_team);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction buyXaddr(address _affCode, uint256 _team) public payable { \n    0x2145(_team);\n}\n\nfunction plyrRnds_(uint256 varg0, uint256 varg1) public nonPayable { \n    MEM[v0.data] = _plyrRnds_[varg1][2];\n    return _plyrRnds_[varg1], _plyrRnds_[varg1][1];\n}\n\nfunction isNewPlayer(address _addr) public nonPayable { \n    v0 = 0x2388(_addr);\n    return v0;\n}\n\nfunction buyXname(bytes32 _affCode, uint256 _team) public payable { \n    0x23b7(_team);\n}\n\nfunction potSplit_(uint256 varg0) public nonPayable { \n    return _potSplit_[varg0], _potSplit_[varg0][1];\n}\n\nfunction getTimeLeft() public nonPayable { \n    v0 = 0x25da();\n    return v0;\n}\n\nfunction calcKeysReceived(uint256 _rID, uint256 _eth) public nonPayable { \n    v0 = 0x2669(_eth);\n    return v0;\n}\n\nfunction iWantXKeys(uint256 _keys) public nonPayable { \n    v0 = 0x2711(_keys);\n    return v0;\n}\n\nfunction activated_() public nonPayable { \n    return _activated_;\n}\n\nfunction plyr_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _getPlayerLAff[varg0][2];\n    MEM[MEM[64] + 96] = _getPlayerLAff[varg0][3];\n    return address(_getPlayerLAff[varg0]), _getPlayerLAff[varg0][1], v1, v1, _getPlayerLAff[varg0][4], _getPlayerLAff[varg0][5], _getPlayerLAff[varg0][6];\n}\n\nfunction getPlayerLAff(uint256 _pID) public nonPayable { \n    return _getPlayerLAff[_pID][6];\n}\n\nfunction getPlayerInfoByAddress(address _addr) public nonPayable { \n    v0 = _pIDxAddr_[_addr];\n    v1 = 0x4004(_getPlayerLAff[v0][5], v0);\n    v2 = _SafeAdd(v1, _getPlayerLAff[v0][3]);\n    MEM[v3.data] = _plyrRnds_[v0][1];\n    MEM[MEM[64] + 96] = _getPlayerLAff[v0][2];\n    return v0, _getPlayerLAff[v0][1], v4, v4, v2, _getPlayerLAff[v0][4], _plyrRnds_[v0];\n}\n\nfunction registerNameXID(string _nameString, uint256 _affCode) public payable { \n    v0 = new bytes[](_nameString.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + _nameString, _nameString.length);\n    0x28fc(_affCode, v0);\n}\n\nfunction 0x970(uint256 varg0) private { \n    v0 = 0x499e();\n    if (!_pIDxAddr_[msg.sender]) {\n        v1 = 0x2aec(msg.sender);\n        _pIDxAddr_[msg.sender] = v1;\n        _getPlayerLAff[v1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getPlayerLAff[v1];\n        MEM[varg0] += 1;\n    }\n    return varg0;\n}\n\nfunction 0x9f1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + stor_2;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8 = 0x2e46();\n            MEM[v8] += varg0 * 0xde0b6b3a7640000;\n            MEM[v8 + 32] += varg1;\n            v9 = _getPlayerLAff[varg1][1];\n            emit onBuyAndDistribute(msg.sender, v9, msg.value, MEM[v8], MEM[v8 + 32], address(MEM[v8 + 64]), MEM[v8 + 96], MEM[v8 + 128], MEM[v8 + 160], MEM[v8 + 192]);\n        }\n        v10 = _SafeAdd(msg.value, _getPlayerLAff[varg1][3]);\n        _getPlayerLAff[varg1][3] = v10;\n    } else {\n        0x2b53(varg0, varg1, v11, msg.value, v12);\n    }\n    return ;\n}\n\nfunction 0xbda() private { \n    v0 = v1 = block.timestamp > stor_2 + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = 0x44364c5bb000;\n    } else {\n        v7 = _SafeAdd(0xde0b6b3a7640000, _round_[_rID_][5]);\n        v5 = v8 = 0x3241(0xde0b6b3a7640000, v7);\n        goto 0xc980xbda;\n    }\n    return v5;\n}\n\nfunction 0xcd4(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !v3;\n    if (v3) {\n        v1 = v4 = v3 == _getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v1) {\n        v5 = v6 = _pIDxName_[v3];\n        if (v6 != _pIDxName_[v3][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v6;\n        }\n    } else {\n        v5 = v7 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v8 = 0x326e(varg1);\n    0x3292(v0, varg0, v8, v5);\n    return ;\n}\n\nfunction 0xede(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    v1 = v2 = 0;\n    require(!msg.sender.code.size, 'sorry humans only');\n    v3 = v4 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v3 = v5 = !_pIDxAddr_[msg.sender];\n    }\n    require(v3, 'already has name');\n    v6 = 0x3462(varg1);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v7 = 0x2388(msg.sender);\n    v8 = 0x970(v0);\n    v9 = 0x2aec(msg.sender);\n    v10 = !varg0;\n    v11 = v12 = varg0;\n    if (varg0) {\n        v11 = v13 = v6 != varg0;\n    }\n    if (v11) {\n        v1 = v14 = _pIDxName_[varg0];\n        if (v14 != _pIDxName_[varg0][6]) {\n            _getPlayerLAff[v9][6] = v14;\n        }\n    }\n    0x3c75(v6, v9);\n    emit onNewName(v9, msg.sender, v6, v7, v1, address(_getPlayerLAff[v1]), _getPlayerLAff[v1][1], msg.value, block.timestamp);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x18a25e8) {\n            getBuyPrice();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x79ce327 == v0) {\n            reLoadXname(bytes32,uint256,uint256);\n        } else if (0xe07ef81 == v0) {\n            registerNameXname(string,bytes32);\n        } else if (0xf15f4c0 == v0) {\n            activate();\n        } else if (0x10f01eba == v0) {\n            pIDxAddr_(address);\n        } else if (0x180603eb == v0) {\n            registrationFee_();\n        } else if (0x24c33d33 == v0) {\n            round_(uint256);\n        } else if (0x2660316e == v0) {\n            plyrNames_(uint256,bytes32);\n        } else if (0x27d87924 == v0) {\n            registerNameXaddr(string,address);\n        } else if (0x2ce21999 == v0) {\n            fees_(uint256);\n        } else if (0x2e19ebdc == v0) {\n            pIDxName_(bytes32);\n        } else if (0x349cdcac == v0) {\n            reLoadXid(uint256,uint256,uint256);\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x5893d481 == v0) {\n            rndTmEth_(uint256,uint256);\n        } else if (0x624ae5c0 == v0) {\n            rID_();\n        } else if (0x63066434 == v0) {\n            getPlayerVaults(uint256);\n        } else if (0x747dff42 == v0) {\n            getCurrentRoundInfo();\n        } else if (0x82bfc739 == v0) {\n            reLoadXaddr(address,uint256,uint256);\n        } else if (0x82e37b2c == v0) {\n            getPlayerName(uint256);\n        } else if (0x8f38f309 == v0) {\n            buyXid(uint256,uint256);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x98a0871d == v0) {\n            buyXaddr(address,uint256);\n        } else if (0xa2bccae9 == v0) {\n            plyrRnds_(uint256,uint256);\n        } else if (0xa2e7223e == v0) {\n            isNewPlayer(address);\n        } else if (0xa65b37a1 == v0) {\n            buyXname(bytes32,uint256);\n        } else if (0xc519500e == v0) {\n            potSplit_(uint256);\n        } else if (0xc7e284b8 == v0) {\n            getTimeLeft();\n        } else if (0xce89c80c == v0) {\n            calcKeysReceived(uint256,uint256);\n        } else if (0xcf808000 == v0) {\n            iWantXKeys(uint256);\n        } else if (0xd53b2679 == v0) {\n            activated_();\n        } else if (0xde7874f3 == v0) {\n            plyr_(uint256);\n        } else if (0xe3c08adf == v0) {\n            getPlayerLAff(uint256);\n        } else if (0xee0b5d8b == v0) {\n            getPlayerInfoByAddress(address);\n        } else if (0xf32306d2 == v0) {\n            registerNameXID(string,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.01.25 14:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 _registrationFee_; // STORAGE[0x3]\nuint256 _rID_; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pIDxAddr_; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _pIDxName_; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _getPlayerLAff; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _plyrRnds_; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _plyrNames_; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _round_; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _rndTmEth_; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _fees_; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _potSplit_; // STORAGE[0xd]\nuint256 _activated_; // STORAGE[0xe] bytes 0 to 0\n\n// Events\nonBuyAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonNewName(uint256, address, bytes32, bool, uint256, address, bytes32, uint256, uint256);\nonWithdrawAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonWithdraw(uint256, address, bytes32, uint256, uint256);\nonReLoadAndDistribute(address, bytes32, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonEndTx(uint256, uint256, bytes32, address, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\n\nfunction 0x131a(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    v1 = v2 = 0;\n    require(!msg.sender.code.size, 'sorry humans only');\n    v3 = v4 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v3 = v5 = !_pIDxAddr_[msg.sender];\n    }\n    require(v3, 'already has name');\n    v6 = 0x3462(varg1);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v7 = 0x2388(msg.sender);\n    v8 = 0x970(v0);\n    v9 = 0x2aec(msg.sender);\n    v10 = !address(varg0);\n    v11 = v12 = address(varg0);\n    if (address(varg0)) {\n        v11 = v13 = address(varg0) != msg.sender;\n    }\n    if (v11) {\n        v14 = address(varg0);\n        v1 = v15 = _pIDxAddr_[v14];\n        if (v15 != _getPlayerLAff[v9][6]) {\n            _getPlayerLAff[v9][6] = v15;\n            0x3c75(v6, v9);\n        }\n    }\n    0x3c75(v6, v9);\n    emit onNewName(v9, msg.sender, v6, v7, v1, address(_getPlayerLAff[v1]), _getPlayerLAff[v1][1], msg.value, block.timestamp);\n    return ;\n}\n\nfunction 0x1561(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !v3;\n    if (v3) {\n        v1 = v4 = v3 == _pIDxAddr_[msg.sender];\n    }\n    if (!v1) {\n        if (v3 != _getPlayerLAff[_pIDxAddr_[msg.sender]][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v3;\n        }\n    } else {\n        v3 = v5 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v6 = 0x326e(varg1);\n    0x3292(v0, varg0, v6, v3);\n    return ;\n}\n\nfunction 0x1747() private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    v1 = v2 = block.timestamp > _round_[msg.sender][2];\n    if (v2) {\n        v1 = v3 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v1) {\n        v1 = v4 = _round_[_rID_];\n    }\n    if (!v1) {\n        v5 = 0x3dca(_pIDxAddr_[msg.sender]);\n        if (v5 > 0) {\n            v6 = address(_getPlayerLAff[_pIDxAddr_[msg.sender]]).call().value(v5).gas(2300 * !v5);\n            require(v6); // checks call status, propagates error data on error\n        }\n        emit onWithdraw(_pIDxAddr_[msg.sender], msg.sender, _getPlayerLAff[_pIDxAddr_[msg.sender]][1], v5, block.timestamp);\n    } else {\n        _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n        v7 = 0x2e46();\n        v8 = 0x3dca(v0);\n        if (v8 > 0) {\n            v9 = address(_getPlayerLAff[v0]).call().value(v8).gas(2300 * !v8);\n            require(v9); // checks call status, propagates error data on error\n        }\n        MEM[0 + v7] = MEM[0 + v7] + 0;\n        MEM[32 + v7] = MEM[32 + v7] + v0;\n        emit onWithdrawAndDistribute(msg.sender, ~0x0 & (~0x0 & _getPlayerLAff[v0][0x1]), v8, MEM[0 + v7], MEM[32 + v7], address(MEM[64 + v7]), ~0x0 & (~0x0 & MEM[96 + v7]), MEM[128 + v7], MEM[160 + v7], MEM[192 + v7]);\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    0x9f1(v1, 2);\n}\n\nfunction 0x1d13(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !address(v3);\n    if (address(v3)) {\n        v1 = v4 = msg.sender == address(v3);\n    }\n    if (!v1) {\n        v5 = address(v3);\n        v6 = v7 = _pIDxAddr_[v5];\n        if (v7 != _getPlayerLAff[v5][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v7;\n            v8 = v9 = 0x326e(varg1);\n        }\n    } else {\n        v6 = v10 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v8 = v11 = 0x326e(varg1);\n    0x3292(v0, varg0, v8, v6);\n    return ;\n}\n\nfunction 0x1f0f(uint256 varg0) private { \n    return _getPlayerLAff[varg0][1];\n}\n\nfunction 0x1f27(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = v3 = !v4;\n    if (v4) {\n        v2 = v5 = v4 == _pIDxAddr_[msg.sender];\n    }\n    if (!v2) {\n        if (v4 != _getPlayerLAff[_pIDxAddr_[msg.sender]][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v4;\n        }\n    } else {\n        v4 = v6 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v7 = 0x326e(varg0);\n    0x9f1(v1, v7);\n    return ;\n}\n\nfunction 0x2145(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = 0x326e(varg0);\n    v3 = v4 = !address(v5);\n    if (address(v5)) {\n        v3 = v6 = msg.sender == address(v5);\n    }\n    if (!v3) {\n        v7 = address(v5);\n        v8 = v9 = _pIDxAddr_[v7];\n        if (v9 != _getPlayerLAff[v7][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v9;\n        }\n    } else {\n        v8 = v10 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    0x9f1(v1, v2);\n    return ;\n}\n\nfunction 0x2388(uint256 varg0) private { \n    v0 = address(varg0);\n    if (_pIDxAddr_[v0]) {\n        v1 = v2 = 0;\n        goto 0x1f220x2388;\n    } else {\n        v1 = v3 = 1;\n    }\n    return v1;\n}\n\nfunction 0x23b7(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = v3 = !v4;\n    if (v4) {\n        v2 = v5 = v4 == _getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v2) {\n        v6 = v7 = _pIDxName_[v4];\n        if (v7 != _pIDxName_[v4][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v7;\n        }\n    } else {\n        v6 = v8 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v9 = 0x326e(varg0);\n    0x9f1(v1, v9);\n    return ;\n}\n\nfunction 0x25da() private { \n    if (block.timestamp >= _round_[_rID_][2]) {\n        v0 = v1 = 0;\n    } else {\n        if (block.timestamp <= _round_[_rID_][4] + stor_2) {\n            v0 = v2 = _SafeSub(block.timestamp, stor_2 + _round_[_rID_][4]);\n        } else {\n            v0 = v3 = _SafeSub(block.timestamp, _round_[_rID_][2]);\n        }\n        goto 0xc980x25da;\n    }\n    return v0;\n}\n\nfunction 0x2669(uint256 varg0) private { \n    v0 = v1 = block.timestamp > _round_[v2][4] + stor_2;\n    if (v1) {\n        v0 = v3 = block.timestamp <= _round_[v2][2];\n        if (block.timestamp > _round_[v2][2]) {\n            v0 = v4 = block.timestamp > _round_[v2][2];\n            if (v4) {\n                v0 = v5 = !_round_[v2];\n            }\n        }\n    }\n    if (!v0) {\n        v6 = v7 = 0x4083(varg0);\n    } else {\n        v6 = v8, v9, v10, v11 = 0x4062(varg0);\n    }\n    return v6;\n}\n\nfunction 0x2711(uint256 varg0) private { \n    v0 = v1 = block.timestamp > stor_2 + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = 0x40fb(varg0);\n    } else {\n        v7 = _SafeAdd(varg0, _round_[_rID_][5]);\n        v5 = v8 = 0x3241(varg0, v7);\n    }\n    return v5;\n}\n\nfunction 0x28fc(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(!msg.sender.code.size, 'sorry humans only');\n    v1 = v2 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v1 = v3 = !_pIDxAddr_[msg.sender];\n    }\n    require(v1, 'already has name');\n    v4 = 0x3462(varg1);\n    v5 = 0x2388(msg.sender);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v6 = 0x970(v0);\n    v7 = 0x2aec(msg.sender);\n    v8 = !varg0;\n    v9 = v10 = varg0;\n    if (varg0) {\n        v9 = v11 = varg0 != _getPlayerLAff[v7][6];\n    }\n    if (v9) {\n        v9 = v12 = varg0 != v7;\n    }\n    if (!v9) {\n        if (varg0 == v7) {\n            varg0 = v13 = 0;\n            0x3c75(v4, v7);\n        }\n    } else {\n        _getPlayerLAff[v7][6] = varg0;\n    }\n    0x3c75(v4, v7);\n    emit onNewName(v7, msg.sender, v4, v5, varg0, address(_getPlayerLAff[varg0]), _getPlayerLAff[varg0][1], msg.value, block.timestamp);\n    return ;\n}\n\nfunction 0x2aec(uint256 varg0) private { \n    v0 = address(varg0);\n    if (_pIDxAddr_[v0]) {\n        v1 = address(varg0);\n        v2 = v3 = _pIDxAddr_[v1];\n        goto 0x1f220x2aec;\n    } else {\n        v2 = v4 = 1 + stor_0;\n        stor_0 = v4;\n        v5 = address(varg0);\n        _pIDxAddr_[v5] = v4;\n    }\n    return v2;\n}\n\nfunction 0x2b53(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    varg2 = v0 = 0;\n    if (!_plyrRnds_[v1][1]) {\n        varg2 = v2 = 0x4168(varg0, varg4);\n    }\n    v3 = v4 = 0x56bc75e2d63100000 > _round_[v1][6];\n    if (v4) {\n        v5 = _SafeAdd(varg3, _plyrRnds_[v1]);\n        v3 = v6 = v5 > 0xde0b6b3a7640000;\n    }\n    if (v3) {\n        varg2 = v7 = _SafeSub(_plyrRnds_[v1], 0xde0b6b3a7640000);\n        varg2 = v8 = _SafeSub(v7, varg3);\n        v9 = _SafeAdd(v8, _getPlayerLAff[varg4][3]);\n        _getPlayerLAff[varg4][3] = v9;\n    }\n    if (varg2 > 0x3b9aca00) {\n        varg2 = v10 = 11414;\n        varg2 = v11, v12, varg2 = v13, varg2 = v14 = 0x4062(varg2);\n        if (v11 >= 0xde0b6b3a7640000) {\n            varg2 = v15 = 11441;\n            varg2 = v16 = 0;\n            varg2 = v17 = block.timestamp;\n            v18 = v19 = v17 > _round_[varg1][2];\n            if (v19) {\n                v18 = v20 = !_round_[varg1];\n            }\n            if (!v18) {\n                varg2 = v21 = _round_[varg1][2];\n                varg2 = v22 = 16965;\n                varg2 = v23 = 0x3f51(v11, 0xde0b6b3a7640000, 30);\n            } else {\n                varg2 = v24 = 16916;\n                varg2 = v25 = 0x3f51(v11, 0xde0b6b3a7640000, 30);\n            }\n        }\n        varg2 = v26 = _SafeAdd(varg2, varg2);\n        v27 = varg2 + varg2;\n        require(v27 >= varg2, 'SafeMath add failed');\n        _plyrRnds_[varg2][2] = v27;\n        varg2 = v28 = 18835;\n        v29 = 0x3e5d(_round_[varg2][5], varg2);\n        assert(0xde0b6b3a7640000);\n        varg2 = v29 / 0xde0b6b3a7640000;\n        while (varg2 > varg2) {\n            varg2 = varg2 - varg2;\n            goto {'0x4993', '0x3e1b0x2b53', '0x44f2', '0x1bd10x2b53'};\n            continue;\n            varg2 = _SafeSub(varg2, varg2);\n            varg2 = v30 = 17682;\n            varg2 = v31 = 0;\n            v32 = 0x3e5d(0xde0b6b3a7640000, varg2);\n            assert(_round_[varg2][5]);\n            varg2 = v32 / _round_[varg2][5];\n            v33 = _SafeAdd(_round_[varg2][8], varg2);\n            _round_[varg2][8] = v33;\n            v34 = 0x3e5d(varg2, varg2);\n            assert(0xde0b6b3a7640000);\n            varg2 = v35 = _plyrRnds_[varg2][2];\n            varg2 = v34 / 0xde0b6b3a7640000;\n            varg2 = v36 = 18739;\n            varg2 = v37 = 15899;\n            v38 = 0x3e5d(varg2, _round_[varg2][8]);\n            assert(0xde0b6b3a7640000);\n            varg2 = v38 / 0xde0b6b3a7640000;\n        }\n        revert('SafeMath sub failed');\n        if (varg2 > 0) {\n            varg2 = _SafeSub(varg2, varg2);\n        }\n        require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n        v39 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(varg2).gas(msg.gas);\n        if (v39) {\n            varg2 = v40 = _round_[varg2][7];\n            varg2 = v41 = 17858;\n            varg2 = v42 = _SafeAdd(varg2, varg2);\n        } else {\n            RETURNDATACOPY(0, 0, RETURNDATASIZE());\n            revert(0, RETURNDATASIZE());\n        }\n        v43 = _SafeAdd(varg2, 0x15180);\n        if (varg2 >= v43) {\n            v44 = _SafeAdd(varg2, 0x15180);\n            _round_[varg2][2] = v44;\n        } else {\n            _round_[varg2][2] = varg2;\n        }\n        if (varg2 != _round_[varg2]) {\n            _round_[varg2] = varg2;\n        }\n        if (varg2 != _round_[varg2][1]) {\n            _round_[varg2][1] = varg2;\n        }\n        MEM[varg2] += 100;\n        _round_[varg2][7] = varg2;\n        v45 = _SafeAdd(MEM[varg2 + 192], varg2);\n        MEM[varg2 + 192] = v45;\n        MEM[varg2 + 224] = varg2;\n        MEM[0 + varg2] = MEM[0 + varg2] + 0xde0b6b3a7640000 * block.timestamp + 0x1431e0fae6d7217caa0000000 * varg2;\n        MEM[32 + varg2] = MEM[32 + varg2] + varg2 + 0x1aba4714957d300d0e549208b31adb10000000000000 * _rID_;\n        emit onEndTx(MEM[0 + varg2], MEM[32 + varg2], ~0x0 & (~0x0 & _getPlayerLAff[varg2][0x1]), msg.sender, varg2, varg2, address(MEM[64 + varg2]), ~0x0 & (~0x0 & MEM[96 + varg2]), MEM[128 + varg2], MEM[160 + varg2], MEM[192 + varg2], MEM[224 + varg2]);\n        goto 0xed30x2b53;\n        v46 = _SafeAdd(_plyrRnds_[varg2][1], varg2);\n        _plyrRnds_[varg2][1] = v46;\n        v47 = _SafeAdd(_plyrRnds_[varg2], varg2);\n        _plyrRnds_[varg2] = v47;\n        v48 = _SafeAdd(_round_[varg2][5], varg2);\n        _round_[varg2][5] = v48;\n        v49 = _SafeAdd(_round_[varg2][6], varg2);\n        _round_[varg2][6] = v49;\n        v50 = _SafeAdd(_rndTmEth_[varg2], varg2);\n        _rndTmEth_[varg2] = v50;\n        v51 = 0x499e();\n        v52 = v53 = varg2 / 10;\n        v54 = 0x3e5d(3, varg2);\n        assert(100);\n        if (_getPlayerLAff[varg2][6]) {\n            v55 = v56 = _getPlayerLAff[varg2][6] != varg2;\n            if (v56) {\n                v55 = v57 = _getPlayerLAff[_getPlayerLAff[varg2][6]][1];\n            }\n            if (!v55) {\n                v52 = v58 = _SafeAdd(v54 / 100, v53);\n            } else {\n                v59 = _SafeAdd(_getPlayerLAff[_getPlayerLAff[varg2][6]][4], v54 / 100);\n                _getPlayerLAff[_getPlayerLAff[varg2][6]][4] = v59;\n            }\n        } else {\n            v52 = v60 = _SafeAdd(v54 / 100, v53);\n        }\n        v61 = v62 = varg2 != varg2;\n        if (v62) {\n            v61 = v63 = _getPlayerLAff[varg2][1];\n        }\n        if (!v61) {\n            require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n            v64 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(v52).gas(msg.gas);\n            if (!v64) {\n                RETURNDATACOPY(0, 0, RETURNDATASIZE());\n                revert(0, RETURNDATASIZE());\n            }\n        } else {\n            v65 = _SafeAdd(_getPlayerLAff[varg2][4], v52);\n            _getPlayerLAff[varg2][4] = v65;\n        }\n        varg2 = v66 = 11831;\n        varg2 = v67 = 0x499e();\n        varg2 = v68 = 0;\n        v69 = 0x3e5d(_fees_[varg2][1], varg2);\n        assert(100);\n        varg2 = v69 / 100;\n        v70 = 0x3e5d(_fees_[varg2][2], varg2);\n        assert(100);\n        varg2 = v70 / 100;\n        varg2 = v71 = 17650;\n        varg2 = v72 = 7121;\n        v73 = 0x3e5d(13, varg2);\n        assert(100);\n        varg2 = v73 / 100;\n    }\n    return ;\n}\n\nfunction 0x2e46() private { \n    v0 = v1 = 0x499e();\n    v0 = v2 = _rID_;\n    v0 = v3 = 0;\n    v0 = v4 = _round_[v2];\n    v0 = v5 = _round_[v2][1];\n    v0 = v6 = _round_[v2][7];\n    v7 = 0x3e5d(48, v6);\n    assert(100);\n    v0 = v8 = v7 / 100;\n    v0 = v9 = v6 / 50;\n    v10 = 0x3e5d(_potSplit_[v5][1], v6);\n    assert(100);\n    v0 = v11 = v10 / 100;\n    v0 = v12 = 12002;\n    v0 = v13 = 7121;\n    v14 = v15 = _SafeSub(v8, v6);\n    while (1) {\n        v14 = _SafeSub(v0, v14);\n    }\n    v16 = 0x3e5d(0xde0b6b3a7640000, v0);\n    assert(_round_[v0][5]);\n    v17 = 0x3e5d(_round_[v0][5], v16 / _round_[v0][5]);\n    assert(0xde0b6b3a7640000);\n    require(v17 / 0xde0b6b3a7640000 <= v0, 'SafeMath sub failed');\n    if (v0 - v17 / 0xde0b6b3a7640000 > 0) {\n        v0 = v18 = _SafeSub(v0 - v17 / 0xde0b6b3a7640000, v0);\n        v14 = v19 = _SafeAdd(v0 - v17 / 0xde0b6b3a7640000, v14);\n    }\n    v20 = _SafeAdd(_getPlayerLAff[v0][2], v0);\n    _getPlayerLAff[v0][2] = v20;\n    require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n    v21 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(v0).gas(msg.gas);\n    require(v21); // checks call status, propagates error data on error\n    v22 = _SafeAdd(_round_[v0][8], v16 / _round_[v0][5]);\n    _round_[v0][8] = v22;\n    MEM[0 + v2] = MEM[0 + v2] + 0xf4240 * _round_[v0][2];\n    MEM[32 + v2] = MEM[32 + v2] + 0x52b7d2dcc80cd2e4000000 * v0 + 0x16345785d8a0000 * v0;\n    MEM[64 + v2] = address(_round_[v0][0]);\n    MEM[96 + v2] = ~0x0 & (~0x0 & _round_[v0][0x1]);\n    MEM[128 + v2] = v0;\n    MEM[192 + v2] = v0;\n    MEM[160 + v2] = v14;\n    _rID_ += 1;\n    _round_[v0][4] = block.timestamp;\n    v23 = _SafeAdd(36000, block.timestamp);\n    _round_[1 + v0][2] = v23;\n    _round_[1 + v0][7] = v14;\n    return v2;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, 'SafeMath add failed');\n    return v0;\n}\n\nfunction 0x3241(uint256 varg0, uint256 varg1) private { \n    v0 = _SafeSub(varg0, varg1);\n    v1 = 0x40fb(v0);\n    v2 = 0x40fb(varg1);\n    v3 = _SafeSub(v1, v2);\n    return v3;\n}\n\nfunction 0x326e(uint256 varg0) private { \n    v0 = v1 = varg0 < 0;\n    if (varg0 >= 0) {\n        v0 = v2 = varg0 > 3;\n    }\n    if (!v0) {\n        goto 0x1f220x326e;\n    } else {\n        varg0 = v3 = 2;\n    }\n    return varg0;\n}\n\nfunction 0x3292(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + stor_2;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8 = 0x2e46();\n            MEM[v8] += varg0 * 0xde0b6b3a7640000;\n            MEM[v8 + 32] += varg2;\n            v9 = _getPlayerLAff[varg2][1];\n            emit onReLoadAndDistribute(msg.sender, v9, MEM[v8], MEM[v8 + 32], address(MEM[v8 + 64]), MEM[v8 + 96], MEM[v8 + 128], MEM[v8 + 160], MEM[v8 + 192]);\n            return ;\n        }\n    } else {\n        v10 = 0x3dca(v11);\n        v12 = _SafeSub(varg1, v10);\n        _getPlayerLAff[v11][3] = v12;\n        0x2b53(varg0, varg2, varg3, varg1, v11);\n        goto 0x1ab30x3292;\n    }\n    return ;\n}\n\nfunction getBuyPrice() public nonPayable { \n    v0 = 0xbda();\n    return v0;\n}\n\nfunction 0x3462(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0.length <= 32;\n    if (varg0.length <= 32) {\n        v2 = v4 = varg0.length > 0;\n    }\n    require(v2, 'string must be between 1 and 32 characters');\n    assert(0 < varg0.length);\n    v5 = v6 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248;\n    if (v6) {\n        assert(varg0.length - 1 < varg0.length);\n        v5 = v7 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (varg0.length - 1)] >> 248 << 248;\n    }\n    require(v5, 'string cannot start or end with space');\n    assert(0 < varg0.length);\n    if (0x3000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        require(0x7800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0x');\n        assert(1 < varg0.length);\n        require(0x5800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0X');\n    }\n    v8 = v9 = 0;\n    while (v8 < varg0.length) {\n        if (v8 < varg0.length) {\n            break;\n        }\n        assert(v8 < varg0.length);\n        v10 = v11 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x4000000000000000000000000000000000000000000000000000000000000000;\n        if (v11) {\n            assert(v8 < varg0.length);\n            v10 = v12 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x5b00000000000000000000000000000000000000000000000000000000000000;\n        }\n        if (!v10) {\n            assert(v8 < varg0.length);\n            v13 = v14 = 0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248;\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(v8 < varg0.length);\n                v13 = v15 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x6000000000000000000000000000000000000000000000000000000000000000;\n                if (v15) {\n                    assert(v8 < varg0.length);\n                    v13 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x7b00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (!v13) {\n                assert(v8 < varg0.length);\n                v13 = v17 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x2f00000000000000000000000000000000000000000000000000000000000000;\n                if (v17) {\n                    assert(v8 < varg0.length);\n                    v13 = v18 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3a00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            require(v13, 'string contains invalid characters');\n            assert(v8 < varg0.length);\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(1 + v8 < varg0.length);\n                require(0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (1 + v8)] >> 248 << 248, 'string cannot contain consecutive spaces');\n            }\n            v19 = v20 = !v0;\n            if (v20) {\n                assert(v8 < varg0.length);\n                v19 = v21 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3000000000000000000000000000000000000000000000000000000000000000;\n                if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 >= 0x3000000000000000000000000000000000000000000000000000000000000000) {\n                    assert(v8 < varg0.length);\n                    v19 = v22 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x3900000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (v19) {\n                v0 = v23 = 1;\n            }\n        } else {\n            assert(v8 < varg0.length);\n            assert(v8 < varg0.length);\n            MEM8[varg0.data + v8] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 32 + (MEM[varg0.data + v8] >> 248 << 248 >> 248) << 248, 0x0)) & 0xFF;\n            if (!v0) {\n                v0 = v24 = 1;\n            }\n        }\n        v8 = v8 + 1;\n    }\n    require(v0 == 1, 'string cannot be only numbers');\n    return MEM[varg0.data];\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction 0x3c75(uint256 varg0, uint256 varg1) private { \n    if (_pIDxName_[varg0]) {\n        require(1 == 0xff & _plyrNames_[varg1], 'sorry that names already taken');\n    }\n    _getPlayerLAff[varg1][1] = varg0;\n    _pIDxName_[varg1] = varg1;\n    if (!(0xff & _plyrNames_[varg1])) {\n        _plyrNames_[varg1] = 0x1 | ~0xff & _plyrNames_[varg1];\n    }\n    require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n    v0 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(msg.value).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x3dca(uint256 varg0) private { \n    0x4759(_getPlayerLAff[varg0][5], varg0);\n    v0 = _SafeAdd(_getPlayerLAff[varg0][3], _getPlayerLAff[varg0][2]);\n    v1 = _SafeAdd(_getPlayerLAff[varg0][4], v0);\n    if (v1 > 0) {\n        _getPlayerLAff[varg0][2] = 0;\n        _getPlayerLAff[varg0][3] = 0;\n        _getPlayerLAff[varg0][4] = 0;\n    }\n    return v1;\n}\n\nfunction 0x3e5d(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath mul failed');\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0x3ed4(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = _plyrRnds_[varg0][1];\n    varg0 = v3 = _round_[varg0][5];\n    v4 = _round_[varg0][1];\n    varg0 = v5 = 0xde0b6b3a7640000;\n    v0 = v6 = 16275;\n    v0 = v7 = 16263;\n    v0 = v8 = 16222;\n    v9 = 0x3e5d(_round_[varg0][1], _round_[varg0][7]);\n    assert(100);\n    v10 = v9 / 100;\n    while (1) {\n        if (v10) {\n            goto 0x3e6e0x3ed4;\n        }\n        v10 = v11 = 0;\n        while (1) {\n            goto {'0x3f870x3ed4', '0x3f5e', '0x3f93'};\n            if (varg0) {\n                break;\n            }\n            assert(varg0);\n            v12 = _round_[varg0][8];\n            v10 = v10 / varg0 + v12;\n            require(v10 >= v12, 'SafeMath add failed');\n        }\n        continue;\n        v10 *= varg0;\n        assert(v10);\n        require(v10 / v10 == varg0, 'SafeMath mul failed');\n    }\n    assert(varg0);\n    return v10 / varg0, v0, varg0, v0;\n}\n\nfunction reLoadXname(bytes32 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    0xcd4(varg2, varg1);\n}\n\nfunction 0x3f51(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    if (v0) {\n        v1 = varg2 * v0;\n        assert(v0);\n        require(v1 / v0 == varg2, 'SafeMath mul failed');\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1, 'SafeMath sub failed');\n    return varg1 - varg0;\n}\n\nfunction 0x4004(uint256 varg0, uint256 varg1) private { \n    v0 = _plyrRnds_[varg0][2];\n    v1 = 0x3e5d(_plyrRnds_[varg0][1], _round_[varg0][8]);\n    assert(0xde0b6b3a7640000);\n    require(v0 <= v1 / 0xde0b6b3a7640000, 'SafeMath sub failed');\n    return v1 / 0xde0b6b3a7640000 - v0;\n}\n\nfunction 0x4062(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = 12903;\n    v0 = v3 = 0x4083(v0);\n    varg0 = v4 = 7121;\n    v0 = v5 = varg0 + v0;\n    require(v5 >= v0, 'SafeMath add failed');\n    varg0 = v6 = 0;\n    v0 = v7 = 0x9502f90;\n    varg0 = v8 = 16619;\n    v0 = v9 = 0x3b2a1d15167e7c5699bfde00000;\n    v10 = 0x3e5d(0xde0b6b3a7640000, v5);\n    v11 = 0x3e5d(0x1027e72f1f1281308800000, v10);\n    v12 = _SafeAdd(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000, v11);\n    v0 = v13 = 0x47f0(v12);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        assert(v0);\n        v0 = v0 / v0;\n        goto 0x1bd10x4062;\n    }\n    require(v0 <= v0, 'SafeMath sub failed');\n    return v0 - v0, v0, varg0, v0;\n}\n\nfunction 0x4083(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0x9502f90;\n    v0 = v4 = 16619;\n    v5 = v6 = 0x3b2a1d15167e7c5699bfde00000;\n    v7 = 0x3e5d(0xde0b6b3a7640000, varg0);\n    v8 = 0x3e5d(0x1027e72f1f1281308800000, v7);\n    v9 = _SafeAdd(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000, v8);\n    v2 = v10 = 0x47f0(v9);\n    v5 = v11 = _SafeSub(v6, v10);\n    require(v5 <= v2, 'SafeMath sub failed');\n    while (1) {\n        goto 0x32670x4083;\n    }\n    assert(v2);\n    return v5 / v2;\n}\n\nfunction registerNameXname(string varg0, bytes32 varg1) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    0xede(varg1, v0);\n}\n\nfunction 0x40fb(uint256 varg0) private { \n    v0 = 0x4843(0xde0b6b3a7640000);\n    v1 = 0x3e5d(0xde0b6b3a7640000, varg0);\n    v2 = 0x3e5d(v1, 0x886c8f673070);\n    assert(2);\n    v3 = 0x4843(varg0);\n    v4 = 0x3e5d(v3, 0x4a817c8);\n    require((v2 >> 1) + v4 >= v4, 'SafeMath add failed');\n    assert(v0);\n    return ((v2 >> 1) + v4) / v0;\n}\n\nfunction 0x4168(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    if (_getPlayerLAff[varg1][5]) {\n        0x4759(_getPlayerLAff[varg1][5], varg1);\n    }\n    _getPlayerLAff[varg1][5] = _rID_;\n    MEM[varg0] += 10;\n    return varg0;\n}\n\nfunction activate() public nonPayable { \n    require(msg.sender == 0x701b5b2f6bc3f74eb15daebacfc65e6eadfbb0da, 'only team just can activate');\n    require(!_activated_, 'Star3d already activated');\n    _activated_ = 1;\n    _rID_ = 1;\n    MEM[0] = 1;\n    MEM[32] = 10;\n    STORAGE[0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bcb] = block.timestamp;\n    STORAGE[0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bc9] = 36000 + (stor_1 + block.timestamp);\n}\n\nfunction pIDxAddr_(address varg0) public nonPayable { \n    return _pIDxAddr_[varg0];\n}\n\nfunction 0x4759(uint256 varg0, uint256 varg1) private { \n    v0 = 0x4004(varg0, varg1);\n    if (v0 > 0) {\n        v1 = _SafeAdd(_getPlayerLAff[varg1][3], v0);\n        _getPlayerLAff[varg1][3] = v1;\n        v2 = _SafeAdd(_plyrRnds_[varg1][2], v0);\n        _plyrRnds_[varg1][2] = v2;\n    }\n    return ;\n}\n\nfunction 0x47f0(uint256 varg0) private { \n    v0 = _SafeAdd(1, varg0);\n    assert(2);\n    varg0 = v1 = v0 >> 1;\n    while (varg0 < varg0) {\n        if (varg0) {\n            break;\n        }\n        assert(varg0);\n        v2 = varg0 / varg0;\n        if (varg0 + v2 >= v2) {\n            break;\n        }\n        require(varg0 + v2 >= v2, 'SafeMath add failed');\n        assert(2);\n        varg0 = varg0 + v2 >> 1;\n    }\n    return varg0;\n}\n\nfunction 0x4843(uint256 varg0) private { \n    v0 = 0x3e5d(varg0, varg0);\n    return v0;\n}\n\nfunction registrationFee_() public nonPayable { \n    return _registrationFee_;\n}\n\nfunction 0x499e() private { \n    MEM[64] = MEM[64] + 256;\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    return MEM[64];\n}\n\nfunction round_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _round_[varg0][2];\n    MEM[MEM[64] + 96] = _round_[varg0][0x3] & 0xff;\n    return _round_[varg0], _round_[varg0][1], v1, v1, _round_[varg0][4], _round_[varg0][5], _round_[varg0][6], _round_[varg0][7], _round_[varg0][8], _round_[varg0][9], _round_[varg0][10];\n}\n\nfunction plyrNames_(uint256 varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _plyrNames_[varg1];\n}\n\nfunction registerNameXaddr(string _nameString, address _affCode) public payable { \n    v0 = new bytes[](_nameString.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + _nameString, _nameString.length);\n    0x131a(_affCode, v0);\n}\n\nfunction fees_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _fees_[varg0][2];\n    MEM[MEM[64] + 96] = _fees_[varg0][3];\n    return _fees_[varg0], _fees_[varg0][1];\n}\n\nfunction pIDxName_(bytes32 varg0) public nonPayable { \n    return _pIDxName_[varg0];\n}\n\nfunction reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) public nonPayable { \n    0x1561(_eth, _team);\n}\n\nfunction withdraw() public nonPayable { \n    0x1747();\n}\n\nfunction rndTmEth_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _rndTmEth_[varg1];\n}\n\nfunction rID_() public nonPayable { \n    return _rID_;\n}\n\nfunction getPlayerVaults(uint256 _pID) public nonPayable { \n    v0 = v1 = 1644;\n    v2 = v3 = _rID_;\n    v0 = v4 = 0;\n    v5 = v6 = block.timestamp > _round_[v3][2];\n    if (v6) {\n        v5 = v7 = !(0xff & _round_[v3][0x3]);\n    }\n    if (v5) {\n        v5 = v8 = _round_[v3];\n    }\n    if (!v5) {\n        v9 = v10 = _getPlayerLAff[_pID][2];\n        v11 = v12 = 7163;\n        v13 = v14 = 0x4004(_getPlayerLAff[_pID][5], _pID);\n    } else {\n        if (_pID != _round_[v3]) {\n            v15 = _getPlayerLAff[_pID][2];\n            v16 = _plyrRnds_[v3][2];\n            v9 = v17 = 7121;\n            v18 = v19, v20 = v21, v22 = v23, v11 = v24 = 0x3ed4(v3);\n        } else {\n            v25 = 0x3e5d(48, _round_[v3][7]);\n            assert(100);\n            require(v25 / 100 + _getPlayerLAff[_pID][2] >= _getPlayerLAff[_pID][2], 'SafeMath add failed');\n            v26 = _plyrRnds_[v3][2];\n            v9 = v27 = 7121;\n            v18 = v28, v20 = v29, v22 = v30, v11 = v31 = 0x3ed4(v3);\n        }\n        v13 = v32 = _SafeSub(v20, v18);\n    }\n    v33 = _SafeAdd(v13, _getPlayerLAff[v2][3]);\n    MEM[v34.data] = _getPlayerLAff[v2][4];\n    return v9, v33;\n}\n\nfunction getCurrentRoundInfo() public nonPayable { \n    MEM[v0.data] = _round_[_rID_][2];\n    MEM[MEM[64] + 96] = _round_[_rID_][4];\n    return _rID_, _round_[_rID_][5], v1, v1, _round_[_rID_][7], _round_[_rID_][1] + 10 * _round_[_rID_], address(_round_[_round_[_rID_]]), _round_[_round_[_rID_]][1], _rndTmEth_[_round_[_rID_]], _rndTmEth_[1], _rndTmEth_[1], _rndTmEth_[3];\n}\n\nfunction reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) public nonPayable { \n    0x1d13(_eth, _team);\n}\n\nfunction getPlayerName(uint256 _pID) public nonPayable { \n    v0 = 0x1f0f(_pID);\n    return v0;\n}\n\nfunction buyXid(uint256 _affCode, uint256 _team) public payable { \n    0x1f27(_team);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction buyXaddr(address _affCode, uint256 _team) public payable { \n    0x2145(_team);\n}\n\nfunction plyrRnds_(uint256 varg0, uint256 varg1) public nonPayable { \n    MEM[v0.data] = _plyrRnds_[varg1][2];\n    return _plyrRnds_[varg1], _plyrRnds_[varg1][1];\n}\n\nfunction isNewPlayer(address _addr) public nonPayable { \n    v0 = 0x2388(_addr);\n    return v0;\n}\n\nfunction buyXname(bytes32 _affCode, uint256 _team) public payable { \n    0x23b7(_team);\n}\n\nfunction potSplit_(uint256 varg0) public nonPayable { \n    return _potSplit_[varg0], _potSplit_[varg0][1];\n}\n\nfunction getTimeLeft() public nonPayable { \n    v0 = 0x25da();\n    return v0;\n}\n\nfunction calcKeysReceived(uint256 _rID, uint256 _eth) public nonPayable { \n    v0 = 0x2669(_eth);\n    return v0;\n}\n\nfunction iWantXKeys(uint256 _keys) public nonPayable { \n    v0 = 0x2711(_keys);\n    return v0;\n}\n\nfunction activated_() public nonPayable { \n    return _activated_;\n}\n\nfunction plyr_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _getPlayerLAff[varg0][2];\n    MEM[MEM[64] + 96] = _getPlayerLAff[varg0][3];\n    return address(_getPlayerLAff[varg0]), _getPlayerLAff[varg0][1], v1, v1, _getPlayerLAff[varg0][4], _getPlayerLAff[varg0][5], _getPlayerLAff[varg0][6];\n}\n\nfunction getPlayerLAff(uint256 _pID) public nonPayable { \n    return _getPlayerLAff[_pID][6];\n}\n\nfunction getPlayerInfoByAddress(address _addr) public nonPayable { \n    v0 = _pIDxAddr_[_addr];\n    v1 = 0x4004(_getPlayerLAff[v0][5], v0);\n    v2 = _SafeAdd(v1, _getPlayerLAff[v0][3]);\n    MEM[v3.data] = _plyrRnds_[v0][1];\n    MEM[MEM[64] + 96] = _getPlayerLAff[v0][2];\n    return v0, _getPlayerLAff[v0][1], v4, v4, v2, _getPlayerLAff[v0][4], _plyrRnds_[v0];\n}\n\nfunction registerNameXID(string _nameString, uint256 _affCode) public payable { \n    v0 = new bytes[](_nameString.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + _nameString, _nameString.length);\n    0x28fc(_affCode, v0);\n}\n\nfunction 0x970(uint256 varg0) private { \n    v0 = 0x499e();\n    if (!_pIDxAddr_[msg.sender]) {\n        v1 = 0x2aec(msg.sender);\n        _pIDxAddr_[msg.sender] = v1;\n        _getPlayerLAff[v1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getPlayerLAff[v1];\n        MEM[varg0] += 1;\n    }\n    return varg0;\n}\n\nfunction 0x9f1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + stor_2;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8 = 0x2e46();\n            MEM[v8] += varg0 * 0xde0b6b3a7640000;\n            MEM[v8 + 32] += varg1;\n            v9 = _getPlayerLAff[varg1][1];\n            emit onBuyAndDistribute(msg.sender, v9, msg.value, MEM[v8], MEM[v8 + 32], address(MEM[v8 + 64]), MEM[v8 + 96], MEM[v8 + 128], MEM[v8 + 160], MEM[v8 + 192]);\n        }\n        v10 = _SafeAdd(msg.value, _getPlayerLAff[varg1][3]);\n        _getPlayerLAff[varg1][3] = v10;\n    } else {\n        0x2b53(varg0, varg1, v11, msg.value, v12);\n    }\n    return ;\n}\n\nfunction 0xbda() private { \n    v0 = v1 = block.timestamp > stor_2 + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = 0x44364c5bb000;\n    } else {\n        v7 = _SafeAdd(0xde0b6b3a7640000, _round_[_rID_][5]);\n        v5 = v8 = 0x3241(0xde0b6b3a7640000, v7);\n        goto 0xc980xbda;\n    }\n    return v5;\n}\n\nfunction 0xcd4(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !v3;\n    if (v3) {\n        v1 = v4 = v3 == _getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v1) {\n        v5 = v6 = _pIDxName_[v3];\n        if (v6 != _pIDxName_[v3][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v6;\n        }\n    } else {\n        v5 = v7 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v8 = 0x326e(varg1);\n    0x3292(v0, varg0, v8, v5);\n    return ;\n}\n\nfunction 0xede(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    v1 = v2 = 0;\n    require(!msg.sender.code.size, 'sorry humans only');\n    v3 = v4 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v3 = v5 = !_pIDxAddr_[msg.sender];\n    }\n    require(v3, 'already has name');\n    v6 = 0x3462(varg1);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v7 = 0x2388(msg.sender);\n    v8 = 0x970(v0);\n    v9 = 0x2aec(msg.sender);\n    v10 = !varg0;\n    v11 = v12 = varg0;\n    if (varg0) {\n        v11 = v13 = v6 != varg0;\n    }\n    if (v11) {\n        v1 = v14 = _pIDxName_[varg0];\n        if (v14 != _pIDxName_[varg0][6]) {\n            _getPlayerLAff[v9][6] = v14;\n        }\n    }\n    0x3c75(v6, v9);\n    emit onNewName(v9, msg.sender, v6, v7, v1, address(_getPlayerLAff[v1]), _getPlayerLAff[v1][1], msg.value, block.timestamp);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x18a25e8) {\n            getBuyPrice();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x79ce327 == v0) {\n            reLoadXname(bytes32,uint256,uint256);\n        } else if (0xe07ef81 == v0) {\n            registerNameXname(string,bytes32);\n        } else if (0xf15f4c0 == v0) {\n            activate();\n        } else if (0x10f01eba == v0) {\n            pIDxAddr_(address);\n        } else if (0x180603eb == v0) {\n            registrationFee_();\n        } else if (0x24c33d33 == v0) {\n            round_(uint256);\n        } else if (0x2660316e == v0) {\n            plyrNames_(uint256,bytes32);\n        } else if (0x27d87924 == v0) {\n            registerNameXaddr(string,address);\n        } else if (0x2ce21999 == v0) {\n            fees_(uint256);\n        } else if (0x2e19ebdc == v0) {\n            pIDxName_(bytes32);\n        } else if (0x349cdcac == v0) {\n            reLoadXid(uint256,uint256,uint256);\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x5893d481 == v0) {\n            rndTmEth_(uint256,uint256);\n        } else if (0x624ae5c0 == v0) {\n            rID_();\n        } else if (0x63066434 == v0) {\n            getPlayerVaults(uint256);\n        } else if (0x747dff42 == v0) {\n            getCurrentRoundInfo();\n        } else if (0x82bfc739 == v0) {\n            reLoadXaddr(address,uint256,uint256);\n        } else if (0x82e37b2c == v0) {\n            getPlayerName(uint256);\n        } else if (0x8f38f309 == v0) {\n            buyXid(uint256,uint256);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x98a0871d == v0) {\n            buyXaddr(address,uint256);\n        } else if (0xa2bccae9 == v0) {\n            plyrRnds_(uint256,uint256);\n        } else if (0xa2e7223e == v0) {\n            isNewPlayer(address);\n        } else if (0xa65b37a1 == v0) {\n            buyXname(bytes32,uint256);\n        } else if (0xc519500e == v0) {\n            potSplit_(uint256);\n        } else if (0xc7e284b8 == v0) {\n            getTimeLeft();\n        } else if (0xce89c80c == v0) {\n            calcKeysReceived(uint256,uint256);\n        } else if (0xcf808000 == v0) {\n            iWantXKeys(uint256);\n        } else if (0xd53b2679 == v0) {\n            activated_();\n        } else if (0xde7874f3 == v0) {\n            plyr_(uint256);\n        } else if (0xe3c08adf == v0) {\n            getPlayerLAff(uint256);\n        } else if (0xee0b5d8b == v0) {\n            getPlayerInfoByAddress(address);\n        } else if (0xf32306d2 == v0) {\n            registerNameXID(string,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.01.25 14:41 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 stor_1; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 _registrationFee_; // STORAGE[0x3]\nuint256 _rID_; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pIDxAddr_; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _pIDxName_; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _getPlayerLAff; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _plyrRnds_; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _plyrNames_; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _round_; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _rndTmEth_; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _fees_; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _potSplit_; // STORAGE[0xd]\nuint256 _activated_; // STORAGE[0xe] bytes 0 to 0\n\n// Events\nonBuyAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonNewName(uint256, address, bytes32, bool, uint256, address, bytes32, uint256, uint256);\nonWithdrawAndDistribute(address, bytes32, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonWithdraw(uint256, address, bytes32, uint256, uint256);\nonReLoadAndDistribute(address, bytes32, uint256, uint256, address, bytes32, uint256, uint256, uint256);\nonEndTx(uint256, uint256, bytes32, address, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256);\n\nfunction 0x131a(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    v1 = v2 = 0;\n    require(!msg.sender.code.size, 'sorry humans only');\n    v3 = v4 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v3 = v5 = !_pIDxAddr_[msg.sender];\n    }\n    require(v3, 'already has name');\n    v6 = 0x3462(varg1);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v7 = 0x2388(msg.sender);\n    v8 = 0x970(v0);\n    v9 = 0x2aec(msg.sender);\n    v10 = !address(varg0);\n    v11 = v12 = address(varg0);\n    if (address(varg0)) {\n        v11 = v13 = address(varg0) != msg.sender;\n    }\n    if (v11) {\n        v14 = address(varg0);\n        v1 = v15 = _pIDxAddr_[v14];\n        if (v15 != _getPlayerLAff[v9][6]) {\n            _getPlayerLAff[v9][6] = v15;\n            0x3c75(v6, v9);\n        }\n    }\n    0x3c75(v6, v9);\n    emit onNewName(v9, msg.sender, v6, v7, v1, address(_getPlayerLAff[v1]), _getPlayerLAff[v1][1], msg.value, block.timestamp);\n    return ;\n}\n\nfunction 0x1561(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !v3;\n    if (v3) {\n        v1 = v4 = v3 == _pIDxAddr_[msg.sender];\n    }\n    if (!v1) {\n        if (v3 != _getPlayerLAff[_pIDxAddr_[msg.sender]][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v3;\n        }\n    } else {\n        v3 = v5 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v6 = 0x326e(varg1);\n    0x3292(v0, varg0, v6, v3);\n    return ;\n}\n\nfunction 0x1747() private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    v1 = v2 = block.timestamp > _round_[msg.sender][2];\n    if (v2) {\n        v1 = v3 = !(0xff & _round_[_rID_][0x3]);\n    }\n    if (v1) {\n        v1 = v4 = _round_[_rID_];\n    }\n    if (!v1) {\n        v5 = 0x3dca(_pIDxAddr_[msg.sender]);\n        if (v5 > 0) {\n            v6 = address(_getPlayerLAff[_pIDxAddr_[msg.sender]]).call().value(v5).gas(2300 * !v5);\n            require(v6); // checks call status, propagates error data on error\n        }\n        emit onWithdraw(_pIDxAddr_[msg.sender], msg.sender, _getPlayerLAff[_pIDxAddr_[msg.sender]][1], v5, block.timestamp);\n    } else {\n        _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n        v7 = 0x2e46();\n        v8 = 0x3dca(v0);\n        if (v8 > 0) {\n            v9 = address(_getPlayerLAff[v0]).call().value(v8).gas(2300 * !v8);\n            require(v9); // checks call status, propagates error data on error\n        }\n        MEM[0 + v7] = MEM[0 + v7] + 0;\n        MEM[32 + v7] = MEM[32 + v7] + v0;\n        emit onWithdrawAndDistribute(msg.sender, ~0x0 & (~0x0 & _getPlayerLAff[v0][0x1]), v8, MEM[0 + v7], MEM[32 + v7], address(MEM[64 + v7]), ~0x0 & (~0x0 & MEM[96 + v7]), MEM[128 + v7], MEM[160 + v7], MEM[192 + v7]);\n    }\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    0x9f1(v1, 2);\n}\n\nfunction 0x1d13(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !address(v3);\n    if (address(v3)) {\n        v1 = v4 = msg.sender == address(v3);\n    }\n    if (!v1) {\n        v5 = address(v3);\n        v6 = v7 = _pIDxAddr_[v5];\n        if (v7 != _getPlayerLAff[v5][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v7;\n            v8 = v9 = 0x326e(varg1);\n        }\n    } else {\n        v6 = v10 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v8 = v11 = 0x326e(varg1);\n    0x3292(v0, varg0, v8, v6);\n    return ;\n}\n\nfunction 0x1f0f(uint256 varg0) private { \n    return _getPlayerLAff[varg0][1];\n}\n\nfunction 0x1f27(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = v3 = !v4;\n    if (v4) {\n        v2 = v5 = v4 == _pIDxAddr_[msg.sender];\n    }\n    if (!v2) {\n        if (v4 != _getPlayerLAff[_pIDxAddr_[msg.sender]][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v4;\n        }\n    } else {\n        v4 = v6 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v7 = 0x326e(varg0);\n    0x9f1(v1, v7);\n    return ;\n}\n\nfunction 0x2145(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = 0x326e(varg0);\n    v3 = v4 = !address(v5);\n    if (address(v5)) {\n        v3 = v6 = msg.sender == address(v5);\n    }\n    if (!v3) {\n        v7 = address(v5);\n        v8 = v9 = _pIDxAddr_[v7];\n        if (v9 != _getPlayerLAff[v7][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v9;\n        }\n    } else {\n        v8 = v10 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    0x9f1(v1, v2);\n    return ;\n}\n\nfunction 0x2388(uint256 varg0) private { \n    v0 = address(varg0);\n    if (_pIDxAddr_[v0]) {\n        v1 = v2 = 0;\n        goto 0x1f220x2388;\n    } else {\n        v1 = v3 = 1;\n    }\n    return v1;\n}\n\nfunction 0x23b7(uint256 varg0) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(msg.value >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(msg.value <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = 0x970(v0);\n    v2 = v3 = !v4;\n    if (v4) {\n        v2 = v5 = v4 == _getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v2) {\n        v6 = v7 = _pIDxName_[v4];\n        if (v7 != _pIDxName_[v4][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v7;\n        }\n    } else {\n        v6 = v8 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v9 = 0x326e(varg0);\n    0x9f1(v1, v9);\n    return ;\n}\n\nfunction 0x25da() private { \n    if (block.timestamp >= _round_[_rID_][2]) {\n        v0 = v1 = 0;\n    } else {\n        if (block.timestamp <= _round_[_rID_][4] + stor_2) {\n            v0 = v2 = _SafeSub(block.timestamp, stor_2 + _round_[_rID_][4]);\n        } else {\n            v0 = v3 = _SafeSub(block.timestamp, _round_[_rID_][2]);\n        }\n        goto 0xc980x25da;\n    }\n    return v0;\n}\n\nfunction 0x2669(uint256 varg0) private { \n    v0 = v1 = block.timestamp > _round_[v2][4] + stor_2;\n    if (v1) {\n        v0 = v3 = block.timestamp <= _round_[v2][2];\n        if (block.timestamp > _round_[v2][2]) {\n            v0 = v4 = block.timestamp > _round_[v2][2];\n            if (v4) {\n                v0 = v5 = !_round_[v2];\n            }\n        }\n    }\n    if (!v0) {\n        v6 = v7 = 0x4083(varg0);\n    } else {\n        v6 = v8, v9, v10, v11 = 0x4062(varg0);\n    }\n    return v6;\n}\n\nfunction 0x2711(uint256 varg0) private { \n    v0 = v1 = block.timestamp > stor_2 + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = 0x40fb(varg0);\n    } else {\n        v7 = _SafeAdd(varg0, _round_[_rID_][5]);\n        v5 = v8 = 0x3241(varg0, v7);\n    }\n    return v5;\n}\n\nfunction 0x28fc(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(!msg.sender.code.size, 'sorry humans only');\n    v1 = v2 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v1 = v3 = !_pIDxAddr_[msg.sender];\n    }\n    require(v1, 'already has name');\n    v4 = 0x3462(varg1);\n    v5 = 0x2388(msg.sender);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v6 = 0x970(v0);\n    v7 = 0x2aec(msg.sender);\n    v8 = !varg0;\n    v9 = v10 = varg0;\n    if (varg0) {\n        v9 = v11 = varg0 != _getPlayerLAff[v7][6];\n    }\n    if (v9) {\n        v9 = v12 = varg0 != v7;\n    }\n    if (!v9) {\n        if (varg0 == v7) {\n            varg0 = v13 = 0;\n            0x3c75(v4, v7);\n        }\n    } else {\n        _getPlayerLAff[v7][6] = varg0;\n    }\n    0x3c75(v4, v7);\n    emit onNewName(v7, msg.sender, v4, v5, varg0, address(_getPlayerLAff[varg0]), _getPlayerLAff[varg0][1], msg.value, block.timestamp);\n    return ;\n}\n\nfunction 0x2aec(uint256 varg0) private { \n    v0 = address(varg0);\n    if (_pIDxAddr_[v0]) {\n        v1 = address(varg0);\n        v2 = v3 = _pIDxAddr_[v1];\n        goto 0x1f220x2aec;\n    } else {\n        v2 = v4 = 1 + stor_0;\n        stor_0 = v4;\n        v5 = address(varg0);\n        _pIDxAddr_[v5] = v4;\n    }\n    return v2;\n}\n\nfunction 0x2b53(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    varg2 = v0 = 0;\n    if (!_plyrRnds_[v1][1]) {\n        varg2 = v2 = 0x4168(varg0, varg4);\n    }\n    v3 = v4 = 0x56bc75e2d63100000 > _round_[v1][6];\n    if (v4) {\n        v5 = _SafeAdd(varg3, _plyrRnds_[v1]);\n        v3 = v6 = v5 > 0xde0b6b3a7640000;\n    }\n    if (v3) {\n        varg2 = v7 = _SafeSub(_plyrRnds_[v1], 0xde0b6b3a7640000);\n        varg2 = v8 = _SafeSub(v7, varg3);\n        v9 = _SafeAdd(v8, _getPlayerLAff[varg4][3]);\n        _getPlayerLAff[varg4][3] = v9;\n    }\n    if (varg2 > 0x3b9aca00) {\n        varg2 = v10 = 11414;\n        varg2 = v11, v12, varg2 = v13, varg2 = v14 = 0x4062(varg2);\n        if (v11 >= 0xde0b6b3a7640000) {\n            varg2 = v15 = 11441;\n            varg2 = v16 = 0;\n            varg2 = v17 = block.timestamp;\n            v18 = v19 = v17 > _round_[varg1][2];\n            if (v19) {\n                v18 = v20 = !_round_[varg1];\n            }\n            if (!v18) {\n                varg2 = v21 = _round_[varg1][2];\n                varg2 = v22 = 16965;\n                varg2 = v23 = 0x3f51(v11, 0xde0b6b3a7640000, 30);\n            } else {\n                varg2 = v24 = 16916;\n                varg2 = v25 = 0x3f51(v11, 0xde0b6b3a7640000, 30);\n            }\n        }\n        varg2 = v26 = _SafeAdd(varg2, varg2);\n        v27 = varg2 + varg2;\n        require(v27 >= varg2, 'SafeMath add failed');\n        _plyrRnds_[varg2][2] = v27;\n        varg2 = v28 = 18835;\n        v29 = 0x3e5d(_round_[varg2][5], varg2);\n        assert(0xde0b6b3a7640000);\n        varg2 = v29 / 0xde0b6b3a7640000;\n        while (varg2 > varg2) {\n            varg2 = varg2 - varg2;\n            goto {'0x4993', '0x3e1b0x2b53', '0x44f2', '0x1bd10x2b53'};\n            continue;\n            varg2 = _SafeSub(varg2, varg2);\n            varg2 = v30 = 17682;\n            varg2 = v31 = 0;\n            v32 = 0x3e5d(0xde0b6b3a7640000, varg2);\n            assert(_round_[varg2][5]);\n            varg2 = v32 / _round_[varg2][5];\n            v33 = _SafeAdd(_round_[varg2][8], varg2);\n            _round_[varg2][8] = v33;\n            v34 = 0x3e5d(varg2, varg2);\n            assert(0xde0b6b3a7640000);\n            varg2 = v35 = _plyrRnds_[varg2][2];\n            varg2 = v34 / 0xde0b6b3a7640000;\n            varg2 = v36 = 18739;\n            varg2 = v37 = 15899;\n            v38 = 0x3e5d(varg2, _round_[varg2][8]);\n            assert(0xde0b6b3a7640000);\n            varg2 = v38 / 0xde0b6b3a7640000;\n        }\n        revert('SafeMath sub failed');\n        if (varg2 > 0) {\n            varg2 = _SafeSub(varg2, varg2);\n        }\n        require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n        v39 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(varg2).gas(msg.gas);\n        if (v39) {\n            varg2 = v40 = _round_[varg2][7];\n            varg2 = v41 = 17858;\n            varg2 = v42 = _SafeAdd(varg2, varg2);\n        } else {\n            RETURNDATACOPY(0, 0, RETURNDATASIZE());\n            revert(0, RETURNDATASIZE());\n        }\n        v43 = _SafeAdd(varg2, 0x15180);\n        if (varg2 >= v43) {\n            v44 = _SafeAdd(varg2, 0x15180);\n            _round_[varg2][2] = v44;\n        } else {\n            _round_[varg2][2] = varg2;\n        }\n        if (varg2 != _round_[varg2]) {\n            _round_[varg2] = varg2;\n        }\n        if (varg2 != _round_[varg2][1]) {\n            _round_[varg2][1] = varg2;\n        }\n        MEM[varg2] += 100;\n        _round_[varg2][7] = varg2;\n        v45 = _SafeAdd(MEM[varg2 + 192], varg2);\n        MEM[varg2 + 192] = v45;\n        MEM[varg2 + 224] = varg2;\n        MEM[0 + varg2] = MEM[0 + varg2] + 0xde0b6b3a7640000 * block.timestamp + 0x1431e0fae6d7217caa0000000 * varg2;\n        MEM[32 + varg2] = MEM[32 + varg2] + varg2 + 0x1aba4714957d300d0e549208b31adb10000000000000 * _rID_;\n        emit onEndTx(MEM[0 + varg2], MEM[32 + varg2], ~0x0 & (~0x0 & _getPlayerLAff[varg2][0x1]), msg.sender, varg2, varg2, address(MEM[64 + varg2]), ~0x0 & (~0x0 & MEM[96 + varg2]), MEM[128 + varg2], MEM[160 + varg2], MEM[192 + varg2], MEM[224 + varg2]);\n        goto 0xed30x2b53;\n        v46 = _SafeAdd(_plyrRnds_[varg2][1], varg2);\n        _plyrRnds_[varg2][1] = v46;\n        v47 = _SafeAdd(_plyrRnds_[varg2], varg2);\n        _plyrRnds_[varg2] = v47;\n        v48 = _SafeAdd(_round_[varg2][5], varg2);\n        _round_[varg2][5] = v48;\n        v49 = _SafeAdd(_round_[varg2][6], varg2);\n        _round_[varg2][6] = v49;\n        v50 = _SafeAdd(_rndTmEth_[varg2], varg2);\n        _rndTmEth_[varg2] = v50;\n        v51 = 0x499e();\n        v52 = v53 = varg2 / 10;\n        v54 = 0x3e5d(3, varg2);\n        assert(100);\n        if (_getPlayerLAff[varg2][6]) {\n            v55 = v56 = _getPlayerLAff[varg2][6] != varg2;\n            if (v56) {\n                v55 = v57 = _getPlayerLAff[_getPlayerLAff[varg2][6]][1];\n            }\n            if (!v55) {\n                v52 = v58 = _SafeAdd(v54 / 100, v53);\n            } else {\n                v59 = _SafeAdd(_getPlayerLAff[_getPlayerLAff[varg2][6]][4], v54 / 100);\n                _getPlayerLAff[_getPlayerLAff[varg2][6]][4] = v59;\n            }\n        } else {\n            v52 = v60 = _SafeAdd(v54 / 100, v53);\n        }\n        v61 = v62 = varg2 != varg2;\n        if (v62) {\n            v61 = v63 = _getPlayerLAff[varg2][1];\n        }\n        if (!v61) {\n            require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n            v64 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(v52).gas(msg.gas);\n            if (!v64) {\n                RETURNDATACOPY(0, 0, RETURNDATASIZE());\n                revert(0, RETURNDATASIZE());\n            }\n        } else {\n            v65 = _SafeAdd(_getPlayerLAff[varg2][4], v52);\n            _getPlayerLAff[varg2][4] = v65;\n        }\n        varg2 = v66 = 11831;\n        varg2 = v67 = 0x499e();\n        varg2 = v68 = 0;\n        v69 = 0x3e5d(_fees_[varg2][1], varg2);\n        assert(100);\n        varg2 = v69 / 100;\n        v70 = 0x3e5d(_fees_[varg2][2], varg2);\n        assert(100);\n        varg2 = v70 / 100;\n        varg2 = v71 = 17650;\n        varg2 = v72 = 7121;\n        v73 = 0x3e5d(13, varg2);\n        assert(100);\n        varg2 = v73 / 100;\n    }\n    return ;\n}\n\nfunction 0x2e46() private { \n    v0 = v1 = 0x499e();\n    v0 = v2 = _rID_;\n    v0 = v3 = 0;\n    v0 = v4 = _round_[v2];\n    v0 = v5 = _round_[v2][1];\n    v0 = v6 = _round_[v2][7];\n    v7 = 0x3e5d(48, v6);\n    assert(100);\n    v0 = v8 = v7 / 100;\n    v0 = v9 = v6 / 50;\n    v10 = 0x3e5d(_potSplit_[v5][1], v6);\n    assert(100);\n    v0 = v11 = v10 / 100;\n    v0 = v12 = 12002;\n    v0 = v13 = 7121;\n    v14 = v15 = _SafeSub(v8, v6);\n    while (1) {\n        v14 = _SafeSub(v0, v14);\n    }\n    v16 = 0x3e5d(0xde0b6b3a7640000, v0);\n    assert(_round_[v0][5]);\n    v17 = 0x3e5d(_round_[v0][5], v16 / _round_[v0][5]);\n    assert(0xde0b6b3a7640000);\n    require(v17 / 0xde0b6b3a7640000 <= v0, 'SafeMath sub failed');\n    if (v0 - v17 / 0xde0b6b3a7640000 > 0) {\n        v0 = v18 = _SafeSub(v0 - v17 / 0xde0b6b3a7640000, v0);\n        v14 = v19 = _SafeAdd(v0 - v17 / 0xde0b6b3a7640000, v14);\n    }\n    v20 = _SafeAdd(_getPlayerLAff[v0][2], v0);\n    _getPlayerLAff[v0][2] = v20;\n    require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n    v21 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(v0).gas(msg.gas);\n    require(v21); // checks call status, propagates error data on error\n    v22 = _SafeAdd(_round_[v0][8], v16 / _round_[v0][5]);\n    _round_[v0][8] = v22;\n    MEM[0 + v2] = MEM[0 + v2] + 0xf4240 * _round_[v0][2];\n    MEM[32 + v2] = MEM[32 + v2] + 0x52b7d2dcc80cd2e4000000 * v0 + 0x16345785d8a0000 * v0;\n    MEM[64 + v2] = address(_round_[v0][0]);\n    MEM[96 + v2] = ~0x0 & (~0x0 & _round_[v0][0x1]);\n    MEM[128 + v2] = v0;\n    MEM[192 + v2] = v0;\n    MEM[160 + v2] = v14;\n    _rID_ += 1;\n    _round_[v0][4] = block.timestamp;\n    v23 = _SafeAdd(36000, block.timestamp);\n    _round_[1 + v0][2] = v23;\n    _round_[1 + v0][7] = v14;\n    return v2;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, 'SafeMath add failed');\n    return v0;\n}\n\nfunction 0x3241(uint256 varg0, uint256 varg1) private { \n    v0 = _SafeSub(varg0, varg1);\n    v1 = 0x40fb(v0);\n    v2 = 0x40fb(varg1);\n    v3 = _SafeSub(v1, v2);\n    return v3;\n}\n\nfunction 0x326e(uint256 varg0) private { \n    v0 = v1 = varg0 < 0;\n    if (varg0 >= 0) {\n        v0 = v2 = varg0 > 3;\n    }\n    if (!v0) {\n        goto 0x1f220x326e;\n    } else {\n        varg0 = v3 = 2;\n    }\n    return varg0;\n}\n\nfunction 0x3292(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + stor_2;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8 = 0x2e46();\n            MEM[v8] += varg0 * 0xde0b6b3a7640000;\n            MEM[v8 + 32] += varg2;\n            v9 = _getPlayerLAff[varg2][1];\n            emit onReLoadAndDistribute(msg.sender, v9, MEM[v8], MEM[v8 + 32], address(MEM[v8 + 64]), MEM[v8 + 96], MEM[v8 + 128], MEM[v8 + 160], MEM[v8 + 192]);\n            return ;\n        }\n    } else {\n        v10 = 0x3dca(v11);\n        v12 = _SafeSub(varg1, v10);\n        _getPlayerLAff[v11][3] = v12;\n        0x2b53(varg0, varg2, varg3, varg1, v11);\n        goto 0x1ab30x3292;\n    }\n    return ;\n}\n\nfunction getBuyPrice() public nonPayable { \n    v0 = 0xbda();\n    return v0;\n}\n\nfunction 0x3462(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = varg0.length <= 32;\n    if (varg0.length <= 32) {\n        v2 = v4 = varg0.length > 0;\n    }\n    require(v2, 'string must be between 1 and 32 characters');\n    assert(0 < varg0.length);\n    v5 = v6 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248;\n    if (v6) {\n        assert(varg0.length - 1 < varg0.length);\n        v5 = v7 = 0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (varg0.length - 1)] >> 248 << 248;\n    }\n    require(v5, 'string cannot start or end with space');\n    assert(0 < varg0.length);\n    if (0x3000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 0] >> 248 << 248) {\n        assert(1 < varg0.length);\n        require(0x7800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0x');\n        assert(1 < varg0.length);\n        require(0x5800000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + 1] >> 248 << 248, 'string cannot start with 0X');\n    }\n    v8 = v9 = 0;\n    while (v8 < varg0.length) {\n        if (v8 < varg0.length) {\n            break;\n        }\n        assert(v8 < varg0.length);\n        v10 = v11 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x4000000000000000000000000000000000000000000000000000000000000000;\n        if (v11) {\n            assert(v8 < varg0.length);\n            v10 = v12 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x5b00000000000000000000000000000000000000000000000000000000000000;\n        }\n        if (!v10) {\n            assert(v8 < varg0.length);\n            v13 = v14 = 0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248;\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(v8 < varg0.length);\n                v13 = v15 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x6000000000000000000000000000000000000000000000000000000000000000;\n                if (v15) {\n                    assert(v8 < varg0.length);\n                    v13 = v16 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x7b00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (!v13) {\n                assert(v8 < varg0.length);\n                v13 = v17 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x2f00000000000000000000000000000000000000000000000000000000000000;\n                if (v17) {\n                    assert(v8 < varg0.length);\n                    v13 = v18 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3a00000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            require(v13, 'string contains invalid characters');\n            assert(v8 < varg0.length);\n            if (0x2000000000000000000000000000000000000000000000000000000000000000 == ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248) {\n                assert(1 + v8 < varg0.length);\n                require(0x2000000000000000000000000000000000000000000000000000000000000000 != ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + (1 + v8)] >> 248 << 248, 'string cannot contain consecutive spaces');\n            }\n            v19 = v20 = !v0;\n            if (v20) {\n                assert(v8 < varg0.length);\n                v19 = v21 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 < 0x3000000000000000000000000000000000000000000000000000000000000000;\n                if (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 >= 0x3000000000000000000000000000000000000000000000000000000000000000) {\n                    assert(v8 < varg0.length);\n                    v19 = v22 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[varg0.data + v8] >> 248 << 248 > 0x3900000000000000000000000000000000000000000000000000000000000000;\n                }\n            }\n            if (v19) {\n                v0 = v23 = 1;\n            }\n        } else {\n            assert(v8 < varg0.length);\n            assert(v8 < varg0.length);\n            MEM8[varg0.data + v8] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 32 + (MEM[varg0.data + v8] >> 248 << 248 >> 248) << 248, 0x0)) & 0xFF;\n            if (!v0) {\n                v0 = v24 = 1;\n            }\n        }\n        v8 = v8 + 1;\n    }\n    require(v0 == 1, 'string cannot be only numbers');\n    return MEM[varg0.data];\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction 0x3c75(uint256 varg0, uint256 varg1) private { \n    if (_pIDxName_[varg0]) {\n        require(1 == 0xff & _plyrNames_[varg1], 'sorry that names already taken');\n    }\n    _getPlayerLAff[varg1][1] = varg0;\n    _pIDxName_[varg1] = varg1;\n    if (!(0xff & _plyrNames_[varg1])) {\n        _plyrNames_[varg1] = 0x1 | ~0xff & _plyrNames_[varg1];\n    }\n    require(0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.code.size);\n    v0 = 0xab274af9ccf1dd9ac0d7de680fb41ffc2486ce8d.deposit().value(msg.value).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x3dca(uint256 varg0) private { \n    0x4759(_getPlayerLAff[varg0][5], varg0);\n    v0 = _SafeAdd(_getPlayerLAff[varg0][3], _getPlayerLAff[varg0][2]);\n    v1 = _SafeAdd(_getPlayerLAff[varg0][4], v0);\n    if (v1 > 0) {\n        _getPlayerLAff[varg0][2] = 0;\n        _getPlayerLAff[varg0][3] = 0;\n        _getPlayerLAff[varg0][4] = 0;\n    }\n    return v1;\n}\n\nfunction 0x3e5d(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        require(v0 / varg1 == varg0, 'SafeMath mul failed');\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction 0x3ed4(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = _plyrRnds_[varg0][1];\n    varg0 = v3 = _round_[varg0][5];\n    v4 = _round_[varg0][1];\n    varg0 = v5 = 0xde0b6b3a7640000;\n    v0 = v6 = 16275;\n    v0 = v7 = 16263;\n    v0 = v8 = 16222;\n    v9 = 0x3e5d(_round_[varg0][1], _round_[varg0][7]);\n    assert(100);\n    v10 = v9 / 100;\n    while (1) {\n        if (v10) {\n            goto 0x3e6e0x3ed4;\n        }\n        v10 = v11 = 0;\n        while (1) {\n            goto {'0x3f870x3ed4', '0x3f5e', '0x3f93'};\n            if (varg0) {\n                break;\n            }\n            assert(varg0);\n            v12 = _round_[varg0][8];\n            v10 = v10 / varg0 + v12;\n            require(v10 >= v12, 'SafeMath add failed');\n        }\n        continue;\n        v10 *= varg0;\n        assert(v10);\n        require(v10 / v10 == varg0, 'SafeMath mul failed');\n    }\n    assert(varg0);\n    return v10 / varg0, v0, varg0, v0;\n}\n\nfunction reLoadXname(bytes32 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    0xcd4(varg2, varg1);\n}\n\nfunction 0x3f51(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    if (v0) {\n        v1 = varg2 * v0;\n        assert(v0);\n        require(v1 / v0 == varg2, 'SafeMath mul failed');\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1, 'SafeMath sub failed');\n    return varg1 - varg0;\n}\n\nfunction 0x4004(uint256 varg0, uint256 varg1) private { \n    v0 = _plyrRnds_[varg0][2];\n    v1 = 0x3e5d(_plyrRnds_[varg0][1], _round_[varg0][8]);\n    assert(0xde0b6b3a7640000);\n    require(v0 <= v1 / 0xde0b6b3a7640000, 'SafeMath sub failed');\n    return v1 / 0xde0b6b3a7640000 - v0;\n}\n\nfunction 0x4062(uint256 varg0) private { \n    v0 = v1 = 0;\n    varg0 = v2 = 12903;\n    v0 = v3 = 0x4083(v0);\n    varg0 = v4 = 7121;\n    v0 = v5 = varg0 + v0;\n    require(v5 >= v0, 'SafeMath add failed');\n    varg0 = v6 = 0;\n    v0 = v7 = 0x9502f90;\n    varg0 = v8 = 16619;\n    v0 = v9 = 0x3b2a1d15167e7c5699bfde00000;\n    v10 = 0x3e5d(0xde0b6b3a7640000, v5);\n    v11 = 0x3e5d(0x1027e72f1f1281308800000, v10);\n    v12 = _SafeAdd(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000, v11);\n    v0 = v13 = 0x47f0(v12);\n    while (1) {\n        v0 = _SafeSub(v0, v0);\n        assert(v0);\n        v0 = v0 / v0;\n        goto 0x1bd10x4062;\n    }\n    require(v0 <= v0, 'SafeMath sub failed');\n    return v0 - v0, v0, varg0, v0;\n}\n\nfunction 0x4083(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0x9502f90;\n    v0 = v4 = 16619;\n    v5 = v6 = 0x3b2a1d15167e7c5699bfde00000;\n    v7 = 0x3e5d(0xde0b6b3a7640000, varg0);\n    v8 = 0x3e5d(0x1027e72f1f1281308800000, v7);\n    v9 = _SafeAdd(0xdac7055469777a6122ee4310dd6c14410500f2904840000000000, v8);\n    v2 = v10 = 0x47f0(v9);\n    v5 = v11 = _SafeSub(v6, v10);\n    require(v5 <= v2, 'SafeMath sub failed');\n    while (1) {\n        goto 0x32670x4083;\n    }\n    assert(v2);\n    return v5 / v2;\n}\n\nfunction registerNameXname(string varg0, bytes32 varg1) public payable { \n    v0 = new bytes[](varg0.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    0xede(varg1, v0);\n}\n\nfunction 0x40fb(uint256 varg0) private { \n    v0 = 0x4843(0xde0b6b3a7640000);\n    v1 = 0x3e5d(0xde0b6b3a7640000, varg0);\n    v2 = 0x3e5d(v1, 0x886c8f673070);\n    assert(2);\n    v3 = 0x4843(varg0);\n    v4 = 0x3e5d(v3, 0x4a817c8);\n    require((v2 >> 1) + v4 >= v4, 'SafeMath add failed');\n    assert(v0);\n    return ((v2 >> 1) + v4) / v0;\n}\n\nfunction 0x4168(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    if (_getPlayerLAff[varg1][5]) {\n        0x4759(_getPlayerLAff[varg1][5], varg1);\n    }\n    _getPlayerLAff[varg1][5] = _rID_;\n    MEM[varg0] += 10;\n    return varg0;\n}\n\nfunction activate() public nonPayable { \n    require(msg.sender == 0x701b5b2f6bc3f74eb15daebacfc65e6eadfbb0da, 'only team just can activate');\n    require(!_activated_, 'Star3d already activated');\n    _activated_ = 1;\n    _rID_ = 1;\n    MEM[0] = 1;\n    MEM[32] = 10;\n    STORAGE[0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bcb] = block.timestamp;\n    STORAGE[0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bc9] = 36000 + (stor_1 + block.timestamp);\n}\n\nfunction pIDxAddr_(address varg0) public nonPayable { \n    return _pIDxAddr_[varg0];\n}\n\nfunction 0x4759(uint256 varg0, uint256 varg1) private { \n    v0 = 0x4004(varg0, varg1);\n    if (v0 > 0) {\n        v1 = _SafeAdd(_getPlayerLAff[varg1][3], v0);\n        _getPlayerLAff[varg1][3] = v1;\n        v2 = _SafeAdd(_plyrRnds_[varg1][2], v0);\n        _plyrRnds_[varg1][2] = v2;\n    }\n    return ;\n}\n\nfunction 0x47f0(uint256 varg0) private { \n    v0 = _SafeAdd(1, varg0);\n    assert(2);\n    varg0 = v1 = v0 >> 1;\n    while (varg0 < varg0) {\n        if (varg0) {\n            break;\n        }\n        assert(varg0);\n        v2 = varg0 / varg0;\n        if (varg0 + v2 >= v2) {\n            break;\n        }\n        require(varg0 + v2 >= v2, 'SafeMath add failed');\n        assert(2);\n        varg0 = varg0 + v2 >> 1;\n    }\n    return varg0;\n}\n\nfunction 0x4843(uint256 varg0) private { \n    v0 = 0x3e5d(varg0, varg0);\n    return v0;\n}\n\nfunction registrationFee_() public nonPayable { \n    return _registrationFee_;\n}\n\nfunction 0x499e() private { \n    MEM[64] = MEM[64] + 256;\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[128 + MEM[64]] = 0;\n    MEM[160 + MEM[64]] = 0;\n    MEM[192 + MEM[64]] = 0;\n    MEM[224 + MEM[64]] = 0;\n    return MEM[64];\n}\n\nfunction round_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _round_[varg0][2];\n    MEM[MEM[64] + 96] = _round_[varg0][0x3] & 0xff;\n    return _round_[varg0], _round_[varg0][1], v1, v1, _round_[varg0][4], _round_[varg0][5], _round_[varg0][6], _round_[varg0][7], _round_[varg0][8], _round_[varg0][9], _round_[varg0][10];\n}\n\nfunction plyrNames_(uint256 varg0, bytes32 varg1) public nonPayable { \n    return 0xff & _plyrNames_[varg1];\n}\n\nfunction registerNameXaddr(string _nameString, address _affCode) public payable { \n    v0 = new bytes[](_nameString.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + _nameString, _nameString.length);\n    0x131a(_affCode, v0);\n}\n\nfunction fees_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _fees_[varg0][2];\n    MEM[MEM[64] + 96] = _fees_[varg0][3];\n    return _fees_[varg0], _fees_[varg0][1];\n}\n\nfunction pIDxName_(bytes32 varg0) public nonPayable { \n    return _pIDxName_[varg0];\n}\n\nfunction reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) public nonPayable { \n    0x1561(_eth, _team);\n}\n\nfunction withdraw() public nonPayable { \n    0x1747();\n}\n\nfunction rndTmEth_(uint256 varg0, uint256 varg1) public nonPayable { \n    return _rndTmEth_[varg1];\n}\n\nfunction rID_() public nonPayable { \n    return _rID_;\n}\n\nfunction getPlayerVaults(uint256 _pID) public nonPayable { \n    v0 = v1 = 1644;\n    v2 = v3 = _rID_;\n    v0 = v4 = 0;\n    v5 = v6 = block.timestamp > _round_[v3][2];\n    if (v6) {\n        v5 = v7 = !(0xff & _round_[v3][0x3]);\n    }\n    if (v5) {\n        v5 = v8 = _round_[v3];\n    }\n    if (!v5) {\n        v9 = v10 = _getPlayerLAff[_pID][2];\n        v11 = v12 = 7163;\n        v13 = v14 = 0x4004(_getPlayerLAff[_pID][5], _pID);\n    } else {\n        if (_pID != _round_[v3]) {\n            v15 = _getPlayerLAff[_pID][2];\n            v16 = _plyrRnds_[v3][2];\n            v9 = v17 = 7121;\n            v18 = v19, v20 = v21, v22 = v23, v11 = v24 = 0x3ed4(v3);\n        } else {\n            v25 = 0x3e5d(48, _round_[v3][7]);\n            assert(100);\n            require(v25 / 100 + _getPlayerLAff[_pID][2] >= _getPlayerLAff[_pID][2], 'SafeMath add failed');\n            v26 = _plyrRnds_[v3][2];\n            v9 = v27 = 7121;\n            v18 = v28, v20 = v29, v22 = v30, v11 = v31 = 0x3ed4(v3);\n        }\n        v13 = v32 = _SafeSub(v20, v18);\n    }\n    v33 = _SafeAdd(v13, _getPlayerLAff[v2][3]);\n    MEM[v34.data] = _getPlayerLAff[v2][4];\n    return v9, v33;\n}\n\nfunction getCurrentRoundInfo() public nonPayable { \n    MEM[v0.data] = _round_[_rID_][2];\n    MEM[MEM[64] + 96] = _round_[_rID_][4];\n    return _rID_, _round_[_rID_][5], v1, v1, _round_[_rID_][7], _round_[_rID_][1] + 10 * _round_[_rID_], address(_round_[_round_[_rID_]]), _round_[_round_[_rID_]][1], _rndTmEth_[_round_[_rID_]], _rndTmEth_[1], _rndTmEth_[1], _rndTmEth_[3];\n}\n\nfunction reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) public nonPayable { \n    0x1d13(_eth, _team);\n}\n\nfunction getPlayerName(uint256 _pID) public nonPayable { \n    v0 = 0x1f0f(_pID);\n    return v0;\n}\n\nfunction buyXid(uint256 _affCode, uint256 _team) public payable { \n    0x1f27(_team);\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (0x1f & v1.length) {\n        MEM[v0.data] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v0.data];\n    }\n    return v0;\n}\n\nfunction buyXaddr(address _affCode, uint256 _team) public payable { \n    0x2145(_team);\n}\n\nfunction plyrRnds_(uint256 varg0, uint256 varg1) public nonPayable { \n    MEM[v0.data] = _plyrRnds_[varg1][2];\n    return _plyrRnds_[varg1], _plyrRnds_[varg1][1];\n}\n\nfunction isNewPlayer(address _addr) public nonPayable { \n    v0 = 0x2388(_addr);\n    return v0;\n}\n\nfunction buyXname(bytes32 _affCode, uint256 _team) public payable { \n    0x23b7(_team);\n}\n\nfunction potSplit_(uint256 varg0) public nonPayable { \n    return _potSplit_[varg0], _potSplit_[varg0][1];\n}\n\nfunction getTimeLeft() public nonPayable { \n    v0 = 0x25da();\n    return v0;\n}\n\nfunction calcKeysReceived(uint256 _rID, uint256 _eth) public nonPayable { \n    v0 = 0x2669(_eth);\n    return v0;\n}\n\nfunction iWantXKeys(uint256 _keys) public nonPayable { \n    v0 = 0x2711(_keys);\n    return v0;\n}\n\nfunction activated_() public nonPayable { \n    return _activated_;\n}\n\nfunction plyr_(uint256 varg0) public nonPayable { \n    MEM[v0.data] = _getPlayerLAff[varg0][2];\n    MEM[MEM[64] + 96] = _getPlayerLAff[varg0][3];\n    return address(_getPlayerLAff[varg0]), _getPlayerLAff[varg0][1], v1, v1, _getPlayerLAff[varg0][4], _getPlayerLAff[varg0][5], _getPlayerLAff[varg0][6];\n}\n\nfunction getPlayerLAff(uint256 _pID) public nonPayable { \n    return _getPlayerLAff[_pID][6];\n}\n\nfunction getPlayerInfoByAddress(address _addr) public nonPayable { \n    v0 = _pIDxAddr_[_addr];\n    v1 = 0x4004(_getPlayerLAff[v0][5], v0);\n    v2 = _SafeAdd(v1, _getPlayerLAff[v0][3]);\n    MEM[v3.data] = _plyrRnds_[v0][1];\n    MEM[MEM[64] + 96] = _getPlayerLAff[v0][2];\n    return v0, _getPlayerLAff[v0][1], v4, v4, v2, _getPlayerLAff[v0][4], _plyrRnds_[v0];\n}\n\nfunction registerNameXID(string _nameString, uint256 _affCode) public payable { \n    v0 = new bytes[](_nameString.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + _nameString, _nameString.length);\n    0x28fc(_affCode, v0);\n}\n\nfunction 0x970(uint256 varg0) private { \n    v0 = 0x499e();\n    if (!_pIDxAddr_[msg.sender]) {\n        v1 = 0x2aec(msg.sender);\n        _pIDxAddr_[msg.sender] = v1;\n        _getPlayerLAff[v1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getPlayerLAff[v1];\n        MEM[varg0] += 1;\n    }\n    return varg0;\n}\n\nfunction 0x9f1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = block.timestamp > _round_[_rID_][4] + stor_2;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = block.timestamp > _round_[_rID_][2];\n        if (v6) {\n            v5 = v7 = !(0xff & _round_[_rID_][0x3]);\n        }\n        if (v5) {\n            _round_[_rID_][3] = 0x1 | ~0xff & _round_[_rID_][0x3];\n            v8 = 0x2e46();\n            MEM[v8] += varg0 * 0xde0b6b3a7640000;\n            MEM[v8 + 32] += varg1;\n            v9 = _getPlayerLAff[varg1][1];\n            emit onBuyAndDistribute(msg.sender, v9, msg.value, MEM[v8], MEM[v8 + 32], address(MEM[v8 + 64]), MEM[v8 + 96], MEM[v8 + 128], MEM[v8 + 160], MEM[v8 + 192]);\n        }\n        v10 = _SafeAdd(msg.value, _getPlayerLAff[varg1][3]);\n        _getPlayerLAff[varg1][3] = v10;\n    } else {\n        0x2b53(varg0, varg1, v11, msg.value, v12);\n    }\n    return ;\n}\n\nfunction 0xbda() private { \n    v0 = v1 = block.timestamp > stor_2 + _round_[_rID_][4];\n    if (v1) {\n        v0 = v2 = block.timestamp <= _round_[_rID_][2];\n        if (block.timestamp > _round_[_rID_][2]) {\n            v0 = v3 = block.timestamp > _round_[_rID_][2];\n            if (v3) {\n                v0 = v4 = !_round_[_rID_];\n            }\n        }\n    }\n    if (!v0) {\n        v5 = v6 = 0x44364c5bb000;\n    } else {\n        v7 = _SafeAdd(0xde0b6b3a7640000, _round_[_rID_][5]);\n        v5 = v8 = 0x3241(0xde0b6b3a7640000, v7);\n        goto 0xc980xbda;\n    }\n    return v5;\n}\n\nfunction 0xcd4(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    require(1 == _activated_, 'its not ready yet.  check ?eta in discord');\n    require(!msg.sender.code.size, 'sorry humans only');\n    require(varg0 >= 0x3b9aca00, 'pocket lint: not a valid currency');\n    require(varg0 <= 0x152d02c7e14af6800000, 'no vitalik, no');\n    v1 = v2 = !v3;\n    if (v3) {\n        v1 = v4 = v3 == _getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    }\n    if (!v1) {\n        v5 = v6 = _pIDxName_[v3];\n        if (v6 != _pIDxName_[v3][6]) {\n            _getPlayerLAff[_pIDxAddr_[msg.sender]][6] = v6;\n        }\n    } else {\n        v5 = v7 = _getPlayerLAff[_pIDxAddr_[msg.sender]][6];\n    }\n    v8 = 0x326e(varg1);\n    0x3292(v0, varg0, v8, v5);\n    return ;\n}\n\nfunction 0xede(uint256 varg0, uint256 varg1) private { \n    v0 = 0x499e();\n    v1 = v2 = 0;\n    require(!msg.sender.code.size, 'sorry humans only');\n    v3 = v4 = !_getPlayerLAff[_pIDxAddr_[msg.sender]][1];\n    if (_getPlayerLAff[_pIDxAddr_[msg.sender]][1]) {\n        v3 = v5 = !_pIDxAddr_[msg.sender];\n    }\n    require(v3, 'already has name');\n    v6 = 0x3462(varg1);\n    require(msg.value >= _registrationFee_, 'umm.....  you have to pay the name fee');\n    v7 = 0x2388(msg.sender);\n    v8 = 0x970(v0);\n    v9 = 0x2aec(msg.sender);\n    v10 = !varg0;\n    v11 = v12 = varg0;\n    if (varg0) {\n        v11 = v13 = v6 != varg0;\n    }\n    if (v11) {\n        v1 = v14 = _pIDxName_[varg0];\n        if (v14 != _pIDxName_[varg0][6]) {\n            _getPlayerLAff[v9][6] = v14;\n        }\n    }\n    0x3c75(v6, v9);\n    emit onNewName(v9, msg.sender, v6, v7, v1, address(_getPlayerLAff[v1]), _getPlayerLAff[v1][1], msg.value, block.timestamp);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x18a25e8) {\n            getBuyPrice();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x79ce327 == v0) {\n            reLoadXname(bytes32,uint256,uint256);\n        } else if (0xe07ef81 == v0) {\n            registerNameXname(string,bytes32);\n        } else if (0xf15f4c0 == v0) {\n            activate();\n        } else if (0x10f01eba == v0) {\n            pIDxAddr_(address);\n        } else if (0x180603eb == v0) {\n            registrationFee_();\n        } else if (0x24c33d33 == v0) {\n            round_(uint256);\n        } else if (0x2660316e == v0) {\n            plyrNames_(uint256,bytes32);\n        } else if (0x27d87924 == v0) {\n            registerNameXaddr(string,address);\n        } else if (0x2ce21999 == v0) {\n            fees_(uint256);\n        } else if (0x2e19ebdc == v0) {\n            pIDxName_(bytes32);\n        } else if (0x349cdcac == v0) {\n            reLoadXid(uint256,uint256,uint256);\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x5893d481 == v0) {\n            rndTmEth_(uint256,uint256);\n        } else if (0x624ae5c0 == v0) {\n            rID_();\n        } else if (0x63066434 == v0) {\n            getPlayerVaults(uint256);\n        } else if (0x747dff42 == v0) {\n            getCurrentRoundInfo();\n        } else if (0x82bfc739 == v0) {\n            reLoadXaddr(address,uint256,uint256);\n        } else if (0x82e37b2c == v0) {\n            getPlayerName(uint256);\n        } else if (0x8f38f309 == v0) {\n            buyXid(uint256,uint256);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0x98a0871d == v0) {\n            buyXaddr(address,uint256);\n        } else if (0xa2bccae9 == v0) {\n            plyrRnds_(uint256,uint256);\n        } else if (0xa2e7223e == v0) {\n            isNewPlayer(address);\n        } else if (0xa65b37a1 == v0) {\n            buyXname(bytes32,uint256);\n        } else if (0xc519500e == v0) {\n            potSplit_(uint256);\n        } else if (0xc7e284b8 == v0) {\n            getTimeLeft();\n        } else if (0xce89c80c == v0) {\n            calcKeysReceived(uint256,uint256);\n        } else if (0xcf808000 == v0) {\n            iWantXKeys(uint256);\n        } else if (0xd53b2679 == v0) {\n            activated_();\n        } else if (0xde7874f3 == v0) {\n            plyr_(uint256);\n        } else if (0xe3c08adf == v0) {\n            getPlayerLAff(uint256);\n        } else if (0xee0b5d8b == v0) {\n            getPlayerInfoByAddress(address);\n        } else if (0xf32306d2 == v0) {\n            registerNameXID(string,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 125.67799806594849,
	"usage": {
		"completion_tokens": 1264,
		"prompt_tokens": 17076,
		"total_tokens": 18340
	}
}