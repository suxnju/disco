{
	"address": "0x4e61ba9c25d43e802c6be8d160432e4989dea1fc",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity equivalent of the provided decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.7;\n\ncontract IOUContract {\n    mapping (address => uint256) private _iou_purchased;\n    mapping (address => uint256) private _eth_sent;\n    uint256 private _total_iou_available;\n    uint256 private _total_iou_purchased;\n    address private _token;\n    address private _haltPurchases;\n    bool private _halt_purchases;\n\n    constructor(address token, uint256 totalIOUAvailable) {\n        _token = token;\n        _total_iou_available = totalIOUAvailable;\n        _haltPurchases = msg.sender;\n    }\n\n    function haltPurchases() public {\n        require(msg.sender == _haltPurchases, \"Unauthorized access\");\n        _halt_purchases = true;\n    }\n\n    function resumePurchases() public {\n        require(msg.sender == _haltPurchases, \"Unauthorized access\");\n        _halt_purchases = false;\n    }\n\n    function purchase() public payable {\n        require(!_halt_purchases, \"Purchases are halted\");\n        require(_total_iou_purchased + 160 * msg.value <= _total_iou_available, \"Insufficient IOUs available\");\n        _iou_purchased[msg.sender] += 160 * msg.value;\n        _eth_sent[msg.sender] += msg.value;\n        _total_iou_purchased += 160 * msg.value;\n    }\n\n    function iou_purchased(address user) public view returns(uint256) {\n        return _iou_purchased[user];\n    }\n\n    function total_iou_available() public view returns(uint256) {\n        return _total_iou_available;\n    }\n\n    function withdrawTokens() public {\n        // Logic for withdrawing tokens\n    }\n\n    function total_iou_purchased() public view returns(uint256) {\n        return _total_iou_purchased;\n    }\n\n    function halt_purchases() public view returns(bool) {\n        return _halt_purchases;\n    }\n\n    function token() public view returns(address) {\n        return _token;\n    }\n\n    function eth_sent(address user) public view returns(uint256) {\n        return _eth_sent[user];\n    }\n}\n```\nPlease note that some details may be missing or inaccurate due to the nature of decompilation. The `withdraw()` and `withdrawTokens()` functions are not fully implemented, as the original EVM Bytecode does not contain enough information to recreate the logic in Solidity.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459078,
	"id": "chatcmpl-8R3WIUkvKjobZmn49anq1TpDAg0rn",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 13:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _iou_purchased; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _eth_sent; // STORAGE[0x1]\nuint256 _total_iou_available; // STORAGE[0x2]\nuint256 _total_iou_purchased; // STORAGE[0x3]\naddress _token; // STORAGE[0x4] bytes 0 to 19\naddress _haltPurchases; // STORAGE[0x5] bytes 0 to 19\nuint8 _halt_purchases; // STORAGE[0x5] bytes 20 to 20\n\n\nfunction haltPurchases() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    _halt_purchases = 1;\n}\n\nfunction withdraw() public payable { \n    0x27b();\n}\n\nfunction resumePurchases() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    _halt_purchases = 0;\n}\n\nfunction purchase() public payable { \n    0x9d4();\n}\n\nfunction iou_purchased(address varg0) public payable { \n    assert(!msg.value);\n    return _iou_purchased[varg0];\n}\n\nfunction total_iou_available() public payable { \n    assert(!msg.value);\n    return _total_iou_available;\n}\n\nfunction withdrawTokens() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    MEM[32 + MEM[64]] = 0;\n    assert(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    assert(v0);\n    assert(_token.code.size);\n    v2 = _token.transfer(_haltPurchases, v1).gas(msg.gas - 710);\n    assert(v2);\n}\n\nfunction total_iou_purchased() public payable { \n    assert(!msg.value);\n    return _total_iou_purchased;\n}\n\nfunction halt_purchases() public payable { \n    assert(!msg.value);\n    return _halt_purchases;\n}\n\nfunction token() public payable { \n    assert(!msg.value);\n    return _token;\n}\n\nfunction 0x27b() private { \n    v0 = v1 = block.number > 0x40163f;\n    if (v1) {\n        MEM[32 + MEM[64]] = 0;\n        assert(_token.code.size);\n        v2, v3 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n        assert(v2);\n        v0 = v4 = _iou_purchased[msg.sender] > v3;\n    }\n    if (!v0) {\n        MEM[32 + MEM[64]] = 0;\n        assert(_token.code.size);\n        v5, v6 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n        assert(v5);\n        v7 = v8 = v6 == 0;\n        if (v6 != 0) {\n            MEM[32 + MEM[64]] = 0;\n            assert(_token.code.size);\n            v9, v10 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n            assert(v9);\n            v7 = v11 = _iou_purchased[msg.sender] > v10;\n        }\n        require(!v7);\n        v12 = v13 = _iou_purchased[msg.sender] == 0;\n        if (_iou_purchased[msg.sender] != 0) {\n            v12 = v14 = _eth_sent[msg.sender] == 0;\n        }\n        require(!v12);\n        _iou_purchased[msg.sender] = 0;\n        _eth_sent[msg.sender] = 0;\n        assert(_token.code.size);\n        v15 = _token.transfer(msg.sender, _iou_purchased[msg.sender]).gas(msg.gas - 710);\n        assert(v15);\n        v16 = _haltPurchases.call().value(_eth_sent[msg.sender]).gas(!_eth_sent[msg.sender] * 2300);\n        assert(v16);\n    } else {\n        v17 = v18 = _eth_sent[msg.sender] == 0;\n        if (_eth_sent[msg.sender] != 0) {\n            v17 = v19 = _iou_purchased[msg.sender] == 0;\n        }\n        require(!v17);\n        _total_iou_purchased = _total_iou_purchased - _iou_purchased[msg.sender];\n        _eth_sent[msg.sender] = 0;\n        _eth_sent[msg.sender] = 0;\n        v20 = msg.sender.call().value(_eth_sent[msg.sender]).gas(!_eth_sent[msg.sender] * 2300);\n        assert(v20);\n    }\n    return ;\n}\n\nfunction 0x9d4() private { \n    require(!_halt_purchases);\n    require(_total_iou_purchased + 160 * msg.value <= _total_iou_available);\n    _iou_purchased[msg.sender] = _iou_purchased[msg.sender] + 160 * msg.value;\n    _eth_sent[msg.sender] = _eth_sent[msg.sender] + msg.value;\n    _total_iou_purchased = _total_iou_purchased + 160 * msg.value;\n    return ;\n}\n\nfunction eth_sent(address varg0) public payable { \n    assert(!msg.value);\n    return _eth_sent[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x5bc99f8 == function_selector) {\n            eth_sent(address);\n        } else if (0x8551d34 == function_selector) {\n            haltPurchases();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x60e6fb26 == function_selector) {\n            resumePurchases();\n        } else if (0x64edfbf0 == function_selector) {\n            purchase();\n        } else if (0x820ecdaf == function_selector) {\n            iou_purchased(address);\n        } else if (0x8c7d3241 == function_selector) {\n            total_iou_available();\n        } else if (0x8d8f2adb == function_selector) {\n            withdrawTokens();\n        } else if (0x98ef4b0b == function_selector) {\n            total_iou_purchased();\n        } else if (0xf1317c09 == function_selector) {\n            halt_purchases();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    if (msg.value != 0) {\n        0x9d4();\n    } else {\n        0x27b();\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 13:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _iou_purchased; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _eth_sent; // STORAGE[0x1]\nuint256 _total_iou_available; // STORAGE[0x2]\nuint256 _total_iou_purchased; // STORAGE[0x3]\naddress _token; // STORAGE[0x4] bytes 0 to 19\naddress _haltPurchases; // STORAGE[0x5] bytes 0 to 19\nuint8 _halt_purchases; // STORAGE[0x5] bytes 20 to 20\n\n\nfunction haltPurchases() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    _halt_purchases = 1;\n}\n\nfunction withdraw() public payable { \n    0x27b();\n}\n\nfunction resumePurchases() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    _halt_purchases = 0;\n}\n\nfunction purchase() public payable { \n    0x9d4();\n}\n\nfunction iou_purchased(address varg0) public payable { \n    assert(!msg.value);\n    return _iou_purchased[varg0];\n}\n\nfunction total_iou_available() public payable { \n    assert(!msg.value);\n    return _total_iou_available;\n}\n\nfunction withdrawTokens() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    MEM[32 + MEM[64]] = 0;\n    assert(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    assert(v0);\n    assert(_token.code.size);\n    v2 = _token.transfer(_haltPurchases, v1).gas(msg.gas - 710);\n    assert(v2);\n}\n\nfunction total_iou_purchased() public payable { \n    assert(!msg.value);\n    return _total_iou_purchased;\n}\n\nfunction halt_purchases() public payable { \n    assert(!msg.value);\n    return _halt_purchases;\n}\n\nfunction token() public payable { \n    assert(!msg.value);\n    return _token;\n}\n\nfunction 0x27b() private { \n    v0 = v1 = block.number > 0x40163f;\n    if (v1) {\n        MEM[32 + MEM[64]] = 0;\n        assert(_token.code.size);\n        v2, v3 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n        assert(v2);\n        v0 = v4 = _iou_purchased[msg.sender] > v3;\n    }\n    if (!v0) {\n        MEM[32 + MEM[64]] = 0;\n        assert(_token.code.size);\n        v5, v6 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n        assert(v5);\n        v7 = v8 = v6 == 0;\n        if (v6 != 0) {\n            MEM[32 + MEM[64]] = 0;\n            assert(_token.code.size);\n            v9, v10 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n            assert(v9);\n            v7 = v11 = _iou_purchased[msg.sender] > v10;\n        }\n        require(!v7);\n        v12 = v13 = _iou_purchased[msg.sender] == 0;\n        if (_iou_purchased[msg.sender] != 0) {\n            v12 = v14 = _eth_sent[msg.sender] == 0;\n        }\n        require(!v12);\n        _iou_purchased[msg.sender] = 0;\n        _eth_sent[msg.sender] = 0;\n        assert(_token.code.size);\n        v15 = _token.transfer(msg.sender, _iou_purchased[msg.sender]).gas(msg.gas - 710);\n        assert(v15);\n        v16 = _haltPurchases.call().value(_eth_sent[msg.sender]).gas(!_eth_sent[msg.sender] * 2300);\n        assert(v16);\n    } else {\n        v17 = v18 = _eth_sent[msg.sender] == 0;\n        if (_eth_sent[msg.sender] != 0) {\n            v17 = v19 = _iou_purchased[msg.sender] == 0;\n        }\n        require(!v17);\n        _total_iou_purchased = _total_iou_purchased - _iou_purchased[msg.sender];\n        _eth_sent[msg.sender] = 0;\n        _eth_sent[msg.sender] = 0;\n        v20 = msg.sender.call().value(_eth_sent[msg.sender]).gas(!_eth_sent[msg.sender] * 2300);\n        assert(v20);\n    }\n    return ;\n}\n\nfunction 0x9d4() private { \n    require(!_halt_purchases);\n    require(_total_iou_purchased + 160 * msg.value <= _total_iou_available);\n    _iou_purchased[msg.sender] = _iou_purchased[msg.sender] + 160 * msg.value;\n    _eth_sent[msg.sender] = _eth_sent[msg.sender] + msg.value;\n    _total_iou_purchased = _total_iou_purchased + 160 * msg.value;\n    return ;\n}\n\nfunction eth_sent(address varg0) public payable { \n    assert(!msg.value);\n    return _eth_sent[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x5bc99f8 == function_selector) {\n            eth_sent(address);\n        } else if (0x8551d34 == function_selector) {\n            haltPurchases();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x60e6fb26 == function_selector) {\n            resumePurchases();\n        } else if (0x64edfbf0 == function_selector) {\n            purchase();\n        } else if (0x820ecdaf == function_selector) {\n            iou_purchased(address);\n        } else if (0x8c7d3241 == function_selector) {\n            total_iou_available();\n        } else if (0x8d8f2adb == function_selector) {\n            withdrawTokens();\n        } else if (0x98ef4b0b == function_selector) {\n            total_iou_purchased();\n        } else if (0xf1317c09 == function_selector) {\n            halt_purchases();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    if (msg.value != 0) {\n        0x9d4();\n    } else {\n        0x27b();\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 13:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _iou_purchased; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _eth_sent; // STORAGE[0x1]\nuint256 _total_iou_available; // STORAGE[0x2]\nuint256 _total_iou_purchased; // STORAGE[0x3]\naddress _token; // STORAGE[0x4] bytes 0 to 19\naddress _haltPurchases; // STORAGE[0x5] bytes 0 to 19\nuint8 _halt_purchases; // STORAGE[0x5] bytes 20 to 20\n\n\nfunction haltPurchases() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    _halt_purchases = 1;\n}\n\nfunction withdraw() public payable { \n    0x27b();\n}\n\nfunction resumePurchases() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    _halt_purchases = 0;\n}\n\nfunction purchase() public payable { \n    0x9d4();\n}\n\nfunction iou_purchased(address varg0) public payable { \n    assert(!msg.value);\n    return _iou_purchased[varg0];\n}\n\nfunction total_iou_available() public payable { \n    assert(!msg.value);\n    return _total_iou_available;\n}\n\nfunction withdrawTokens() public payable { \n    assert(!msg.value);\n    require(msg.sender == _haltPurchases);\n    MEM[32 + MEM[64]] = 0;\n    assert(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    assert(v0);\n    assert(_token.code.size);\n    v2 = _token.transfer(_haltPurchases, v1).gas(msg.gas - 710);\n    assert(v2);\n}\n\nfunction total_iou_purchased() public payable { \n    assert(!msg.value);\n    return _total_iou_purchased;\n}\n\nfunction halt_purchases() public payable { \n    assert(!msg.value);\n    return _halt_purchases;\n}\n\nfunction token() public payable { \n    assert(!msg.value);\n    return _token;\n}\n\nfunction 0x27b() private { \n    v0 = v1 = block.number > 0x40163f;\n    if (v1) {\n        MEM[32 + MEM[64]] = 0;\n        assert(_token.code.size);\n        v2, v3 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n        assert(v2);\n        v0 = v4 = _iou_purchased[msg.sender] > v3;\n    }\n    if (!v0) {\n        MEM[32 + MEM[64]] = 0;\n        assert(_token.code.size);\n        v5, v6 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n        assert(v5);\n        v7 = v8 = v6 == 0;\n        if (v6 != 0) {\n            MEM[32 + MEM[64]] = 0;\n            assert(_token.code.size);\n            v9, v10 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n            assert(v9);\n            v7 = v11 = _iou_purchased[msg.sender] > v10;\n        }\n        require(!v7);\n        v12 = v13 = _iou_purchased[msg.sender] == 0;\n        if (_iou_purchased[msg.sender] != 0) {\n            v12 = v14 = _eth_sent[msg.sender] == 0;\n        }\n        require(!v12);\n        _iou_purchased[msg.sender] = 0;\n        _eth_sent[msg.sender] = 0;\n        assert(_token.code.size);\n        v15 = _token.transfer(msg.sender, _iou_purchased[msg.sender]).gas(msg.gas - 710);\n        assert(v15);\n        v16 = _haltPurchases.call().value(_eth_sent[msg.sender]).gas(!_eth_sent[msg.sender] * 2300);\n        assert(v16);\n    } else {\n        v17 = v18 = _eth_sent[msg.sender] == 0;\n        if (_eth_sent[msg.sender] != 0) {\n            v17 = v19 = _iou_purchased[msg.sender] == 0;\n        }\n        require(!v17);\n        _total_iou_purchased = _total_iou_purchased - _iou_purchased[msg.sender];\n        _eth_sent[msg.sender] = 0;\n        _eth_sent[msg.sender] = 0;\n        v20 = msg.sender.call().value(_eth_sent[msg.sender]).gas(!_eth_sent[msg.sender] * 2300);\n        assert(v20);\n    }\n    return ;\n}\n\nfunction 0x9d4() private { \n    require(!_halt_purchases);\n    require(_total_iou_purchased + 160 * msg.value <= _total_iou_available);\n    _iou_purchased[msg.sender] = _iou_purchased[msg.sender] + 160 * msg.value;\n    _eth_sent[msg.sender] = _eth_sent[msg.sender] + msg.value;\n    _total_iou_purchased = _total_iou_purchased + 160 * msg.value;\n    return ;\n}\n\nfunction eth_sent(address varg0) public payable { \n    assert(!msg.value);\n    return _eth_sent[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x5bc99f8 == function_selector) {\n            eth_sent(address);\n        } else if (0x8551d34 == function_selector) {\n            haltPurchases();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x60e6fb26 == function_selector) {\n            resumePurchases();\n        } else if (0x64edfbf0 == function_selector) {\n            purchase();\n        } else if (0x820ecdaf == function_selector) {\n            iou_purchased(address);\n        } else if (0x8c7d3241 == function_selector) {\n            total_iou_available();\n        } else if (0x8d8f2adb == function_selector) {\n            withdrawTokens();\n        } else if (0x98ef4b0b == function_selector) {\n            total_iou_purchased();\n        } else if (0xf1317c09 == function_selector) {\n            halt_purchases();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    if (msg.value != 0) {\n        0x9d4();\n    } else {\n        0x27b();\n    }\n}\n.",
	"status": "1",
	"time_cost": 21.932631254196167,
	"usage": {
		"completion_tokens": 510,
		"prompt_tokens": 1560,
		"total_tokens": 2070
	}
}