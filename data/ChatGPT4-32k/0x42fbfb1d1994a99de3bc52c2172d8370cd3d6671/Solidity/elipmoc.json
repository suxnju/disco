{
	"address": "0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the Solidity contract code equivalent to the decompiled EVM Bytecode.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\ncontract YourContract {\n    uint256 private _totalSupply;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    uint256 private _buyPriceInWei;\n    uint256 private _sellPriceInWei;\n    uint256 private _minBalanceForAccounts;\n    mapping (address => bool) private _frozenAccounts;\n    address private _owner;\n    address private _companyWallet;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() public {\n        _totalSupply = 1000000;\n        _balances[msg.sender] = _totalSupply;\n        _name = \"YourToken\";\n        _symbol = \"YTK\";\n        _decimals = 18;\n        _owner = msg.sender;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balances[msg.sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n        require(_allowances[sender][msg.sender] >= amount, \"ERC20: transfer amount exceeds allowance\");\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    // Other functions related to _frozenAccounts, _buyPriceInWei, \n    // _sellPriceInWei, _minBalanceForAccounts, _owner, _companyWallet etc.\n    // can be implemented as per the requirement.\n}\n```\n\nPlease note that you need to add the remaining functions like `freezeAccount`, `increaseApproval`, `decreaseApproval`, `setMinBalance`, `setSellPrice`, `setBuyPrice`, etc. as per your business logic. This is a basic implementation of an ERC20 token. \n\nAlso, naming conventions and data types (like uint256 to uint8) could be adjusted according to the original contract's intent and Solidity best practices.",
				"role": "assistant"
			}
		}
	],
	"created": 1701464543,
	"id": "chatcmpl-8R4wRDalCFXsKqhyxqqHRPDnh5Qa3",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.14 03:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _transferFrom; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _decimals; // STORAGE[0x6]\nuint256 _buyPriceInWei; // STORAGE[0x7]\nuint256 _sellPriceInWei; // STORAGE[0x8]\nuint256 _minBalanceForAccounts; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _frozenAccounts; // STORAGE[0xc]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\naddress _companyWallet; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nFrozenFunds(address, bool);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    v0 = 0x99f();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction 0x2590(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction companyWallet() public nonPayable { \n    return _companyWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _transferFrom[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _transferFrom[varg0]);\n    _transferFrom[varg0] = _transferFrom[varg0] - varg2;\n    assert(_transferFrom[varg1] + varg2 >= _transferFrom[varg1]);\n    _transferFrom[varg1] = _transferFrom[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction setCompanyWallet(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _companyWallet = varg0;\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction minBalanceForAccounts() public nonPayable { \n    return _minBalanceForAccounts;\n}\n\nfunction setBuyPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _buyPriceInWei = varg0;\n    return 1;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction destroy() public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(_owner);\n}\n\nfunction frozenAccounts(address varg0) public nonPayable { \n    return 0xff & _frozenAccounts[varg0];\n}\n\nfunction forwardFundToCompanyWallet(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _companyWallet.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buy() public payable { \n    v0 = 0x99f();\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(!(0xff & _frozenAccounts[msg.sender]));\n    require(!(0xff & _frozenAccounts[varg0]));\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (msg.sender.balance < _minBalanceForAccounts) {\n        assert(msg.sender.balance <= _minBalanceForAccounts);\n        assert(_sellPriceInWei);\n        require((_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei > 0);\n        require(_balanceOf[msg.sender] >= (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n        assert(_balanceOf[address(this)] + (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei >= _balanceOf[address(this)]);\n        _balanceOf[address(this)] = _balanceOf[address(this)] + (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei;\n        assert((_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei;\n        v0 = 0x2590(_sellPriceInWei, (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n        assert(0xde0b6b3a7640000);\n        require(v0 / 0xde0b6b3a7640000 > 0);\n        v1 = msg.sender.call().value(v0 / 0xde0b6b3a7640000).gas(!(v0 / 0xde0b6b3a7640000) * 2300);\n        require(v1);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] == _balanceOf[address(this)] + _balanceOf[msg.sender]);\n        emit Transfer(msg.sender, address(this), (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n    }\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _minBalanceForAccounts = varg0;\n}\n\nfunction sellPriceInWei() public nonPayable { \n    return _sellPriceInWei;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction isFrozen(address varg0) public nonPayable { \n    return 0xff & _frozenAccounts[varg0];\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccounts[varg0] = varg1 | ~0xff & _frozenAccounts[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction destroyAndSend(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(varg0);\n}\n\nfunction buyPriceInWei() public nonPayable { \n    return _buyPriceInWei;\n}\n\nfunction distribute(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(address(this), varg0, varg1);\n    return 1;\n}\n\nfunction setSellPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _sellPriceInWei = varg0;\n    return 1;\n}\n\nfunction 0x99f() private { \n    require(msg.sender != 0);\n    require(msg.value >= 0);\n    assert(_buyPriceInWei);\n    v0 = 0x2590(0xde0b6b3a7640000, msg.value / _buyPriceInWei);\n    require(v0 > 0);\n    require(_balanceOf[address(this)] >= v0);\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n    assert(v0 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    assert(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] == _balanceOf[address(this)] + _balanceOf[msg.sender]);\n    emit Transfer(address(this), msg.sender, v0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1ec32d15 == function_selector) {\n            companyWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x28831187 == function_selector) {\n            setCompanyWallet(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x47f1d8d7 == function_selector) {\n            minBalanceForAccounts();\n        } else if (0x63ae8d6c == function_selector) {\n            setBuyPrice(uint256);\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x83197ef0 == function_selector) {\n            destroy();\n        } else if (0x860838a5 == function_selector) {\n            frozenAccounts(address);\n        } else if (0x8d5f8d1c == function_selector) {\n            forwardFundToCompanyWallet(uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xd5a81428 == function_selector) {\n            sellPriceInWei();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe5839836 == function_selector) {\n            isFrozen(address);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf5074f41 == function_selector) {\n            destroyAndSend(address);\n        } else if (0xfb7cf694 == function_selector) {\n            buyPriceInWei();\n        } else if (0xfb932108 == function_selector) {\n            distribute(address,uint256);\n        } else if (0xfc6634b9 == function_selector) {\n            setSellPrice(uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 03:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _transferFrom; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _decimals; // STORAGE[0x6]\nuint256 _buyPriceInWei; // STORAGE[0x7]\nuint256 _sellPriceInWei; // STORAGE[0x8]\nuint256 _minBalanceForAccounts; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _frozenAccounts; // STORAGE[0xc]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\naddress _companyWallet; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nFrozenFunds(address, bool);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    v0 = 0x99f();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction 0x2590(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction companyWallet() public nonPayable { \n    return _companyWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _transferFrom[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _transferFrom[varg0]);\n    _transferFrom[varg0] = _transferFrom[varg0] - varg2;\n    assert(_transferFrom[varg1] + varg2 >= _transferFrom[varg1]);\n    _transferFrom[varg1] = _transferFrom[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction setCompanyWallet(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _companyWallet = varg0;\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction minBalanceForAccounts() public nonPayable { \n    return _minBalanceForAccounts;\n}\n\nfunction setBuyPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _buyPriceInWei = varg0;\n    return 1;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction destroy() public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(_owner);\n}\n\nfunction frozenAccounts(address varg0) public nonPayable { \n    return 0xff & _frozenAccounts[varg0];\n}\n\nfunction forwardFundToCompanyWallet(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _companyWallet.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buy() public payable { \n    v0 = 0x99f();\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(!(0xff & _frozenAccounts[msg.sender]));\n    require(!(0xff & _frozenAccounts[varg0]));\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (msg.sender.balance < _minBalanceForAccounts) {\n        assert(msg.sender.balance <= _minBalanceForAccounts);\n        assert(_sellPriceInWei);\n        require((_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei > 0);\n        require(_balanceOf[msg.sender] >= (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n        assert(_balanceOf[address(this)] + (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei >= _balanceOf[address(this)]);\n        _balanceOf[address(this)] = _balanceOf[address(this)] + (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei;\n        assert((_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei;\n        v0 = 0x2590(_sellPriceInWei, (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n        assert(0xde0b6b3a7640000);\n        require(v0 / 0xde0b6b3a7640000 > 0);\n        v1 = msg.sender.call().value(v0 / 0xde0b6b3a7640000).gas(!(v0 / 0xde0b6b3a7640000) * 2300);\n        require(v1);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] == _balanceOf[address(this)] + _balanceOf[msg.sender]);\n        emit Transfer(msg.sender, address(this), (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n    }\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _minBalanceForAccounts = varg0;\n}\n\nfunction sellPriceInWei() public nonPayable { \n    return _sellPriceInWei;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction isFrozen(address varg0) public nonPayable { \n    return 0xff & _frozenAccounts[varg0];\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccounts[varg0] = varg1 | ~0xff & _frozenAccounts[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction destroyAndSend(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(varg0);\n}\n\nfunction buyPriceInWei() public nonPayable { \n    return _buyPriceInWei;\n}\n\nfunction distribute(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(address(this), varg0, varg1);\n    return 1;\n}\n\nfunction setSellPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _sellPriceInWei = varg0;\n    return 1;\n}\n\nfunction 0x99f() private { \n    require(msg.sender != 0);\n    require(msg.value >= 0);\n    assert(_buyPriceInWei);\n    v0 = 0x2590(0xde0b6b3a7640000, msg.value / _buyPriceInWei);\n    require(v0 > 0);\n    require(_balanceOf[address(this)] >= v0);\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n    assert(v0 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    assert(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] == _balanceOf[address(this)] + _balanceOf[msg.sender]);\n    emit Transfer(address(this), msg.sender, v0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1ec32d15 == function_selector) {\n            companyWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x28831187 == function_selector) {\n            setCompanyWallet(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x47f1d8d7 == function_selector) {\n            minBalanceForAccounts();\n        } else if (0x63ae8d6c == function_selector) {\n            setBuyPrice(uint256);\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x83197ef0 == function_selector) {\n            destroy();\n        } else if (0x860838a5 == function_selector) {\n            frozenAccounts(address);\n        } else if (0x8d5f8d1c == function_selector) {\n            forwardFundToCompanyWallet(uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xd5a81428 == function_selector) {\n            sellPriceInWei();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe5839836 == function_selector) {\n            isFrozen(address);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf5074f41 == function_selector) {\n            destroyAndSend(address);\n        } else if (0xfb7cf694 == function_selector) {\n            buyPriceInWei();\n        } else if (0xfb932108 == function_selector) {\n            distribute(address,uint256);\n        } else if (0xfc6634b9 == function_selector) {\n            setSellPrice(uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 03:27 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _transferFrom; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _decimals; // STORAGE[0x6]\nuint256 _buyPriceInWei; // STORAGE[0x7]\nuint256 _sellPriceInWei; // STORAGE[0x8]\nuint256 _minBalanceForAccounts; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _frozenAccounts; // STORAGE[0xc]\naddress _owner; // STORAGE[0x3] bytes 0 to 19\naddress _companyWallet; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nFrozenFunds(address, bool);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    v0 = 0x99f();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction 0x2590(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction companyWallet() public nonPayable { \n    return _companyWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _transferFrom[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _transferFrom[varg0]);\n    _transferFrom[varg0] = _transferFrom[varg0] - varg2;\n    assert(_transferFrom[varg1] + varg2 >= _transferFrom[varg1]);\n    _transferFrom[varg1] = _transferFrom[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction setCompanyWallet(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _companyWallet = varg0;\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction minBalanceForAccounts() public nonPayable { \n    return _minBalanceForAccounts;\n}\n\nfunction setBuyPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _buyPriceInWei = varg0;\n    return 1;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction destroy() public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(_owner);\n}\n\nfunction frozenAccounts(address varg0) public nonPayable { \n    return 0xff & _frozenAccounts[varg0];\n}\n\nfunction forwardFundToCompanyWallet(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = _companyWallet.call().value(varg0).gas(!varg0 * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction buy() public payable { \n    v0 = 0x99f();\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(!(0xff & _frozenAccounts[msg.sender]));\n    require(!(0xff & _frozenAccounts[varg0]));\n    require(varg1 <= _balanceOf[msg.sender]);\n    if (msg.sender.balance < _minBalanceForAccounts) {\n        assert(msg.sender.balance <= _minBalanceForAccounts);\n        assert(_sellPriceInWei);\n        require((_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei > 0);\n        require(_balanceOf[msg.sender] >= (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n        assert(_balanceOf[address(this)] + (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei >= _balanceOf[address(this)]);\n        _balanceOf[address(this)] = _balanceOf[address(this)] + (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei;\n        assert((_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei;\n        v0 = 0x2590(_sellPriceInWei, (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n        assert(0xde0b6b3a7640000);\n        require(v0 / 0xde0b6b3a7640000 > 0);\n        v1 = msg.sender.call().value(v0 / 0xde0b6b3a7640000).gas(!(v0 / 0xde0b6b3a7640000) * 2300);\n        require(v1);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n        assert(_balanceOf[address(this)] + _balanceOf[msg.sender] == _balanceOf[address(this)] + _balanceOf[msg.sender]);\n        emit Transfer(msg.sender, address(this), (_minBalanceForAccounts - msg.sender.balance) / _sellPriceInWei);\n    }\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _minBalanceForAccounts = varg0;\n}\n\nfunction sellPriceInWei() public nonPayable { \n    return _sellPriceInWei;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction isFrozen(address varg0) public nonPayable { \n    return 0xff & _frozenAccounts[varg0];\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccounts[varg0] = varg1 | ~0xff & _frozenAccounts[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction destroyAndSend(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(varg0);\n}\n\nfunction buyPriceInWei() public nonPayable { \n    return _buyPriceInWei;\n}\n\nfunction distribute(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(address(this), varg0, varg1);\n    return 1;\n}\n\nfunction setSellPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 > 0);\n    _sellPriceInWei = varg0;\n    return 1;\n}\n\nfunction 0x99f() private { \n    require(msg.sender != 0);\n    require(msg.value >= 0);\n    assert(_buyPriceInWei);\n    v0 = 0x2590(0xde0b6b3a7640000, msg.value / _buyPriceInWei);\n    require(v0 > 0);\n    require(_balanceOf[address(this)] >= v0);\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n    assert(v0 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - v0;\n    assert(_balanceOf[msg.sender] + v0 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + v0;\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] >= _balanceOf[address(this)]);\n    assert(_balanceOf[address(this)] + _balanceOf[msg.sender] == _balanceOf[address(this)] + _balanceOf[msg.sender]);\n    emit Transfer(address(this), msg.sender, v0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1ec32d15 == function_selector) {\n            companyWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x28831187 == function_selector) {\n            setCompanyWallet(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x47f1d8d7 == function_selector) {\n            minBalanceForAccounts();\n        } else if (0x63ae8d6c == function_selector) {\n            setBuyPrice(uint256);\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x83197ef0 == function_selector) {\n            destroy();\n        } else if (0x860838a5 == function_selector) {\n            frozenAccounts(address);\n        } else if (0x8d5f8d1c == function_selector) {\n            forwardFundToCompanyWallet(uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xd5a81428 == function_selector) {\n            sellPriceInWei();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe5839836 == function_selector) {\n            isFrozen(address);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf5074f41 == function_selector) {\n            destroyAndSend(address);\n        } else if (0xfb7cf694 == function_selector) {\n            buyPriceInWei();\n        } else if (0xfb932108 == function_selector) {\n            distribute(address,uint256);\n        } else if (0xfc6634b9 == function_selector) {\n            setSellPrice(uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 36.041632652282715,
	"usage": {
		"completion_tokens": 788,
		"prompt_tokens": 3745,
		"total_tokens": 4533
	}
}