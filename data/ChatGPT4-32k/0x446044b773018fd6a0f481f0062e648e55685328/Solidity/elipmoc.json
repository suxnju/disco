{
	"address": "0x446044b773018fd6a0f481f0062e648e55685328",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity smart contract that mirrors the decompiled code:\n\n```solidity\npragma solidity ^0.8.4;\n\ninterface IToken {\n    function mintFromICO(address _to, uint256 _value) external;\n}\n\ninterface IAuthorize {\n    function isWhitelisted(address _address) external view returns (bool);\n}\n\ncontract MyContract {\n    mapping (address => uint256) private _investedEther;\n    uint256 private _startPreSale;\n    uint256 private _endPreSale;\n    uint256 private _weisRaised;\n    uint256 private _buyPrice;\n    uint256 private _dollarPrice;\n    uint256 private _soldTokensPreSale;\n    uint256 private _softcapPreSale;\n    uint256 private _hardCapPreSale;\n    address private _setStartPreSale;\n    IToken private _token;\n    IAuthorize private _authorize;\n    address private _backEndOperator;\n\n    event Refund(uint256 _value, address _address);\n    event UpdateDollar(uint256 _time, uint256 _dollarPrice);\n\n    fallback() external payable {\n        require(_authorize.isWhitelisted(msg.sender));\n        require(msg.value + _weisRaised >= _weisRaised);\n        _weisRaised += msg.value;\n        require(_investedEther[msg.sender] + msg.value >= _investedEther[msg.sender]);\n        _investedEther[msg.sender] += msg.value;\n    }\n\n    function backEndOperator() public view returns (address) {\n        return _backEndOperator;\n    }\n\n    function refundPreSale() public {\n        require(_soldTokensPreSale < _softcapPreSale && block.timestamp > _endPreSale);\n        require(_investedEther[msg.sender] >= 0);\n        payable(msg.sender).transfer(_investedEther[msg.sender]);\n        _weisRaised -= _investedEther[msg.sender];\n        _investedEther[msg.sender] = 0;\n        emit Refund(_investedEther[msg.sender], msg.sender);\n    }\n\n    function investedEther(address _address) public view returns (uint256) {\n        return _investedEther[_address];\n    }\n\n    function transferEthFromContract(address _address, uint256 _value) public {\n        require(msg.sender == _setStartPreSale);\n        payable(_address).transfer(_value);\n    }\n\n    function setStartPreSale(uint256 _value) public {\n        require(msg.sender == _setStartPreSale);\n        _startPreSale = _value;\n    }\n\n    function dollarPrice() public view returns (uint256) {\n        return _dollarPrice;\n    }\n\n    function softcapPreSale() public view returns (uint256) {\n        return _softcapPreSale;\n    }\n\n    function isPreSale() public view returns (bool) {\n        return block.timestamp >= _startPreSale && block.timestamp <= _endPreSale;\n    }\n\n    function startPreSale() public view returns (uint256) {\n        return _startPreSale;\n    }\n\n    function setBuyPrice(uint256 _value) public {\n        require(msg.sender == _backEndOperator || msg.sender == _setStartPreSale);\n        _dollarPrice = _value;\n        _buyPrice = 0xde0b6b3a7640000 / _value / 10;\n        emit UpdateDollar(block.timestamp, _dollarPrice);\n    }\n\n    function buyPrice() public view returns (uint256) {\n        return _buyPrice;\n    }\n\n    function mintManual(address _address, uint256 _value) public {\n        require(msg.sender == _backEndOperator || msg.sender == _setStartPreSale);\n        _token.mintFromICO(_address, _value);\n        _soldTokensPreSale += _value;\n    }\n\n    function owner() public view returns (address) {\n        return _setStartPreSale;\n    }\n\n    function authorize() public view returns (IAuthorize) {\n        return _authorize;\n    }\n\n    function setBackEndAddress(address _address) public {\n        require(msg.sender == _setStartPreSale);\n        _backEndOperator = _address;\n    }\n\n    function soldTokensPreSale() public view returns (uint256) {\n        return _soldTokensPreSale;\n    }\n\n    function weisRaised() public view returns (uint256) {\n        return _weisRaised;\n    }\n\n    function setEndPreSale(uint256 _value) public {\n        require(msg.sender == _setStartPreSale);\n        _endPreSale = _value;\n    }\n\n    function endPreSale() public view returns (uint256) {\n        return _endPreSale;\n    }\n\n    function hardCapPreSale() public view returns (uint256) {\n        return _hardCapPreSale;\n    }\n\n    function token() public view returns (IToken) {\n        return _token;\n    }\n}\n```\nThis contract includes methods for managing presales for a token, including setting the presale start and end, setting prices, authorizing and refunding investments, and more. The fallback function is used to receive any ether sent to the contract address, and it updates the contract's internal record of the sender's invested ether.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461918,
	"id": "chatcmpl-8R4G6KIMtddYOlqSUCO7Z6t5dkbWl",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 20:03 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _investedEther; // STORAGE[0x6]\nuint256 _startPreSale; // STORAGE[0x7]\nuint256 _endPreSale; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 _weisRaised; // STORAGE[0xe]\nuint256 _buyPrice; // STORAGE[0xf]\nuint256 _dollarPrice; // STORAGE[0x10]\nuint256 _soldTokensPreSale; // STORAGE[0x11]\nuint256 _softcapPreSale; // STORAGE[0x12]\nuint256 _hardCapPreSale; // STORAGE[0x13]\naddress _setStartPreSale; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x1] bytes 0 to 19\naddress _authorize; // STORAGE[0x2] bytes 0 to 19\naddress _backEndOperator; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\nuint160 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nRefund(uint256, address);\nUpdateDollar(uint256, uint256);\n\nfunction fallback() public payable { \n    require(_authorize.code.size);\n    v0, v1 = _authorize.isWhitelisted(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    v2 = 0x455();\n    require(v2);\n    v3 = v4 = 0;\n    v5 = v6 = 1188;\n    v7 = v8 = _buyPrice;\n    v9 = v10 = 0xbb7(0xde0b6b3a7640000, msg.value);\n    while (!v7) {\n        assert(v7);\n        require(_token.code.size);\n        v11 = _token.mintFromICO(stor_5_0_19, v3).gas(msg.gas);\n        require(v11); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(msg.value + _weisRaised >= _weisRaised);\n        _weisRaised += msg.value;\n        require(_soldTokensPreSale <= _hardCapPreSale);\n        assert(msg.value + _investedEther[msg.sender] >= _investedEther[msg.sender]);\n        _investedEther[msg.sender] += msg.value;\n        exit;\n        v3 = v9 / v7;\n        goto {'0x4c3', '0x4a4', '0x588', '0x62c'};\n        v5 = v12 = 1219;\n        v7 = v13 = 100;\n        v14 = v15 = block.timestamp > _startPreSale;\n        if (v15) {\n            v14 = block.timestamp < stor_9;\n        }\n        if (!v14) {\n            v16 = v17 = block.timestamp > stor_9;\n            if (v17) {\n                v16 = block.timestamp < stor_a;\n            }\n            if (!v16) {\n                v18 = v19 = block.timestamp > stor_a;\n                if (v19) {\n                    v18 = block.timestamp < stor_b;\n                }\n                if (!v18) {\n                    v20 = v21 = block.timestamp > stor_b;\n                    if (v21) {\n                        v20 = block.timestamp < stor_c;\n                    }\n                    if (!v20) {\n                        v22 = v23 = block.timestamp > stor_c;\n                        if (v23) {\n                            v22 = block.timestamp < stor_d;\n                        }\n                        if (!v22) {\n                            v24 = v25 = 0;\n                        } else {\n                            v24 = v26 = 25;\n                        }\n                    } else {\n                        v24 = v27 = 30;\n                    }\n                } else {\n                    v24 = v28 = 33;\n                }\n            } else {\n                v24 = v29 = 40;\n            }\n        } else {\n            v24 = v30 = 50;\n        }\n        v9 = 0xbb7(v24, v3);\n        v3 += v3;\n        assert(v3 >= v3);\n        MEM[MEM[64]] = 0x3aa0396a00000000000000000000000000000000000000000000000000000000;\n        MEM[MEM[64] + 4] = msg.sender;\n        MEM[MEM[64] + 36] = v3;\n        require(_token.code.size);\n        v31 = _token.call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 32]).gas(msg.gas);\n        require(v31); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v3 + _soldTokensPreSale >= _soldTokensPreSale);\n        _soldTokensPreSale += v3;\n        v5 = v32 = 1416;\n        v7 = v33 = 44;\n        v9 = 0xbb7(10, v3);\n        MEM[MEM[64]] = 0x3aa0396a00000000000000000000000000000000000000000000000000000000;\n        MEM[MEM[64] + 4] = stor_4_0_19;\n        MEM[MEM[64] + 36] = v3;\n        require(_token.code.size);\n        v34 = _token.call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 32]).gas(msg.gas);\n        require(v34); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v5 = v35 = 1580;\n        v7 = v36 = 200;\n        v9 = 0xbb7(3, v3);\n    }\n}\n\nfunction backEndOperator() public nonPayable { \n    return _backEndOperator;\n}\n\nfunction refundPreSale() public nonPayable { \n    v0 = v1 = _soldTokensPreSale < _softcapPreSale;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endPreSale;\n    }\n    require(v0);\n    require(_investedEther[msg.sender] >= 0);\n    _investedEther[msg.sender] = 0;\n    v3 = msg.sender.call().value(_investedEther[msg.sender]).gas(2300 * !_investedEther[msg.sender]);\n    require(v3); // checks call status, propagates error data on error\n    assert(_investedEther[msg.sender] <= _weisRaised);\n    _weisRaised = _weisRaised - _investedEther[msg.sender];\n    emit Refund(_investedEther[msg.sender], msg.sender);\n}\n\nfunction investedEther(address varg0) public nonPayable { \n    return _investedEther[varg0];\n}\n\nfunction transferEthFromContract(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction setStartPreSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _startPreSale = varg0;\n}\n\nfunction dollarPrice() public nonPayable { \n    return _dollarPrice;\n}\n\nfunction softcapPreSale() public nonPayable { \n    return _softcapPreSale;\n}\n\nfunction isPreSale() public nonPayable { \n    v0 = 0x455();\n    return v0;\n}\n\nfunction startPreSale() public nonPayable { \n    return _startPreSale;\n}\n\nfunction setBuyPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _backEndOperator;\n    if (msg.sender != _backEndOperator) {\n        v0 = v2 = msg.sender == _setStartPreSale;\n    }\n    require(v0);\n    _dollarPrice = varg0;\n    assert(varg0);\n    assert(10);\n    _buyPrice = 0xde0b6b3a7640000 / varg0 / 10;\n    emit UpdateDollar(block.timestamp, _dollarPrice);\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction mintManual(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _backEndOperator;\n    if (msg.sender != _backEndOperator) {\n        v0 = msg.sender == _setStartPreSale;\n    }\n    require(v0);\n    require(_token.code.size);\n    v2 = _token.mintFromICO(varg0, varg1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(varg1 + _soldTokensPreSale >= _soldTokensPreSale);\n    _soldTokensPreSale += varg1;\n    v3 = v4 = 2524;\n    v5 = v6 = 44;\n    v7 = v8 = 0xbb7(10, varg1);\n    while (!v5) {\n        assert(v5);\n        require(_token.code.size);\n        v9 = _token.mintFromICO(stor_5_0_19, v7 / v5).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        exit;\n        goto {'0x9dcB0x371', '0xa80B0x371'};\n        require(_token.code.size);\n        v10 = _token.mintFromICO(stor_4_0_19, v7 / v5).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v11 = 2688;\n        v5 = v12 = 200;\n        v7 = v13 = 0xbb7(3, varg1);\n    }\n}\n\nfunction owner() public nonPayable { \n    return _setStartPreSale;\n}\n\nfunction authorize() public nonPayable { \n    return _authorize;\n}\n\nfunction setBackEndAddress(address varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _backEndOperator = varg0;\n}\n\nfunction soldTokensPreSale() public nonPayable { \n    return _soldTokensPreSale;\n}\n\nfunction weisRaised() public nonPayable { \n    return _weisRaised;\n}\n\nfunction setEndPreSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _endPreSale = varg0;\n}\n\nfunction endPreSale() public nonPayable { \n    return _endPreSale;\n}\n\nfunction hardCapPreSale() public nonPayable { \n    return _hardCapPreSale;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x455() private { \n    v0 = v1 = block.timestamp >= _startPreSale;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endPreSale;\n    }\n    return v0;\n}\n\nfunction 0xbb7(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x50895ff) {\n            backEndOperator();\n        } else if (0x1c232194 == function_selector) {\n            refundPreSale();\n        } else if (0x274448ff == function_selector) {\n            investedEther(address);\n        } else if (0x31198d19 == function_selector) {\n            transferEthFromContract(address,uint256);\n        } else if (0x384a6494 == function_selector) {\n            setStartPreSale(uint256);\n        } else if (0x40d7b7b8 == function_selector) {\n            dollarPrice();\n        } else if (0x4b63189c == function_selector) {\n            softcapPreSale();\n        } else if (0x4ced4734 == function_selector) {\n            isPreSale();\n        } else if (0x55dd574c == function_selector) {\n            startPreSale();\n        } else if (0x63ae8d6c == function_selector) {\n            setBuyPrice(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8ca5da35 == function_selector) {\n            mintManual(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xababa4a7 == function_selector) {\n            authorize();\n        } else if (0xb701dc14 == function_selector) {\n            setBackEndAddress(address);\n        } else if (0xd893b9f1 == function_selector) {\n            soldTokensPreSale();\n        } else if (0xda5f838d == function_selector) {\n            weisRaised();\n        } else if (0xe0462547 == function_selector) {\n            setEndPreSale(uint256);\n        } else if (0xee889ed0 == function_selector) {\n            endPreSale();\n        } else if (0xf7e4a4a9 == function_selector) {\n            hardCapPreSale();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 20:03 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _investedEther; // STORAGE[0x6]\nuint256 _startPreSale; // STORAGE[0x7]\nuint256 _endPreSale; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 _weisRaised; // STORAGE[0xe]\nuint256 _buyPrice; // STORAGE[0xf]\nuint256 _dollarPrice; // STORAGE[0x10]\nuint256 _soldTokensPreSale; // STORAGE[0x11]\nuint256 _softcapPreSale; // STORAGE[0x12]\nuint256 _hardCapPreSale; // STORAGE[0x13]\naddress _setStartPreSale; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x1] bytes 0 to 19\naddress _authorize; // STORAGE[0x2] bytes 0 to 19\naddress _backEndOperator; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\nuint160 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nRefund(uint256, address);\nUpdateDollar(uint256, uint256);\n\nfunction fallback() public payable { \n    require(_authorize.code.size);\n    v0, v1 = _authorize.isWhitelisted(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    v2 = 0x455();\n    require(v2);\n    v3 = v4 = 0;\n    v5 = v6 = 1188;\n    v7 = v8 = _buyPrice;\n    v9 = v10 = 0xbb7(0xde0b6b3a7640000, msg.value);\n    while (!v7) {\n        assert(v7);\n        require(_token.code.size);\n        v11 = _token.mintFromICO(stor_5_0_19, v3).gas(msg.gas);\n        require(v11); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(msg.value + _weisRaised >= _weisRaised);\n        _weisRaised += msg.value;\n        require(_soldTokensPreSale <= _hardCapPreSale);\n        assert(msg.value + _investedEther[msg.sender] >= _investedEther[msg.sender]);\n        _investedEther[msg.sender] += msg.value;\n        exit;\n        v3 = v9 / v7;\n        goto {'0x4c3', '0x4a4', '0x588', '0x62c'};\n        v5 = v12 = 1219;\n        v7 = v13 = 100;\n        v14 = v15 = block.timestamp > _startPreSale;\n        if (v15) {\n            v14 = block.timestamp < stor_9;\n        }\n        if (!v14) {\n            v16 = v17 = block.timestamp > stor_9;\n            if (v17) {\n                v16 = block.timestamp < stor_a;\n            }\n            if (!v16) {\n                v18 = v19 = block.timestamp > stor_a;\n                if (v19) {\n                    v18 = block.timestamp < stor_b;\n                }\n                if (!v18) {\n                    v20 = v21 = block.timestamp > stor_b;\n                    if (v21) {\n                        v20 = block.timestamp < stor_c;\n                    }\n                    if (!v20) {\n                        v22 = v23 = block.timestamp > stor_c;\n                        if (v23) {\n                            v22 = block.timestamp < stor_d;\n                        }\n                        if (!v22) {\n                            v24 = v25 = 0;\n                        } else {\n                            v24 = v26 = 25;\n                        }\n                    } else {\n                        v24 = v27 = 30;\n                    }\n                } else {\n                    v24 = v28 = 33;\n                }\n            } else {\n                v24 = v29 = 40;\n            }\n        } else {\n            v24 = v30 = 50;\n        }\n        v9 = 0xbb7(v24, v3);\n        v3 += v3;\n        assert(v3 >= v3);\n        MEM[MEM[64]] = 0x3aa0396a00000000000000000000000000000000000000000000000000000000;\n        MEM[MEM[64] + 4] = msg.sender;\n        MEM[MEM[64] + 36] = v3;\n        require(_token.code.size);\n        v31 = _token.call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 32]).gas(msg.gas);\n        require(v31); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v3 + _soldTokensPreSale >= _soldTokensPreSale);\n        _soldTokensPreSale += v3;\n        v5 = v32 = 1416;\n        v7 = v33 = 44;\n        v9 = 0xbb7(10, v3);\n        MEM[MEM[64]] = 0x3aa0396a00000000000000000000000000000000000000000000000000000000;\n        MEM[MEM[64] + 4] = stor_4_0_19;\n        MEM[MEM[64] + 36] = v3;\n        require(_token.code.size);\n        v34 = _token.call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 32]).gas(msg.gas);\n        require(v34); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v5 = v35 = 1580;\n        v7 = v36 = 200;\n        v9 = 0xbb7(3, v3);\n    }\n}\n\nfunction backEndOperator() public nonPayable { \n    return _backEndOperator;\n}\n\nfunction refundPreSale() public nonPayable { \n    v0 = v1 = _soldTokensPreSale < _softcapPreSale;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endPreSale;\n    }\n    require(v0);\n    require(_investedEther[msg.sender] >= 0);\n    _investedEther[msg.sender] = 0;\n    v3 = msg.sender.call().value(_investedEther[msg.sender]).gas(2300 * !_investedEther[msg.sender]);\n    require(v3); // checks call status, propagates error data on error\n    assert(_investedEther[msg.sender] <= _weisRaised);\n    _weisRaised = _weisRaised - _investedEther[msg.sender];\n    emit Refund(_investedEther[msg.sender], msg.sender);\n}\n\nfunction investedEther(address varg0) public nonPayable { \n    return _investedEther[varg0];\n}\n\nfunction transferEthFromContract(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction setStartPreSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _startPreSale = varg0;\n}\n\nfunction dollarPrice() public nonPayable { \n    return _dollarPrice;\n}\n\nfunction softcapPreSale() public nonPayable { \n    return _softcapPreSale;\n}\n\nfunction isPreSale() public nonPayable { \n    v0 = 0x455();\n    return v0;\n}\n\nfunction startPreSale() public nonPayable { \n    return _startPreSale;\n}\n\nfunction setBuyPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _backEndOperator;\n    if (msg.sender != _backEndOperator) {\n        v0 = v2 = msg.sender == _setStartPreSale;\n    }\n    require(v0);\n    _dollarPrice = varg0;\n    assert(varg0);\n    assert(10);\n    _buyPrice = 0xde0b6b3a7640000 / varg0 / 10;\n    emit UpdateDollar(block.timestamp, _dollarPrice);\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction mintManual(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _backEndOperator;\n    if (msg.sender != _backEndOperator) {\n        v0 = msg.sender == _setStartPreSale;\n    }\n    require(v0);\n    require(_token.code.size);\n    v2 = _token.mintFromICO(varg0, varg1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(varg1 + _soldTokensPreSale >= _soldTokensPreSale);\n    _soldTokensPreSale += varg1;\n    v3 = v4 = 2524;\n    v5 = v6 = 44;\n    v7 = v8 = 0xbb7(10, varg1);\n    while (!v5) {\n        assert(v5);\n        require(_token.code.size);\n        v9 = _token.mintFromICO(stor_5_0_19, v7 / v5).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        exit;\n        goto {'0x9dcB0x371', '0xa80B0x371'};\n        require(_token.code.size);\n        v10 = _token.mintFromICO(stor_4_0_19, v7 / v5).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v11 = 2688;\n        v5 = v12 = 200;\n        v7 = v13 = 0xbb7(3, varg1);\n    }\n}\n\nfunction owner() public nonPayable { \n    return _setStartPreSale;\n}\n\nfunction authorize() public nonPayable { \n    return _authorize;\n}\n\nfunction setBackEndAddress(address varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _backEndOperator = varg0;\n}\n\nfunction soldTokensPreSale() public nonPayable { \n    return _soldTokensPreSale;\n}\n\nfunction weisRaised() public nonPayable { \n    return _weisRaised;\n}\n\nfunction setEndPreSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _endPreSale = varg0;\n}\n\nfunction endPreSale() public nonPayable { \n    return _endPreSale;\n}\n\nfunction hardCapPreSale() public nonPayable { \n    return _hardCapPreSale;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x455() private { \n    v0 = v1 = block.timestamp >= _startPreSale;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endPreSale;\n    }\n    return v0;\n}\n\nfunction 0xbb7(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x50895ff) {\n            backEndOperator();\n        } else if (0x1c232194 == function_selector) {\n            refundPreSale();\n        } else if (0x274448ff == function_selector) {\n            investedEther(address);\n        } else if (0x31198d19 == function_selector) {\n            transferEthFromContract(address,uint256);\n        } else if (0x384a6494 == function_selector) {\n            setStartPreSale(uint256);\n        } else if (0x40d7b7b8 == function_selector) {\n            dollarPrice();\n        } else if (0x4b63189c == function_selector) {\n            softcapPreSale();\n        } else if (0x4ced4734 == function_selector) {\n            isPreSale();\n        } else if (0x55dd574c == function_selector) {\n            startPreSale();\n        } else if (0x63ae8d6c == function_selector) {\n            setBuyPrice(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8ca5da35 == function_selector) {\n            mintManual(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xababa4a7 == function_selector) {\n            authorize();\n        } else if (0xb701dc14 == function_selector) {\n            setBackEndAddress(address);\n        } else if (0xd893b9f1 == function_selector) {\n            soldTokensPreSale();\n        } else if (0xda5f838d == function_selector) {\n            weisRaised();\n        } else if (0xe0462547 == function_selector) {\n            setEndPreSale(uint256);\n        } else if (0xee889ed0 == function_selector) {\n            endPreSale();\n        } else if (0xf7e4a4a9 == function_selector) {\n            hardCapPreSale();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 20:03 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _investedEther; // STORAGE[0x6]\nuint256 _startPreSale; // STORAGE[0x7]\nuint256 _endPreSale; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 _weisRaised; // STORAGE[0xe]\nuint256 _buyPrice; // STORAGE[0xf]\nuint256 _dollarPrice; // STORAGE[0x10]\nuint256 _soldTokensPreSale; // STORAGE[0x11]\nuint256 _softcapPreSale; // STORAGE[0x12]\nuint256 _hardCapPreSale; // STORAGE[0x13]\naddress _setStartPreSale; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x1] bytes 0 to 19\naddress _authorize; // STORAGE[0x2] bytes 0 to 19\naddress _backEndOperator; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\nuint160 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nRefund(uint256, address);\nUpdateDollar(uint256, uint256);\n\nfunction fallback() public payable { \n    require(_authorize.code.size);\n    v0, v1 = _authorize.isWhitelisted(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1);\n    v2 = 0x455();\n    require(v2);\n    v3 = v4 = 0;\n    v5 = v6 = 1188;\n    v7 = v8 = _buyPrice;\n    v9 = v10 = 0xbb7(0xde0b6b3a7640000, msg.value);\n    while (!v7) {\n        assert(v7);\n        require(_token.code.size);\n        v11 = _token.mintFromICO(stor_5_0_19, v3).gas(msg.gas);\n        require(v11); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(msg.value + _weisRaised >= _weisRaised);\n        _weisRaised += msg.value;\n        require(_soldTokensPreSale <= _hardCapPreSale);\n        assert(msg.value + _investedEther[msg.sender] >= _investedEther[msg.sender]);\n        _investedEther[msg.sender] += msg.value;\n        exit;\n        v3 = v9 / v7;\n        goto {'0x4c3', '0x4a4', '0x588', '0x62c'};\n        v5 = v12 = 1219;\n        v7 = v13 = 100;\n        v14 = v15 = block.timestamp > _startPreSale;\n        if (v15) {\n            v14 = block.timestamp < stor_9;\n        }\n        if (!v14) {\n            v16 = v17 = block.timestamp > stor_9;\n            if (v17) {\n                v16 = block.timestamp < stor_a;\n            }\n            if (!v16) {\n                v18 = v19 = block.timestamp > stor_a;\n                if (v19) {\n                    v18 = block.timestamp < stor_b;\n                }\n                if (!v18) {\n                    v20 = v21 = block.timestamp > stor_b;\n                    if (v21) {\n                        v20 = block.timestamp < stor_c;\n                    }\n                    if (!v20) {\n                        v22 = v23 = block.timestamp > stor_c;\n                        if (v23) {\n                            v22 = block.timestamp < stor_d;\n                        }\n                        if (!v22) {\n                            v24 = v25 = 0;\n                        } else {\n                            v24 = v26 = 25;\n                        }\n                    } else {\n                        v24 = v27 = 30;\n                    }\n                } else {\n                    v24 = v28 = 33;\n                }\n            } else {\n                v24 = v29 = 40;\n            }\n        } else {\n            v24 = v30 = 50;\n        }\n        v9 = 0xbb7(v24, v3);\n        v3 += v3;\n        assert(v3 >= v3);\n        MEM[MEM[64]] = 0x3aa0396a00000000000000000000000000000000000000000000000000000000;\n        MEM[MEM[64] + 4] = msg.sender;\n        MEM[MEM[64] + 36] = v3;\n        require(_token.code.size);\n        v31 = _token.call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 32]).gas(msg.gas);\n        require(v31); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(v3 + _soldTokensPreSale >= _soldTokensPreSale);\n        _soldTokensPreSale += v3;\n        v5 = v32 = 1416;\n        v7 = v33 = 44;\n        v9 = 0xbb7(10, v3);\n        MEM[MEM[64]] = 0x3aa0396a00000000000000000000000000000000000000000000000000000000;\n        MEM[MEM[64] + 4] = stor_4_0_19;\n        MEM[MEM[64] + 36] = v3;\n        require(_token.code.size);\n        v34 = _token.call(MEM[(MEM[64]) len 68], MEM[(MEM[64]) len 32]).gas(msg.gas);\n        require(v34); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v5 = v35 = 1580;\n        v7 = v36 = 200;\n        v9 = 0xbb7(3, v3);\n    }\n}\n\nfunction backEndOperator() public nonPayable { \n    return _backEndOperator;\n}\n\nfunction refundPreSale() public nonPayable { \n    v0 = v1 = _soldTokensPreSale < _softcapPreSale;\n    if (v1) {\n        v0 = v2 = block.timestamp > _endPreSale;\n    }\n    require(v0);\n    require(_investedEther[msg.sender] >= 0);\n    _investedEther[msg.sender] = 0;\n    v3 = msg.sender.call().value(_investedEther[msg.sender]).gas(2300 * !_investedEther[msg.sender]);\n    require(v3); // checks call status, propagates error data on error\n    assert(_investedEther[msg.sender] <= _weisRaised);\n    _weisRaised = _weisRaised - _investedEther[msg.sender];\n    emit Refund(_investedEther[msg.sender], msg.sender);\n}\n\nfunction investedEther(address varg0) public nonPayable { \n    return _investedEther[varg0];\n}\n\nfunction transferEthFromContract(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    v0 = varg0.call().value(varg1).gas(2300 * !varg1);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction setStartPreSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _startPreSale = varg0;\n}\n\nfunction dollarPrice() public nonPayable { \n    return _dollarPrice;\n}\n\nfunction softcapPreSale() public nonPayable { \n    return _softcapPreSale;\n}\n\nfunction isPreSale() public nonPayable { \n    v0 = 0x455();\n    return v0;\n}\n\nfunction startPreSale() public nonPayable { \n    return _startPreSale;\n}\n\nfunction setBuyPrice(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _backEndOperator;\n    if (msg.sender != _backEndOperator) {\n        v0 = v2 = msg.sender == _setStartPreSale;\n    }\n    require(v0);\n    _dollarPrice = varg0;\n    assert(varg0);\n    assert(10);\n    _buyPrice = 0xde0b6b3a7640000 / varg0 / 10;\n    emit UpdateDollar(block.timestamp, _dollarPrice);\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction mintManual(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _backEndOperator;\n    if (msg.sender != _backEndOperator) {\n        v0 = msg.sender == _setStartPreSale;\n    }\n    require(v0);\n    require(_token.code.size);\n    v2 = _token.mintFromICO(varg0, varg1).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(varg1 + _soldTokensPreSale >= _soldTokensPreSale);\n    _soldTokensPreSale += varg1;\n    v3 = v4 = 2524;\n    v5 = v6 = 44;\n    v7 = v8 = 0xbb7(10, varg1);\n    while (!v5) {\n        assert(v5);\n        require(_token.code.size);\n        v9 = _token.mintFromICO(stor_5_0_19, v7 / v5).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        exit;\n        goto {'0x9dcB0x371', '0xa80B0x371'};\n        require(_token.code.size);\n        v10 = _token.mintFromICO(stor_4_0_19, v7 / v5).gas(msg.gas);\n        require(v10); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v3 = v11 = 2688;\n        v5 = v12 = 200;\n        v7 = v13 = 0xbb7(3, varg1);\n    }\n}\n\nfunction owner() public nonPayable { \n    return _setStartPreSale;\n}\n\nfunction authorize() public nonPayable { \n    return _authorize;\n}\n\nfunction setBackEndAddress(address varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _backEndOperator = varg0;\n}\n\nfunction soldTokensPreSale() public nonPayable { \n    return _soldTokensPreSale;\n}\n\nfunction weisRaised() public nonPayable { \n    return _weisRaised;\n}\n\nfunction setEndPreSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _setStartPreSale);\n    _endPreSale = varg0;\n}\n\nfunction endPreSale() public nonPayable { \n    return _endPreSale;\n}\n\nfunction hardCapPreSale() public nonPayable { \n    return _hardCapPreSale;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x455() private { \n    v0 = v1 = block.timestamp >= _startPreSale;\n    if (v1) {\n        v0 = v2 = block.timestamp <= _endPreSale;\n    }\n    return v0;\n}\n\nfunction 0xbb7(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x50895ff) {\n            backEndOperator();\n        } else if (0x1c232194 == function_selector) {\n            refundPreSale();\n        } else if (0x274448ff == function_selector) {\n            investedEther(address);\n        } else if (0x31198d19 == function_selector) {\n            transferEthFromContract(address,uint256);\n        } else if (0x384a6494 == function_selector) {\n            setStartPreSale(uint256);\n        } else if (0x40d7b7b8 == function_selector) {\n            dollarPrice();\n        } else if (0x4b63189c == function_selector) {\n            softcapPreSale();\n        } else if (0x4ced4734 == function_selector) {\n            isPreSale();\n        } else if (0x55dd574c == function_selector) {\n            startPreSale();\n        } else if (0x63ae8d6c == function_selector) {\n            setBuyPrice(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8ca5da35 == function_selector) {\n            mintManual(address,uint256);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xababa4a7 == function_selector) {\n            authorize();\n        } else if (0xb701dc14 == function_selector) {\n            setBackEndAddress(address);\n        } else if (0xd893b9f1 == function_selector) {\n            soldTokensPreSale();\n        } else if (0xda5f838d == function_selector) {\n            weisRaised();\n        } else if (0xe0462547 == function_selector) {\n            setEndPreSale(uint256);\n        } else if (0xee889ed0 == function_selector) {\n            endPreSale();\n        } else if (0xf7e4a4a9 == function_selector) {\n            hardCapPreSale();\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 41.76875591278076,
	"usage": {
		"completion_tokens": 1065,
		"prompt_tokens": 3307,
		"total_tokens": 4372
	}
}