{
	"address": "0x2a0c0dbecc7e4d658f48e01e3fa353f44050c208",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the Solidity contract code that corresponds to the provided decompiled code:\n\n```solidity\npragma solidity >=0.4.22 <0.7.0;\n\ncontract ExampleContract {\n    address public owner;\n    mapping (address => uint256) public invalidOrder;\n    mapping (address => mapping (address => uint256)) public tokens;\n    mapping (address => bool) public admins;\n    address public feeAccount;\n    uint256 public inactivityReleasePeriod;\n    mapping (address => uint256) public lastActiveTransaction;\n    mapping (address => uint256) public orderFills;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyAdmin {\n        require(admins[msg.sender]);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n        feeAccount = msg.sender;\n        inactivityReleasePeriod = 1 days;\n    }\n\n    function setAdmin(address admin, bool isAdmin) public onlyOwner {\n        admins[admin] = isAdmin;\n    }\n\n    function setInactivityReleasePeriod(uint256 expiry) public onlyAdmin {\n        require(expiry <= 30 days);\n        inactivityReleasePeriod = expiry;\n    }\n\n    function setOwner(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n\n    function invalidateOrdersBefore(address user, uint256 nonce) public onlyAdmin {\n        require(nonce >= invalidOrder[user]);\n        invalidOrder[user] = nonce;\n    }\n\n    function deposit() public payable {\n        tokens[0x0000000000000000000000000000000000000000][msg.sender] += msg.value;\n        lastActiveTransaction[msg.sender] = block.number;\n    }\n\n    function depositToken(address token, uint256 amount) public {\n        require(token != 0x0);\n        tokens[token][msg.sender] += amount;\n        lastActiveTransaction[msg.sender] = block.number;\n        require(Token(token).transferFrom(msg.sender, this, amount));\n    }\n\n    function withdraw(address token, uint256 amount) public {\n        require(block.number - lastActiveTransaction[msg.sender] >= inactivityReleasePeriod);\n        require(tokens[token][msg.sender] >= amount);\n        tokens[token][msg.sender] -= amount;\n        if (token == 0x0) {\n            msg.sender.transfer(amount);\n        } else {\n            require(Token(token).transfer(msg.sender, amount));\n        }\n    }\n\n    // This function is intentionally incomplete as the decompiled code was incomplete\n    function trade(uint256[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) public onlyAdmin {\n        // trade logic goes here\n    }\n}\n\ninterface Token {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n```\nPlease note, the `trade` function is incomplete because the decompiled code was incomplete. You'll need to complete the function based on your business logic. The contract uses the ERC20 token standard, so it's important that the token contracts you're interacting with adhere to this standard.",
				"role": "assistant"
			}
		}
	],
	"created": 1700470681,
	"id": "chatcmpl-8MuOPpzLasBRzT5z0cmnauSGvd5Xq",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  invalidOrder is mapping of uint256 at storage 1\n  tokens is mapping of uint256 at storage 2\n  stor3 is mapping of uint8 at storage 3\n  lastActiveTransaction is mapping of uint256 at storage 4\n  orderFills is mapping of uint256 at storage 5\n  feeAccount is address at storage 6\n  inactivityReleasePeriod is uint256 at storage 7\n  stor8 is mapping of uint8 at storage 8\n  stor9 is mapping of uint8 at storage 9\n\ndef lastActiveTransaction(address _param1): # not payable\n  return lastActiveTransaction[_param1]\n\ndef withdrawn(bytes32 _param1): # not payable\n  return bool(stor9[_param1])\n\ndef admins(address _param1): # not payable\n  return bool(stor3[_param1])\n\ndef tokens(address _param1, address _param2): # not payable\n  return tokens[_param1][_param2]\n\ndef feeAccount(): # not payable\n  return feeAccount\n\ndef invalidOrder(address _param1): # not payable\n  return invalidOrder[_param1]\n\ndef getOwner(): # not payable\n  return owner\n\ndef owner(): # not payable\n  return owner\n\ndef traded(bytes32 _param1): # not payable\n  return bool(stor8[_param1])\n\ndef inactivityReleasePeriod(): # not payable\n  return inactivityReleasePeriod\n\ndef orderFills(bytes32 _param1): # not payable\n  return orderFills[_param1]\n\ndef balanceOf(address token, address user): # not payable\n  return tokens[address(token)][address(user)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?): # not payable, default function\n  revert\n\ndef assert(bool assertion): # not payable\n  require assertion\n\ndef safeSub(uint256 a, uint256 b): # not payable\n  require b <= a\n  return (a - b)\n\ndef safeAdd(uint256 a, uint256 b): # not payable\n  require b + a >= a\n  require b + a >= b\n  return (b + a)\n\ndef safeMul(uint256 a, uint256 b): # not payable\n  if a:\n      require a\n      require b * a / a == b\n  return (b * a)\n\ndef setAdmin(address admin, bool isAdmin): # not payable\n  require owner == caller\n  stor3[address(admin)] = uint8(isAdmin)\n\ndef setInactivityReleasePeriod(uint256 expiry): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require expiry <= 10^6\n  inactivityReleasePeriod = expiry\n  return 1\n\ndef setOwner(address _newOwner): # not payable\n  require owner == caller\n  log SetOwner(\n        address previousOwner=owner,\n        address newOwner=_newOwner)\n  owner = _newOwner\n\ndef invalidateOrdersBefore(address user, uint256 nonce): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require nonce >= invalidOrder[address(user)]\n  invalidOrder[address(user)] = nonce\n\ndef deposit() payable: \n  require call.value + tokens[0][caller] >= tokens[0][caller]\n  require call.value + tokens[0][caller] >= call.value\n  tokens[0][caller] += call.value\n  lastActiveTransaction[caller] = block.number\n  log Deposit(\n        address token=0,\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 balance=tokens[0][caller])\n\ndef depositToken(address token, uint256 amount): # not payable\n  require amount + tokens[address(token)][caller] >= tokens[address(token)][caller]\n  require amount + tokens[address(token)][caller] >= amount\n  tokens[address(token)][caller] += amount\n  lastActiveTransaction[caller] = block.number\n  require ext_code.size(token)\n  call token.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, address(this.address), amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  log Deposit(\n        address token=address(token),\n        address user=caller,\n        uint256 amount=amount,\n        uint256 balance=tokens[address(token)][caller])\n\ndef withdraw(address _token, uint256 _amount): # not payable\n  require lastActiveTransaction[caller] <= block.number\n  require block.number - lastActiveTransaction[caller] >= inactivityReleasePeriod\n  require tokens[address(_token)][caller] >= _amount\n  require _amount <= tokens[address(_token)][caller]\n  tokens[address(_token)][caller] -= _amount\n  if not _token:\n      call caller with:\n         value _amount wei\n           gas 2300 * is_zero(value) wei\n      require ext_call.success\n  else:\n      require ext_code.size(_token)\n      call _token.transfer(address recipient, uint256 amount) with:\n           gas gas_remaining - 710 wei\n          args caller, _amount\n      require ext_call.success\n      require ext_call.return_data[0]\n  log Withdraw(\n        address token=address(_token),\n        address user=caller,\n        uint256 amount=_amount,\n        uint256 balance=tokens[address(_token)][caller])\n  return 0\n\ndef adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 feeWithdrawal): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require not stor9[this.address][token][amount][user][nonce]\n  stor9[this.address][token][amount][user][nonce] = 1\n  signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, token, amount, user, nonce)), v << 248, r, s) # precompiled\n  require erecover.result\n  require address(signer) == user\n  require tokens[address(token)][address(user)] >= amount\n  require amount <= tokens[address(token)][address(user)]\n  tokens[address(token)][address(user)] -= amount\n  if feeWithdrawal > 5 * 10^16:\n      require 5 * 10^16 * amount / 5 * 10^16 == amount\n      require (5 * 10^16 * amount / 10^18) + tokens[address(token)][stor6] >= tokens[address(token)][stor6]\n      require (5 * 10^16 * amount / 10^18) + tokens[address(token)][stor6] >= 5 * 10^16 * amount / 10^18\n      tokens[address(token)][stor6] += 5 * 10^16 * amount / 10^18\n      require 95 * 10^16 * amount / 95 * 10^16 == amount\n      if not token:\n          call user with:\n             value 95 * 10^16 * amount / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          require ext_call.success\n      else:\n          require ext_code.size(token)\n          call token.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining - 710 wei\n              args address(user), 95 * 10^16 * amount / 10^18\n          require ext_call.success\n          require ext_call.return_data[0]\n      lastActiveTransaction[address(user)] = block.number\n      log Withdraw(\n            address token=address(token),\n            address user=address(user),\n            uint256 amount=95 * 10^16 * amount / 10^18,\n            uint256 balance=tokens[address(token)][address(user)])\n  else:\n      if feeWithdrawal:\n          require feeWithdrawal\n          require amount * feeWithdrawal / feeWithdrawal == amount\n      require (amount * feeWithdrawal / 10^18) + tokens[address(token)][stor6] >= tokens[address(token)][stor6]\n      require (amount * feeWithdrawal / 10^18) + tokens[address(token)][stor6] >= amount * feeWithdrawal / 10^18\n      tokens[address(token)][stor6] += amount * feeWithdrawal / 10^18\n      if -feeWithdrawal + 10^18:\n          require -feeWithdrawal + 10^18\n          require (10^18 * amount) - (feeWithdrawal * amount) / -feeWithdrawal + 10^18 == amount\n      if not token:\n          call user with:\n             value (10^18 * amount) - (feeWithdrawal * amount) / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          require ext_call.success\n      else:\n          require ext_code.size(token)\n          call token.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining - 710 wei\n              args address(user), (10^18 * amount) - (feeWithdrawal * amount) / 10^18\n          require ext_call.success\n          require ext_call.return_data[0]\n      lastActiveTransaction[address(user)] = block.number\n      log Withdraw(\n            address token=address(token),\n            address user=address(user),\n            uint256 amount=(10^18 * amount) - (feeWithdrawal * amount) / 10^18,\n            uint256 balance=tokens[address(token)][address(user)])\n  return 0\n\ndef trade(uint256[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs): # not payable\n  if owner == caller:\n      require invalidOrder[address(call.data[324])] <= call.data[100]\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))), call.data[388] << 248, call.data[452], call.data[484]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[324])\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324])), call.data[132], address(call.data[356]), call.data[164])), call.data[420] << 248, call.data[516], call.data[548]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[356])\n      require not stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]]\n      stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]] = 1\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= call.data[132]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] <= call.data[4]\n      require tokens[address(call.data[260])][address(call.data[356])] >= call.data[132]\n      if call.data[196] <= 10^17:\n          if call.data[228] <= 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              require call.data[132] * call.data[36] / call.data[4] <= tokens[address(call.data[292])][address(call.data[324])]\n                          else:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                              require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n      else:\n          if call.data[228] > 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n  else:\n      require stor3[caller]\n      require invalidOrder[address(call.data[324])] <= call.data[100]\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))), call.data[388] << 248, call.data[452], call.data[484]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[324])\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324])), call.data[132], address(call.data[356]), call.data[164])), call.data[420] << 248, call.data[516], call.data[548]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[356])\n      require not stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]]\n      stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]] = 1\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= call.data[132]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] <= call.data[4]\n      require tokens[address(call.data[260])][address(call.data[356])] >= call.data[132]\n      if call.data[196] > 10^17:\n          if call.data[228] <= 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if call.data[132]:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[36]\n          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          require call.data[4]\n          require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n          require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n          tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n          if not call.data[132]:\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[132]\n          require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n          require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n          require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n          tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n          if not call.data[132]:\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[132]\n          require 10^17 * call.data[132] / call.data[132] == 10^17\n          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n          if call.data[36]:\n      else:\n          if call.data[228] > 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if call.data[132]:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n              require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n              if not call.data[132]:\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n              require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          require call.data[132] * call.data[36] / call.data[4] <= tokens[address(call.data[292])][address(call.data[324])]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  invalidOrder is mapping of uint256 at storage 1\n  tokens is mapping of uint256 at storage 2\n  stor3 is mapping of uint8 at storage 3\n  lastActiveTransaction is mapping of uint256 at storage 4\n  orderFills is mapping of uint256 at storage 5\n  feeAccount is address at storage 6\n  inactivityReleasePeriod is uint256 at storage 7\n  stor8 is mapping of uint8 at storage 8\n  stor9 is mapping of uint8 at storage 9\n\ndef lastActiveTransaction(address _param1): # not payable\n  return lastActiveTransaction[_param1]\n\ndef withdrawn(bytes32 _param1): # not payable\n  return bool(stor9[_param1])\n\ndef admins(address _param1): # not payable\n  return bool(stor3[_param1])\n\ndef tokens(address _param1, address _param2): # not payable\n  return tokens[_param1][_param2]\n\ndef feeAccount(): # not payable\n  return feeAccount\n\ndef invalidOrder(address _param1): # not payable\n  return invalidOrder[_param1]\n\ndef getOwner(): # not payable\n  return owner\n\ndef owner(): # not payable\n  return owner\n\ndef traded(bytes32 _param1): # not payable\n  return bool(stor8[_param1])\n\ndef inactivityReleasePeriod(): # not payable\n  return inactivityReleasePeriod\n\ndef orderFills(bytes32 _param1): # not payable\n  return orderFills[_param1]\n\ndef balanceOf(address token, address user): # not payable\n  return tokens[address(token)][address(user)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?): # not payable, default function\n  revert\n\ndef assert(bool assertion): # not payable\n  require assertion\n\ndef safeSub(uint256 a, uint256 b): # not payable\n  require b <= a\n  return (a - b)\n\ndef safeAdd(uint256 a, uint256 b): # not payable\n  require b + a >= a\n  require b + a >= b\n  return (b + a)\n\ndef safeMul(uint256 a, uint256 b): # not payable\n  if a:\n      require a\n      require b * a / a == b\n  return (b * a)\n\ndef setAdmin(address admin, bool isAdmin): # not payable\n  require owner == caller\n  stor3[address(admin)] = uint8(isAdmin)\n\ndef setInactivityReleasePeriod(uint256 expiry): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require expiry <= 10^6\n  inactivityReleasePeriod = expiry\n  return 1\n\ndef setOwner(address _newOwner): # not payable\n  require owner == caller\n  log SetOwner(\n        address previousOwner=owner,\n        address newOwner=_newOwner)\n  owner = _newOwner\n\ndef invalidateOrdersBefore(address user, uint256 nonce): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require nonce >= invalidOrder[address(user)]\n  invalidOrder[address(user)] = nonce\n\ndef deposit() payable: \n  require call.value + tokens[0][caller] >= tokens[0][caller]\n  require call.value + tokens[0][caller] >= call.value\n  tokens[0][caller] += call.value\n  lastActiveTransaction[caller] = block.number\n  log Deposit(\n        address token=0,\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 balance=tokens[0][caller])\n\ndef depositToken(address token, uint256 amount): # not payable\n  require amount + tokens[address(token)][caller] >= tokens[address(token)][caller]\n  require amount + tokens[address(token)][caller] >= amount\n  tokens[address(token)][caller] += amount\n  lastActiveTransaction[caller] = block.number\n  require ext_code.size(token)\n  call token.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, address(this.address), amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  log Deposit(\n        address token=address(token),\n        address user=caller,\n        uint256 amount=amount,\n        uint256 balance=tokens[address(token)][caller])\n\ndef withdraw(address _token, uint256 _amount): # not payable\n  require lastActiveTransaction[caller] <= block.number\n  require block.number - lastActiveTransaction[caller] >= inactivityReleasePeriod\n  require tokens[address(_token)][caller] >= _amount\n  require _amount <= tokens[address(_token)][caller]\n  tokens[address(_token)][caller] -= _amount\n  if not _token:\n      call caller with:\n         value _amount wei\n           gas 2300 * is_zero(value) wei\n      require ext_call.success\n  else:\n      require ext_code.size(_token)\n      call _token.transfer(address recipient, uint256 amount) with:\n           gas gas_remaining - 710 wei\n          args caller, _amount\n      require ext_call.success\n      require ext_call.return_data[0]\n  log Withdraw(\n        address token=address(_token),\n        address user=caller,\n        uint256 amount=_amount,\n        uint256 balance=tokens[address(_token)][caller])\n  return 0\n\ndef adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 feeWithdrawal): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require not stor9[this.address][token][amount][user][nonce]\n  stor9[this.address][token][amount][user][nonce] = 1\n  signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, token, amount, user, nonce)), v << 248, r, s) # precompiled\n  require erecover.result\n  require address(signer) == user\n  require tokens[address(token)][address(user)] >= amount\n  require amount <= tokens[address(token)][address(user)]\n  tokens[address(token)][address(user)] -= amount\n  if feeWithdrawal > 5 * 10^16:\n      require 5 * 10^16 * amount / 5 * 10^16 == amount\n      require (5 * 10^16 * amount / 10^18) + tokens[address(token)][stor6] >= tokens[address(token)][stor6]\n      require (5 * 10^16 * amount / 10^18) + tokens[address(token)][stor6] >= 5 * 10^16 * amount / 10^18\n      tokens[address(token)][stor6] += 5 * 10^16 * amount / 10^18\n      require 95 * 10^16 * amount / 95 * 10^16 == amount\n      if not token:\n          call user with:\n             value 95 * 10^16 * amount / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          require ext_call.success\n      else:\n          require ext_code.size(token)\n          call token.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining - 710 wei\n              args address(user), 95 * 10^16 * amount / 10^18\n          require ext_call.success\n          require ext_call.return_data[0]\n      lastActiveTransaction[address(user)] = block.number\n      log Withdraw(\n            address token=address(token),\n            address user=address(user),\n            uint256 amount=95 * 10^16 * amount / 10^18,\n            uint256 balance=tokens[address(token)][address(user)])\n  else:\n      if feeWithdrawal:\n          require feeWithdrawal\n          require amount * feeWithdrawal / feeWithdrawal == amount\n      require (amount * feeWithdrawal / 10^18) + tokens[address(token)][stor6] >= tokens[address(token)][stor6]\n      require (amount * feeWithdrawal / 10^18) + tokens[address(token)][stor6] >= amount * feeWithdrawal / 10^18\n      tokens[address(token)][stor6] += amount * feeWithdrawal / 10^18\n      if -feeWithdrawal + 10^18:\n          require -feeWithdrawal + 10^18\n          require (10^18 * amount) - (feeWithdrawal * amount) / -feeWithdrawal + 10^18 == amount\n      if not token:\n          call user with:\n             value (10^18 * amount) - (feeWithdrawal * amount) / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          require ext_call.success\n      else:\n          require ext_code.size(token)\n          call token.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining - 710 wei\n              args address(user), (10^18 * amount) - (feeWithdrawal * amount) / 10^18\n          require ext_call.success\n          require ext_call.return_data[0]\n      lastActiveTransaction[address(user)] = block.number\n      log Withdraw(\n            address token=address(token),\n            address user=address(user),\n            uint256 amount=(10^18 * amount) - (feeWithdrawal * amount) / 10^18,\n            uint256 balance=tokens[address(token)][address(user)])\n  return 0\n\ndef trade(uint256[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs): # not payable\n  if owner == caller:\n      require invalidOrder[address(call.data[324])] <= call.data[100]\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))), call.data[388] << 248, call.data[452], call.data[484]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[324])\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324])), call.data[132], address(call.data[356]), call.data[164])), call.data[420] << 248, call.data[516], call.data[548]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[356])\n      require not stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]]\n      stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]] = 1\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= call.data[132]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] <= call.data[4]\n      require tokens[address(call.data[260])][address(call.data[356])] >= call.data[132]\n      if call.data[196] <= 10^17:\n          if call.data[228] <= 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              require call.data[132] * call.data[36] / call.data[4] <= tokens[address(call.data[292])][address(call.data[324])]\n                          else:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                              require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n      else:\n          if call.data[228] > 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n  else:\n      require stor3[caller]\n      require invalidOrder[address(call.data[324])] <= call.data[100]\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))), call.data[388] << 248, call.data[452], call.data[484]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[324])\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324])), call.data[132], address(call.data[356]), call.data[164])), call.data[420] << 248, call.data[516], call.data[548]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[356])\n      require not stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]]\n      stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]] = 1\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= call.data[132]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] <= call.data[4]\n      require tokens[address(call.data[260])][address(call.data[356])] >= call.data[132]\n      if call.data[196] > 10^17:\n          if call.data[228] <= 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if call.data[132]:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[36]\n          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          require call.data[4]\n          require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n          require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n          tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n          if not call.data[132]:\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[132]\n          require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n          require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n          require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n          tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n          if not call.data[132]:\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[132]\n          require 10^17 * call.data[132] / call.data[132] == 10^17\n          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n          if call.data[36]:\n      else:\n          if call.data[228] > 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if call.data[132]:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n              require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n              if not call.data[132]:\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n              require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          require call.data[132] * call.data[36] / call.data[4] <= tokens[address(call.data[292])][address(call.data[324])]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  invalidOrder is mapping of uint256 at storage 1\n  tokens is mapping of uint256 at storage 2\n  stor3 is mapping of uint8 at storage 3\n  lastActiveTransaction is mapping of uint256 at storage 4\n  orderFills is mapping of uint256 at storage 5\n  feeAccount is address at storage 6\n  inactivityReleasePeriod is uint256 at storage 7\n  stor8 is mapping of uint8 at storage 8\n  stor9 is mapping of uint8 at storage 9\n\ndef lastActiveTransaction(address _param1): # not payable\n  return lastActiveTransaction[_param1]\n\ndef withdrawn(bytes32 _param1): # not payable\n  return bool(stor9[_param1])\n\ndef admins(address _param1): # not payable\n  return bool(stor3[_param1])\n\ndef tokens(address _param1, address _param2): # not payable\n  return tokens[_param1][_param2]\n\ndef feeAccount(): # not payable\n  return feeAccount\n\ndef invalidOrder(address _param1): # not payable\n  return invalidOrder[_param1]\n\ndef getOwner(): # not payable\n  return owner\n\ndef owner(): # not payable\n  return owner\n\ndef traded(bytes32 _param1): # not payable\n  return bool(stor8[_param1])\n\ndef inactivityReleasePeriod(): # not payable\n  return inactivityReleasePeriod\n\ndef orderFills(bytes32 _param1): # not payable\n  return orderFills[_param1]\n\ndef balanceOf(address token, address user): # not payable\n  return tokens[address(token)][address(user)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?): # not payable, default function\n  revert\n\ndef assert(bool assertion): # not payable\n  require assertion\n\ndef safeSub(uint256 a, uint256 b): # not payable\n  require b <= a\n  return (a - b)\n\ndef safeAdd(uint256 a, uint256 b): # not payable\n  require b + a >= a\n  require b + a >= b\n  return (b + a)\n\ndef safeMul(uint256 a, uint256 b): # not payable\n  if a:\n      require a\n      require b * a / a == b\n  return (b * a)\n\ndef setAdmin(address admin, bool isAdmin): # not payable\n  require owner == caller\n  stor3[address(admin)] = uint8(isAdmin)\n\ndef setInactivityReleasePeriod(uint256 expiry): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require expiry <= 10^6\n  inactivityReleasePeriod = expiry\n  return 1\n\ndef setOwner(address _newOwner): # not payable\n  require owner == caller\n  log SetOwner(\n        address previousOwner=owner,\n        address newOwner=_newOwner)\n  owner = _newOwner\n\ndef invalidateOrdersBefore(address user, uint256 nonce): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require nonce >= invalidOrder[address(user)]\n  invalidOrder[address(user)] = nonce\n\ndef deposit() payable: \n  require call.value + tokens[0][caller] >= tokens[0][caller]\n  require call.value + tokens[0][caller] >= call.value\n  tokens[0][caller] += call.value\n  lastActiveTransaction[caller] = block.number\n  log Deposit(\n        address token=0,\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 balance=tokens[0][caller])\n\ndef depositToken(address token, uint256 amount): # not payable\n  require amount + tokens[address(token)][caller] >= tokens[address(token)][caller]\n  require amount + tokens[address(token)][caller] >= amount\n  tokens[address(token)][caller] += amount\n  lastActiveTransaction[caller] = block.number\n  require ext_code.size(token)\n  call token.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, address(this.address), amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  log Deposit(\n        address token=address(token),\n        address user=caller,\n        uint256 amount=amount,\n        uint256 balance=tokens[address(token)][caller])\n\ndef withdraw(address _token, uint256 _amount): # not payable\n  require lastActiveTransaction[caller] <= block.number\n  require block.number - lastActiveTransaction[caller] >= inactivityReleasePeriod\n  require tokens[address(_token)][caller] >= _amount\n  require _amount <= tokens[address(_token)][caller]\n  tokens[address(_token)][caller] -= _amount\n  if not _token:\n      call caller with:\n         value _amount wei\n           gas 2300 * is_zero(value) wei\n      require ext_call.success\n  else:\n      require ext_code.size(_token)\n      call _token.transfer(address recipient, uint256 amount) with:\n           gas gas_remaining - 710 wei\n          args caller, _amount\n      require ext_call.success\n      require ext_call.return_data[0]\n  log Withdraw(\n        address token=address(_token),\n        address user=caller,\n        uint256 amount=_amount,\n        uint256 balance=tokens[address(_token)][caller])\n  return 0\n\ndef adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 feeWithdrawal): # not payable\n  if owner != caller:\n      require stor3[caller]\n  require not stor9[this.address][token][amount][user][nonce]\n  stor9[this.address][token][amount][user][nonce] = 1\n  signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, token, amount, user, nonce)), v << 248, r, s) # precompiled\n  require erecover.result\n  require address(signer) == user\n  require tokens[address(token)][address(user)] >= amount\n  require amount <= tokens[address(token)][address(user)]\n  tokens[address(token)][address(user)] -= amount\n  if feeWithdrawal > 5 * 10^16:\n      require 5 * 10^16 * amount / 5 * 10^16 == amount\n      require (5 * 10^16 * amount / 10^18) + tokens[address(token)][stor6] >= tokens[address(token)][stor6]\n      require (5 * 10^16 * amount / 10^18) + tokens[address(token)][stor6] >= 5 * 10^16 * amount / 10^18\n      tokens[address(token)][stor6] += 5 * 10^16 * amount / 10^18\n      require 95 * 10^16 * amount / 95 * 10^16 == amount\n      if not token:\n          call user with:\n             value 95 * 10^16 * amount / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          require ext_call.success\n      else:\n          require ext_code.size(token)\n          call token.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining - 710 wei\n              args address(user), 95 * 10^16 * amount / 10^18\n          require ext_call.success\n          require ext_call.return_data[0]\n      lastActiveTransaction[address(user)] = block.number\n      log Withdraw(\n            address token=address(token),\n            address user=address(user),\n            uint256 amount=95 * 10^16 * amount / 10^18,\n            uint256 balance=tokens[address(token)][address(user)])\n  else:\n      if feeWithdrawal:\n          require feeWithdrawal\n          require amount * feeWithdrawal / feeWithdrawal == amount\n      require (amount * feeWithdrawal / 10^18) + tokens[address(token)][stor6] >= tokens[address(token)][stor6]\n      require (amount * feeWithdrawal / 10^18) + tokens[address(token)][stor6] >= amount * feeWithdrawal / 10^18\n      tokens[address(token)][stor6] += amount * feeWithdrawal / 10^18\n      if -feeWithdrawal + 10^18:\n          require -feeWithdrawal + 10^18\n          require (10^18 * amount) - (feeWithdrawal * amount) / -feeWithdrawal + 10^18 == amount\n      if not token:\n          call user with:\n             value (10^18 * amount) - (feeWithdrawal * amount) / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          require ext_call.success\n      else:\n          require ext_code.size(token)\n          call token.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining - 710 wei\n              args address(user), (10^18 * amount) - (feeWithdrawal * amount) / 10^18\n          require ext_call.success\n          require ext_call.return_data[0]\n      lastActiveTransaction[address(user)] = block.number\n      log Withdraw(\n            address token=address(token),\n            address user=address(user),\n            uint256 amount=(10^18 * amount) - (feeWithdrawal * amount) / 10^18,\n            uint256 balance=tokens[address(token)][address(user)])\n  return 0\n\ndef trade(uint256[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs): # not payable\n  if owner == caller:\n      require invalidOrder[address(call.data[324])] <= call.data[100]\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))), call.data[388] << 248, call.data[452], call.data[484]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[324])\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324])), call.data[132], address(call.data[356]), call.data[164])), call.data[420] << 248, call.data[516], call.data[548]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[356])\n      require not stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]]\n      stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]] = 1\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= call.data[132]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] <= call.data[4]\n      require tokens[address(call.data[260])][address(call.data[356])] >= call.data[132]\n      if call.data[196] <= 10^17:\n          if call.data[228] <= 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              require call.data[132] * call.data[36] / call.data[4] <= tokens[address(call.data[292])][address(call.data[324])]\n                          else:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                              require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n      else:\n          if call.data[228] > 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if not call.data[132]:\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n  else:\n      require stor3[caller]\n      require invalidOrder[address(call.data[324])] <= call.data[100]\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))), call.data[388] << 248, call.data[452], call.data[484]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[324])\n      signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324])), call.data[132], address(call.data[356]), call.data[164])), call.data[420] << 248, call.data[516], call.data[548]) # precompiled\n      require erecover.result\n      require address(signer) == address(call.data[356])\n      require not stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]]\n      stor8[sha3(this.address, address(call.data[260]), call.data[4], address(call.data[292]), call.data[36], call.data[68], call.data[100], address(call.data[324]))][call.data[132]][address(call.data[356])][call.data[164]] = 1\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] >= call.data[132]\n      require call.data[132] + orderFills[this.address][address(call.data[260])][call.data[4]][address(call.data[292])][call.data[36]][call.data[68]][call.data[100]][address(call.data[324])] <= call.data[4]\n      require tokens[address(call.data[260])][address(call.data[356])] >= call.data[132]\n      if call.data[196] > 10^17:\n          if call.data[228] <= 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if not call.data[132]:\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                      if call.data[132]:\n                          require call.data[132]\n                          require 10^17 * call.data[132] / call.data[132] == 10^17\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require 10^17 * call.data[132] / call.data[132] == 10^17\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[36]\n          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          require call.data[4]\n          require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n          require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n          tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n          if not call.data[132]:\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n              if not call.data[132]:\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require 10^17 * call.data[132] / call.data[132] == 10^17\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[132]\n          require 25 * 10^13 * 3600 * call.data[132] / call.data[132] == 25 * 10^13 * 3600\n          require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n          require (25 * 10^13 * 3600 * call.data[132] / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= 25 * 10^13 * 3600 * call.data[132] / 10^18\n          tokens[address(call.data[260])][address(call.data[324])] += 25 * 10^13 * 3600 * call.data[132] / 10^18\n          if not call.data[132]:\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          require call.data[132]\n          require 10^17 * call.data[132] / call.data[132] == 10^17\n          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n          require (10^17 * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= 10^17 * call.data[132] / 10^18\n          tokens[address(call.data[260])][stor6] += 10^17 * call.data[132] / 10^18\n          if call.data[36]:\n      else:\n          if call.data[228] > 10^17:\n              if not call.data[36]:\n                  require call.data[4]\n                  require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n                  require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n                  tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n                  if not call.data[132]:\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if not call.data[132]:\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if not call.data[36]:\n                              require call.data[4]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      else:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                          require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                          tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                          if call.data[36]:\n                              require call.data[36]\n                              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                      require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                      if call.data[132]:\n                          require call.data[132]\n                          require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n              require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n              require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n              tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n              if not call.data[132]:\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[132]\n              require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n              require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n              require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n              tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n              if not call.data[36]:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              require call.data[36]\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if not call.data[36]:\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          require call.data[132] * call.data[36] / call.data[4] <= tokens[address(call.data[292])][address(call.data[324])]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[132]\n                  require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if not call.data[36]:\n                      require call.data[4]\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require call.data[36]\n                  require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n          else:\n              require call.data[36]\n              require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              require call.data[4]\n              require tokens[address(call.data[292])][address(call.data[324])] >= call.data[132] * call.data[36] / call.data[4]\n              require call.data[132] <= tokens[address(call.data[260])][address(call.data[356])]\n              tokens[address(call.data[260])][address(call.data[356])] -= call.data[132]\n              if not call.data[132]:\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if not call.data[132]:\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if not call.data[36]:\n                          require call.data[4]\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n                  else:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                      require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                      tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                      if call.data[36]:\n                          require call.data[36]\n                          require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n              else:\n                  require call.data[132]\n                  require (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / call.data[132] == -call.data[196] + 10^18\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= tokens[address(call.data[260])][address(call.data[324])]\n                  require ((10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18) + tokens[address(call.data[260])][address(call.data[324])] >= (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  tokens[address(call.data[260])][address(call.data[324])] += (10^18 * call.data[132]) - (call.data[196] * call.data[132]) / 10^18\n                  if call.data[132]:\n                      require call.data[132]\n                      require call.data[196] * call.data[132] / call.data[132] == call.data[196]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= tokens[address(call.data[260])][stor6]\n                  require (call.data[196] * call.data[132] / 10^18) + tokens[address(call.data[260])][stor6] >= call.data[196] * call.data[132] / 10^18\n                  tokens[address(call.data[260])][stor6] += call.data[196] * call.data[132] / 10^18\n                  if call.data[36]:\n                      require call.data[36]\n                      require call.data[132] * call.data[36] / call.data[36] == call.data[132]\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
	"status": "1",
	"time_cost": 64.39222025871277,
	"usage": {
		"completion_tokens": 649,
		"prompt_tokens": 23588,
		"total_tokens": 24237
	}
}