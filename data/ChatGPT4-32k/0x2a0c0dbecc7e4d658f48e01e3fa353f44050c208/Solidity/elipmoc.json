{
	"address": "0x2a0c0dbecc7e4d658f48e01e3fa353f44050c208",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code describes various functions and actions that the contract performs. Here's how the Solidity contract could look, although please note that this is a simplified version and the actual contract might include more complex logic:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MyContract {\n    address private owner;\n    mapping(address => uint256) balance;\n    mapping(address => bool) admins;\n    mapping(bytes32 => bool) withdrawn;\n    event SetOwner(address indexed oldOwner, address indexed newOwner);\n    event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);\n    event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setOwner(address newOwner) public onlyOwner {\n        emit SetOwner(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function deposit(uint256 amount) public {\n        balance[msg.sender] += amount;\n        emit Deposit(address(0), msg.sender, amount, balance[msg.sender]);\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balance[msg.sender] >= amount);\n        balance[msg.sender] -= amount;\n        emit Withdraw(address(0), msg.sender, amount, balance[msg.sender]);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return balance[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(balance[msg.sender] >= amount);\n        balance[msg.sender] -= amount;\n        balance[recipient] += amount;\n        return true;\n    }\n\n    function setAdmin(address account, bool isAdmin) public onlyOwner {\n        admins[account] = isAdmin;\n    }\n\n    function isAdmin(address account) public view returns (bool) {\n        return admins[account];\n    }\n}\n``` \n\nThis contract allows the owner to set other admins, and those admins can manage the balances of addresses. Users can deposit and withdraw their balances, and the balance transfers are logged as events. The contract also includes a function for checking if a certain address is an admin.",
				"role": "assistant"
			}
		}
	],
	"created": 1701455307,
	"id": "chatcmpl-8R2XTYYpdSPg1UzUNizzM9AYxusXP",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 07:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x5]\nuint256 _inactivityReleasePeriod; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _traded; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0x9]\naddress _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x6] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n// Events\nSetOwner(address, address);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction assert(bool varg0) public nonPayable { \n    0x620(varg0);\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    0x620(_getOwner == msg.sender);\n    emit SetOwner(_getOwner, varg0);\n    _getOwner = varg0;\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    v2 = keccak256(address(this), varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v2]));\n    _withdrawn[v2] = 0x1 | ~0xff & _withdrawn[v2];\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v3, v4 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v2), varg4 & 0xff & 0xff, varg5, varg6);\n    require(v3);\n    require(address(v4) == varg2);\n    if (varg7 > 0xb1a2bc2ec50000) {\n        v5 = v6 = 0xb1a2bc2ec50000;\n    }\n    require(_tokens[varg2] >= varg1);\n    0x620(varg1 <= _tokens[varg2]);\n    _tokens[varg2] = _tokens[varg2] - varg1;\n    v7 = _SafeMul(varg1, v5);\n    assert(0xde0b6b3a7640000);\n    v8 = v9 = v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount];\n    if (v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount]) {\n        v8 = v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= v7 / 0xde0b6b3a7640000;\n        goto 0x6200x6b4B0x186;\n    }\n    require(v8);\n    _tokens[_feeAccount] += v7 / 0xde0b6b3a7640000;\n    v10 = _SafeMul(varg1, 0xde0b6b3a7640000 - v5);\n    assert(0xde0b6b3a7640000);\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v11, v12 = varg0.transfer(varg2, v10 / 0xde0b6b3a7640000).gas(msg.gas - 710);\n        require(v11);\n        require(v12);\n    } else {\n        v13 = varg2.call().value(v10 / 0xde0b6b3a7640000).gas(2300 * !(v10 / 0xde0b6b3a7640000));\n        require(v13);\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, v10 / 0xde0b6b3a7640000, _lastActiveTransaction[varg0]);\n    return 0;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    _lastActiveTransaction[msg.sender] = block.number;\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v1);\n    require(v2);\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    0x620(_getOwner == msg.sender);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction owner() public nonPayable { \n    return _getOwner;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    0x620(varg1 <= varg0);\n    return varg0 - varg1;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeMul(varg1, varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[0] = msg.sender;\n    MEM[32] = 0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction traded(bytes32 varg0) public nonPayable { \n    return 0xff & _traded[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg0 <= 0xf4240);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, varg0);\n    return v0;\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = MEM[64];\n    CALLDATACOPY(v1, 4, 256);\n    v0 = v2 = MEM[64];\n    CALLDATACOPY(v2, 260, 128);\n    v0 = v3 = MEM[64];\n    CALLDATACOPY(v3, 388, 64);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 452, 128);\n    v0 = v5 = 0;\n    v6 = v7 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v6 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v6);\n    require(_invalidOrder[address(MEM[64 + v2])] <= MEM[96 + v1]);\n    v0 = v8 = keccak256(address(this), address(MEM[0 + v2]), MEM[0 + v1], address(MEM[32 + v2]), MEM[32 + v1], MEM[64 + v1], MEM[96 + v1], address(MEM[64 + v2]));\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v9, v10 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v8), MEM[0 + v3] & 0xff, MEM[0 + v4], MEM[32 + v4]);\n    require(v9);\n    require(address(MEM[v11.data - 32]) == address(MEM[64 + v2]));\n    v0 = v12 = keccak256(v8, MEM[128 + v1], address(MEM[96 + v2]), MEM[160 + v1]);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v13, v14 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v12), MEM[32 + v3] & 0xff, MEM[64 + v4], MEM[96 + v4]);\n    require(v13);\n    require(address(MEM[MEM[64] - 32]) == address(MEM[96 + v2]));\n    require(!(0xff & _traded[v12]));\n    _traded[v12] = 0x1 | ~0xff & _traded[v12];\n    if (MEM[192 + v1] > 0x16345785d8a0000) {\n        MEM[192 + v1] = 0x16345785d8a0000;\n    }\n    if (MEM[224 + v1] > 0x16345785d8a0000) {\n        MEM[224 + v1] = 0x16345785d8a0000;\n    }\n    v0 = v15 = MEM[0 + v1];\n    v0 = v16 = _orderFills[v8];\n    v0 = v17 = 5016;\n    v18 = v19 = MEM[128 + v1];\n    while (1) {\n        v20 = v18 + v0;\n        v21 = v22 = 3571;\n        v23 = v24 = v20 >= v0;\n        if (v20 < v0) {\n            goto 0xdee0xf89B0x4a5;\n        }\n        if (v23) {\n            break;\n        }\n        require(v23);\n        v25 = address(MEM[32 + v0]);\n        _tokens[_feeAccount] = v20;\n        v26 = MEM[128 + v0];\n        v27 = v28 = v26 + _orderFills[v0] >= _orderFills[v0];\n        if (v26 + _orderFills[v0] >= _orderFills[v0]) {\n            v27 = v26 + _orderFills[v0] >= v26;\n            goto 0x6200x138eB0x194fB0x4a5;\n        }\n        require(v27);\n        _orderFills[v0] += v26;\n        v29 = address(MEM[64 + v0]);\n        _lastActiveTransaction[v29] = block.number;\n        v30 = address(MEM[96 + v0]);\n        _lastActiveTransaction[v30] = block.number;\n        v31 = v0;\n        return v31;\n        goto {'0x15caB0x4a5', '0x185aB0x4a5', '0x142cB0x4a5', '0x1740B0x4a5', '0x168cB0x4a5', '0x1841B0x4a5', '0x9160xf89B0x4a5', '0x174fB0x4a5', '0x1398B0x4a5', '0x1947B0x4a5', '0x182fB0x4a5'};\n        assert(v0);\n        v18 = v20 / v0;\n        continue;\n        require(v20 <= v0);\n        v32 = address(MEM[0 + v0]);\n        v33 = address(MEM[96 + v0]);\n        require(STORAGE[keccak256(v33, keccak256(v32, 2))] >= MEM[128 + v0]);\n        v0 = v34 = MEM[0 + v0];\n        v0 = v35 = 5164;\n        v20 = v36 = MEM[32 + v0];\n        v37 = v38 = 4;\n        assert(v0);\n        v39 = address(MEM[32 + v0]);\n        v40 = address(MEM[64 + v0]);\n        require(STORAGE[keccak256(v40, keccak256(v39, 2))] >= v20 / v0);\n        v0 = v41 = 5360;\n        v42 = address(MEM[0 + v0]);\n        v43 = address(MEM[96 + v0]);\n        v0 = v44 = STORAGE[keccak256(v43, keccak256(v42, 2))];\n        v45 = v46 = MEM[128 + v0];\n        v47 = address(MEM[0 + v0]);\n        v48 = address(MEM[64 + v0]);\n        STORAGE[keccak256(v48, keccak256(v47, 2))] = v20;\n        v0 = v49 = 5772;\n        v50 = address(MEM[0 + v0]);\n        v0 = v51 = _tokens[_feeAccount];\n        v0 = v52 = 0xde0b6b3a7640000;\n        v0 = v53 = 2326;\n        v20 = v54 = MEM[128 + v0];\n        v37 = v55 = 6;\n        goto 0x1422B0x4a5;\n        v56 = address(MEM[0 + v0]);\n        _tokens[_feeAccount] = v20;\n        v0 = v57 = 5967;\n        v58 = address(MEM[32 + v0]);\n        v59 = address(MEM[64 + v0]);\n        v0 = v60 = STORAGE[keccak256(v59, keccak256(v58, 2))];\n        v0 = v61 = MEM[0 + v0];\n        v0 = v62 = 5952;\n        v20 = v63 = MEM[32 + v0];\n        v37 = v64 = 4;\n        goto 0x1422B0x4a5;\n        assert(v0);\n        v45 = v65 = v20 / v0;\n        0x620(v45 <= v0);\n        v20 = v66 = v0 - v45;\n        goto {'0x14f0B0x4a5', '0x174fB0x4a5', '0x168cB0x4a5', '0x15caB0x4a5'};\n        v67 = address(MEM[0 + v0]);\n        v68 = address(MEM[96 + v0]);\n        STORAGE[keccak256(v68, keccak256(v67, 2))] = v66;\n        v0 = v69 = 5578;\n        v70 = address(MEM[0 + v0]);\n        v71 = address(MEM[64 + v0]);\n        v0 = v72 = STORAGE[keccak256(v71, keccak256(v70, 2))];\n        v0 = v73 = 0xde0b6b3a7640000;\n        v0 = v74 = 2326;\n        v20 = v75 = MEM[128 + v0];\n        v76 = v77 = 0xde0b6b3a7640000 - MEM[192 + v0];\n        goto 0xdcf0xf89B0x4a5;\n        v78 = address(MEM[32 + v0]);\n        v79 = address(MEM[64 + v0]);\n        STORAGE[keccak256(v79, keccak256(v78, 2))] = v20;\n        v0 = v80 = 6234;\n        v81 = address(MEM[32 + v0]);\n        v82 = address(MEM[96 + v0]);\n        v0 = v83 = STORAGE[keccak256(v82, keccak256(v81, 2))];\n        v0 = v84 = 0xde0b6b3a7640000;\n        v0 = v85 = MEM[0 + v0];\n        v0 = v86 = 6209;\n        v0 = v87 = 6191;\n        v20 = v88 = 0xde0b6b3a7640000 - MEM[224 + v0];\n        v37 = v89 = 1;\n        goto 0x1422B0x4a5;\n        v37 = v90 = 4;\n        v76 = v91 = MEM[(v37 << 5) + v0];\n        v20 *= v76;\n        v21 = v92 = 3571;\n        v23 = v93 = !v20;\n        if (v20) {\n            assert(v20);\n            v23 = v94 = v20 / v20 == v76;\n        }\n        assert(v0);\n        v20 = v20 / v0;\n        assert(v0);\n        v95 = address(MEM[32 + v0]);\n        v96 = address(MEM[96 + v0]);\n        STORAGE[keccak256(v96, keccak256(v95, 2))] = v20;\n        v0 = v97 = 6471;\n        v98 = address(MEM[32 + v0]);\n        v0 = v99 = _tokens[_feeAccount];\n        v0 = v100 = 0xde0b6b3a7640000;\n        v0 = v101 = MEM[0 + v0];\n        v0 = v102 = 6209;\n        v0 = v103 = 6191;\n        v20 = v104 = MEM[224 + v0];\n        v37 = 1;\n        goto 0x1422B0x4a5;\n        v23 = v20 >= v18;\n        goto 0x6200xf89B0x4a5;\n    }\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    0x620(_lastActiveTransaction[msg.sender] <= block.number);\n    require(block.number - _lastActiveTransaction[msg.sender] >= _inactivityReleasePeriod);\n    require(_tokens[msg.sender] >= varg1);\n    0x620(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v0);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v2);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction 0x620(uint256 varg0) private { \n    require(varg0);\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n        goto 0x6200xf61;\n    }\n    require(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x674763c) {\n            assert(bool);\n        } else if (0x13af4035 == v0) {\n            setOwner(address);\n        } else if (0x2295115b == v0) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == v0) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == v0) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x4b0bddd2 == v0) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == v0) {\n            tokens(address,address);\n        } else if (0x65e17c9d == v0) {\n            feeAccount();\n        } else if (0x83dbb27b == v0) {\n            invalidOrder(address);\n        } else if (0x893d20e8 == v0) {\n            getOwner();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa293d1e8 == v0) {\n            safeSub(uint256,uint256);\n        } else if (0xb12de559 == v0) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xd05c78da == v0) {\n            safeMul(uint256,uint256);\n        } else if (0xd0e30db0 == v0) {\n            deposit();\n        } else if (0xd5813323 == v0) {\n            traded(bytes32);\n        } else if (0xdd93c74a == v0) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xe6cb9013 == v0) {\n            safeAdd(uint256,uint256);\n        } else if (0xef343588 == v0) {\n            trade(uint256[8],address[4],uint8[2],bytes32[4]);\n        } else if (0xf31174ee == v0) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == v0) {\n            balanceOf(address,address);\n        }\n    }\n    require(!msg.value);\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 07:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x5]\nuint256 _inactivityReleasePeriod; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _traded; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0x9]\naddress _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x6] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n// Events\nSetOwner(address, address);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction assert(bool varg0) public nonPayable { \n    0x620(varg0);\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    0x620(_getOwner == msg.sender);\n    emit SetOwner(_getOwner, varg0);\n    _getOwner = varg0;\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    v2 = keccak256(address(this), varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v2]));\n    _withdrawn[v2] = 0x1 | ~0xff & _withdrawn[v2];\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v3, v4 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v2), varg4 & 0xff & 0xff, varg5, varg6);\n    require(v3);\n    require(address(v4) == varg2);\n    if (varg7 > 0xb1a2bc2ec50000) {\n        v5 = v6 = 0xb1a2bc2ec50000;\n    }\n    require(_tokens[varg2] >= varg1);\n    0x620(varg1 <= _tokens[varg2]);\n    _tokens[varg2] = _tokens[varg2] - varg1;\n    v7 = _SafeMul(varg1, v5);\n    assert(0xde0b6b3a7640000);\n    v8 = v9 = v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount];\n    if (v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount]) {\n        v8 = v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= v7 / 0xde0b6b3a7640000;\n        goto 0x6200x6b4B0x186;\n    }\n    require(v8);\n    _tokens[_feeAccount] += v7 / 0xde0b6b3a7640000;\n    v10 = _SafeMul(varg1, 0xde0b6b3a7640000 - v5);\n    assert(0xde0b6b3a7640000);\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v11, v12 = varg0.transfer(varg2, v10 / 0xde0b6b3a7640000).gas(msg.gas - 710);\n        require(v11);\n        require(v12);\n    } else {\n        v13 = varg2.call().value(v10 / 0xde0b6b3a7640000).gas(2300 * !(v10 / 0xde0b6b3a7640000));\n        require(v13);\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, v10 / 0xde0b6b3a7640000, _lastActiveTransaction[varg0]);\n    return 0;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    _lastActiveTransaction[msg.sender] = block.number;\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v1);\n    require(v2);\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    0x620(_getOwner == msg.sender);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction owner() public nonPayable { \n    return _getOwner;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    0x620(varg1 <= varg0);\n    return varg0 - varg1;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeMul(varg1, varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[0] = msg.sender;\n    MEM[32] = 0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction traded(bytes32 varg0) public nonPayable { \n    return 0xff & _traded[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg0 <= 0xf4240);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, varg0);\n    return v0;\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = MEM[64];\n    CALLDATACOPY(v1, 4, 256);\n    v0 = v2 = MEM[64];\n    CALLDATACOPY(v2, 260, 128);\n    v0 = v3 = MEM[64];\n    CALLDATACOPY(v3, 388, 64);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 452, 128);\n    v0 = v5 = 0;\n    v6 = v7 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v6 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v6);\n    require(_invalidOrder[address(MEM[64 + v2])] <= MEM[96 + v1]);\n    v0 = v8 = keccak256(address(this), address(MEM[0 + v2]), MEM[0 + v1], address(MEM[32 + v2]), MEM[32 + v1], MEM[64 + v1], MEM[96 + v1], address(MEM[64 + v2]));\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v9, v10 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v8), MEM[0 + v3] & 0xff, MEM[0 + v4], MEM[32 + v4]);\n    require(v9);\n    require(address(MEM[v11.data - 32]) == address(MEM[64 + v2]));\n    v0 = v12 = keccak256(v8, MEM[128 + v1], address(MEM[96 + v2]), MEM[160 + v1]);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v13, v14 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v12), MEM[32 + v3] & 0xff, MEM[64 + v4], MEM[96 + v4]);\n    require(v13);\n    require(address(MEM[MEM[64] - 32]) == address(MEM[96 + v2]));\n    require(!(0xff & _traded[v12]));\n    _traded[v12] = 0x1 | ~0xff & _traded[v12];\n    if (MEM[192 + v1] > 0x16345785d8a0000) {\n        MEM[192 + v1] = 0x16345785d8a0000;\n    }\n    if (MEM[224 + v1] > 0x16345785d8a0000) {\n        MEM[224 + v1] = 0x16345785d8a0000;\n    }\n    v0 = v15 = MEM[0 + v1];\n    v0 = v16 = _orderFills[v8];\n    v0 = v17 = 5016;\n    v18 = v19 = MEM[128 + v1];\n    while (1) {\n        v20 = v18 + v0;\n        v21 = v22 = 3571;\n        v23 = v24 = v20 >= v0;\n        if (v20 < v0) {\n            goto 0xdee0xf89B0x4a5;\n        }\n        if (v23) {\n            break;\n        }\n        require(v23);\n        v25 = address(MEM[32 + v0]);\n        _tokens[_feeAccount] = v20;\n        v26 = MEM[128 + v0];\n        v27 = v28 = v26 + _orderFills[v0] >= _orderFills[v0];\n        if (v26 + _orderFills[v0] >= _orderFills[v0]) {\n            v27 = v26 + _orderFills[v0] >= v26;\n            goto 0x6200x138eB0x194fB0x4a5;\n        }\n        require(v27);\n        _orderFills[v0] += v26;\n        v29 = address(MEM[64 + v0]);\n        _lastActiveTransaction[v29] = block.number;\n        v30 = address(MEM[96 + v0]);\n        _lastActiveTransaction[v30] = block.number;\n        v31 = v0;\n        return v31;\n        goto {'0x15caB0x4a5', '0x185aB0x4a5', '0x142cB0x4a5', '0x1740B0x4a5', '0x168cB0x4a5', '0x1841B0x4a5', '0x9160xf89B0x4a5', '0x174fB0x4a5', '0x1398B0x4a5', '0x1947B0x4a5', '0x182fB0x4a5'};\n        assert(v0);\n        v18 = v20 / v0;\n        continue;\n        require(v20 <= v0);\n        v32 = address(MEM[0 + v0]);\n        v33 = address(MEM[96 + v0]);\n        require(STORAGE[keccak256(v33, keccak256(v32, 2))] >= MEM[128 + v0]);\n        v0 = v34 = MEM[0 + v0];\n        v0 = v35 = 5164;\n        v20 = v36 = MEM[32 + v0];\n        v37 = v38 = 4;\n        assert(v0);\n        v39 = address(MEM[32 + v0]);\n        v40 = address(MEM[64 + v0]);\n        require(STORAGE[keccak256(v40, keccak256(v39, 2))] >= v20 / v0);\n        v0 = v41 = 5360;\n        v42 = address(MEM[0 + v0]);\n        v43 = address(MEM[96 + v0]);\n        v0 = v44 = STORAGE[keccak256(v43, keccak256(v42, 2))];\n        v45 = v46 = MEM[128 + v0];\n        v47 = address(MEM[0 + v0]);\n        v48 = address(MEM[64 + v0]);\n        STORAGE[keccak256(v48, keccak256(v47, 2))] = v20;\n        v0 = v49 = 5772;\n        v50 = address(MEM[0 + v0]);\n        v0 = v51 = _tokens[_feeAccount];\n        v0 = v52 = 0xde0b6b3a7640000;\n        v0 = v53 = 2326;\n        v20 = v54 = MEM[128 + v0];\n        v37 = v55 = 6;\n        goto 0x1422B0x4a5;\n        v56 = address(MEM[0 + v0]);\n        _tokens[_feeAccount] = v20;\n        v0 = v57 = 5967;\n        v58 = address(MEM[32 + v0]);\n        v59 = address(MEM[64 + v0]);\n        v0 = v60 = STORAGE[keccak256(v59, keccak256(v58, 2))];\n        v0 = v61 = MEM[0 + v0];\n        v0 = v62 = 5952;\n        v20 = v63 = MEM[32 + v0];\n        v37 = v64 = 4;\n        goto 0x1422B0x4a5;\n        assert(v0);\n        v45 = v65 = v20 / v0;\n        0x620(v45 <= v0);\n        v20 = v66 = v0 - v45;\n        goto {'0x14f0B0x4a5', '0x174fB0x4a5', '0x168cB0x4a5', '0x15caB0x4a5'};\n        v67 = address(MEM[0 + v0]);\n        v68 = address(MEM[96 + v0]);\n        STORAGE[keccak256(v68, keccak256(v67, 2))] = v66;\n        v0 = v69 = 5578;\n        v70 = address(MEM[0 + v0]);\n        v71 = address(MEM[64 + v0]);\n        v0 = v72 = STORAGE[keccak256(v71, keccak256(v70, 2))];\n        v0 = v73 = 0xde0b6b3a7640000;\n        v0 = v74 = 2326;\n        v20 = v75 = MEM[128 + v0];\n        v76 = v77 = 0xde0b6b3a7640000 - MEM[192 + v0];\n        goto 0xdcf0xf89B0x4a5;\n        v78 = address(MEM[32 + v0]);\n        v79 = address(MEM[64 + v0]);\n        STORAGE[keccak256(v79, keccak256(v78, 2))] = v20;\n        v0 = v80 = 6234;\n        v81 = address(MEM[32 + v0]);\n        v82 = address(MEM[96 + v0]);\n        v0 = v83 = STORAGE[keccak256(v82, keccak256(v81, 2))];\n        v0 = v84 = 0xde0b6b3a7640000;\n        v0 = v85 = MEM[0 + v0];\n        v0 = v86 = 6209;\n        v0 = v87 = 6191;\n        v20 = v88 = 0xde0b6b3a7640000 - MEM[224 + v0];\n        v37 = v89 = 1;\n        goto 0x1422B0x4a5;\n        v37 = v90 = 4;\n        v76 = v91 = MEM[(v37 << 5) + v0];\n        v20 *= v76;\n        v21 = v92 = 3571;\n        v23 = v93 = !v20;\n        if (v20) {\n            assert(v20);\n            v23 = v94 = v20 / v20 == v76;\n        }\n        assert(v0);\n        v20 = v20 / v0;\n        assert(v0);\n        v95 = address(MEM[32 + v0]);\n        v96 = address(MEM[96 + v0]);\n        STORAGE[keccak256(v96, keccak256(v95, 2))] = v20;\n        v0 = v97 = 6471;\n        v98 = address(MEM[32 + v0]);\n        v0 = v99 = _tokens[_feeAccount];\n        v0 = v100 = 0xde0b6b3a7640000;\n        v0 = v101 = MEM[0 + v0];\n        v0 = v102 = 6209;\n        v0 = v103 = 6191;\n        v20 = v104 = MEM[224 + v0];\n        v37 = 1;\n        goto 0x1422B0x4a5;\n        v23 = v20 >= v18;\n        goto 0x6200xf89B0x4a5;\n    }\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    0x620(_lastActiveTransaction[msg.sender] <= block.number);\n    require(block.number - _lastActiveTransaction[msg.sender] >= _inactivityReleasePeriod);\n    require(_tokens[msg.sender] >= varg1);\n    0x620(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v0);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v2);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction 0x620(uint256 varg0) private { \n    require(varg0);\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n        goto 0x6200xf61;\n    }\n    require(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x674763c) {\n            assert(bool);\n        } else if (0x13af4035 == v0) {\n            setOwner(address);\n        } else if (0x2295115b == v0) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == v0) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == v0) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x4b0bddd2 == v0) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == v0) {\n            tokens(address,address);\n        } else if (0x65e17c9d == v0) {\n            feeAccount();\n        } else if (0x83dbb27b == v0) {\n            invalidOrder(address);\n        } else if (0x893d20e8 == v0) {\n            getOwner();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa293d1e8 == v0) {\n            safeSub(uint256,uint256);\n        } else if (0xb12de559 == v0) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xd05c78da == v0) {\n            safeMul(uint256,uint256);\n        } else if (0xd0e30db0 == v0) {\n            deposit();\n        } else if (0xd5813323 == v0) {\n            traded(bytes32);\n        } else if (0xdd93c74a == v0) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xe6cb9013 == v0) {\n            safeAdd(uint256,uint256);\n        } else if (0xef343588 == v0) {\n            trade(uint256[8],address[4],uint8[2],bytes32[4]);\n        } else if (0xf31174ee == v0) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == v0) {\n            balanceOf(address,address);\n        }\n    }\n    require(!msg.value);\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 07:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _invalidOrder; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _tokens; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _admins; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _lastActiveTransaction; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x5]\nuint256 _inactivityReleasePeriod; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _traded; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _withdrawn; // STORAGE[0x9]\naddress _getOwner; // STORAGE[0x0] bytes 0 to 19\nuint160 _feeAccount; // STORAGE[0x6] bytes 0 to 19\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b]\n\n// Events\nSetOwner(address, address);\nWithdraw(address, address, uint256, uint256);\nDeposit(address, address, uint256, uint256);\n\nfunction assert(bool varg0) public nonPayable { \n    0x620(varg0);\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    0x620(_getOwner == msg.sender);\n    emit SetOwner(_getOwner, varg0);\n    _getOwner = varg0;\n}\n\nfunction adminWithdraw(address varg0, uint256 varg1, address varg2, uint256 varg3, uint8 varg4, bytes32 varg5, bytes32 varg6, uint256 varg7) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    v2 = keccak256(address(this), varg0, varg1, varg2, varg3);\n    require(!(0xff & _withdrawn[v2]));\n    _withdrawn[v2] = 0x1 | ~0xff & _withdrawn[v2];\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v3, v4 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v2), varg4 & 0xff & 0xff, varg5, varg6);\n    require(v3);\n    require(address(v4) == varg2);\n    if (varg7 > 0xb1a2bc2ec50000) {\n        v5 = v6 = 0xb1a2bc2ec50000;\n    }\n    require(_tokens[varg2] >= varg1);\n    0x620(varg1 <= _tokens[varg2]);\n    _tokens[varg2] = _tokens[varg2] - varg1;\n    v7 = _SafeMul(varg1, v5);\n    assert(0xde0b6b3a7640000);\n    v8 = v9 = v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount];\n    if (v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= _tokens[_feeAccount]) {\n        v8 = v7 / 0xde0b6b3a7640000 + _tokens[_feeAccount] >= v7 / 0xde0b6b3a7640000;\n        goto 0x6200x6b4B0x186;\n    }\n    require(v8);\n    _tokens[_feeAccount] += v7 / 0xde0b6b3a7640000;\n    v10 = _SafeMul(varg1, 0xde0b6b3a7640000 - v5);\n    assert(0xde0b6b3a7640000);\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v11, v12 = varg0.transfer(varg2, v10 / 0xde0b6b3a7640000).gas(msg.gas - 710);\n        require(v11);\n        require(v12);\n    } else {\n        v13 = varg2.call().value(v10 / 0xde0b6b3a7640000).gas(2300 * !(v10 / 0xde0b6b3a7640000));\n        require(v13);\n    }\n    _lastActiveTransaction[varg2] = block.number;\n    emit Withdraw(varg0, varg2, v10 / 0xde0b6b3a7640000, _lastActiveTransaction[varg0]);\n    return 0;\n}\n\nfunction lastActiveTransaction(address varg0) public nonPayable { \n    return _lastActiveTransaction[varg0];\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, _tokens[msg.sender]);\n    _tokens[msg.sender] = v0;\n    _lastActiveTransaction[msg.sender] = block.number;\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v1, v2 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas - 710);\n    require(v1);\n    require(v2);\n    emit Deposit(varg0, msg.sender, varg1, _tokens[msg.sender]);\n}\n\nfunction withdrawn(bytes32 varg0) public nonPayable { \n    return 0xff & _withdrawn[varg0];\n}\n\nfunction admins(address varg0) public nonPayable { \n    return 0xff & _admins[varg0];\n}\n\nfunction setAdmin(address varg0, bool varg1) public nonPayable { \n    0x620(_getOwner == msg.sender);\n    _admins[varg0] = varg1 | ~0xff & _admins[varg0];\n}\n\nfunction tokens(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction feeAccount() public nonPayable { \n    return _feeAccount;\n}\n\nfunction invalidOrder(address varg0) public nonPayable { \n    return _invalidOrder[varg0];\n}\n\nfunction getOwner() public nonPayable { \n    return _getOwner;\n}\n\nfunction owner() public nonPayable { \n    return _getOwner;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    0x620(varg1 <= varg0);\n    return varg0 - varg1;\n}\n\nfunction invalidateOrdersBefore(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg1 >= _invalidOrder[varg0]);\n    _invalidOrder[varg0] = varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeMul(varg1, varg0);\n    return v0;\n}\n\nfunction deposit() public payable { \n    v0 = _SafeAdd(msg.value, _deposit[msg.sender]);\n    _deposit[msg.sender] = v0;\n    _deposit[msg.sender] = block.number;\n    MEM[0] = msg.sender;\n    MEM[32] = 0xac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b;\n    emit Deposit(0, msg.sender, msg.value, _deposit[msg.sender]);\n}\n\nfunction traded(bytes32 varg0) public nonPayable { \n    return 0xff & _traded[varg0];\n}\n\nfunction setInactivityReleasePeriod(uint256 varg0) public nonPayable { \n    v0 = v1 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v0 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v0);\n    require(varg0 <= 0xf4240);\n    _inactivityReleasePeriod = varg0;\n    return 1;\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = _SafeAdd(varg1, varg0);\n    return v0;\n}\n\nfunction trade() public nonPayable { \n    v0 = v1 = MEM[64];\n    CALLDATACOPY(v1, 4, 256);\n    v0 = v2 = MEM[64];\n    CALLDATACOPY(v2, 260, 128);\n    v0 = v3 = MEM[64];\n    CALLDATACOPY(v3, 388, 64);\n    v0 = v4 = MEM[64];\n    CALLDATACOPY(v4, 452, 128);\n    v0 = v5 = 0;\n    v6 = v7 = _getOwner != msg.sender;\n    if (_getOwner != msg.sender) {\n        v6 = !(0xff & _admins[msg.sender]);\n    }\n    require(!v6);\n    require(_invalidOrder[address(MEM[64 + v2])] <= MEM[96 + v1]);\n    v0 = v8 = keccak256(address(this), address(MEM[0 + v2]), MEM[0 + v1], address(MEM[32 + v2]), MEM[32 + v1], MEM[64 + v1], MEM[96 + v1], address(MEM[64 + v2]));\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v9, v10 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v8), MEM[0 + v3] & 0xff, MEM[0 + v4], MEM[32 + v4]);\n    require(v9);\n    require(address(MEM[v11.data - 32]) == address(MEM[64 + v2]));\n    v0 = v12 = keccak256(v8, MEM[128 + v1], address(MEM[96 + v2]), MEM[160 + v1]);\n    MEM[MEM[64]] = 0;\n    MEM[32 + MEM[64]] = 0;\n    v13, v14 = ecrecover(keccak256('\\x19Ethereum Signed Message:\\n32', v12), MEM[32 + v3] & 0xff, MEM[64 + v4], MEM[96 + v4]);\n    require(v13);\n    require(address(MEM[MEM[64] - 32]) == address(MEM[96 + v2]));\n    require(!(0xff & _traded[v12]));\n    _traded[v12] = 0x1 | ~0xff & _traded[v12];\n    if (MEM[192 + v1] > 0x16345785d8a0000) {\n        MEM[192 + v1] = 0x16345785d8a0000;\n    }\n    if (MEM[224 + v1] > 0x16345785d8a0000) {\n        MEM[224 + v1] = 0x16345785d8a0000;\n    }\n    v0 = v15 = MEM[0 + v1];\n    v0 = v16 = _orderFills[v8];\n    v0 = v17 = 5016;\n    v18 = v19 = MEM[128 + v1];\n    while (1) {\n        v20 = v18 + v0;\n        v21 = v22 = 3571;\n        v23 = v24 = v20 >= v0;\n        if (v20 < v0) {\n            goto 0xdee0xf89B0x4a5;\n        }\n        if (v23) {\n            break;\n        }\n        require(v23);\n        v25 = address(MEM[32 + v0]);\n        _tokens[_feeAccount] = v20;\n        v26 = MEM[128 + v0];\n        v27 = v28 = v26 + _orderFills[v0] >= _orderFills[v0];\n        if (v26 + _orderFills[v0] >= _orderFills[v0]) {\n            v27 = v26 + _orderFills[v0] >= v26;\n            goto 0x6200x138eB0x194fB0x4a5;\n        }\n        require(v27);\n        _orderFills[v0] += v26;\n        v29 = address(MEM[64 + v0]);\n        _lastActiveTransaction[v29] = block.number;\n        v30 = address(MEM[96 + v0]);\n        _lastActiveTransaction[v30] = block.number;\n        v31 = v0;\n        return v31;\n        goto {'0x15caB0x4a5', '0x185aB0x4a5', '0x142cB0x4a5', '0x1740B0x4a5', '0x168cB0x4a5', '0x1841B0x4a5', '0x9160xf89B0x4a5', '0x174fB0x4a5', '0x1398B0x4a5', '0x1947B0x4a5', '0x182fB0x4a5'};\n        assert(v0);\n        v18 = v20 / v0;\n        continue;\n        require(v20 <= v0);\n        v32 = address(MEM[0 + v0]);\n        v33 = address(MEM[96 + v0]);\n        require(STORAGE[keccak256(v33, keccak256(v32, 2))] >= MEM[128 + v0]);\n        v0 = v34 = MEM[0 + v0];\n        v0 = v35 = 5164;\n        v20 = v36 = MEM[32 + v0];\n        v37 = v38 = 4;\n        assert(v0);\n        v39 = address(MEM[32 + v0]);\n        v40 = address(MEM[64 + v0]);\n        require(STORAGE[keccak256(v40, keccak256(v39, 2))] >= v20 / v0);\n        v0 = v41 = 5360;\n        v42 = address(MEM[0 + v0]);\n        v43 = address(MEM[96 + v0]);\n        v0 = v44 = STORAGE[keccak256(v43, keccak256(v42, 2))];\n        v45 = v46 = MEM[128 + v0];\n        v47 = address(MEM[0 + v0]);\n        v48 = address(MEM[64 + v0]);\n        STORAGE[keccak256(v48, keccak256(v47, 2))] = v20;\n        v0 = v49 = 5772;\n        v50 = address(MEM[0 + v0]);\n        v0 = v51 = _tokens[_feeAccount];\n        v0 = v52 = 0xde0b6b3a7640000;\n        v0 = v53 = 2326;\n        v20 = v54 = MEM[128 + v0];\n        v37 = v55 = 6;\n        goto 0x1422B0x4a5;\n        v56 = address(MEM[0 + v0]);\n        _tokens[_feeAccount] = v20;\n        v0 = v57 = 5967;\n        v58 = address(MEM[32 + v0]);\n        v59 = address(MEM[64 + v0]);\n        v0 = v60 = STORAGE[keccak256(v59, keccak256(v58, 2))];\n        v0 = v61 = MEM[0 + v0];\n        v0 = v62 = 5952;\n        v20 = v63 = MEM[32 + v0];\n        v37 = v64 = 4;\n        goto 0x1422B0x4a5;\n        assert(v0);\n        v45 = v65 = v20 / v0;\n        0x620(v45 <= v0);\n        v20 = v66 = v0 - v45;\n        goto {'0x14f0B0x4a5', '0x174fB0x4a5', '0x168cB0x4a5', '0x15caB0x4a5'};\n        v67 = address(MEM[0 + v0]);\n        v68 = address(MEM[96 + v0]);\n        STORAGE[keccak256(v68, keccak256(v67, 2))] = v66;\n        v0 = v69 = 5578;\n        v70 = address(MEM[0 + v0]);\n        v71 = address(MEM[64 + v0]);\n        v0 = v72 = STORAGE[keccak256(v71, keccak256(v70, 2))];\n        v0 = v73 = 0xde0b6b3a7640000;\n        v0 = v74 = 2326;\n        v20 = v75 = MEM[128 + v0];\n        v76 = v77 = 0xde0b6b3a7640000 - MEM[192 + v0];\n        goto 0xdcf0xf89B0x4a5;\n        v78 = address(MEM[32 + v0]);\n        v79 = address(MEM[64 + v0]);\n        STORAGE[keccak256(v79, keccak256(v78, 2))] = v20;\n        v0 = v80 = 6234;\n        v81 = address(MEM[32 + v0]);\n        v82 = address(MEM[96 + v0]);\n        v0 = v83 = STORAGE[keccak256(v82, keccak256(v81, 2))];\n        v0 = v84 = 0xde0b6b3a7640000;\n        v0 = v85 = MEM[0 + v0];\n        v0 = v86 = 6209;\n        v0 = v87 = 6191;\n        v20 = v88 = 0xde0b6b3a7640000 - MEM[224 + v0];\n        v37 = v89 = 1;\n        goto 0x1422B0x4a5;\n        v37 = v90 = 4;\n        v76 = v91 = MEM[(v37 << 5) + v0];\n        v20 *= v76;\n        v21 = v92 = 3571;\n        v23 = v93 = !v20;\n        if (v20) {\n            assert(v20);\n            v23 = v94 = v20 / v20 == v76;\n        }\n        assert(v0);\n        v20 = v20 / v0;\n        assert(v0);\n        v95 = address(MEM[32 + v0]);\n        v96 = address(MEM[96 + v0]);\n        STORAGE[keccak256(v96, keccak256(v95, 2))] = v20;\n        v0 = v97 = 6471;\n        v98 = address(MEM[32 + v0]);\n        v0 = v99 = _tokens[_feeAccount];\n        v0 = v100 = 0xde0b6b3a7640000;\n        v0 = v101 = MEM[0 + v0];\n        v0 = v102 = 6209;\n        v0 = v103 = 6191;\n        v20 = v104 = MEM[224 + v0];\n        v37 = 1;\n        goto 0x1422B0x4a5;\n        v23 = v20 >= v18;\n        goto 0x6200xf89B0x4a5;\n    }\n}\n\nfunction inactivityReleasePeriod() public nonPayable { \n    return _inactivityReleasePeriod;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    0x620(_lastActiveTransaction[msg.sender] <= block.number);\n    require(block.number - _lastActiveTransaction[msg.sender] >= _inactivityReleasePeriod);\n    require(_tokens[msg.sender] >= varg1);\n    0x620(varg1 <= _tokens[msg.sender]);\n    _tokens[msg.sender] = _tokens[msg.sender] - varg1;\n    if (varg0) {\n        MEM[32 + MEM[64]] = 0;\n        require(varg0.code.size);\n        v0, v1 = varg0.transfer(msg.sender, varg1).gas(msg.gas - 710);\n        require(v0);\n        require(v1);\n    } else {\n        v2 = msg.sender.call().value(varg1).gas(2300 * !varg1);\n        require(v2);\n    }\n    emit Withdraw(varg0, msg.sender, varg1, _tokens[msg.sender]);\n    return 0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    return _orderFills[varg0];\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _tokens[varg1];\n}\n\nfunction 0x620(uint256 varg0) private { \n    require(varg0);\n    return ;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n        goto 0x6200xf61;\n    }\n    require(v2);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x674763c) {\n            assert(bool);\n        } else if (0x13af4035 == v0) {\n            setOwner(address);\n        } else if (0x2295115b == v0) {\n            adminWithdraw(address,uint256,address,uint256,uint8,bytes32,bytes32,uint256);\n        } else if (0x254dcfe2 == v0) {\n            lastActiveTransaction(address);\n        } else if (0x338b5dea == v0) {\n            depositToken(address,uint256);\n        } else if (0x3823d66c == v0) {\n            withdrawn(bytes32);\n        } else if (0x429b62e5 == v0) {\n            admins(address);\n        } else if (0x4b0bddd2 == v0) {\n            setAdmin(address,bool);\n        } else if (0x508493bc == v0) {\n            tokens(address,address);\n        } else if (0x65e17c9d == v0) {\n            feeAccount();\n        } else if (0x83dbb27b == v0) {\n            invalidOrder(address);\n        } else if (0x893d20e8 == v0) {\n            getOwner();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xa293d1e8 == v0) {\n            safeSub(uint256,uint256);\n        } else if (0xb12de559 == v0) {\n            invalidateOrdersBefore(address,uint256);\n        } else if (0xd05c78da == v0) {\n            safeMul(uint256,uint256);\n        } else if (0xd0e30db0 == v0) {\n            deposit();\n        } else if (0xd5813323 == v0) {\n            traded(bytes32);\n        } else if (0xdd93c74a == v0) {\n            setInactivityReleasePeriod(uint256);\n        } else if (0xe6cb9013 == v0) {\n            safeAdd(uint256,uint256);\n        } else if (0xef343588 == v0) {\n            trade(uint256[8],address[4],uint8[2],bytes32[4]);\n        } else if (0xf31174ee == v0) {\n            inactivityReleasePeriod();\n        } else if (0xf3fef3a3 == v0) {\n            withdraw(address,uint256);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else if (0xf7888aec == v0) {\n            balanceOf(address,address);\n        }\n    }\n    require(!msg.value);\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 22.510101556777954,
	"usage": {
		"completion_tokens": 465,
		"prompt_tokens": 5681,
		"total_tokens": 6146
	}
}