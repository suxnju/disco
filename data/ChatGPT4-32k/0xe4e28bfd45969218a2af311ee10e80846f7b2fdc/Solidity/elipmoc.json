{
	"address": "0xe4e28bfd45969218a2af311ee10e80846f7b2fdc",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code you provided, the following is the Solidity contract code:\n\n```solidity\npragma solidity ^0.8.7;\n\ncontract Contract {\n    uint256 private _duration;\n    uint256 private _hardCap;\n    uint256 private _raised;\n    uint256 private _bonus;\n    uint256 private _start;\n    uint256 private _tokensPerEther;\n    mapping (address => uint256) private _balanceOf;\n    address private _admin1;\n    address private _admin2;\n    address private _admin3;\n    address private _benefit;\n    address private stor_9_0_19;\n    address private _tokenAddress;\n\n    event Investing(address indexed investor, uint256 value, uint256 tokens, uint256 bonusTokens);\n    event Raise(address indexed beneficiary, uint256 value);\n\n    function admin2() public view returns (address) { \n        return _admin2;\n    }\n\n    function duration() public view returns (uint256) { \n        return _duration;\n    }\n\n    function admin1() public view returns (address) { \n        return _admin1;\n    }\n\n    function admin3() public view returns (address) { \n        return _admin3;\n    }\n\n    function benefit() public view returns (address) { \n        return _benefit;\n    }\n\n    function getFunds(uint256 _value) public { \n        require(msg.sender == _admin1 || msg.sender == _admin2 || msg.sender == _admin3, \"Permission denied\");\n        require(_benefit != address(0), \"Invalid beneficiary\");\n        require(_value <= address(this).balance, \"Insufficient balance\");\n        emit Raise(_benefit, _value);\n        (bool success, ) = _benefit.call{value: _value}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n    function setAdmin(address _newAdmin) public { \n        require(msg.sender == _admin1 || msg.sender == _admin2 || msg.sender == _admin3, \"Permission denied\");\n        require(_newAdmin != _admin1 && _newAdmin != _admin2 && _newAdmin != _admin3, \"Invalid new admin\");\n        if (msg.sender == _admin1) {\n            _admin1 = _newAdmin;\n        } else if (msg.sender == _admin2) {\n            _admin2 = _newAdmin;\n        } else {\n            _admin3 = _newAdmin;\n        }\n    }\n\n    function balanceOf(address _owner) public view returns (uint256) { \n        return _balanceOf[_owner];\n    }\n\n    function bonus() public view returns (uint256) { \n        return _bonus;\n    }\n\n    function setBenefit(address _benefitAddress) public { \n        require(msg.sender == _admin1 || msg.sender == _admin2 || msg.sender == _admin3, \"Permission denied\");\n        _benefit = _benefitAddress;\n    }\n\n    function tokenAddress() public view returns (address) { \n        return _tokenAddress;\n    }\n\n    function start() public view returns (uint256) { \n        return _start;\n    }\n\n    function raised() public view returns (uint256) { \n        return _raised;\n    }\n\n    function tokensPerEther() public view returns (uint256) { \n        return _tokensPerEther;\n    }\n\n    function hardCap() public view returns (uint256) { \n        return _hardCap;\n    }\n\n    fallback() external payable { \n        require(_start > 0 && _start <= block.timestamp && _start + _duration > block.timestamp, \"Invalid time\");\n        require(_raised < _hardCap, \"Hard cap reached\");\n        require(address(stor_9_0_19).code.length > 0, \"Invalid contract\");\n        uint256 tokens = msg.value * _tokensPerEther;\n        uint256 bonusTokens = tokens * _bonus / 100;\n        (bool success, ) = stor_9_0_19.call(abi.encodeWithSignature(\"transferPresale(address,uint256)\", msg.sender, tokens + bonusTokens));\n        require(success, \"Transfer failed\");\n        _raised += msg.value;\n        _balanceOf[msg.sender] += msg.value;\n        emit Investing(msg.sender, msg.value, tokens, bonusTokens);\n    }\n}\n```\n\nPlease note that the solidity version and the pragma directive can be adjusted according to your project requirements. Also, the actual contract name and the function names can be renamed as per your needs. The provided contract is a simplified version of the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701460047,
	"id": "chatcmpl-8R3lvc3u1xPMYv9vME8KErnyfcsT9",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 02:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _duration; // STORAGE[0x3]\nuint256 _hardCap; // STORAGE[0x4]\nuint256 _raised; // STORAGE[0x5]\nuint256 _bonus; // STORAGE[0x6]\nuint256 _start; // STORAGE[0x8]\nuint256 _tokensPerEther; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xc]\naddress _admin1; // STORAGE[0x0] bytes 0 to 19\naddress _admin2; // STORAGE[0x1] bytes 0 to 19\naddress _admin3; // STORAGE[0x2] bytes 0 to 19\naddress _benefit; // STORAGE[0x7] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\nuint160 _tokenAddress; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nInvesting(address, uint256, uint256, uint256);\nRaise(address, uint256);\n\nfunction admin2() public nonPayable { \n    return _admin2;\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction admin1() public nonPayable { \n    return _admin1;\n}\n\nfunction admin3() public nonPayable { \n    return _admin3;\n}\n\nfunction benefit() public nonPayable { \n    return _benefit;\n}\n\nfunction getFunds(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == _admin3;\n    }\n    require(v0);\n    require(_benefit != 0);\n    require(varg0 <= (address(this)).balance);\n    emit Raise(_benefit, varg0);\n    v4 = _benefit.call().value(varg0).gas(!varg0 * 2300);\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = msg.sender == _admin3;\n    }\n    require(v0);\n    require(varg0 != _admin1);\n    require(varg0 != _admin2);\n    require(varg0 != _admin3);\n    if (_admin1 != msg.sender) {\n        if (_admin2 != msg.sender) {\n            if (_admin3 == msg.sender) {\n                _admin3 = varg0;\n            }\n        } else {\n            _admin2 = varg0;\n        }\n    } else {\n        _admin1 = varg0;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction setBenefit(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == _admin3;\n    }\n    require(v0);\n    _benefit = varg0;\n}\n\nfunction tokenAddress() public nonPayable { \n    return _tokenAddress;\n}\n\nfunction start() public nonPayable { \n    return _start;\n}\n\nfunction raised() public nonPayable { \n    return _raised;\n}\n\nfunction tokensPerEther() public nonPayable { \n    return _tokensPerEther;\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction fallback() public payable { \n    require(_start > 0);\n    require(_start <= block.timestamp);\n    require(_start + _duration > block.timestamp);\n    require(_raised < _hardCap);\n    require(stor_9_0_19.code.size);\n    v0 = stor_9_0_19.transferPresale(msg.sender, msg.value * _tokensPerEther + msg.value * _tokensPerEther * _bonus / 100).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    _raised = _raised + msg.value;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    emit Investing(msg.sender, msg.value, msg.value * _tokensPerEther, msg.value * _tokensPerEther + msg.value * _tokensPerEther * _bonus / 100);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6a8f8a2 == function_selector) {\n            admin2();\n        } else if (0xfb5a6b4 == function_selector) {\n            duration();\n        } else if (0x115976c4 == function_selector) {\n            admin1();\n        } else if (0x1de46a78 == function_selector) {\n            admin3();\n        } else if (0x2e5113b7 == function_selector) {\n            benefit();\n        } else if (0x3e721015 == function_selector) {\n            getFunds(uint256);\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x93f63e70 == function_selector) {\n            setBenefit(address);\n        } else if (0x9d76ea58 == function_selector) {\n            tokenAddress();\n        } else if (0xbe9a6555 == function_selector) {\n            start();\n        } else if (0xf0ea4bfc == function_selector) {\n            raised();\n        } else if (0xf856d605 == function_selector) {\n            tokensPerEther();\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 02:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _duration; // STORAGE[0x3]\nuint256 _hardCap; // STORAGE[0x4]\nuint256 _raised; // STORAGE[0x5]\nuint256 _bonus; // STORAGE[0x6]\nuint256 _start; // STORAGE[0x8]\nuint256 _tokensPerEther; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xc]\naddress _admin1; // STORAGE[0x0] bytes 0 to 19\naddress _admin2; // STORAGE[0x1] bytes 0 to 19\naddress _admin3; // STORAGE[0x2] bytes 0 to 19\naddress _benefit; // STORAGE[0x7] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\nuint160 _tokenAddress; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nInvesting(address, uint256, uint256, uint256);\nRaise(address, uint256);\n\nfunction admin2() public nonPayable { \n    return _admin2;\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction admin1() public nonPayable { \n    return _admin1;\n}\n\nfunction admin3() public nonPayable { \n    return _admin3;\n}\n\nfunction benefit() public nonPayable { \n    return _benefit;\n}\n\nfunction getFunds(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == _admin3;\n    }\n    require(v0);\n    require(_benefit != 0);\n    require(varg0 <= (address(this)).balance);\n    emit Raise(_benefit, varg0);\n    v4 = _benefit.call().value(varg0).gas(!varg0 * 2300);\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = msg.sender == _admin3;\n    }\n    require(v0);\n    require(varg0 != _admin1);\n    require(varg0 != _admin2);\n    require(varg0 != _admin3);\n    if (_admin1 != msg.sender) {\n        if (_admin2 != msg.sender) {\n            if (_admin3 == msg.sender) {\n                _admin3 = varg0;\n            }\n        } else {\n            _admin2 = varg0;\n        }\n    } else {\n        _admin1 = varg0;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction setBenefit(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == _admin3;\n    }\n    require(v0);\n    _benefit = varg0;\n}\n\nfunction tokenAddress() public nonPayable { \n    return _tokenAddress;\n}\n\nfunction start() public nonPayable { \n    return _start;\n}\n\nfunction raised() public nonPayable { \n    return _raised;\n}\n\nfunction tokensPerEther() public nonPayable { \n    return _tokensPerEther;\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction fallback() public payable { \n    require(_start > 0);\n    require(_start <= block.timestamp);\n    require(_start + _duration > block.timestamp);\n    require(_raised < _hardCap);\n    require(stor_9_0_19.code.size);\n    v0 = stor_9_0_19.transferPresale(msg.sender, msg.value * _tokensPerEther + msg.value * _tokensPerEther * _bonus / 100).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    _raised = _raised + msg.value;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    emit Investing(msg.sender, msg.value, msg.value * _tokensPerEther, msg.value * _tokensPerEther + msg.value * _tokensPerEther * _bonus / 100);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6a8f8a2 == function_selector) {\n            admin2();\n        } else if (0xfb5a6b4 == function_selector) {\n            duration();\n        } else if (0x115976c4 == function_selector) {\n            admin1();\n        } else if (0x1de46a78 == function_selector) {\n            admin3();\n        } else if (0x2e5113b7 == function_selector) {\n            benefit();\n        } else if (0x3e721015 == function_selector) {\n            getFunds(uint256);\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x93f63e70 == function_selector) {\n            setBenefit(address);\n        } else if (0x9d76ea58 == function_selector) {\n            tokenAddress();\n        } else if (0xbe9a6555 == function_selector) {\n            start();\n        } else if (0xf0ea4bfc == function_selector) {\n            raised();\n        } else if (0xf856d605 == function_selector) {\n            tokensPerEther();\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 02:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _duration; // STORAGE[0x3]\nuint256 _hardCap; // STORAGE[0x4]\nuint256 _raised; // STORAGE[0x5]\nuint256 _bonus; // STORAGE[0x6]\nuint256 _start; // STORAGE[0x8]\nuint256 _tokensPerEther; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xc]\naddress _admin1; // STORAGE[0x0] bytes 0 to 19\naddress _admin2; // STORAGE[0x1] bytes 0 to 19\naddress _admin3; // STORAGE[0x2] bytes 0 to 19\naddress _benefit; // STORAGE[0x7] bytes 0 to 19\naddress stor_9_0_19; // STORAGE[0x9] bytes 0 to 19\nuint160 _tokenAddress; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nInvesting(address, uint256, uint256, uint256);\nRaise(address, uint256);\n\nfunction admin2() public nonPayable { \n    return _admin2;\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction admin1() public nonPayable { \n    return _admin1;\n}\n\nfunction admin3() public nonPayable { \n    return _admin3;\n}\n\nfunction benefit() public nonPayable { \n    return _benefit;\n}\n\nfunction getFunds(uint256 varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == _admin3;\n    }\n    require(v0);\n    require(_benefit != 0);\n    require(varg0 <= (address(this)).balance);\n    emit Raise(_benefit, varg0);\n    v4 = _benefit.call().value(varg0).gas(!varg0 * 2300);\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = msg.sender == _admin3;\n    }\n    require(v0);\n    require(varg0 != _admin1);\n    require(varg0 != _admin2);\n    require(varg0 != _admin3);\n    if (_admin1 != msg.sender) {\n        if (_admin2 != msg.sender) {\n            if (_admin3 == msg.sender) {\n                _admin3 = varg0;\n            }\n        } else {\n            _admin2 = varg0;\n        }\n    } else {\n        _admin1 = varg0;\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction setBenefit(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _admin1;\n    if (msg.sender != _admin1) {\n        v0 = v2 = msg.sender == _admin2;\n    }\n    if (!v0) {\n        v0 = v3 = msg.sender == _admin3;\n    }\n    require(v0);\n    _benefit = varg0;\n}\n\nfunction tokenAddress() public nonPayable { \n    return _tokenAddress;\n}\n\nfunction start() public nonPayable { \n    return _start;\n}\n\nfunction raised() public nonPayable { \n    return _raised;\n}\n\nfunction tokensPerEther() public nonPayable { \n    return _tokensPerEther;\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction fallback() public payable { \n    require(_start > 0);\n    require(_start <= block.timestamp);\n    require(_start + _duration > block.timestamp);\n    require(_raised < _hardCap);\n    require(stor_9_0_19.code.size);\n    v0 = stor_9_0_19.transferPresale(msg.sender, msg.value * _tokensPerEther + msg.value * _tokensPerEther * _bonus / 100).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    _raised = _raised + msg.value;\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    emit Investing(msg.sender, msg.value, msg.value * _tokensPerEther, msg.value * _tokensPerEther + msg.value * _tokensPerEther * _bonus / 100);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6a8f8a2 == function_selector) {\n            admin2();\n        } else if (0xfb5a6b4 == function_selector) {\n            duration();\n        } else if (0x115976c4 == function_selector) {\n            admin1();\n        } else if (0x1de46a78 == function_selector) {\n            admin3();\n        } else if (0x2e5113b7 == function_selector) {\n            benefit();\n        } else if (0x3e721015 == function_selector) {\n            getFunds(uint256);\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x93f63e70 == function_selector) {\n            setBenefit(address);\n        } else if (0x9d76ea58 == function_selector) {\n            tokenAddress();\n        } else if (0xbe9a6555 == function_selector) {\n            start();\n        } else if (0xf0ea4bfc == function_selector) {\n            raised();\n        } else if (0xf856d605 == function_selector) {\n            tokensPerEther();\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 48.309531927108765,
	"usage": {
		"completion_tokens": 943,
		"prompt_tokens": 1510,
		"total_tokens": 2453
	}
}