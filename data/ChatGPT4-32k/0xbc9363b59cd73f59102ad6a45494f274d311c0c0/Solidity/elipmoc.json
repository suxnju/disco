{
	"address": "0xbc9363b59cd73f59102ad6a45494f274d311c0c0",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.01 09:17 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _holds; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _fullfilled; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _sellPrice; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _toSell; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _watermark; // STORAGE[0x6]\nuint256 _total; // STORAGE[0x7]\nuint256 _decimals; // STORAGE[0x8]\nuint256[] _symbol; // STORAGE[0x9]\nuint256[] _name; // STORAGE[0xa]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_7_0_0; // STORAGE[0x7] bytes 0 to 0\nuint256 _pause; // STORAGE[0x0] bytes 20 to 20\n\n// Events\nINCOME(uint256);\nApproval(address, address, uint256);\nSELL_HOLDS(address, address, uint256, uint256);\nPAUSED();\nSTARTED();\nWITHDRAWAL(address, uint256);\nPRICE_SET(address, uint256, uint256, uint256);\nTransfer(address, address, uint256);\n\nfunction () public payable { \n    0x83e();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x160e(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(_holds[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_holds[v2] + varg0 > _holds[v1]);\n    v3 = address(varg2);\n    v4 = (_watermark - _fullfilled[v3]) * varg0;\n    v5 = address(varg1);\n    v6 = address(varg1);\n    v7 = address(varg2);\n    _fullfilled[v7] = _fullfilled[v7] - varg0;\n    v8 = address(varg1);\n    _fullfilled[v8] = _fullfilled[v8] + varg0;\n    v9 = address(varg1);\n    assert(_fullfilled[v9]);\n    v10 = address(varg1);\n    _fullfilled[v10] = _watermark - (_watermark - _fullfilled[v6]) * _fullfilled[v5] / _fullfilled[v9];\n    v11 = address(varg2).call().value(v4).gas(!v4 * 2300);\n    require(v11); // checks call status, propagates error data on error\n    emit Transfer(address(varg2), address(varg1), varg0);\n    v12 = address(varg2);\n    emit WITHDRAWAL(v12, v4);\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _total;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(!_pause);\n    require(_allowance[msg.sender] >= varg2);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x160e(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction total() public nonPayable { \n    return _total;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction buyFrom(address varg0) public payable { \n    require(!_pause);\n    require(_sellPrice[varg0] > 0);\n    assert(_sellPrice[varg0]);\n    v0 = v1 = msg.value / _sellPrice[varg0];\n    if (v1 >= _holds[varg0]) {\n        v0 = v2 = _holds[varg0];\n    }\n    if (v0 >= _toSell[varg0]) {\n        v0 = v3 = _toSell[varg0];\n    }\n    require(v0 > 0);\n    _toSell[varg0] = _toSell[varg0] - v0;\n    0x160e(v0, msg.sender, varg0);\n    v4 = varg0.call().value(msg.value).gas(!msg.value * 2300);\n    require(v4); // checks call status, propagates error data on error\n    emit SELL_HOLDS(varg0, msg.sender, v0, _sellPrice[varg0]);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _holds[varg0];\n}\n\nfunction bonus() public nonPayable { \n    return (_watermark - _fullfilled[msg.sender]) * _holds[msg.sender];\n}\n\nfunction pause() public nonPayable { \n    return _pause;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction toSell(address varg0) public nonPayable { \n    return _toSell[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(!_pause);\n    0x160e(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction setState(bool varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _pause = varg0;\n    if (!_pause) {\n        emit STARTED();\n    } else {\n        emit PAUSED();\n    }\n}\n\nfunction fullfilled(address varg0) public nonPayable { \n    return _fullfilled[varg0];\n}\n\nfunction holds(address varg0) public nonPayable { \n    return _holds[varg0];\n}\n\nfunction onIncome() public payable { \n    0x83e();\n}\n\nfunction withdrawal() public nonPayable { \n    require(!_pause);\n    if (_holds[msg.sender] != 0) {\n        _fullfilled[msg.sender] = _watermark;\n        v0 = msg.sender.call().value((_watermark - _fullfilled[msg.sender]) * _holds[msg.sender]).gas(!((_watermark - _fullfilled[msg.sender]) * _holds[msg.sender]) * 2300);\n        require(v0); // checks call status, propagates error data on error\n        emit WITHDRAWAL(msg.sender, (_watermark - _fullfilled[msg.sender]) * _holds[msg.sender]);\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction watermark() public nonPayable { \n    return _watermark;\n}\n\nfunction setPrice(uint256 varg0, uint256 varg1) public nonPayable { \n    _sellPrice[msg.sender] = varg0;\n    _sellPrice[msg.sender] = varg1;\n    emit PRICE_SET(msg.sender, _sellPrice[msg.sender], varg0, varg1);\n}\n\nfunction sellPrice(address varg0) public nonPayable { \n    return _sellPrice[varg0];\n}\n\nfunction 0x83e() private { \n    if (msg.value > 0) {\n        assert(stor_7_0_0);\n        _watermark = _watermark + msg.value / _total;\n        assert(_watermark * _total > _watermark);\n        emit INCOME(msg.value);\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (0x6fdde03 == v0) {\n            name();\n        } else if (0x95ea7b3 == v0) {\n            approve(address,uint256);\n        } else if (0x13af4035 == v0) {\n            setOwner(address);\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x23b872dd == v0) {\n            transferFrom(address,address,uint256);\n        } else if (0x2ddbd13a == v0) {\n            total();\n        } else if (0x313ce567 == v0) {\n            decimals();\n        } else if (0x691a3f64 == v0) {\n            buyFrom(address);\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x75b4d78c == v0) {\n            bonus();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0x92c51d3a == v0) {\n            toSell(address);\n        } else if (0x95d89b41 == v0) {\n            symbol();\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xac9f0222 == v0) {\n            setState(bool);\n        } else if (0xba548298 == v0) {\n            fullfilled(address);\n        } else if (0xc3d073ff == v0) {\n            holds(address);\n        } else if (0xd47c0fb0 == v0) {\n            onIncome();\n        } else if (0xd4e93292 == v0) {\n            withdrawal();\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xf13dc2e2 == v0) {\n            watermark();\n        } else if (0xf7d97577 == v0) {\n            setPrice(uint256,uint256);\n        } else if (0xfcd393b9 == v0) {\n            sellPrice(address);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"status": "Connection error."
}