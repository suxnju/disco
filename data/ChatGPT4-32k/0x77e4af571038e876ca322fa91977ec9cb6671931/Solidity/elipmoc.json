{
	"address": "0x77e4af571038e876ca322fa91977ec9cb6671931",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity version of the given decompiled code:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) private _checkInvestments;\n    mapping (address => uint256) private _checkWithdrawals;\n    mapping (address => uint256) private _checkReferral;\n    uint256 private _step;\n    uint256 private _minimum;\n    uint256 private _stakingRequirement;\n    address private _ownerWallet;\n    address private _owner;\n    \n    event Invest(address indexed from, uint256 value);\n    event Withdraw(address indexed from, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Bounty(address indexed from, uint256 value);\n\n    function withdraw() public {\n        require(_checkWithdrawals[msg.sender] > 0, \"Invalid withdrawal request\");\n        uint256 amount = _checkWithdrawals[msg.sender];\n        _checkWithdrawals[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function minimum() public view returns (uint256) {\n        return _minimum;\n    }\n\n    function stakingRequirement() public view returns (uint256) {\n        return _stakingRequirement;\n    }\n\n    function transferOwnership(address newOwner, address newOwnerWallet) public {\n        require(msg.sender == _owner, \"Caller is not the owner\");\n        require(newOwner != address(0), \"New owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n        _ownerWallet = newOwnerWallet;\n    }\n\n    function checkInvestments(address account) public view returns (uint256) {\n        return _checkInvestments[account];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function ownerWallet() public view returns (address) {\n        return _ownerWallet;\n    }\n\n    function bounty() public {\n        require(_checkReferral[msg.sender] >= _minimum, \"Insufficient referral balance\");\n        if (_checkReferral[msg.sender] < address(this).balance) {\n            _checkReferral[msg.sender] = 0;\n            payable(msg.sender).transfer(_checkReferral[msg.sender]);\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n\n    function checkWithdrawals(address account) public view returns (uint256) {\n        return _checkWithdrawals[account];\n    }\n\n    function checkBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function step() public view returns (uint256) {\n        return _step;\n    }\n\n    function buy(address to) public payable {\n        require(msg.value >= _minimum, \"Insufficient value sent\");\n        _checkInvestments[to] += msg.value;\n        emit Invest(msg.sender, msg.value);\n    }\n\n    function getBalance(address account) public view returns (uint256) {\n        return account.balance;\n    }\n\n    function checkReferral(address account) public view returns (uint256) {\n        return _checkReferral[account];\n    }\n\n    fallback() external payable {\n        buy(msg.sender);\n    }\n}\n```\n\nImportant Notes: \n\n- This code does not include the conversion of private functions `0x284`, `0x468`, `0x701`, `0x7bf`, and `_SafeAdd`. These functions seem to be implementing some complex operations that are not clear from the decompiled code. \n- The `__function_selector__` function was also not included. In Solidity, function selectors are generated automatically and do not need to be implemented manually.\n- Always remember to add the correct SPDX-License-Identifier at the top of your contracts.\n- Always use the latest Solidity version which is compatible with your code to benefit from the latest security and language features. In this case, I've used `0.8.0` but feel free to change as per your needs.\n- The original decompiled code uses storage slots directly, which is not common in Solidity. I've assumed that these slots correspond to state variables and used standard Solidity syntax to declare and manipulate these variables.\n- This code is not tested. Please test it thoroughly before using it in production.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469256,
	"id": "chatcmpl-8R6ASkj1Rq09cmxqFueSX2kmOAz4i",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 23:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x3]\nuint256 _step; // STORAGE[0x4]\nuint256 _minimum; // STORAGE[0x5]\nuint256 _stakingRequirement; // STORAGE[0x6]\naddress _ownerWallet; // STORAGE[0x7] bytes 0 to 19\naddress _owner; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\n\nfunction withdraw() public nonPayable { \n    v0 = 0x468();\n    return v0;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if (_checkReferral[msg.sender] < this.balance) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(2300 * !_checkReferral[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0x701(msg.sender);\n    return v0;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction buy(address varg0) public payable { \n    0x284(varg0);\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0x701(varg0);\n    return v0;\n}\n\nfunction 0x284(uint256 varg0) private { \n    require(msg.value >= _minimum);\n    v0 = v1 = msg.sender;\n    v2 = !address(varg0);\n    v3 = v4 = address(varg0);\n    if (address(varg0)) {\n        v3 = v5 = address(varg0) != address(v1);\n    }\n    if (v3) {\n        v6 = address(varg0);\n        v3 = v7 = _checkInvestments[v6] >= _stakingRequirement;\n    }\n    if (v3) {\n        v8 = v9 = 823;\n        v10 = v11 = 786;\n        v12 = v13 = 100;\n        v14 = v15 = 0x7bf(5, msg.value);\n    }\n    assert(v12);\n    goto {'0x312', '0x3e6'};\n    v16 = address(v0);\n    v17 = _SafeAdd(v14 / v12, _checkReferral[v16]);\n    v18 = address(v0);\n    _checkReferral[v18] = v17;\n    v19 = v0.call().value(v14 / v12).gas(v8 * !(v14 / v12));\n    require(v19); // checks call status, propagates error data on error\n    emit Invest(msg.sender, msg.value);\n    return ;\n    if (_checkInvestments[msg.sender] > 0) {\n        v20 = 0x468();\n        if (v20) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    v21 = _SafeAdd(msg.value, _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = v21;\n    owner_1[msg.sender] = block.timestamp;\n    v0 = v22 = _ownerWallet;\n    v8 = v23 = 2300;\n    v10 = v24 = 998;\n    v12 = v25 = 100;\n    v14 = v26 = 0x7bf(5, msg.value);\n}\n\nfunction 0x468() private { \n    require(0 < owner_1[msg.sender]);\n    v0 = 0x701(msg.sender);\n    if (v0 >= this.balance) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            v3 = _SafeAdd(v0, _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = v3;\n            v4 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v4); // checks call status, propagates error data on error\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v5 = 1;\n    }\n    return v1;\n}\n\nfunction 0x701(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = v2 = 0;\n    v3 = v4 = 1850;\n    v5 = v6 = 60;\n    assert(owner_1[v0] <= block.timestamp);\n    v7 = block.timestamp - owner_1[v0];\n    while (!v5) {\n        assert(v5);\n        v8 = address(varg0);\n        assert(_checkWithdrawals[v8] <= v1);\n        return v1 - _checkWithdrawals[v8];\n        v1 = v7 / v5;\n        goto {'0x770', '0x788', '0x73a'};\n        v9 = address(varg0);\n        v3 = v10 = 1904;\n        v5 = v11 = 100;\n        v7 = v12 = 0x7bf(_step, _checkInvestments[v9]);\n        v3 = v13 = 1928;\n        v5 = v14 = 1440;\n        v7 = 0x7bf(v1, v1);\n    }\n}\n\nfunction 0x7bf(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x284(0);\n}\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc19f80e) {\n            checkReferral(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 23:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x3]\nuint256 _step; // STORAGE[0x4]\nuint256 _minimum; // STORAGE[0x5]\nuint256 _stakingRequirement; // STORAGE[0x6]\naddress _ownerWallet; // STORAGE[0x7] bytes 0 to 19\naddress _owner; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\n\nfunction withdraw() public nonPayable { \n    v0 = 0x468();\n    return v0;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if (_checkReferral[msg.sender] < this.balance) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(2300 * !_checkReferral[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0x701(msg.sender);\n    return v0;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction buy(address varg0) public payable { \n    0x284(varg0);\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0x701(varg0);\n    return v0;\n}\n\nfunction 0x284(uint256 varg0) private { \n    require(msg.value >= _minimum);\n    v0 = v1 = msg.sender;\n    v2 = !address(varg0);\n    v3 = v4 = address(varg0);\n    if (address(varg0)) {\n        v3 = v5 = address(varg0) != address(v1);\n    }\n    if (v3) {\n        v6 = address(varg0);\n        v3 = v7 = _checkInvestments[v6] >= _stakingRequirement;\n    }\n    if (v3) {\n        v8 = v9 = 823;\n        v10 = v11 = 786;\n        v12 = v13 = 100;\n        v14 = v15 = 0x7bf(5, msg.value);\n    }\n    assert(v12);\n    goto {'0x312', '0x3e6'};\n    v16 = address(v0);\n    v17 = _SafeAdd(v14 / v12, _checkReferral[v16]);\n    v18 = address(v0);\n    _checkReferral[v18] = v17;\n    v19 = v0.call().value(v14 / v12).gas(v8 * !(v14 / v12));\n    require(v19); // checks call status, propagates error data on error\n    emit Invest(msg.sender, msg.value);\n    return ;\n    if (_checkInvestments[msg.sender] > 0) {\n        v20 = 0x468();\n        if (v20) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    v21 = _SafeAdd(msg.value, _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = v21;\n    owner_1[msg.sender] = block.timestamp;\n    v0 = v22 = _ownerWallet;\n    v8 = v23 = 2300;\n    v10 = v24 = 998;\n    v12 = v25 = 100;\n    v14 = v26 = 0x7bf(5, msg.value);\n}\n\nfunction 0x468() private { \n    require(0 < owner_1[msg.sender]);\n    v0 = 0x701(msg.sender);\n    if (v0 >= this.balance) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            v3 = _SafeAdd(v0, _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = v3;\n            v4 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v4); // checks call status, propagates error data on error\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v5 = 1;\n    }\n    return v1;\n}\n\nfunction 0x701(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = v2 = 0;\n    v3 = v4 = 1850;\n    v5 = v6 = 60;\n    assert(owner_1[v0] <= block.timestamp);\n    v7 = block.timestamp - owner_1[v0];\n    while (!v5) {\n        assert(v5);\n        v8 = address(varg0);\n        assert(_checkWithdrawals[v8] <= v1);\n        return v1 - _checkWithdrawals[v8];\n        v1 = v7 / v5;\n        goto {'0x770', '0x788', '0x73a'};\n        v9 = address(varg0);\n        v3 = v10 = 1904;\n        v5 = v11 = 100;\n        v7 = v12 = 0x7bf(_step, _checkInvestments[v9]);\n        v3 = v13 = 1928;\n        v5 = v14 = 1440;\n        v7 = 0x7bf(v1, v1);\n    }\n}\n\nfunction 0x7bf(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x284(0);\n}\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc19f80e) {\n            checkReferral(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 23:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _checkInvestments; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _checkWithdrawals; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _checkReferral; // STORAGE[0x3]\nuint256 _step; // STORAGE[0x4]\nuint256 _minimum; // STORAGE[0x5]\nuint256 _stakingRequirement; // STORAGE[0x6]\naddress _ownerWallet; // STORAGE[0x7] bytes 0 to 19\naddress _owner; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nInvest(address, uint256);\nWithdraw(address, uint256);\nOwnershipTransferred(address, address);\nBounty(address, uint256);\n\nfunction withdraw() public nonPayable { \n    v0 = 0x468();\n    return v0;\n}\n\nfunction minimum() public nonPayable { \n    return _minimum;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction transferOwnership(address varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n    _ownerWallet = varg1;\n}\n\nfunction checkInvestments(address varg0) public nonPayable { \n    return _checkInvestments[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction ownerWallet() public nonPayable { \n    return _ownerWallet;\n}\n\nfunction bounty() public nonPayable { \n    if (_checkReferral[msg.sender] >= _minimum) {\n        if (_checkReferral[msg.sender] < this.balance) {\n            _checkReferral[msg.sender] = 0;\n            v0 = msg.sender.call().value(_checkReferral[msg.sender]).gas(2300 * !_checkReferral[msg.sender]);\n            require(v0); // checks call status, propagates error data on error\n            emit Bounty(msg.sender, _checkReferral[msg.sender]);\n        }\n    }\n}\n\nfunction checkWithdrawals(address varg0) public nonPayable { \n    return _checkWithdrawals[varg0];\n}\n\nfunction checkBalance() public nonPayable { \n    v0 = 0x701(msg.sender);\n    return v0;\n}\n\nfunction step() public nonPayable { \n    return _step;\n}\n\nfunction buy(address varg0) public payable { \n    0x284(varg0);\n}\n\nfunction getBalance(address varg0) public nonPayable { \n    v0 = 0x701(varg0);\n    return v0;\n}\n\nfunction 0x284(uint256 varg0) private { \n    require(msg.value >= _minimum);\n    v0 = v1 = msg.sender;\n    v2 = !address(varg0);\n    v3 = v4 = address(varg0);\n    if (address(varg0)) {\n        v3 = v5 = address(varg0) != address(v1);\n    }\n    if (v3) {\n        v6 = address(varg0);\n        v3 = v7 = _checkInvestments[v6] >= _stakingRequirement;\n    }\n    if (v3) {\n        v8 = v9 = 823;\n        v10 = v11 = 786;\n        v12 = v13 = 100;\n        v14 = v15 = 0x7bf(5, msg.value);\n    }\n    assert(v12);\n    goto {'0x312', '0x3e6'};\n    v16 = address(v0);\n    v17 = _SafeAdd(v14 / v12, _checkReferral[v16]);\n    v18 = address(v0);\n    _checkReferral[v18] = v17;\n    v19 = v0.call().value(v14 / v12).gas(v8 * !(v14 / v12));\n    require(v19); // checks call status, propagates error data on error\n    emit Invest(msg.sender, msg.value);\n    return ;\n    if (_checkInvestments[msg.sender] > 0) {\n        v20 = 0x468();\n        if (v20) {\n            _checkWithdrawals[msg.sender] = 0;\n        }\n    }\n    v21 = _SafeAdd(msg.value, _checkInvestments[msg.sender]);\n    _checkInvestments[msg.sender] = v21;\n    owner_1[msg.sender] = block.timestamp;\n    v0 = v22 = _ownerWallet;\n    v8 = v23 = 2300;\n    v10 = v24 = 998;\n    v12 = v25 = 100;\n    v14 = v26 = 0x7bf(5, msg.value);\n}\n\nfunction 0x468() private { \n    require(0 < owner_1[msg.sender]);\n    v0 = 0x701(msg.sender);\n    if (v0 >= this.balance) {\n        v1 = v2 = 0;\n    } else {\n        if (v0 > 0) {\n            v3 = _SafeAdd(v0, _checkWithdrawals[msg.sender]);\n            _checkWithdrawals[msg.sender] = v3;\n            v4 = msg.sender.call().value(v0).gas(2300 * !v0);\n            require(v4); // checks call status, propagates error data on error\n            emit Withdraw(msg.sender, v0);\n        }\n        v1 = v5 = 1;\n    }\n    return v1;\n}\n\nfunction 0x701(uint256 varg0) private { \n    v0 = address(varg0);\n    v1 = v2 = 0;\n    v3 = v4 = 1850;\n    v5 = v6 = 60;\n    assert(owner_1[v0] <= block.timestamp);\n    v7 = block.timestamp - owner_1[v0];\n    while (!v5) {\n        assert(v5);\n        v8 = address(varg0);\n        assert(_checkWithdrawals[v8] <= v1);\n        return v1 - _checkWithdrawals[v8];\n        v1 = v7 / v5;\n        goto {'0x770', '0x788', '0x73a'};\n        v9 = address(varg0);\n        v3 = v10 = 1904;\n        v5 = v11 = 100;\n        v7 = v12 = 0x7bf(_step, _checkInvestments[v9]);\n        v3 = v13 = 1928;\n        v5 = v14 = 1440;\n        v7 = 0x7bf(v1, v1);\n    }\n}\n\nfunction 0x7bf(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x284(0);\n}\n\nfunction checkReferral(address varg0) public nonPayable { \n    return _checkReferral[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc19f80e) {\n            checkReferral(address);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x52d6804d == function_selector) {\n            minimum();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x6d435421 == function_selector) {\n            transferOwnership(address,address);\n        } else if (0x835c1154 == function_selector) {\n            checkInvestments(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9335dcb7 == function_selector) {\n            ownerWallet();\n        } else if (0x943dfef1 == function_selector) {\n            bounty();\n        } else if (0x9d9fcc72 == function_selector) {\n            checkWithdrawals(address);\n        } else if (0xc71daccb == function_selector) {\n            checkBalance();\n        } else if (0xe25fe175 == function_selector) {\n            step();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xf8b2cb4f == function_selector) {\n            getBalance(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 37.92836856842041,
	"usage": {
		"completion_tokens": 889,
		"prompt_tokens": 2070,
		"total_tokens": 2959
	}
}