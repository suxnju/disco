{
	"address": "0x072b4b3008eb2177cce628123d24e75a8e34b9b0",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the pseudocode above, here's a version of the contract in Solidity:\n\n```solidity\npragma solidity ^0.6.1;\n\ncontract MultisigWallet {\n    event Deposit(address indexed sender, uint256 value);\n    event Submission(uint256 indexed transactionId);\n    event Confirmation(address indexed sender, uint256 indexed transactionId);\n    event Execution(uint256 indexed transactionId);\n    event ExecutionFailure(uint256 indexed transactionId);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint256 required);\n    event Revocation(address indexed sender, uint256 indexed transactionId);\n    event DailyLimitChange(uint256 dailyLimit);\n\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n    }\n\n    mapping (uint256 => Transaction) public transactions;\n    mapping (uint256 => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    address[] public owners;\n    uint256 public required;\n    uint256 public transactionCount;\n    uint256 public dailyLimit;\n    uint256 public lastDay;\n    uint256 public spentToday;\n\n    modifier onlyOwner {\n        require(isOwner[msg.sender]);\n        _;\n    }\n\n    modifier confirmed(uint256 transactionId) {\n        require(confirmations[transactionId][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(uint256 transactionId) {\n        require(!confirmations[transactionId][msg.sender]);\n        _;\n    }\n\n    modifier notExecuted(uint256 transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    // Constructor and other functions go here.\n\n    function submitTransaction(address destination, uint256 value, bytes memory data)\n        public\n        returns (uint256 transactionId)\n    {\n        // Implement submitTransaction here.\n    }\n\n    function confirmTransaction(uint256 transactionId)\n        public\n    {\n        // Implement confirmTransaction here.\n    }\n\n    function revokeConfirmation(uint256 transactionId)\n        public\n    {\n        // Implement revokeConfirmation here.\n    }\n\n    function executeTransaction(uint256 transactionId)\n        public\n    {\n        // Implement executeTransaction here.\n    }\n\n    function isConfirmed(uint256 transactionId, address owner)\n        public\n        view\n        returns (bool)\n    {\n        // Implement isConfirmed here.\n    }\n\n    function getConfirmationCount(uint256 transactionId)\n        public\n        view\n        returns (uint256 count)\n    {\n        // Implement getConfirmationCount here.\n    }\n\n    function getTransactionCount(bool pending, bool executed)\n        public\n        view\n        returns (uint256 count)\n    {\n        // Implement getTransactionCount here.\n    }\n\n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        // Implement getOwners here.\n    }\n\n    function getConfirmations(uint256 transactionId)\n        public\n        view\n        returns (address[] memory _confirmations)\n    {\n        // Implement getConfirmations here.\n    }\n\n    function getTransactionIds(uint256 from, uint256 to, bool pending, bool executed)\n        public\n        view\n        returns (uint256[] memory _transactionIds)\n    {\n        // Implement getTransactionIds here.\n    }\n}\n```\n\nPlease note that the actual implementation for each function is not provided in the pseudocode. Therefore, I've just defined the function signatures and used comments to indicate where the implementation would go.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471284,
	"id": "chatcmpl-8MuY8zIYSC22s1sQ7ooSSQwOK8Z2o",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n  dailyLimit is uint256 at storage 6\n  lastDay is uint256 at storage 7\n  spentToday is uint256 at storage 8\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return address(owners[_param1].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef dailyLimit(): # not payable\n  return dailyLimit\n\ndef lastDay(): # not payable\n  return lastDay\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\ndef spentToday(): # not payable\n  return spentToday\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeDailyLimit(uint256 _dailyLimit): # not payable\n  require caller == this.address\n  dailyLimit = _dailyLimit\n  log DailyLimitChange(uint256 dailyLimit=_dailyLimit)\n\ndef calcMaxWithdraw(): # not payable\n  if block.timestamp > lastDay + (24 * 3600):\n      return dailyLimit\n  if dailyLimit >= spentToday:\n      return (dailyLimit - spentToday)\n  else:\n      return 0\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _required <= owners.length\n  require _required\n  require owners.length\n  required = _required\n  log RequirementChange(uint256 required=_required)\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[address(owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  address(owners[owners.length].field_0) = owner\n  log OwnerAddition(address owner=owner)\n\ndef transactions(uint256 _param1): # not payable\n  mem[128] = stor0[_param1][2].field_0\n  idx = 128\n  s = 0\n  while stor0[_param1][2].length + 96 > idx:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[128 len stor0[_param1][2].length]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[newOwner] = 1\n      log OwnerRemoval(address owner=owner)\n      log OwnerAddition(address owner=newOwner)\n      stop\n  stor2[address(owner)] = 0\n  stor2[newOwner] = 1\n  log OwnerRemoval(address owner=owner)\n  log OwnerAddition(address owner=newOwner)\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      mem[(32 * owners.length) + 224 len floor32(owners.length)] = mem[160 len floor32(owners.length)]\n      return memory\n        from (32 * owners.length) + 160\n         len (96 * owners.length) + 64\n  mem[160] = address(owners.field_0)\n  idx = 160\n  s = 0\n  while (32 * owners.length) + 128 > idx:\n      mem[idx + 32] = address(owners[s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 224 len floor32(owners.length)] = mem[160 len floor32(owners.length)]\n  return Array(len=owners.length, data=mem[160 len floor32(owners.length)], mem[(32 * owners.length) + floor32(owners.length) + 224 len (32 * owners.length) - floor32(owners.length)]), \n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=owner)\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=owner)\n\ndef getConfirmations(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 288 len floor32(s)] = mem[(32 * owners.length) + 224 len floor32(s)]\n      return Array(len=s, data=mem[(32 * owners.length) + 224 len floor32(s)], mem[(32 * owners.length) + (32 * s) + floor32(s) + 288 len (32 * s) - floor32(s)]), \n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  mem[(64 * s) + 320 len floor32(s)] = mem[(32 * s) + 256 len floor32(s)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * transactionCount) + 192:\n      mem[(32 * transactionCount) + 192] = to - from\n      idx = from\n      while idx < to:\n          require idx < transactionCount\n          require idx - from < mem[(32 * transactionCount) + 192]\n          mem[(32 * transactionCount) + (32 * idx - from) + 224] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * transactionCount) + (32 * to - from) + 224] = 32\n      mem[(32 * transactionCount) + (32 * to - from) + 256] = mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * to - from) + 288 len floor32(mem[(32 * transactionCount) + 192])] = mem[(32 * transactionCount) + 224 len floor32(mem[(32 * transactionCount) + 192])]\n      return Array(len=mem[(32 * transactionCount) + 192], data=mem[(32 * transactionCount) + (32 * to - from) + 288 len 32 * mem[(32 * transactionCount) + 192]]), \n  mem[(32 * s) + 224] = to - from\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < to - from, None\n      mem[(32 * s) + (32 * idx - from) + 256] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * s) + (32 * to - from) + 256] = 32\n  mem[(32 * s) + (32 * to - from) + 288] = to - from, None\n  mem[(32 * s) + (32 * to - from) + 320 len floor32(to - from)] = mem[(32 * s) + 256 len floor32(to - from)]\n  return memory\n    from (32 * s) + (32 * to - from) + 256\n     len (32 * to - from, None) + 64\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n  if not stor0[transactionId][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[transactionId].field_256 <= dailyLimit:\n          if spentToday + stor0[transactionId].field_256 >= spentToday:\n              uint8(stor0[transactionId].field_768) = 1\n              spentToday += stor0[transactionId].field_256\n              mem[96] = stor0[transactionId][2].field_0\n              idx = 96\n              s = 0\n              while stor0[transactionId][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor0[transactionId][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[transactionId].field_0).mem[96 len 4] with:\n                 value stor0[transactionId].field_256 wei\n                   gas gas_remaining wei\n                  args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionId)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionId)\n                  uint8(stor0[transactionId].field_768) = 0\n                  spentToday -= stor0[transactionId].field_256\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n  if not stor0[transactionId][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[transactionId].field_256 <= dailyLimit:\n          if spentToday + stor0[transactionId].field_256 >= spentToday:\n              uint8(stor0[transactionId].field_768) = 1\n              spentToday += stor0[transactionId].field_256\n              mem[96] = stor0[transactionId][2].field_0\n              idx = 96\n              s = 0\n              while stor0[transactionId][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor0[transactionId][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[transactionId].field_0).mem[96 len 4] with:\n                 value stor0[transactionId].field_256 wei\n                   gas gas_remaining wei\n                  args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionId)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionId)\n                  uint8(stor0[transactionId].field_768) = 0\n                  spentToday -= stor0[transactionId].field_256\n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  if not stor0[stor5][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[stor5].field_256 <= dailyLimit:\n          if spentToday + stor0[stor5].field_256 >= spentToday:\n              uint8(stor0[stor5].field_768) = 1\n              spentToday += stor0[stor5].field_256\n              mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n              idx = ceil32(data.length) + 256\n              s = 0\n              while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n                  mem[idx + 32] = stor0[stor5][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n                 value stor0[stor5].field_256 wei\n                   gas gas_remaining wei\n                  args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionCount)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionCount)\n                  uint8(stor0[stor5].field_768) = 0\n                  spentToday -= stor0[stor5].field_256\n  return transactionCount\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n  dailyLimit is uint256 at storage 6\n  lastDay is uint256 at storage 7\n  spentToday is uint256 at storage 8\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return address(owners[_param1].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef dailyLimit(): # not payable\n  return dailyLimit\n\ndef lastDay(): # not payable\n  return lastDay\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\ndef spentToday(): # not payable\n  return spentToday\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeDailyLimit(uint256 _dailyLimit): # not payable\n  require caller == this.address\n  dailyLimit = _dailyLimit\n  log DailyLimitChange(uint256 dailyLimit=_dailyLimit)\n\ndef calcMaxWithdraw(): # not payable\n  if block.timestamp > lastDay + (24 * 3600):\n      return dailyLimit\n  if dailyLimit >= spentToday:\n      return (dailyLimit - spentToday)\n  else:\n      return 0\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _required <= owners.length\n  require _required\n  require owners.length\n  required = _required\n  log RequirementChange(uint256 required=_required)\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[address(owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  address(owners[owners.length].field_0) = owner\n  log OwnerAddition(address owner=owner)\n\ndef transactions(uint256 _param1): # not payable\n  mem[128] = stor0[_param1][2].field_0\n  idx = 128\n  s = 0\n  while stor0[_param1][2].length + 96 > idx:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[128 len stor0[_param1][2].length]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[newOwner] = 1\n      log OwnerRemoval(address owner=owner)\n      log OwnerAddition(address owner=newOwner)\n      stop\n  stor2[address(owner)] = 0\n  stor2[newOwner] = 1\n  log OwnerRemoval(address owner=owner)\n  log OwnerAddition(address owner=newOwner)\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      mem[(32 * owners.length) + 224 len floor32(owners.length)] = mem[160 len floor32(owners.length)]\n      return memory\n        from (32 * owners.length) + 160\n         len (96 * owners.length) + 64\n  mem[160] = address(owners.field_0)\n  idx = 160\n  s = 0\n  while (32 * owners.length) + 128 > idx:\n      mem[idx + 32] = address(owners[s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 224 len floor32(owners.length)] = mem[160 len floor32(owners.length)]\n  return Array(len=owners.length, data=mem[160 len floor32(owners.length)], mem[(32 * owners.length) + floor32(owners.length) + 224 len (32 * owners.length) - floor32(owners.length)]), \n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=owner)\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=owner)\n\ndef getConfirmations(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 288 len floor32(s)] = mem[(32 * owners.length) + 224 len floor32(s)]\n      return Array(len=s, data=mem[(32 * owners.length) + 224 len floor32(s)], mem[(32 * owners.length) + (32 * s) + floor32(s) + 288 len (32 * s) - floor32(s)]), \n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  mem[(64 * s) + 320 len floor32(s)] = mem[(32 * s) + 256 len floor32(s)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * transactionCount) + 192:\n      mem[(32 * transactionCount) + 192] = to - from\n      idx = from\n      while idx < to:\n          require idx < transactionCount\n          require idx - from < mem[(32 * transactionCount) + 192]\n          mem[(32 * transactionCount) + (32 * idx - from) + 224] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * transactionCount) + (32 * to - from) + 224] = 32\n      mem[(32 * transactionCount) + (32 * to - from) + 256] = mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * to - from) + 288 len floor32(mem[(32 * transactionCount) + 192])] = mem[(32 * transactionCount) + 224 len floor32(mem[(32 * transactionCount) + 192])]\n      return Array(len=mem[(32 * transactionCount) + 192], data=mem[(32 * transactionCount) + (32 * to - from) + 288 len 32 * mem[(32 * transactionCount) + 192]]), \n  mem[(32 * s) + 224] = to - from\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < to - from, None\n      mem[(32 * s) + (32 * idx - from) + 256] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * s) + (32 * to - from) + 256] = 32\n  mem[(32 * s) + (32 * to - from) + 288] = to - from, None\n  mem[(32 * s) + (32 * to - from) + 320 len floor32(to - from)] = mem[(32 * s) + 256 len floor32(to - from)]\n  return memory\n    from (32 * s) + (32 * to - from) + 256\n     len (32 * to - from, None) + 64\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n  if not stor0[transactionId][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[transactionId].field_256 <= dailyLimit:\n          if spentToday + stor0[transactionId].field_256 >= spentToday:\n              uint8(stor0[transactionId].field_768) = 1\n              spentToday += stor0[transactionId].field_256\n              mem[96] = stor0[transactionId][2].field_0\n              idx = 96\n              s = 0\n              while stor0[transactionId][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor0[transactionId][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[transactionId].field_0).mem[96 len 4] with:\n                 value stor0[transactionId].field_256 wei\n                   gas gas_remaining wei\n                  args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionId)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionId)\n                  uint8(stor0[transactionId].field_768) = 0\n                  spentToday -= stor0[transactionId].field_256\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n  if not stor0[transactionId][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[transactionId].field_256 <= dailyLimit:\n          if spentToday + stor0[transactionId].field_256 >= spentToday:\n              uint8(stor0[transactionId].field_768) = 1\n              spentToday += stor0[transactionId].field_256\n              mem[96] = stor0[transactionId][2].field_0\n              idx = 96\n              s = 0\n              while stor0[transactionId][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor0[transactionId][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[transactionId].field_0).mem[96 len 4] with:\n                 value stor0[transactionId].field_256 wei\n                   gas gas_remaining wei\n                  args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionId)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionId)\n                  uint8(stor0[transactionId].field_768) = 0\n                  spentToday -= stor0[transactionId].field_256\n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  if not stor0[stor5][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[stor5].field_256 <= dailyLimit:\n          if spentToday + stor0[stor5].field_256 >= spentToday:\n              uint8(stor0[stor5].field_768) = 1\n              spentToday += stor0[stor5].field_256\n              mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n              idx = ceil32(data.length) + 256\n              s = 0\n              while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n                  mem[idx + 32] = stor0[stor5][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n                 value stor0[stor5].field_256 wei\n                   gas gas_remaining wei\n                  args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionCount)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionCount)\n                  uint8(stor0[stor5].field_768) = 0\n                  spentToday -= stor0[stor5].field_256\n  return transactionCount\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n  dailyLimit is uint256 at storage 6\n  lastDay is uint256 at storage 7\n  spentToday is uint256 at storage 8\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return address(owners[_param1].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef dailyLimit(): # not payable\n  return dailyLimit\n\ndef lastDay(): # not payable\n  return lastDay\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\ndef spentToday(): # not payable\n  return spentToday\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeDailyLimit(uint256 _dailyLimit): # not payable\n  require caller == this.address\n  dailyLimit = _dailyLimit\n  log DailyLimitChange(uint256 dailyLimit=_dailyLimit)\n\ndef calcMaxWithdraw(): # not payable\n  if block.timestamp > lastDay + (24 * 3600):\n      return dailyLimit\n  if dailyLimit >= spentToday:\n      return (dailyLimit - spentToday)\n  else:\n      return 0\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _required <= owners.length\n  require _required\n  require owners.length\n  required = _required\n  log RequirementChange(uint256 required=_required)\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[address(owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  address(owners[owners.length].field_0) = owner\n  log OwnerAddition(address owner=owner)\n\ndef transactions(uint256 _param1): # not payable\n  mem[128] = stor0[_param1][2].field_0\n  idx = 128\n  s = 0\n  while stor0[_param1][2].length + 96 > idx:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[128 len stor0[_param1][2].length]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[newOwner] = 1\n      log OwnerRemoval(address owner=owner)\n      log OwnerAddition(address owner=newOwner)\n      stop\n  stor2[address(owner)] = 0\n  stor2[newOwner] = 1\n  log OwnerRemoval(address owner=owner)\n  log OwnerAddition(address owner=newOwner)\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      mem[(32 * owners.length) + 224 len floor32(owners.length)] = mem[160 len floor32(owners.length)]\n      return memory\n        from (32 * owners.length) + 160\n         len (96 * owners.length) + 64\n  mem[160] = address(owners.field_0)\n  idx = 160\n  s = 0\n  while (32 * owners.length) + 128 > idx:\n      mem[idx + 32] = address(owners[s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 224 len floor32(owners.length)] = mem[160 len floor32(owners.length)]\n  return Array(len=owners.length, data=mem[160 len floor32(owners.length)], mem[(32 * owners.length) + floor32(owners.length) + 224 len (32 * owners.length) - floor32(owners.length)]), \n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=owner)\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=owner)\n\ndef getConfirmations(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 288 len floor32(s)] = mem[(32 * owners.length) + 224 len floor32(s)]\n      return Array(len=s, data=mem[(32 * owners.length) + 224 len floor32(s)], mem[(32 * owners.length) + (32 * s) + floor32(s) + 288 len (32 * s) - floor32(s)]), \n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  mem[(64 * s) + 320 len floor32(s)] = mem[(32 * s) + 256 len floor32(s)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * transactionCount) + 192:\n      mem[(32 * transactionCount) + 192] = to - from\n      idx = from\n      while idx < to:\n          require idx < transactionCount\n          require idx - from < mem[(32 * transactionCount) + 192]\n          mem[(32 * transactionCount) + (32 * idx - from) + 224] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * transactionCount) + (32 * to - from) + 224] = 32\n      mem[(32 * transactionCount) + (32 * to - from) + 256] = mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * to - from) + 288 len floor32(mem[(32 * transactionCount) + 192])] = mem[(32 * transactionCount) + 224 len floor32(mem[(32 * transactionCount) + 192])]\n      return Array(len=mem[(32 * transactionCount) + 192], data=mem[(32 * transactionCount) + (32 * to - from) + 288 len 32 * mem[(32 * transactionCount) + 192]]), \n  mem[(32 * s) + 224] = to - from\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < to - from, None\n      mem[(32 * s) + (32 * idx - from) + 256] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * s) + (32 * to - from) + 256] = 32\n  mem[(32 * s) + (32 * to - from) + 288] = to - from, None\n  mem[(32 * s) + (32 * to - from) + 320 len floor32(to - from)] = mem[(32 * s) + 256 len floor32(to - from)]\n  return memory\n    from (32 * s) + (32 * to - from) + 256\n     len (32 * to - from, None) + 64\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n  if not stor0[transactionId][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[transactionId].field_256 <= dailyLimit:\n          if spentToday + stor0[transactionId].field_256 >= spentToday:\n              uint8(stor0[transactionId].field_768) = 1\n              spentToday += stor0[transactionId].field_256\n              mem[96] = stor0[transactionId][2].field_0\n              idx = 96\n              s = 0\n              while stor0[transactionId][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor0[transactionId][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[transactionId].field_0).mem[96 len 4] with:\n                 value stor0[transactionId].field_256 wei\n                   gas gas_remaining wei\n                  args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionId)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionId)\n                  uint8(stor0[transactionId].field_768) = 0\n                  spentToday -= stor0[transactionId].field_256\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n  if not stor0[transactionId][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[transactionId].field_256 <= dailyLimit:\n          if spentToday + stor0[transactionId].field_256 >= spentToday:\n              uint8(stor0[transactionId].field_768) = 1\n              spentToday += stor0[transactionId].field_256\n              mem[96] = stor0[transactionId][2].field_0\n              idx = 96\n              s = 0\n              while stor0[transactionId][2].length + 96 > idx + 32:\n                  mem[idx + 32] = stor0[transactionId][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[transactionId].field_0).mem[96 len 4] with:\n                 value stor0[transactionId].field_256 wei\n                   gas gas_remaining wei\n                  args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionId)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionId)\n                  uint8(stor0[transactionId].field_768) = 0\n                  spentToday -= stor0[transactionId].field_256\n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  if not stor0[stor5][2].length:\n      if block.timestamp > lastDay + (24 * 3600):\n          lastDay = block.timestamp\n          spentToday = 0\n      if spentToday + stor0[stor5].field_256 <= dailyLimit:\n          if spentToday + stor0[stor5].field_256 >= spentToday:\n              uint8(stor0[stor5].field_768) = 1\n              spentToday += stor0[stor5].field_256\n              mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n              idx = ceil32(data.length) + 256\n              s = 0\n              while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n                  mem[idx + 32] = stor0[stor5][s + 2].field_256\n                  idx = idx + 32\n                  s = s + 1\n                  continue \n              call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n                 value stor0[stor5].field_256 wei\n                   gas gas_remaining wei\n                  args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n              if ext_call.success:\n                  log Execution(uint256 transactionId=transactionCount)\n              else:\n                  log ExecutionFailure(uint256 transactionId=transactionCount)\n                  uint8(stor0[stor5].field_768) = 0\n                  spentToday -= stor0[stor5].field_256\n  return transactionCount\n\n.",
	"status": "1",
	"time_cost": 43.36783480644226,
	"usage": {
		"completion_tokens": 734,
		"prompt_tokens": 6206,
		"total_tokens": 6940
	}
}