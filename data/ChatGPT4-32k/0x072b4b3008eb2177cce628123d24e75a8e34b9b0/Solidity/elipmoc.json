{
	"address": "0x072b4b3008eb2177cce628123d24e75a8e34b9b0",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the recompiled Solidity code from the given decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MultiSigWallet {\n    uint constant public MAX_OWNER_COUNT = 50;\n\n    mapping(uint => Transaction) public transactions;\n    mapping(uint => mapping (address => bool)) public confirmations;\n    mapping(address => bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n    uint public dailyLimit;\n    uint public lastDay;\n    uint public spentToday;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    event Deposit(address indexed sender, uint value);\n    event OwnerRemoval(address indexed owner);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event OwnerAddition(address indexed owner);\n    event RequirementChange(uint required);\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event DailyLimitChange(uint dailyLimit);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Submission(uint indexed transactionId);\n\n    function addOwner(address owner) public {\n        require(msg.sender == address(this));\n        require(!isOwner[owner]);\n        require(owner != address(0));\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    function removeOwner(address owner) public {\n        require(msg.sender == address(this));\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    function replaceOwner(address oldOwner, address newOwner) public {\n        require(msg.sender == address(this));\n        if (isOwner[oldOwner]) {\n            isOwner[oldOwner] = false;\n            isOwner[newOwner] = true;\n            for (uint i=0; i<owners.length; i++)\n                if (owners[i] == oldOwner) {\n                    owners[i] = newOwner;\n                    break;\n                }\n            emit OwnerRemoval(oldOwner);\n            emit OwnerAddition(newOwner);\n        }\n    }\n\n    function changeRequirement(uint _required) public {\n        require(msg.sender == address(this));\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    function changeDailyLimit(uint _dailyLimit) public {\n        require(msg.sender == address(this));\n        dailyLimit = _dailyLimit;\n        emit DailyLimitChange(_dailyLimit);\n    }\n\n    function submitTransaction(address destination, uint value, bytes memory data) public returns (uint transactionId) {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    function addTransaction(address destination, uint value, bytes memory data) internal returns (uint transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    function confirmTransaction(uint transactionId) public {\n        require(isOwner[msg.sender]);\n        confirmations[transactionId][msg.sender] = true;\n        executeTransaction(transactionId);\n        emit Confirmation(msg.sender, transactionId);\n    }\n\n    function executeTransaction(uint transactionId) public {\n        require(transactions[transactionId].executed == false);\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            (bool success,) = txn.destination.call.value(txn.value)(txn.data);\n            if (success)\n                emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    function isConfirmed(uint transactionId) public view returns (bool) {\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    function() external payable {\n        if (msg.value > 0)\n            emit Deposit(msg.sender, msg.value);\n    }\n}\n```\nPlease note that the decompiled code is quite complex and may contain errors, so the recompiled code might not work exactly as expected. Decompiling is the process of converting low-level code into a high-level language, and there is often information lost in this process. In this case, the low-level code was missing some of the context needed to recreate the Solidity code perfectly.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038937,
	"id": "chatcmpl-8ChmjNlUYWlwW7AlH4awlc5UCY0aH",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.05 11:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\nuint256 _dailyLimit; // STORAGE[0x6]\nuint256 _lastDay; // STORAGE[0x7]\nuint256 _spentToday; // STORAGE[0x8]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nDailyLimitChange(uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x12b3(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = v1 = 0xa3c(varg0);\n    if (!v1) {\n        v2 = _transactions[varg0][2];\n        v0 = v3 = !(((!(v2 & 0x1) << 8) + ~0 & v2) >> 1);\n        if (v3) {\n            v4 = _transactions[varg0][1];\n            if (block.timestamp > 0x15180 + _lastDay) {\n                _lastDay = block.timestamp;\n                _spentToday = 0;\n            }\n            v5 = v6 = _spentToday + v4 > _dailyLimit;\n            if (_spentToday + v4 <= _dailyLimit) {\n                v5 = _spentToday + v4 < _spentToday;\n            }\n            if (!v5) {\n                v0 = v7 = 1;\n            } else {\n                v0 = 0;\n            }\n            goto 0x1322;\n        }\n    }\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        if (!v1) {\n            _spentToday += _transactions[varg0][1];\n        }\n        v8 = v9 = MEM[64];\n        v10 = _transactions[varg0][2];\n        if (((!(0x1 & v10) << 8) - 1 & v10) >> 1) {\n            if (31 < ((!(0x1 & v10) << 8) - 1 & v10) >> 1) {\n                do {\n                    MEM[v8] = STORAGE[v11];\n                    v11 += 1;\n                    v8 += 32;\n                } while (v9 + (((!(0x1 & v10) << 8) - 1 & v10) >> 1) <= v8);\n            } else {\n                v12 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v13 = address(_transactions[varg0]).call(v12).value(_transactions[varg0][1]).gas(msg.gas);\n        if (!v13) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            if (!v1) {\n                _spentToday = _spentToday - _transactions[varg0][1];\n            }\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction () public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x15daB0x6dc;\n    }\n    if (_required > _owners.length) {\n        0xf07(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction calcMaxWithdraw() public nonPayable { \n    if (block.timestamp <= 0x15180 + _lastDay) {\n        if (_dailyLimit >= _spentToday) {\n            v0 = v1 = _dailyLimit - _spentToday;\n        } else {\n            v0 = v2 = 0;\n        }\n    } else {\n        v0 = v3 = _dailyLimit;\n    }\n    return v0;\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction dailyLimit() public nonPayable { \n    return _dailyLimit;\n}\n\nfunction lastDay() public nonPayable { \n    return _lastDay;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = v4 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v5 = v6 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        goto 0x15daB0x99c;\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0xa3c(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v4, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length << 5) {\n        v5[v6] = v1[v6];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v13 = v14 = MEM[64];\n    if (MSIZE() >= v14) {\n        v13 = new uint256[](varg1 - varg0);\n    }\n    v13 = new uint256[](varg1 - varg0);\n    while (v15 < varg1) {\n        assert(v15 < v5.length);\n        assert(v15 - varg0 < v13.length);\n        v13[v15 - varg0 << 5] = v7[v15];\n        v15 += 1;\n    }\n    v16 = new array[](v13.length);\n    v17 = v18 = 0;\n    while (v17 < v13.length << 5) {\n        v16[v17] = v13[v17];\n        v17 += 32;\n    }\n    return v16;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v11 = v12 = 0;\n    while (v11 < v5) {\n        assert(v11 < v2.length);\n        assert(v11 < v9.length);\n        v9[v11] = address(v4[v11]);\n        v11 += 1;\n    }\n    v13 = new array[](v9.length);\n    v14 = v15 = 0;\n    while (v14 < v9.length << 5) {\n        v13[v14] = v9[v14];\n        v14 += 32;\n    }\n    return v13;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0xf07(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0xf92(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xf92(_transactionCount);\n    return _transactionCount;\n}\n\nfunction changeDailyLimit(uint256 varg0) public nonPayable { \n    require(msg.sender == address(this));\n    _dailyLimit = varg0;\n    emit DailyLimitChange(varg0);\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 50;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x12b3(varg0);\n}\n\nfunction spentToday() public nonPayable { \n    return _spentToday;\n}\n\nfunction 0xa3c(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf07(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xf92(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x12b3(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x4bc9fdc2 == v0) {\n            calcMaxWithdraw();\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x67eeba0c == v0) {\n            dailyLimit();\n        } else if (0x6b0c932d == v0) {\n            lastDay();\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xcea08621 == v0) {\n            changeDailyLimit(uint256);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        } else if (0xf059cf2b == v0) {\n            spentToday();\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.05 11:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\nuint256 _dailyLimit; // STORAGE[0x6]\nuint256 _lastDay; // STORAGE[0x7]\nuint256 _spentToday; // STORAGE[0x8]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nDailyLimitChange(uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x12b3(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = v1 = 0xa3c(varg0);\n    if (!v1) {\n        v2 = _transactions[varg0][2];\n        v0 = v3 = !(((!(v2 & 0x1) << 8) + ~0 & v2) >> 1);\n        if (v3) {\n            v4 = _transactions[varg0][1];\n            if (block.timestamp > 0x15180 + _lastDay) {\n                _lastDay = block.timestamp;\n                _spentToday = 0;\n            }\n            v5 = v6 = _spentToday + v4 > _dailyLimit;\n            if (_spentToday + v4 <= _dailyLimit) {\n                v5 = _spentToday + v4 < _spentToday;\n            }\n            if (!v5) {\n                v0 = v7 = 1;\n            } else {\n                v0 = 0;\n            }\n            goto 0x1322;\n        }\n    }\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        if (!v1) {\n            _spentToday += _transactions[varg0][1];\n        }\n        v8 = v9 = MEM[64];\n        v10 = _transactions[varg0][2];\n        if (((!(0x1 & v10) << 8) - 1 & v10) >> 1) {\n            if (31 < ((!(0x1 & v10) << 8) - 1 & v10) >> 1) {\n                do {\n                    MEM[v8] = STORAGE[v11];\n                    v11 += 1;\n                    v8 += 32;\n                } while (v9 + (((!(0x1 & v10) << 8) - 1 & v10) >> 1) <= v8);\n            } else {\n                v12 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v13 = address(_transactions[varg0]).call(v12).value(_transactions[varg0][1]).gas(msg.gas);\n        if (!v13) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            if (!v1) {\n                _spentToday = _spentToday - _transactions[varg0][1];\n            }\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction () public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x15daB0x6dc;\n    }\n    if (_required > _owners.length) {\n        0xf07(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction calcMaxWithdraw() public nonPayable { \n    if (block.timestamp <= 0x15180 + _lastDay) {\n        if (_dailyLimit >= _spentToday) {\n            v0 = v1 = _dailyLimit - _spentToday;\n        } else {\n            v0 = v2 = 0;\n        }\n    } else {\n        v0 = v3 = _dailyLimit;\n    }\n    return v0;\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction dailyLimit() public nonPayable { \n    return _dailyLimit;\n}\n\nfunction lastDay() public nonPayable { \n    return _lastDay;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = v4 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v5 = v6 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        goto 0x15daB0x99c;\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0xa3c(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v4, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length << 5) {\n        v5[v6] = v1[v6];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v13 = v14 = MEM[64];\n    if (MSIZE() >= v14) {\n        v13 = new uint256[](varg1 - varg0);\n    }\n    v13 = new uint256[](varg1 - varg0);\n    while (v15 < varg1) {\n        assert(v15 < v5.length);\n        assert(v15 - varg0 < v13.length);\n        v13[v15 - varg0 << 5] = v7[v15];\n        v15 += 1;\n    }\n    v16 = new array[](v13.length);\n    v17 = v18 = 0;\n    while (v17 < v13.length << 5) {\n        v16[v17] = v13[v17];\n        v17 += 32;\n    }\n    return v16;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v11 = v12 = 0;\n    while (v11 < v5) {\n        assert(v11 < v2.length);\n        assert(v11 < v9.length);\n        v9[v11] = address(v4[v11]);\n        v11 += 1;\n    }\n    v13 = new array[](v9.length);\n    v14 = v15 = 0;\n    while (v14 < v9.length << 5) {\n        v13[v14] = v9[v14];\n        v14 += 32;\n    }\n    return v13;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0xf07(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0xf92(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xf92(_transactionCount);\n    return _transactionCount;\n}\n\nfunction changeDailyLimit(uint256 varg0) public nonPayable { \n    require(msg.sender == address(this));\n    _dailyLimit = varg0;\n    emit DailyLimitChange(varg0);\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 50;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x12b3(varg0);\n}\n\nfunction spentToday() public nonPayable { \n    return _spentToday;\n}\n\nfunction 0xa3c(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf07(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xf92(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x12b3(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x4bc9fdc2 == v0) {\n            calcMaxWithdraw();\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x67eeba0c == v0) {\n            dailyLimit();\n        } else if (0x6b0c932d == v0) {\n            lastDay();\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xcea08621 == v0) {\n            changeDailyLimit(uint256);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        } else if (0xf059cf2b == v0) {\n            spentToday();\n        }\n    }\n    ();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.05 11:30 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\nuint256 _dailyLimit; // STORAGE[0x6]\nuint256 _lastDay; // STORAGE[0x7]\nuint256 _spentToday; // STORAGE[0x8]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nDailyLimitChange(uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x12b3(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = v1 = 0xa3c(varg0);\n    if (!v1) {\n        v2 = _transactions[varg0][2];\n        v0 = v3 = !(((!(v2 & 0x1) << 8) + ~0 & v2) >> 1);\n        if (v3) {\n            v4 = _transactions[varg0][1];\n            if (block.timestamp > 0x15180 + _lastDay) {\n                _lastDay = block.timestamp;\n                _spentToday = 0;\n            }\n            v5 = v6 = _spentToday + v4 > _dailyLimit;\n            if (_spentToday + v4 <= _dailyLimit) {\n                v5 = _spentToday + v4 < _spentToday;\n            }\n            if (!v5) {\n                v0 = v7 = 1;\n            } else {\n                v0 = 0;\n            }\n            goto 0x1322;\n        }\n    }\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        if (!v1) {\n            _spentToday += _transactions[varg0][1];\n        }\n        v8 = v9 = MEM[64];\n        v10 = _transactions[varg0][2];\n        if (((!(0x1 & v10) << 8) - 1 & v10) >> 1) {\n            if (31 < ((!(0x1 & v10) << 8) - 1 & v10) >> 1) {\n                do {\n                    MEM[v8] = STORAGE[v11];\n                    v11 += 1;\n                    v8 += 32;\n                } while (v9 + (((!(0x1 & v10) << 8) - 1 & v10) >> 1) <= v8);\n            } else {\n                v12 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v13 = address(_transactions[varg0]).call(v12).value(_transactions[varg0][1]).gas(msg.gas);\n        if (!v13) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            if (!v1) {\n                _spentToday = _spentToday - _transactions[varg0][1];\n            }\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction () public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x15daB0x6dc;\n    }\n    if (_required > _owners.length) {\n        0xf07(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction calcMaxWithdraw() public nonPayable { \n    if (block.timestamp <= 0x15180 + _lastDay) {\n        if (_dailyLimit >= _spentToday) {\n            v0 = v1 = _dailyLimit - _spentToday;\n        } else {\n            v0 = v2 = 0;\n        }\n    } else {\n        v0 = v3 = _dailyLimit;\n    }\n    return v0;\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction dailyLimit() public nonPayable { \n    return _dailyLimit;\n}\n\nfunction lastDay() public nonPayable { \n    return _lastDay;\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = v4 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v5 = v6 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        goto 0x15daB0x99c;\n    }\n    _owners[_owners.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0xa3c(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v4, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length << 5) {\n        v5[v6] = v1[v6];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v13 = v14 = MEM[64];\n    if (MSIZE() >= v14) {\n        v13 = new uint256[](varg1 - varg0);\n    }\n    v13 = new uint256[](varg1 - varg0);\n    while (v15 < varg1) {\n        assert(v15 < v5.length);\n        assert(v15 - varg0 < v13.length);\n        v13[v15 - varg0 << 5] = v7[v15];\n        v15 += 1;\n    }\n    v16 = new array[](v13.length);\n    v17 = v18 = 0;\n    while (v17 < v13.length << 5) {\n        v16[v17] = v13[v17];\n        v17 += 32;\n    }\n    return v16;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v11 = v12 = 0;\n    while (v11 < v5) {\n        assert(v11 < v2.length);\n        assert(v11 < v9.length);\n        v9[v11] = address(v4[v11]);\n        v11 += 1;\n    }\n    v13 = new array[](v9.length);\n    v14 = v15 = 0;\n    while (v14 < v9.length << 5) {\n        v13[v14] = v9[v14];\n        v14 += 32;\n    }\n    return v13;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0xf07(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0xf92(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xf92(_transactionCount);\n    return _transactionCount;\n}\n\nfunction changeDailyLimit(uint256 varg0) public nonPayable { \n    require(msg.sender == address(this));\n    _dailyLimit = varg0;\n    emit DailyLimitChange(varg0);\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 50;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x12b3(varg0);\n}\n\nfunction spentToday() public nonPayable { \n    return _spentToday;\n}\n\nfunction 0xa3c(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf07(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xf92(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x12b3(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x4bc9fdc2 == v0) {\n            calcMaxWithdraw();\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x67eeba0c == v0) {\n            dailyLimit();\n        } else if (0x6b0c932d == v0) {\n            lastDay();\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xcea08621 == v0) {\n            changeDailyLimit(uint256);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        } else if (0xf059cf2b == v0) {\n            spentToday();\n        }\n    }\n    ();\n}\n.",
	"status": "1",
	"time_cost": 44.5232572555542,
	"usage": {
		"completion_tokens": 1009,
		"prompt_tokens": 5375,
		"total_tokens": 6384
	}
}