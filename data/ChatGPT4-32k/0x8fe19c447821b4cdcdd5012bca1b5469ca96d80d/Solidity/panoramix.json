{
	"address": "0x8fe19c447821b4cdcdd5012bca1b5469ca96d80d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the provided decompiled code, here is a Solidity contract code:\n\n```solidity\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping(address => uint256) public balanceOf;\n    uint256 public totalSupply;\n    mapping(address => mapping(address => uint256)) public allowance;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    address public beneficiaryAddress;\n    address public oracleAddress;\n    address public heroContractAddress;\n    mapping(address => bool) public floorContracts;\n    mapping(address => bool) public isMinter;\n    address private _owner;\n\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimalUnits,\n        uint256 initialSupply\n    ) {\n        _owner = msg.sender;\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n        totalSupply = initialSupply;\n        balanceOf[msg.sender] = initialSupply;\n    }\n\n    // Only Owner modifier\n    modifier onlyOwner {\n        require(msg.sender == _owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    function setOracle(address oracle) public onlyOwner {\n        oracleAddress = oracle;\n    }\n\n    function setHeroContract(address heroContract) public onlyOwner {\n        heroContractAddress = heroContract;\n    }\n\n    function setBeneficiary(address newBeneficiary) public onlyOwner {\n        beneficiaryAddress = newBeneficiary;\n    }\n\n    // Other functions...\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= value);\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n}\n```\n\nPlease note that this is a simplified version of the contract and does not cover all the functions in the decompiled code. Some of the functions (like `acceptDividends`, `rewardTokens`, `transferWithParams`, etc.) require additional contracts or interfaces to be defined and are not included in this basic contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472044,
	"id": "chatcmpl-8MukOYnL7mRaR5r0nI9T5Xa2U0k2a",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor0 is address at storage 0\n  balanceOf is mapping of uint256 at storage 1\n  totalSupply is uint256 at storage 2\n  allowance is mapping of uint256 at storage 3\n  name is array of uint256 at storage 4\n  symbol is array of uint256 at storage 5\n  decimals is uint8 at storage 6\n  beneficiaryAddress is address at storage 6 offset 8\n  oracleAddress is address at storage 7\n  heroContractAddress is address at storage 8\n  floorContracts is mapping of address at storage 9\n  stor10 is mapping of uint8 at storage 10\n  stor11 is mapping of uint8 at storage 11\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef heroContract(): # not payable\n  return heroContractAddress\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef canAcceptTokens(address _param1): # not payable\n  return bool(stor10[_param1])\n\ndef decimals(): # not payable\n  return decimals\n\ndef beneficiary(): # not payable\n  return beneficiaryAddress\n\ndef floorContracts(uint32 _param1): # not payable\n  return floorContracts[_param1]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef oracle(): # not payable\n  return oracleAddress\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef isMinter(address account): # not payable\n  return bool(stor11[account])\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef accountAuth(uint256 _param1): # not payable\n  stop\n\ndef setOracle(address _oracle): # not payable\n  require stor0 == caller\n  oracleAddress = _oracle\n\ndef setHeroContract(address _heroContract): # not payable\n  require stor0 == caller\n  heroContractAddress = _heroContract\n\ndef setBeneficiary(address _newBeneficiary): # not payable\n  require stor0 == caller\n  beneficiaryAddress = _newBeneficiary\n\ndef authorizeFloor(uint32 _index, address _floorContract): # not payable\n  require stor0 == caller\n  floorContracts[_index << 224] = _floorContract\n\ndef setIsMinter(address _address, bool _value): # not payable\n  require stor0 == caller\n  stor11[address(_address)] = uint8(_value)\n\ndef setCanAcceptTokens(address _address, bool _value): # not payable\n  require stor0 == caller\n  stor10[address(_address)] = uint8(_value)\n\ndef approve(address spender, uint256 amount): # not payable\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef payoutDividends(address _user, uint256 _value): # not payable\n  require oracleAddress == caller\n  call _user with:\n     value _value wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Withdrawal(\n        address src=_value,\n        uint256 wad=_user)\n\ndef burn(uint256 _value): # not payable\n  require balanceOf[caller] >= _value\n  require _value <= balanceOf[caller]\n  balanceOf[caller] -= _value\n  require _value <= totalSupply\n  totalSupply -= _value\n  log Burn(\n        address from=_value,\n        uint256 value=caller)\n\ndef acceptDividends(uint256 _value, uint32 _floorIndex): # not payable\n  require floorContracts[_floorIndex << 224] == caller\n  require _value / 5 <= _value\n  call beneficiaryAddress with:\n     value _value / 5 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Dividend(uint256 value=(_value - (_value / 5)))\n\ndef increaseApproval(address _spender, uint256 _addedValue): # not payable\n  require _addedValue + allowance[caller][address(_spender)] >= allowance[caller][address(_spender)]\n  allowance[caller][address(_spender)] += _addedValue\n  log Approval(\n        address owner=(_addedValue + allowance[caller][address(_spender)]),\n        address spender=caller,\n        uint256 value=_spender)\n  return 1\n\ndef decreaseApproval(address _spender, uint256 _subtractedValue): # not payable\n  if _subtractedValue <= allowance[caller][address(_spender)]:\n      allowance[caller][address(_spender)] -= _subtractedValue\n  else:\n      allowance[caller][address(_spender)] = 0\n  log Approval(\n        address owner=allowance[caller][address(_spender)],\n        address spender=caller,\n        uint256 value=_spender)\n  return 1\n\ndef rewardTokens(address _user, uint256 _tokens): # not payable\n  if stor0 != caller:\n      require stor11[caller]\n  require _user\n  require _tokens + balanceOf[address(_user)] >= balanceOf[address(_user)]\n  balanceOf[address(_user)] += _tokens\n  require _tokens + totalSupply >= totalSupply\n  totalSupply += _tokens\n  log Transfer(\n        address from=_tokens,\n        address to=this.address,\n        uint256 value=_user)\n\ndef rewardTokensFloor(address _user, uint256 _tokens, uint32 _floorIndex): # not payable\n  require floorContracts[_floorIndex << 224] == caller\n  require _user\n  require _tokens + balanceOf[address(_user)] >= balanceOf[address(_user)]\n  balanceOf[address(_user)] += _tokens\n  require _tokens + totalSupply >= totalSupply\n  totalSupply += _tokens\n  log Transfer(\n        address from=_tokens,\n        address to=this.address,\n        uint256 value=_user)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require 68 == calldata.size\n  require recipient\n  require amount <= balanceOf[caller]\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  if stor10[address(recipient)]:\n      require ext_code.size(recipient)\n      call recipient.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), amount, 0, 0, 0\n      require ext_call.success\n  return 1\n\ndef transferWithParams(address _to, uint256 _value, uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require 164 == calldata.size\n  require _to\n  require _value <= balanceOf[caller]\n  require _value <= balanceOf[caller]\n  balanceOf[caller] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[address(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=caller,\n        uint256 value=_to)\n  if stor10[address(_to)]:\n      require ext_code.size(_to)\n      call _to.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), _value, _param1, _param2, _param3\n      require ext_call.success\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[address(sender)]\n  require amount <= allowance[address(sender)][caller]\n  require amount <= balanceOf[address(sender)]\n  balanceOf[address(sender)] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  if stor10[address(recipient)]:\n      require ext_code.size(recipient)\n      call recipient.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, 0, amount, 0, 0, 0\n      require ext_call.success\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is address at storage 0\n  balanceOf is mapping of uint256 at storage 1\n  totalSupply is uint256 at storage 2\n  allowance is mapping of uint256 at storage 3\n  name is array of uint256 at storage 4\n  symbol is array of uint256 at storage 5\n  decimals is uint8 at storage 6\n  beneficiaryAddress is address at storage 6 offset 8\n  oracleAddress is address at storage 7\n  heroContractAddress is address at storage 8\n  floorContracts is mapping of address at storage 9\n  stor10 is mapping of uint8 at storage 10\n  stor11 is mapping of uint8 at storage 11\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef heroContract(): # not payable\n  return heroContractAddress\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef canAcceptTokens(address _param1): # not payable\n  return bool(stor10[_param1])\n\ndef decimals(): # not payable\n  return decimals\n\ndef beneficiary(): # not payable\n  return beneficiaryAddress\n\ndef floorContracts(uint32 _param1): # not payable\n  return floorContracts[_param1]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef oracle(): # not payable\n  return oracleAddress\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef isMinter(address account): # not payable\n  return bool(stor11[account])\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef accountAuth(uint256 _param1): # not payable\n  stop\n\ndef setOracle(address _oracle): # not payable\n  require stor0 == caller\n  oracleAddress = _oracle\n\ndef setHeroContract(address _heroContract): # not payable\n  require stor0 == caller\n  heroContractAddress = _heroContract\n\ndef setBeneficiary(address _newBeneficiary): # not payable\n  require stor0 == caller\n  beneficiaryAddress = _newBeneficiary\n\ndef authorizeFloor(uint32 _index, address _floorContract): # not payable\n  require stor0 == caller\n  floorContracts[_index << 224] = _floorContract\n\ndef setIsMinter(address _address, bool _value): # not payable\n  require stor0 == caller\n  stor11[address(_address)] = uint8(_value)\n\ndef setCanAcceptTokens(address _address, bool _value): # not payable\n  require stor0 == caller\n  stor10[address(_address)] = uint8(_value)\n\ndef approve(address spender, uint256 amount): # not payable\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef payoutDividends(address _user, uint256 _value): # not payable\n  require oracleAddress == caller\n  call _user with:\n     value _value wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Withdrawal(\n        address src=_value,\n        uint256 wad=_user)\n\ndef burn(uint256 _value): # not payable\n  require balanceOf[caller] >= _value\n  require _value <= balanceOf[caller]\n  balanceOf[caller] -= _value\n  require _value <= totalSupply\n  totalSupply -= _value\n  log Burn(\n        address from=_value,\n        uint256 value=caller)\n\ndef acceptDividends(uint256 _value, uint32 _floorIndex): # not payable\n  require floorContracts[_floorIndex << 224] == caller\n  require _value / 5 <= _value\n  call beneficiaryAddress with:\n     value _value / 5 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Dividend(uint256 value=(_value - (_value / 5)))\n\ndef increaseApproval(address _spender, uint256 _addedValue): # not payable\n  require _addedValue + allowance[caller][address(_spender)] >= allowance[caller][address(_spender)]\n  allowance[caller][address(_spender)] += _addedValue\n  log Approval(\n        address owner=(_addedValue + allowance[caller][address(_spender)]),\n        address spender=caller,\n        uint256 value=_spender)\n  return 1\n\ndef decreaseApproval(address _spender, uint256 _subtractedValue): # not payable\n  if _subtractedValue <= allowance[caller][address(_spender)]:\n      allowance[caller][address(_spender)] -= _subtractedValue\n  else:\n      allowance[caller][address(_spender)] = 0\n  log Approval(\n        address owner=allowance[caller][address(_spender)],\n        address spender=caller,\n        uint256 value=_spender)\n  return 1\n\ndef rewardTokens(address _user, uint256 _tokens): # not payable\n  if stor0 != caller:\n      require stor11[caller]\n  require _user\n  require _tokens + balanceOf[address(_user)] >= balanceOf[address(_user)]\n  balanceOf[address(_user)] += _tokens\n  require _tokens + totalSupply >= totalSupply\n  totalSupply += _tokens\n  log Transfer(\n        address from=_tokens,\n        address to=this.address,\n        uint256 value=_user)\n\ndef rewardTokensFloor(address _user, uint256 _tokens, uint32 _floorIndex): # not payable\n  require floorContracts[_floorIndex << 224] == caller\n  require _user\n  require _tokens + balanceOf[address(_user)] >= balanceOf[address(_user)]\n  balanceOf[address(_user)] += _tokens\n  require _tokens + totalSupply >= totalSupply\n  totalSupply += _tokens\n  log Transfer(\n        address from=_tokens,\n        address to=this.address,\n        uint256 value=_user)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require 68 == calldata.size\n  require recipient\n  require amount <= balanceOf[caller]\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  if stor10[address(recipient)]:\n      require ext_code.size(recipient)\n      call recipient.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), amount, 0, 0, 0\n      require ext_call.success\n  return 1\n\ndef transferWithParams(address _to, uint256 _value, uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require 164 == calldata.size\n  require _to\n  require _value <= balanceOf[caller]\n  require _value <= balanceOf[caller]\n  balanceOf[caller] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[address(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=caller,\n        uint256 value=_to)\n  if stor10[address(_to)]:\n      require ext_code.size(_to)\n      call _to.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), _value, _param1, _param2, _param3\n      require ext_call.success\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[address(sender)]\n  require amount <= allowance[address(sender)][caller]\n  require amount <= balanceOf[address(sender)]\n  balanceOf[address(sender)] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  if stor10[address(recipient)]:\n      require ext_code.size(recipient)\n      call recipient.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, 0, amount, 0, 0, 0\n      require ext_call.success\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is address at storage 0\n  balanceOf is mapping of uint256 at storage 1\n  totalSupply is uint256 at storage 2\n  allowance is mapping of uint256 at storage 3\n  name is array of uint256 at storage 4\n  symbol is array of uint256 at storage 5\n  decimals is uint8 at storage 6\n  beneficiaryAddress is address at storage 6 offset 8\n  oracleAddress is address at storage 7\n  heroContractAddress is address at storage 8\n  floorContracts is mapping of address at storage 9\n  stor10 is mapping of uint8 at storage 10\n  stor11 is mapping of uint8 at storage 11\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef heroContract(): # not payable\n  return heroContractAddress\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef canAcceptTokens(address _param1): # not payable\n  return bool(stor10[_param1])\n\ndef decimals(): # not payable\n  return decimals\n\ndef beneficiary(): # not payable\n  return beneficiaryAddress\n\ndef floorContracts(uint32 _param1): # not payable\n  return floorContracts[_param1]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[address(account)]\n\ndef oracle(): # not payable\n  return oracleAddress\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef isMinter(address account): # not payable\n  return bool(stor11[account])\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[address(owner)][address(spender)]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef accountAuth(uint256 _param1): # not payable\n  stop\n\ndef setOracle(address _oracle): # not payable\n  require stor0 == caller\n  oracleAddress = _oracle\n\ndef setHeroContract(address _heroContract): # not payable\n  require stor0 == caller\n  heroContractAddress = _heroContract\n\ndef setBeneficiary(address _newBeneficiary): # not payable\n  require stor0 == caller\n  beneficiaryAddress = _newBeneficiary\n\ndef authorizeFloor(uint32 _index, address _floorContract): # not payable\n  require stor0 == caller\n  floorContracts[_index << 224] = _floorContract\n\ndef setIsMinter(address _address, bool _value): # not payable\n  require stor0 == caller\n  stor11[address(_address)] = uint8(_value)\n\ndef setCanAcceptTokens(address _address, bool _value): # not payable\n  require stor0 == caller\n  stor10[address(_address)] = uint8(_value)\n\ndef approve(address spender, uint256 amount): # not payable\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef payoutDividends(address _user, uint256 _value): # not payable\n  require oracleAddress == caller\n  call _user with:\n     value _value wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Withdrawal(\n        address src=_value,\n        uint256 wad=_user)\n\ndef burn(uint256 _value): # not payable\n  require balanceOf[caller] >= _value\n  require _value <= balanceOf[caller]\n  balanceOf[caller] -= _value\n  require _value <= totalSupply\n  totalSupply -= _value\n  log Burn(\n        address from=_value,\n        uint256 value=caller)\n\ndef acceptDividends(uint256 _value, uint32 _floorIndex): # not payable\n  require floorContracts[_floorIndex << 224] == caller\n  require _value / 5 <= _value\n  call beneficiaryAddress with:\n     value _value / 5 wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Dividend(uint256 value=(_value - (_value / 5)))\n\ndef increaseApproval(address _spender, uint256 _addedValue): # not payable\n  require _addedValue + allowance[caller][address(_spender)] >= allowance[caller][address(_spender)]\n  allowance[caller][address(_spender)] += _addedValue\n  log Approval(\n        address owner=(_addedValue + allowance[caller][address(_spender)]),\n        address spender=caller,\n        uint256 value=_spender)\n  return 1\n\ndef decreaseApproval(address _spender, uint256 _subtractedValue): # not payable\n  if _subtractedValue <= allowance[caller][address(_spender)]:\n      allowance[caller][address(_spender)] -= _subtractedValue\n  else:\n      allowance[caller][address(_spender)] = 0\n  log Approval(\n        address owner=allowance[caller][address(_spender)],\n        address spender=caller,\n        uint256 value=_spender)\n  return 1\n\ndef rewardTokens(address _user, uint256 _tokens): # not payable\n  if stor0 != caller:\n      require stor11[caller]\n  require _user\n  require _tokens + balanceOf[address(_user)] >= balanceOf[address(_user)]\n  balanceOf[address(_user)] += _tokens\n  require _tokens + totalSupply >= totalSupply\n  totalSupply += _tokens\n  log Transfer(\n        address from=_tokens,\n        address to=this.address,\n        uint256 value=_user)\n\ndef rewardTokensFloor(address _user, uint256 _tokens, uint32 _floorIndex): # not payable\n  require floorContracts[_floorIndex << 224] == caller\n  require _user\n  require _tokens + balanceOf[address(_user)] >= balanceOf[address(_user)]\n  balanceOf[address(_user)] += _tokens\n  require _tokens + totalSupply >= totalSupply\n  totalSupply += _tokens\n  log Transfer(\n        address from=_tokens,\n        address to=this.address,\n        uint256 value=_user)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require 68 == calldata.size\n  require recipient\n  require amount <= balanceOf[caller]\n  require amount <= balanceOf[caller]\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  if stor10[address(recipient)]:\n      require ext_code.size(recipient)\n      call recipient.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), amount, 0, 0, 0\n      require ext_call.success\n  return 1\n\ndef transferWithParams(address _to, uint256 _value, uint256 _param1, uint256 _param2, uint256 _param3): # not payable\n  require 164 == calldata.size\n  require _to\n  require _value <= balanceOf[caller]\n  require _value <= balanceOf[caller]\n  balanceOf[caller] -= _value\n  require _value + balanceOf[_to] >= balanceOf[_to]\n  balanceOf[address(_to)] = _value + balanceOf[_to]\n  log Transfer(\n        address from=_value,\n        address to=caller,\n        uint256 value=_to)\n  if stor10[address(_to)]:\n      require ext_code.size(_to)\n      call _to.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), _value, _param1, _param2, _param3\n      require ext_call.success\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient\n  require amount <= balanceOf[address(sender)]\n  require amount <= allowance[address(sender)][caller]\n  require amount <= balanceOf[address(sender)]\n  balanceOf[address(sender)] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  require amount <= allowance[address(sender)][caller]\n  allowance[address(sender)][caller] -= amount\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  if stor10[address(recipient)]:\n      require ext_code.size(recipient)\n      call recipient.acceptTokens(address _from, uint256 _value, uint256 , uint256 , uint256 ) with:\n           gas gas_remaining wei\n          args 0, 0, amount, 0, 0, 0\n      require ext_call.success\n  return 1\n\n.",
	"status": "1",
	"time_cost": 35.6873037815094,
	"usage": {
		"completion_tokens": 459,
		"prompt_tokens": 1989,
		"total_tokens": 2448
	}
}