{
	"address": "0xa52c8371d379d7036a862673b08bd73faf4660fd",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the contract in Solidity based on the decompiled code:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract SmartContract {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n```\n\nThis contract is a basic ERC20 token contract. It has the functions `transfer`, `approve`, and `transferFrom` which are part of the ERC20 standard. The `constructor` function sets the `totalSupply` of tokens, the `name` and `symbol` of the token. The `decimals` variable is set to 18 by default to be compatible with the majority of wallets and exchanges. \n\nPlease note that without the full Solidity source code and without knowing the exact functionality of the contract, it's impossible to fully decompile and recreate the exact contract from the EVM bytecode. The above contract is a simplified version and may not include all the functionalities of the original contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457186,
	"id": "chatcmpl-8R31mIrqoGUHv6s0PpiCEkAm1qv8T",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _tokensAvailable; // STORAGE[0xa]\nuint256 _solvency; // STORAGE[0xb]\nuint256 _profit; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _emails; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _dividends; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _paidDividends; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x11]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _closeBuy; // STORAGE[0x9] bytes 0 to 0\nuint8 _closeSell; // STORAGE[0x9] bytes 1 to 1\naddress _comisionGetter; // STORAGE[0xd] bytes 0 to 19\n\n// Events\nLogWithdrawal(address, uint256);\nTransfer(address, address, uint256);\nLogDeposit(address, uint256);\nFrozenFunds(address, bool);\n\nfunction fallback() public payable { \n    0xc8b();\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x217b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balanceOf[v2] + varg0 > _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v5] - varg0;\n    v6 = address(varg1);\n    _balanceOf[v6] = _balanceOf[v6] + varg0;\n    _tokensAvailable = _balanceOf[address(this)];\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction 0x2485(uint256 varg0, uint256 varg1) private { \n    if (!varg0) {\n        if (varg1 <= _profit) {\n            _profit = _profit - varg1;\n        } else {\n            _profit = 0;\n        }\n    } else {\n        _profit = _profit + varg1;\n    }\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction adminResetEmail(address varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    require(msg.sender == _owner);\n    require(_balanceOf[varg0] > 0);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _emails[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _emails[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    require((address(this)).balance >= (varg2 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg2 * _sellPrice << 2) / 1000).gas(!((varg2 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x217b(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction setEmail(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(_balanceOf[msg.sender] > 0);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _emails[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _emails[msg.sender] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _emails[msg.sender]) << 8) - 1 & _emails[msg.sender]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    return 1;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit LogWithdrawal(msg.sender, varg0);\n    _solvency = (address(this)).balance - varg0;\n    0x2485(1, varg0);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction comisionGetter() public nonPayable { \n    return _comisionGetter;\n}\n\nfunction tokensAvailable() public nonPayable { \n    return _tokensAvailable;\n}\n\nfunction profit() public nonPayable { \n    return _profit;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction solvency() public nonPayable { \n    return _solvency;\n}\n\nfunction mintToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    _tokensAvailable = _balanceOf[address(this)];\n    emit Transfer(0, address(this), varg1);\n    emit Transfer(address(this), varg0, varg1);\n}\n\nfunction refillTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x217b(varg0, this, msg.sender);\n}\n\nfunction dividends(uint256 varg0) public nonPayable { \n    return _dividends[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction dividendsGetPaid(uint256 varg0) public nonPayable { \n    require(!(0xff & _frozenAccount[msg.sender]));\n    require(_balanceOf[msg.sender] > 0);\n    require(_dividends[varg0] > 0);\n    assert(varg0 < _paidDividends[msg.sender]);\n    require(STORAGE[keccak256(keccak256(msg.sender, 16)) + varg0] == 0);\n    assert(_totalSupply);\n    v0 = _balanceOf[msg.sender] / _totalSupply * 10000 * _dividends[varg0] / 10000;\n    require((address(this)).balance >= v0);\n    assert(varg0 < _paidDividends[msg.sender]);\n    STORAGE[keccak256(keccak256(msg.sender, 16)) + varg0] = v0;\n    emit LogWithdrawal(msg.sender, v0);\n    _solvency = (address(this)).balance - v0;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(1);\n    return 1;\n}\n\nfunction buy() public payable { \n    0xc8b();\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require((address(this)).balance >= (varg1 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg1 * _sellPrice << 2) / 1000).gas(!((varg1 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    0x217b(varg1, varg0, msg.sender);\n}\n\nfunction setStatus(bool varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _closeBuy = varg0;\n    _closeSell = varg1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction closeSell() public nonPayable { \n    return _closeSell;\n}\n\nfunction closeBuy() public nonPayable { \n    return _closeBuy;\n}\n\nfunction emails(address varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _emails[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction paidDividends(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 < _paidDividends[varg0]);\n    return STORAGE[keccak256(keccak256(varg0, 16)) + varg1];\n}\n\nfunction deposit() public payable { \n    require((address(this)).balance + msg.value > (address(this)).balance);\n    _solvency = (address(this)).balance;\n    0x2485(0, msg.value);\n    emit LogDeposit(msg.sender, msg.value);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(!_closeSell);\n    require((address(this)).balance >= varg0 * _sellPrice + (varg0 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg0 * _sellPrice << 2) / 1000).gas(!((varg0 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    0x217b(varg0, this, msg.sender);\n    _solvency = (address(this)).balance - (varg0 * _sellPrice + (varg0 * _sellPrice << 2) / 1000);\n    v1 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction setDividends(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg1);\n    _dividends[varg0] = varg1;\n    return 1;\n}\n\nfunction 0xc8b() private { \n    require(!_closeBuy);\n    assert(_buyPrice);\n    v0 = msg.value / _buyPrice * _buyPrice - msg.value / _buyPrice * _sellPrice - (msg.value / _buyPrice * _buyPrice << 2) / 1000;\n    require((address(this)).balance >= (msg.value / _buyPrice * _buyPrice << 2) / 1000);\n    v1 = _comisionGetter.call().value((msg.value / _buyPrice * _buyPrice << 2) / 1000).gas(!((msg.value / _buyPrice * _buyPrice << 2) / 1000) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    0x217b(msg.value / _buyPrice, msg.sender, this);\n    _solvency = (address(this)).balance - v0;\n    0x2485(1, v0);\n    v2 = _owner.call().value(v0).gas(!v0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x1573e8a5 == function_selector) {\n            adminResetEmail(address,string);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x282b065a == function_selector) {\n            setEmail(string);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x5c4fb1c5 == function_selector) {\n            comisionGetter();\n        } else if (0x60659a92 == function_selector) {\n            tokensAvailable();\n        } else if (0x66d16cc3 == function_selector) {\n            profit();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x773c5049 == function_selector) {\n            solvency();\n        } else if (0x79c65068 == function_selector) {\n            mintToken(address,uint256);\n        } else if (0x7ef5b6ea == function_selector) {\n            refillTokens(uint256);\n        } else if (0x814b3fe0 == function_selector) {\n            dividends(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9fb52b6e == function_selector) {\n            dividendsGetPaid(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb3c2eac1 == function_selector) {\n            setStatus(bool,bool);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xba83c970 == function_selector) {\n            closeSell();\n        } else if (0xc6ab5cdc == function_selector) {\n            closeBuy();\n        } else if (0xcb2da07c == function_selector) {\n            emails(address);\n        } else if (0xcca00971 == function_selector) {\n            paidDividends(address,uint256);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfaad4a49 == function_selector) {\n            setDividends(uint256,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _tokensAvailable; // STORAGE[0xa]\nuint256 _solvency; // STORAGE[0xb]\nuint256 _profit; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _emails; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _dividends; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _paidDividends; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x11]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _closeBuy; // STORAGE[0x9] bytes 0 to 0\nuint8 _closeSell; // STORAGE[0x9] bytes 1 to 1\naddress _comisionGetter; // STORAGE[0xd] bytes 0 to 19\n\n// Events\nLogWithdrawal(address, uint256);\nTransfer(address, address, uint256);\nLogDeposit(address, uint256);\nFrozenFunds(address, bool);\n\nfunction fallback() public payable { \n    0xc8b();\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x217b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balanceOf[v2] + varg0 > _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v5] - varg0;\n    v6 = address(varg1);\n    _balanceOf[v6] = _balanceOf[v6] + varg0;\n    _tokensAvailable = _balanceOf[address(this)];\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction 0x2485(uint256 varg0, uint256 varg1) private { \n    if (!varg0) {\n        if (varg1 <= _profit) {\n            _profit = _profit - varg1;\n        } else {\n            _profit = 0;\n        }\n    } else {\n        _profit = _profit + varg1;\n    }\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction adminResetEmail(address varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    require(msg.sender == _owner);\n    require(_balanceOf[varg0] > 0);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _emails[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _emails[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    require((address(this)).balance >= (varg2 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg2 * _sellPrice << 2) / 1000).gas(!((varg2 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x217b(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction setEmail(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(_balanceOf[msg.sender] > 0);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _emails[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _emails[msg.sender] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _emails[msg.sender]) << 8) - 1 & _emails[msg.sender]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    return 1;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit LogWithdrawal(msg.sender, varg0);\n    _solvency = (address(this)).balance - varg0;\n    0x2485(1, varg0);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction comisionGetter() public nonPayable { \n    return _comisionGetter;\n}\n\nfunction tokensAvailable() public nonPayable { \n    return _tokensAvailable;\n}\n\nfunction profit() public nonPayable { \n    return _profit;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction solvency() public nonPayable { \n    return _solvency;\n}\n\nfunction mintToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    _tokensAvailable = _balanceOf[address(this)];\n    emit Transfer(0, address(this), varg1);\n    emit Transfer(address(this), varg0, varg1);\n}\n\nfunction refillTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x217b(varg0, this, msg.sender);\n}\n\nfunction dividends(uint256 varg0) public nonPayable { \n    return _dividends[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction dividendsGetPaid(uint256 varg0) public nonPayable { \n    require(!(0xff & _frozenAccount[msg.sender]));\n    require(_balanceOf[msg.sender] > 0);\n    require(_dividends[varg0] > 0);\n    assert(varg0 < _paidDividends[msg.sender]);\n    require(STORAGE[keccak256(keccak256(msg.sender, 16)) + varg0] == 0);\n    assert(_totalSupply);\n    v0 = _balanceOf[msg.sender] / _totalSupply * 10000 * _dividends[varg0] / 10000;\n    require((address(this)).balance >= v0);\n    assert(varg0 < _paidDividends[msg.sender]);\n    STORAGE[keccak256(keccak256(msg.sender, 16)) + varg0] = v0;\n    emit LogWithdrawal(msg.sender, v0);\n    _solvency = (address(this)).balance - v0;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(1);\n    return 1;\n}\n\nfunction buy() public payable { \n    0xc8b();\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require((address(this)).balance >= (varg1 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg1 * _sellPrice << 2) / 1000).gas(!((varg1 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    0x217b(varg1, varg0, msg.sender);\n}\n\nfunction setStatus(bool varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _closeBuy = varg0;\n    _closeSell = varg1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction closeSell() public nonPayable { \n    return _closeSell;\n}\n\nfunction closeBuy() public nonPayable { \n    return _closeBuy;\n}\n\nfunction emails(address varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _emails[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction paidDividends(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 < _paidDividends[varg0]);\n    return STORAGE[keccak256(keccak256(varg0, 16)) + varg1];\n}\n\nfunction deposit() public payable { \n    require((address(this)).balance + msg.value > (address(this)).balance);\n    _solvency = (address(this)).balance;\n    0x2485(0, msg.value);\n    emit LogDeposit(msg.sender, msg.value);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(!_closeSell);\n    require((address(this)).balance >= varg0 * _sellPrice + (varg0 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg0 * _sellPrice << 2) / 1000).gas(!((varg0 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    0x217b(varg0, this, msg.sender);\n    _solvency = (address(this)).balance - (varg0 * _sellPrice + (varg0 * _sellPrice << 2) / 1000);\n    v1 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction setDividends(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg1);\n    _dividends[varg0] = varg1;\n    return 1;\n}\n\nfunction 0xc8b() private { \n    require(!_closeBuy);\n    assert(_buyPrice);\n    v0 = msg.value / _buyPrice * _buyPrice - msg.value / _buyPrice * _sellPrice - (msg.value / _buyPrice * _buyPrice << 2) / 1000;\n    require((address(this)).balance >= (msg.value / _buyPrice * _buyPrice << 2) / 1000);\n    v1 = _comisionGetter.call().value((msg.value / _buyPrice * _buyPrice << 2) / 1000).gas(!((msg.value / _buyPrice * _buyPrice << 2) / 1000) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    0x217b(msg.value / _buyPrice, msg.sender, this);\n    _solvency = (address(this)).balance - v0;\n    0x2485(1, v0);\n    v2 = _owner.call().value(v0).gas(!v0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x1573e8a5 == function_selector) {\n            adminResetEmail(address,string);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x282b065a == function_selector) {\n            setEmail(string);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x5c4fb1c5 == function_selector) {\n            comisionGetter();\n        } else if (0x60659a92 == function_selector) {\n            tokensAvailable();\n        } else if (0x66d16cc3 == function_selector) {\n            profit();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x773c5049 == function_selector) {\n            solvency();\n        } else if (0x79c65068 == function_selector) {\n            mintToken(address,uint256);\n        } else if (0x7ef5b6ea == function_selector) {\n            refillTokens(uint256);\n        } else if (0x814b3fe0 == function_selector) {\n            dividends(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9fb52b6e == function_selector) {\n            dividendsGetPaid(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb3c2eac1 == function_selector) {\n            setStatus(bool,bool);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xba83c970 == function_selector) {\n            closeSell();\n        } else if (0xc6ab5cdc == function_selector) {\n            closeBuy();\n        } else if (0xcb2da07c == function_selector) {\n            emails(address);\n        } else if (0xcca00971 == function_selector) {\n            paidDividends(address,uint256);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfaad4a49 == function_selector) {\n            setDividends(uint256,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _sellPrice; // STORAGE[0x7]\nuint256 _buyPrice; // STORAGE[0x8]\nuint256 _tokensAvailable; // STORAGE[0xa]\nuint256 _solvency; // STORAGE[0xb]\nuint256 _profit; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _emails; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _dividends; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _paidDividends; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _frozenAccount; // STORAGE[0x11]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _closeBuy; // STORAGE[0x9] bytes 0 to 0\nuint8 _closeSell; // STORAGE[0x9] bytes 1 to 1\naddress _comisionGetter; // STORAGE[0xd] bytes 0 to 19\n\n// Events\nLogWithdrawal(address, uint256);\nTransfer(address, address, uint256);\nLogDeposit(address, uint256);\nFrozenFunds(address, bool);\n\nfunction fallback() public payable { \n    0xc8b();\n}\n\nfunction setPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _sellPrice = varg0;\n    _buyPrice = varg1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0x217b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1) != 0);\n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    v2 = address(varg1);\n    require(_balanceOf[v2] + varg0 > _balanceOf[v1]);\n    v3 = address(varg2);\n    require(!(0xff & _frozenAccount[v3]));\n    v4 = address(varg1);\n    require(!(0xff & _frozenAccount[v4]));\n    v5 = address(varg2);\n    _balanceOf[v5] = _balanceOf[v5] - varg0;\n    v6 = address(varg1);\n    _balanceOf[v6] = _balanceOf[v6] + varg0;\n    _tokensAvailable = _balanceOf[address(this)];\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction 0x2485(uint256 varg0, uint256 varg1) private { \n    if (!varg0) {\n        if (varg1 <= _profit) {\n            _profit = _profit - varg1;\n        } else {\n            _profit = 0;\n        }\n    } else {\n        _profit = _profit + varg1;\n    }\n    return ;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction adminResetEmail(address varg0, string varg1) public nonPayable { \n    v0 = new bytes[](varg1.length);\n    CALLDATACOPY(v0.data, 36 + varg1, varg1.length);\n    require(msg.sender == _owner);\n    require(_balanceOf[varg0] > 0);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _emails[varg0] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _emails[varg0] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    require((address(this)).balance >= (varg2 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg2 * _sellPrice << 2) / 1000).gas(!((varg2 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x217b(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction setEmail(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    require(_balanceOf[msg.sender] > 0);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _emails[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _emails[msg.sender] = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _emails[msg.sender]) << 8) - 1 & _emails[msg.sender]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    return 1;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit LogWithdrawal(msg.sender, varg0);\n    _solvency = (address(this)).balance - varg0;\n    0x2485(1, varg0);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction sellPrice() public nonPayable { \n    return _sellPrice;\n}\n\nfunction comisionGetter() public nonPayable { \n    return _comisionGetter;\n}\n\nfunction tokensAvailable() public nonPayable { \n    return _tokensAvailable;\n}\n\nfunction profit() public nonPayable { \n    return _profit;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction solvency() public nonPayable { \n    return _solvency;\n}\n\nfunction mintToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    _totalSupply = _totalSupply + varg1;\n    _tokensAvailable = _balanceOf[address(this)];\n    emit Transfer(0, address(this), varg1);\n    emit Transfer(address(this), varg0, varg1);\n}\n\nfunction refillTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x217b(varg0, this, msg.sender);\n}\n\nfunction dividends(uint256 varg0) public nonPayable { \n    return _dividends[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction dividendsGetPaid(uint256 varg0) public nonPayable { \n    require(!(0xff & _frozenAccount[msg.sender]));\n    require(_balanceOf[msg.sender] > 0);\n    require(_dividends[varg0] > 0);\n    assert(varg0 < _paidDividends[msg.sender]);\n    require(STORAGE[keccak256(keccak256(msg.sender, 16)) + varg0] == 0);\n    assert(_totalSupply);\n    v0 = _balanceOf[msg.sender] / _totalSupply * 10000 * _dividends[varg0] / 10000;\n    require((address(this)).balance >= v0);\n    assert(varg0 < _paidDividends[msg.sender]);\n    STORAGE[keccak256(keccak256(msg.sender, 16)) + varg0] = v0;\n    emit LogWithdrawal(msg.sender, v0);\n    _solvency = (address(this)).balance - v0;\n    v1 = msg.sender.call().value(v0).gas(!v0 * 2300);\n    require(v1); // checks call status, propagates error data on error\n    require(1);\n    return 1;\n}\n\nfunction buy() public payable { \n    0xc8b();\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require((address(this)).balance >= (varg1 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg1 * _sellPrice << 2) / 1000).gas(!((varg1 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    0x217b(varg1, varg0, msg.sender);\n}\n\nfunction setStatus(bool varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _closeBuy = varg0;\n    _closeSell = varg1;\n}\n\nfunction frozenAccount(address varg0) public nonPayable { \n    return 0xff & _frozenAccount[varg0];\n}\n\nfunction closeSell() public nonPayable { \n    return _closeSell;\n}\n\nfunction closeBuy() public nonPayable { \n    return _closeBuy;\n}\n\nfunction emails(address varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) {\n        if (31 < ((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _emails[varg0]) << 8) - 1 & _emails[varg0]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _emails[varg0] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction paidDividends(address varg0, uint256 varg1) public nonPayable { \n    assert(varg1 < _paidDividends[varg0]);\n    return STORAGE[keccak256(keccak256(varg0, 16)) + varg1];\n}\n\nfunction deposit() public payable { \n    require((address(this)).balance + msg.value > (address(this)).balance);\n    _solvency = (address(this)).balance;\n    0x2485(0, msg.value);\n    emit LogDeposit(msg.sender, msg.value);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    require(!_closeSell);\n    require((address(this)).balance >= varg0 * _sellPrice + (varg0 * _sellPrice << 2) / 1000);\n    v0 = _comisionGetter.call().value((varg0 * _sellPrice << 2) / 1000).gas(!((varg0 * _sellPrice << 2) / 1000) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    0x217b(varg0, this, msg.sender);\n    _solvency = (address(this)).balance - (varg0 * _sellPrice + (varg0 * _sellPrice << 2) / 1000);\n    v1 = msg.sender.call().value(varg0 * _sellPrice).gas(!(varg0 * _sellPrice) * 2300);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction freezeAccount(address varg0, bool varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _frozenAccount[varg0] = varg1 | ~0xff & _frozenAccount[varg0];\n    emit FrozenFunds(varg0, varg1);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction setDividends(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance >= varg1);\n    _dividends[varg0] = varg1;\n    return 1;\n}\n\nfunction 0xc8b() private { \n    require(!_closeBuy);\n    assert(_buyPrice);\n    v0 = msg.value / _buyPrice * _buyPrice - msg.value / _buyPrice * _sellPrice - (msg.value / _buyPrice * _buyPrice << 2) / 1000;\n    require((address(this)).balance >= (msg.value / _buyPrice * _buyPrice << 2) / 1000);\n    v1 = _comisionGetter.call().value((msg.value / _buyPrice * _buyPrice << 2) / 1000).gas(!((msg.value / _buyPrice * _buyPrice << 2) / 1000) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    0x217b(msg.value / _buyPrice, msg.sender, this);\n    _solvency = (address(this)).balance - v0;\n    0x2485(1, v0);\n    v2 = _owner.call().value(v0).gas(!v0 * 2300);\n    require(v2); // checks call status, propagates error data on error\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x5fefda7 == function_selector) {\n            setPrices(uint256,uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x1573e8a5 == function_selector) {\n            adminResetEmail(address,string);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x282b065a == function_selector) {\n            setEmail(string);\n        } else if (0x2e1a7d4d == function_selector) {\n            withdraw(uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x5c4fb1c5 == function_selector) {\n            comisionGetter();\n        } else if (0x60659a92 == function_selector) {\n            tokensAvailable();\n        } else if (0x66d16cc3 == function_selector) {\n            profit();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x773c5049 == function_selector) {\n            solvency();\n        } else if (0x79c65068 == function_selector) {\n            mintToken(address,uint256);\n        } else if (0x7ef5b6ea == function_selector) {\n            refillTokens(uint256);\n        } else if (0x814b3fe0 == function_selector) {\n            dividends(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9fb52b6e == function_selector) {\n            dividendsGetPaid(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb3c2eac1 == function_selector) {\n            setStatus(bool,bool);\n        } else if (0xb414d4b6 == function_selector) {\n            frozenAccount(address);\n        } else if (0xba83c970 == function_selector) {\n            closeSell();\n        } else if (0xc6ab5cdc == function_selector) {\n            closeBuy();\n        } else if (0xcb2da07c == function_selector) {\n            emails(address);\n        } else if (0xcca00971 == function_selector) {\n            paidDividends(address,uint256);\n        } else if (0xd0e30db0 == function_selector) {\n            deposit();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe724529c == function_selector) {\n            freezeAccount(address,bool);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfaad4a49 == function_selector) {\n            setDividends(uint256,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 36.664440393447876,
	"usage": {
		"completion_tokens": 514,
		"prompt_tokens": 5034,
		"total_tokens": 5548
	}
}