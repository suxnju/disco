{
	"address": "0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code that could resemble the provided decompiled code. Please note that the decompiled code is not perfect and might have inconsistencies, hence the Solidity code might not be perfect either.\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract CryptoPunks {\n\n    struct Punk {\n        bool isAssigned;\n        address owner;\n    }\n\n    uint constant punkCount = 10000;\n    mapping (uint => Punk) punks;\n    mapping (address => uint) pendingWithdrawals;\n    uint punksRemainingToAssign = punkCount;\n    address owner;\n\n    event Assign(address indexed to, uint punkIndex);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function getPunk(uint punkIndex) public {\n        require(punksRemainingToAssign != 0);\n        require(!punks[punkIndex].isAssigned);\n        punks[punkIndex].owner = msg.sender;\n        punks[punkIndex].isAssigned = true;\n        punksRemainingToAssign--;\n        emit Assign(msg.sender, punkIndex);\n    }\n\n    function transferPunk(address to, uint punkIndex) public {\n        require(punks[punkIndex].isAssigned);\n        require(punks[punkIndex].owner == msg.sender);\n        punks[punkIndex].owner = to;\n        emit Assign(to, punkIndex);\n    }\n\n    function punkIndexToAddress(uint punkIndex) public view returns (address) {\n        return punks[punkIndex].owner;\n    }\n}\n```\n\nThis contract allows for the creation of 10,000 \"CryptoPunks\", which can be claimed by any Ethereum address. Once claimed, they can be transferred to another address by the current owner. The current owner of a specific CryptoPunk can be looked up using the `punkIndexToAddress()` function.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038639,
	"id": "chatcmpl-8Chhv03651hBD3ZblYVgMnIzshhPp",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 17:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _imageHash; // STORAGE[0x0]\nuint256[] _standard; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 _nextPunkIndexToAssign; // STORAGE[0x7]\nuint256 _punksRemainingToAssign; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _punkIndexToAddress; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _punksOfferedForSale; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _punkBids; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _pendingWithdrawals; // STORAGE[0xe]\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _allPunksAssigned; // STORAGE[0x8] bytes 0 to 0\naddress _allInitialOwnersAssigned; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nPunkBidEntered(uint256, uint256, address);\nTransfer(address, address, uint256);\nPunkBought(uint256, uint256, address, address);\nPunkBidWithdrawn(uint256, uint256, address);\nAssign(address, uint256);\nPunkOffered(uint256, uint256, address);\nPunkNoLongerForSale(uint256);\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction 0x1a0b(uint256 varg0) private { \n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    _punksOfferedForSale[varg0] = _punksOfferedForSale[varg0] & ~0xff | 0x0;\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2] | msg.sender;\n    _punksOfferedForSale[varg0][3] = 0;\n    _punksOfferedForSale[varg0][4] = _punksOfferedForSale[varg0][0x4] & ~0xffffffffffffffffffffffffffffffffffffffff | 0x0;\n    emit PunkNoLongerForSale(varg0);\n    return ;\n}\n\nfunction punksOfferedForSale(uint256 varg0) public payable { \n    assert(!msg.value);\n    return _punksOfferedForSale[varg0] & 0xff, _punksOfferedForSale[varg0][1], address(_punksOfferedForSale[varg0][0x2]), _punksOfferedForSale[varg0][3], address(_punksOfferedForSale[varg0][0x4]);\n}\n\nfunction enterBidForPunk(uint256 varg0) public payable { \n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]));\n    require(address(_punkIndexToAddress[varg0]) != msg.sender);\n    require(msg.value);\n    require(msg.value > _punkBids[varg0][3]);\n    if (_punkBids[varg0][3] > 0) {\n        _pendingWithdrawals[address(_punkBids[varg0][0x2])] += _punkBids[varg0][3];\n    }\n    v0 = new array[](1);\n    _punkBids[varg0] = v0.length | ~0xff & _punkBids[varg0];\n    _punkBids[varg0][1] = varg0;\n    _punkBids[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[varg0][0x2];\n    _punkBids[varg0][3] = msg.value;\n    emit PunkBidEntered(varg0, msg.sender, msg.value);\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction acceptBidForPunk(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(_punkBids[varg0][3]);\n    require(_punkBids[varg0][3] >= varg1);\n    _punkIndexToAddress[varg0] = address(_punkBids[varg0][0x2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[msg.sender] += ~0;\n    v0 = address(_punkBids[varg0][0x2]);\n    _punkIndexToAddress[v0] += 1;\n    emit Transfer(msg.sender, address(_punkBids[varg0][0x2]), 1);\n    _punksOfferedForSale[v0][0] = 0x0 | ~0xff & _punksOfferedForSale[v0][0x0];\n    _punksOfferedForSale[v0][1] = varg0;\n    _punksOfferedForSale[v0][2] = address(_punkBids[varg0][2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[v0][0x2];\n    _punksOfferedForSale[v0][3] = 0;\n    _punksOfferedForSale[v0][4] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[v0][0x4];\n    _punkBids[v0][0] = 0x0 | ~0xff & _punkBids[v0][0x0];\n    _punkBids[v0][1] = varg0;\n    _punkBids[v0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[v0][0x2];\n    _punkBids[v0][3] = 0;\n    _pendingWithdrawals[msg.sender] = _pendingWithdrawals[msg.sender] + _punkBids[varg0][3];\n    emit PunkBought(varg0, msg.sender, address(_punkBids[varg0][2]), _punkBids[varg0][3]);\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction setInitialOwners(address[] varg0, uint256[] varg1) public payable { \n    assert(!msg.value);\n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length << 5);\n    CALLDATACOPY(v1.data, 36 + varg1, varg1.length << 5);\n    require(_allInitialOwnersAssigned == msg.sender);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        assert(v2 < v0.length);\n        assert(v2 < v1.length);\n        v4 = v1[v2];\n        require(_allInitialOwnersAssigned == msg.sender);\n        require(!_allPunksAssigned);\n        require(v4 < 10000);\n        if (address(_punkIndexToAddress[v4]) != address(v0[v2])) {\n            if (!address(_punkIndexToAddress[v4])) {\n                _punksRemainingToAssign += ~0;\n            } else {\n                _punkIndexToAddress[v4] += ~0;\n            }\n            _punkIndexToAddress[v4] = address(v0[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[v4];\n            _punkIndexToAddress[address(v0[v2])] += 1;\n            emit Assign(address(v0[v2]), v4);\n            goto 0xd30B0x2af;\n        }\n        v2 += 1;\n    }\n}\n\nfunction withdraw() public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    _pendingWithdrawals[msg.sender] = 0;\n    v0 = msg.sender.call().value(_pendingWithdrawals[msg.sender]).gas(2300 * !_pendingWithdrawals[msg.sender]);\n    assert(v0);\n}\n\nfunction imageHash() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) {\n        if (31 < (_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _imageHash.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction nextPunkIndexToAssign() public payable { \n    assert(!msg.value);\n    return _nextPunkIndexToAssign;\n}\n\nfunction punkIndexToAddress(uint256 varg0) public payable { \n    assert(!msg.value);\n    return address(_punkIndexToAddress[varg0]);\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction punkBids(uint256 varg0) public payable { \n    assert(!msg.value);\n    return _punkBids[varg0] & 0xff, _punkBids[varg0][1], address(_punkBids[varg0][0x2]), _punkBids[varg0][3];\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction allInitialOwnersAssigned() public payable { \n    assert(!msg.value);\n    require(_allInitialOwnersAssigned == msg.sender);\n    _allPunksAssigned = 1;\n}\n\nfunction allPunksAssigned() public payable { \n    assert(!msg.value);\n    return _allPunksAssigned;\n}\n\nfunction buyPunk(uint256 varg0) public payable { \n    require(_allPunksAssigned);\n    require(varg0 < 10000);\n    require(0xff & _punksOfferedForSale[varg0]);\n    v0 = v1 = address(_punksOfferedForSale[varg0][0x4]);\n    if (address(_punksOfferedForSale[varg0][0x4])) {\n        v0 = address(_punksOfferedForSale[varg0][0x4]) != msg.sender;\n    }\n    require(!v0);\n    require(msg.value >= _punksOfferedForSale[varg0][3]);\n    require(address(_punkIndexToAddress[varg0]) == address(_punksOfferedForSale[varg0][0x2]));\n    _punkIndexToAddress[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[address(_punksOfferedForSale[varg0][0x2])] += ~0;\n    _punkIndexToAddress[address(_punksOfferedForSale[varg0][0x2])] += 1;\n    emit Transfer(address(_punksOfferedForSale[varg0][0x2]), msg.sender, 1);\n    0x1a0b(varg0);\n    _pendingWithdrawals[address(_punksOfferedForSale[varg0][0x2])] += msg.value;\n    emit PunkBought(varg0, address(_punksOfferedForSale[varg0][0x2]), msg.sender, msg.value);\n    if (address(_pendingWithdrawals[address(address(_punksOfferedForSale[varg0][0x2]))][0x2]) == msg.sender) {\n        _pendingWithdrawals[msg.sender] += _pendingWithdrawals[address(_punksOfferedForSale[varg0][0x2])][3];\n        _pendingWithdrawals[msg.sender] = 0x0 | ~0xff & _pendingWithdrawals[msg.sender];\n        _pendingWithdrawals[msg.sender][1] = varg0;\n        _pendingWithdrawals[msg.sender][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingWithdrawals[msg.sender][0x2];\n        _pendingWithdrawals[msg.sender][3] = 0;\n        goto 0x2450x55e;\n    }\n}\n\nfunction transferPunk(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg1]) == msg.sender);\n    require(varg1 < 10000);\n    if (0xff & _punksOfferedForSale[varg1]) {\n        0x1a0b(varg1);\n    }\n    _punkIndexToAddress[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg1];\n    _punkIndexToAddress[msg.sender] += ~0;\n    _punkIndexToAddress[msg.sender] += 1;\n    emit Transfer(msg.sender, varg0, 1);\n    emit 0x5af636b70da6819000c49f85b21fa82081c632069bb626f30932034099107d8(msg.sender, varg0, varg1);\n    if (address(_punkBids[address(msg.sender)][0x2]) == varg0) {\n        v0 = varg0;\n        _pendingWithdrawals[v0] += _punkBids[msg.sender][3];\n        _pendingWithdrawals[v0] = 0x0 | ~0xff & _pendingWithdrawals[v0];\n        _pendingWithdrawals[v0][1] = varg1;\n        _pendingWithdrawals[v0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingWithdrawals[v0][0x2];\n        _pendingWithdrawals[v0][3] = 0;\n    }\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction withdrawBidForPunk(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]));\n    require(address(_punkIndexToAddress[varg0]) != msg.sender);\n    require(address(_punkBids[varg0][0x2]) == msg.sender);\n    emit PunkBidWithdrawn(varg0, msg.sender, _punkBids[varg0][3]);\n    _punkBids[varg0] = 0x0 | ~0xff & _punkBids[varg0];\n    _punkBids[varg0][1] = varg0;\n    _punkBids[varg0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[varg0][0x2];\n    _punkBids[varg0][3] = 0;\n    v0 = msg.sender.call().value(_punkBids[varg0][3]).gas(!_punkBids[varg0][3] * 2300);\n    assert(v0);\n}\n\nfunction setInitialOwner(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allInitialOwnersAssigned == msg.sender);\n    require(!_allPunksAssigned);\n    require(varg1 < 10000);\n    if (address(_punkIndexToAddress[varg1]) != varg0) {\n        if (!address(_punkIndexToAddress[varg1])) {\n            _punksRemainingToAssign += ~0;\n        } else {\n            _punkIndexToAddress[address(_punkIndexToAddress[varg1])] += ~0;\n        }\n        _punkIndexToAddress[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg1];\n        _punkIndexToAddress[varg0] += 1;\n        emit Assign(varg0, varg1);\n        goto 0x2450x631;\n    }\n}\n\nfunction offerPunkForSaleToAddress(uint256 varg0, uint256 varg1, address varg2) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    v0 = new array[](1);\n    _punksOfferedForSale[varg0] = v0.length | ~0xff & _punksOfferedForSale[varg0];\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2];\n    _punksOfferedForSale[varg0][3] = varg1;\n    _punksOfferedForSale[varg0][4] = varg2 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x4];\n    emit PunkOffered(varg0, varg2, varg1);\n}\n\nfunction punksRemainingToAssign() public payable { \n    assert(!msg.value);\n    return _punksRemainingToAssign;\n}\n\nfunction offerPunkForSale(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    v0 = new array[](1);\n    _punksOfferedForSale[varg0] = v0.length | ~0xff & _punksOfferedForSale[varg0];\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2];\n    _punksOfferedForSale[varg0][3] = varg1;\n    _punksOfferedForSale[varg0][4] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x4];\n    emit PunkOffered(varg0, 0, varg1);\n}\n\nfunction getPunk(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(_punksRemainingToAssign);\n    require(!address(_punkIndexToAddress[varg0]));\n    require(varg0 < 10000);\n    _punkIndexToAddress[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[msg.sender] += 1;\n    _punksRemainingToAssign += ~0;\n    emit Assign(msg.sender, varg0);\n}\n\nfunction pendingWithdrawals(address varg0) public payable { \n    assert(!msg.value);\n    return _pendingWithdrawals[varg0];\n}\n\nfunction punkNoLongerForSale(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1a0b(varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x88f11f3 == function_selector) {\n            punksOfferedForSale(uint256);\n        } else if (0x91dbfd2 == function_selector) {\n            enterBidForPunk(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23165b75 == function_selector) {\n            acceptBidForPunk(uint256,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x39c5dde6 == function_selector) {\n            setInitialOwners(address[],uint256[]);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x51605d80 == function_selector) {\n            imageHash();\n        } else if (0x52f29a25 == function_selector) {\n            nextPunkIndexToAssign();\n        } else if (0x58178168 == function_selector) {\n            punkIndexToAddress(uint256);\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x6e743fa9 == function_selector) {\n            punkBids(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7ecedac9 == function_selector) {\n            allInitialOwnersAssigned();\n        } else if (0x8126c38a == function_selector) {\n            allPunksAssigned();\n        } else if (0x8264fe98 == function_selector) {\n            buyPunk(uint256);\n        } else if (0x8b72a2ec == function_selector) {\n            transferPunk(address,uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x979bc638 == function_selector) {\n            withdrawBidForPunk(uint256);\n        } else if (0xa75a9049 == function_selector) {\n            setInitialOwner(address,uint256);\n        } else if (0xbf31196f == function_selector) {\n            offerPunkForSaleToAddress(uint256,uint256,address);\n        } else if (0xc0d6ce63 == function_selector) {\n            punksRemainingToAssign();\n        } else if (0xc44193c3 == function_selector) {\n            offerPunkForSale(uint256,uint256);\n        } else if (0xc81d1d5b == function_selector) {\n            getPunk(uint256);\n        } else if (0xf3f43703 == function_selector) {\n            pendingWithdrawals(address);\n        } else if (0xf6eeff1e == function_selector) {\n            punkNoLongerForSale(uint256);\n        }\n    }\n    throw();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 17:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _imageHash; // STORAGE[0x0]\nuint256[] _standard; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 _nextPunkIndexToAssign; // STORAGE[0x7]\nuint256 _punksRemainingToAssign; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _punkIndexToAddress; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _punksOfferedForSale; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _punkBids; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _pendingWithdrawals; // STORAGE[0xe]\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _allPunksAssigned; // STORAGE[0x8] bytes 0 to 0\naddress _allInitialOwnersAssigned; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nPunkBidEntered(uint256, uint256, address);\nTransfer(address, address, uint256);\nPunkBought(uint256, uint256, address, address);\nPunkBidWithdrawn(uint256, uint256, address);\nAssign(address, uint256);\nPunkOffered(uint256, uint256, address);\nPunkNoLongerForSale(uint256);\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction 0x1a0b(uint256 varg0) private { \n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    _punksOfferedForSale[varg0] = _punksOfferedForSale[varg0] & ~0xff | 0x0;\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2] | msg.sender;\n    _punksOfferedForSale[varg0][3] = 0;\n    _punksOfferedForSale[varg0][4] = _punksOfferedForSale[varg0][0x4] & ~0xffffffffffffffffffffffffffffffffffffffff | 0x0;\n    emit PunkNoLongerForSale(varg0);\n    return ;\n}\n\nfunction punksOfferedForSale(uint256 varg0) public payable { \n    assert(!msg.value);\n    return _punksOfferedForSale[varg0] & 0xff, _punksOfferedForSale[varg0][1], address(_punksOfferedForSale[varg0][0x2]), _punksOfferedForSale[varg0][3], address(_punksOfferedForSale[varg0][0x4]);\n}\n\nfunction enterBidForPunk(uint256 varg0) public payable { \n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]));\n    require(address(_punkIndexToAddress[varg0]) != msg.sender);\n    require(msg.value);\n    require(msg.value > _punkBids[varg0][3]);\n    if (_punkBids[varg0][3] > 0) {\n        _pendingWithdrawals[address(_punkBids[varg0][0x2])] += _punkBids[varg0][3];\n    }\n    v0 = new array[](1);\n    _punkBids[varg0] = v0.length | ~0xff & _punkBids[varg0];\n    _punkBids[varg0][1] = varg0;\n    _punkBids[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[varg0][0x2];\n    _punkBids[varg0][3] = msg.value;\n    emit PunkBidEntered(varg0, msg.sender, msg.value);\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction acceptBidForPunk(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(_punkBids[varg0][3]);\n    require(_punkBids[varg0][3] >= varg1);\n    _punkIndexToAddress[varg0] = address(_punkBids[varg0][0x2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[msg.sender] += ~0;\n    v0 = address(_punkBids[varg0][0x2]);\n    _punkIndexToAddress[v0] += 1;\n    emit Transfer(msg.sender, address(_punkBids[varg0][0x2]), 1);\n    _punksOfferedForSale[v0][0] = 0x0 | ~0xff & _punksOfferedForSale[v0][0x0];\n    _punksOfferedForSale[v0][1] = varg0;\n    _punksOfferedForSale[v0][2] = address(_punkBids[varg0][2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[v0][0x2];\n    _punksOfferedForSale[v0][3] = 0;\n    _punksOfferedForSale[v0][4] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[v0][0x4];\n    _punkBids[v0][0] = 0x0 | ~0xff & _punkBids[v0][0x0];\n    _punkBids[v0][1] = varg0;\n    _punkBids[v0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[v0][0x2];\n    _punkBids[v0][3] = 0;\n    _pendingWithdrawals[msg.sender] = _pendingWithdrawals[msg.sender] + _punkBids[varg0][3];\n    emit PunkBought(varg0, msg.sender, address(_punkBids[varg0][2]), _punkBids[varg0][3]);\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction setInitialOwners(address[] varg0, uint256[] varg1) public payable { \n    assert(!msg.value);\n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length << 5);\n    CALLDATACOPY(v1.data, 36 + varg1, varg1.length << 5);\n    require(_allInitialOwnersAssigned == msg.sender);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        assert(v2 < v0.length);\n        assert(v2 < v1.length);\n        v4 = v1[v2];\n        require(_allInitialOwnersAssigned == msg.sender);\n        require(!_allPunksAssigned);\n        require(v4 < 10000);\n        if (address(_punkIndexToAddress[v4]) != address(v0[v2])) {\n            if (!address(_punkIndexToAddress[v4])) {\n                _punksRemainingToAssign += ~0;\n            } else {\n                _punkIndexToAddress[v4] += ~0;\n            }\n            _punkIndexToAddress[v4] = address(v0[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[v4];\n            _punkIndexToAddress[address(v0[v2])] += 1;\n            emit Assign(address(v0[v2]), v4);\n            goto 0xd30B0x2af;\n        }\n        v2 += 1;\n    }\n}\n\nfunction withdraw() public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    _pendingWithdrawals[msg.sender] = 0;\n    v0 = msg.sender.call().value(_pendingWithdrawals[msg.sender]).gas(2300 * !_pendingWithdrawals[msg.sender]);\n    assert(v0);\n}\n\nfunction imageHash() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) {\n        if (31 < (_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _imageHash.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction nextPunkIndexToAssign() public payable { \n    assert(!msg.value);\n    return _nextPunkIndexToAssign;\n}\n\nfunction punkIndexToAddress(uint256 varg0) public payable { \n    assert(!msg.value);\n    return address(_punkIndexToAddress[varg0]);\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction punkBids(uint256 varg0) public payable { \n    assert(!msg.value);\n    return _punkBids[varg0] & 0xff, _punkBids[varg0][1], address(_punkBids[varg0][0x2]), _punkBids[varg0][3];\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction allInitialOwnersAssigned() public payable { \n    assert(!msg.value);\n    require(_allInitialOwnersAssigned == msg.sender);\n    _allPunksAssigned = 1;\n}\n\nfunction allPunksAssigned() public payable { \n    assert(!msg.value);\n    return _allPunksAssigned;\n}\n\nfunction buyPunk(uint256 varg0) public payable { \n    require(_allPunksAssigned);\n    require(varg0 < 10000);\n    require(0xff & _punksOfferedForSale[varg0]);\n    v0 = v1 = address(_punksOfferedForSale[varg0][0x4]);\n    if (address(_punksOfferedForSale[varg0][0x4])) {\n        v0 = address(_punksOfferedForSale[varg0][0x4]) != msg.sender;\n    }\n    require(!v0);\n    require(msg.value >= _punksOfferedForSale[varg0][3]);\n    require(address(_punkIndexToAddress[varg0]) == address(_punksOfferedForSale[varg0][0x2]));\n    _punkIndexToAddress[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[address(_punksOfferedForSale[varg0][0x2])] += ~0;\n    _punkIndexToAddress[address(_punksOfferedForSale[varg0][0x2])] += 1;\n    emit Transfer(address(_punksOfferedForSale[varg0][0x2]), msg.sender, 1);\n    0x1a0b(varg0);\n    _pendingWithdrawals[address(_punksOfferedForSale[varg0][0x2])] += msg.value;\n    emit PunkBought(varg0, address(_punksOfferedForSale[varg0][0x2]), msg.sender, msg.value);\n    if (address(_pendingWithdrawals[address(address(_punksOfferedForSale[varg0][0x2]))][0x2]) == msg.sender) {\n        _pendingWithdrawals[msg.sender] += _pendingWithdrawals[address(_punksOfferedForSale[varg0][0x2])][3];\n        _pendingWithdrawals[msg.sender] = 0x0 | ~0xff & _pendingWithdrawals[msg.sender];\n        _pendingWithdrawals[msg.sender][1] = varg0;\n        _pendingWithdrawals[msg.sender][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingWithdrawals[msg.sender][0x2];\n        _pendingWithdrawals[msg.sender][3] = 0;\n        goto 0x2450x55e;\n    }\n}\n\nfunction transferPunk(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg1]) == msg.sender);\n    require(varg1 < 10000);\n    if (0xff & _punksOfferedForSale[varg1]) {\n        0x1a0b(varg1);\n    }\n    _punkIndexToAddress[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg1];\n    _punkIndexToAddress[msg.sender] += ~0;\n    _punkIndexToAddress[msg.sender] += 1;\n    emit Transfer(msg.sender, varg0, 1);\n    emit 0x5af636b70da6819000c49f85b21fa82081c632069bb626f30932034099107d8(msg.sender, varg0, varg1);\n    if (address(_punkBids[address(msg.sender)][0x2]) == varg0) {\n        v0 = varg0;\n        _pendingWithdrawals[v0] += _punkBids[msg.sender][3];\n        _pendingWithdrawals[v0] = 0x0 | ~0xff & _pendingWithdrawals[v0];\n        _pendingWithdrawals[v0][1] = varg1;\n        _pendingWithdrawals[v0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingWithdrawals[v0][0x2];\n        _pendingWithdrawals[v0][3] = 0;\n    }\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction withdrawBidForPunk(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]));\n    require(address(_punkIndexToAddress[varg0]) != msg.sender);\n    require(address(_punkBids[varg0][0x2]) == msg.sender);\n    emit PunkBidWithdrawn(varg0, msg.sender, _punkBids[varg0][3]);\n    _punkBids[varg0] = 0x0 | ~0xff & _punkBids[varg0];\n    _punkBids[varg0][1] = varg0;\n    _punkBids[varg0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[varg0][0x2];\n    _punkBids[varg0][3] = 0;\n    v0 = msg.sender.call().value(_punkBids[varg0][3]).gas(!_punkBids[varg0][3] * 2300);\n    assert(v0);\n}\n\nfunction setInitialOwner(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allInitialOwnersAssigned == msg.sender);\n    require(!_allPunksAssigned);\n    require(varg1 < 10000);\n    if (address(_punkIndexToAddress[varg1]) != varg0) {\n        if (!address(_punkIndexToAddress[varg1])) {\n            _punksRemainingToAssign += ~0;\n        } else {\n            _punkIndexToAddress[address(_punkIndexToAddress[varg1])] += ~0;\n        }\n        _punkIndexToAddress[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg1];\n        _punkIndexToAddress[varg0] += 1;\n        emit Assign(varg0, varg1);\n        goto 0x2450x631;\n    }\n}\n\nfunction offerPunkForSaleToAddress(uint256 varg0, uint256 varg1, address varg2) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    v0 = new array[](1);\n    _punksOfferedForSale[varg0] = v0.length | ~0xff & _punksOfferedForSale[varg0];\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2];\n    _punksOfferedForSale[varg0][3] = varg1;\n    _punksOfferedForSale[varg0][4] = varg2 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x4];\n    emit PunkOffered(varg0, varg2, varg1);\n}\n\nfunction punksRemainingToAssign() public payable { \n    assert(!msg.value);\n    return _punksRemainingToAssign;\n}\n\nfunction offerPunkForSale(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    v0 = new array[](1);\n    _punksOfferedForSale[varg0] = v0.length | ~0xff & _punksOfferedForSale[varg0];\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2];\n    _punksOfferedForSale[varg0][3] = varg1;\n    _punksOfferedForSale[varg0][4] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x4];\n    emit PunkOffered(varg0, 0, varg1);\n}\n\nfunction getPunk(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(_punksRemainingToAssign);\n    require(!address(_punkIndexToAddress[varg0]));\n    require(varg0 < 10000);\n    _punkIndexToAddress[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[msg.sender] += 1;\n    _punksRemainingToAssign += ~0;\n    emit Assign(msg.sender, varg0);\n}\n\nfunction pendingWithdrawals(address varg0) public payable { \n    assert(!msg.value);\n    return _pendingWithdrawals[varg0];\n}\n\nfunction punkNoLongerForSale(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1a0b(varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x88f11f3 == function_selector) {\n            punksOfferedForSale(uint256);\n        } else if (0x91dbfd2 == function_selector) {\n            enterBidForPunk(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23165b75 == function_selector) {\n            acceptBidForPunk(uint256,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x39c5dde6 == function_selector) {\n            setInitialOwners(address[],uint256[]);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x51605d80 == function_selector) {\n            imageHash();\n        } else if (0x52f29a25 == function_selector) {\n            nextPunkIndexToAssign();\n        } else if (0x58178168 == function_selector) {\n            punkIndexToAddress(uint256);\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x6e743fa9 == function_selector) {\n            punkBids(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7ecedac9 == function_selector) {\n            allInitialOwnersAssigned();\n        } else if (0x8126c38a == function_selector) {\n            allPunksAssigned();\n        } else if (0x8264fe98 == function_selector) {\n            buyPunk(uint256);\n        } else if (0x8b72a2ec == function_selector) {\n            transferPunk(address,uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x979bc638 == function_selector) {\n            withdrawBidForPunk(uint256);\n        } else if (0xa75a9049 == function_selector) {\n            setInitialOwner(address,uint256);\n        } else if (0xbf31196f == function_selector) {\n            offerPunkForSaleToAddress(uint256,uint256,address);\n        } else if (0xc0d6ce63 == function_selector) {\n            punksRemainingToAssign();\n        } else if (0xc44193c3 == function_selector) {\n            offerPunkForSale(uint256,uint256);\n        } else if (0xc81d1d5b == function_selector) {\n            getPunk(uint256);\n        } else if (0xf3f43703 == function_selector) {\n            pendingWithdrawals(address);\n        } else if (0xf6eeff1e == function_selector) {\n            punkNoLongerForSale(uint256);\n        }\n    }\n    throw();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 17:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _imageHash; // STORAGE[0x0]\nuint256[] _standard; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 _nextPunkIndexToAssign; // STORAGE[0x7]\nuint256 _punksRemainingToAssign; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _punkIndexToAddress; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _punksOfferedForSale; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _punkBids; // STORAGE[0xd]\nmapping (uint256 => [uint256]) _pendingWithdrawals; // STORAGE[0xe]\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _allPunksAssigned; // STORAGE[0x8] bytes 0 to 0\naddress _allInitialOwnersAssigned; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nPunkBidEntered(uint256, uint256, address);\nTransfer(address, address, uint256);\nPunkBought(uint256, uint256, address, address);\nPunkBidWithdrawn(uint256, uint256, address);\nAssign(address, uint256);\nPunkOffered(uint256, uint256, address);\nPunkNoLongerForSale(uint256);\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction 0x1a0b(uint256 varg0) private { \n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    _punksOfferedForSale[varg0] = _punksOfferedForSale[varg0] & ~0xff | 0x0;\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2] | msg.sender;\n    _punksOfferedForSale[varg0][3] = 0;\n    _punksOfferedForSale[varg0][4] = _punksOfferedForSale[varg0][0x4] & ~0xffffffffffffffffffffffffffffffffffffffff | 0x0;\n    emit PunkNoLongerForSale(varg0);\n    return ;\n}\n\nfunction punksOfferedForSale(uint256 varg0) public payable { \n    assert(!msg.value);\n    return _punksOfferedForSale[varg0] & 0xff, _punksOfferedForSale[varg0][1], address(_punksOfferedForSale[varg0][0x2]), _punksOfferedForSale[varg0][3], address(_punksOfferedForSale[varg0][0x4]);\n}\n\nfunction enterBidForPunk(uint256 varg0) public payable { \n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]));\n    require(address(_punkIndexToAddress[varg0]) != msg.sender);\n    require(msg.value);\n    require(msg.value > _punkBids[varg0][3]);\n    if (_punkBids[varg0][3] > 0) {\n        _pendingWithdrawals[address(_punkBids[varg0][0x2])] += _punkBids[varg0][3];\n    }\n    v0 = new array[](1);\n    _punkBids[varg0] = v0.length | ~0xff & _punkBids[varg0];\n    _punkBids[varg0][1] = varg0;\n    _punkBids[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[varg0][0x2];\n    _punkBids[varg0][3] = msg.value;\n    emit PunkBidEntered(varg0, msg.sender, msg.value);\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction acceptBidForPunk(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(_punkBids[varg0][3]);\n    require(_punkBids[varg0][3] >= varg1);\n    _punkIndexToAddress[varg0] = address(_punkBids[varg0][0x2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[msg.sender] += ~0;\n    v0 = address(_punkBids[varg0][0x2]);\n    _punkIndexToAddress[v0] += 1;\n    emit Transfer(msg.sender, address(_punkBids[varg0][0x2]), 1);\n    _punksOfferedForSale[v0][0] = 0x0 | ~0xff & _punksOfferedForSale[v0][0x0];\n    _punksOfferedForSale[v0][1] = varg0;\n    _punksOfferedForSale[v0][2] = address(_punkBids[varg0][2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[v0][0x2];\n    _punksOfferedForSale[v0][3] = 0;\n    _punksOfferedForSale[v0][4] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[v0][0x4];\n    _punkBids[v0][0] = 0x0 | ~0xff & _punkBids[v0][0x0];\n    _punkBids[v0][1] = varg0;\n    _punkBids[v0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[v0][0x2];\n    _punkBids[v0][3] = 0;\n    _pendingWithdrawals[msg.sender] = _pendingWithdrawals[msg.sender] + _punkBids[varg0][3];\n    emit PunkBought(varg0, msg.sender, address(_punkBids[varg0][2]), _punkBids[varg0][3]);\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction setInitialOwners(address[] varg0, uint256[] varg1) public payable { \n    assert(!msg.value);\n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length << 5);\n    CALLDATACOPY(v1.data, 36 + varg1, varg1.length << 5);\n    require(_allInitialOwnersAssigned == msg.sender);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        assert(v2 < v0.length);\n        assert(v2 < v1.length);\n        v4 = v1[v2];\n        require(_allInitialOwnersAssigned == msg.sender);\n        require(!_allPunksAssigned);\n        require(v4 < 10000);\n        if (address(_punkIndexToAddress[v4]) != address(v0[v2])) {\n            if (!address(_punkIndexToAddress[v4])) {\n                _punksRemainingToAssign += ~0;\n            } else {\n                _punkIndexToAddress[v4] += ~0;\n            }\n            _punkIndexToAddress[v4] = address(v0[v2]) | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[v4];\n            _punkIndexToAddress[address(v0[v2])] += 1;\n            emit Assign(address(v0[v2]), v4);\n            goto 0xd30B0x2af;\n        }\n        v2 += 1;\n    }\n}\n\nfunction withdraw() public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    _pendingWithdrawals[msg.sender] = 0;\n    v0 = msg.sender.call().value(_pendingWithdrawals[msg.sender]).gas(2300 * !_pendingWithdrawals[msg.sender]);\n    assert(v0);\n}\n\nfunction imageHash() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) {\n        if (31 < (_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_imageHash.length & ~0 + (!(_imageHash.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _imageHash.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction nextPunkIndexToAssign() public payable { \n    assert(!msg.value);\n    return _nextPunkIndexToAssign;\n}\n\nfunction punkIndexToAddress(uint256 varg0) public payable { \n    assert(!msg.value);\n    return address(_punkIndexToAddress[varg0]);\n}\n\nfunction standard() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n        if (31 < (_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_standard.length & ~0 + (!(_standard.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _standard.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction punkBids(uint256 varg0) public payable { \n    assert(!msg.value);\n    return _punkBids[varg0] & 0xff, _punkBids[varg0][1], address(_punkBids[varg0][0x2]), _punkBids[varg0][3];\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction allInitialOwnersAssigned() public payable { \n    assert(!msg.value);\n    require(_allInitialOwnersAssigned == msg.sender);\n    _allPunksAssigned = 1;\n}\n\nfunction allPunksAssigned() public payable { \n    assert(!msg.value);\n    return _allPunksAssigned;\n}\n\nfunction buyPunk(uint256 varg0) public payable { \n    require(_allPunksAssigned);\n    require(varg0 < 10000);\n    require(0xff & _punksOfferedForSale[varg0]);\n    v0 = v1 = address(_punksOfferedForSale[varg0][0x4]);\n    if (address(_punksOfferedForSale[varg0][0x4])) {\n        v0 = address(_punksOfferedForSale[varg0][0x4]) != msg.sender;\n    }\n    require(!v0);\n    require(msg.value >= _punksOfferedForSale[varg0][3]);\n    require(address(_punkIndexToAddress[varg0]) == address(_punksOfferedForSale[varg0][0x2]));\n    _punkIndexToAddress[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[address(_punksOfferedForSale[varg0][0x2])] += ~0;\n    _punkIndexToAddress[address(_punksOfferedForSale[varg0][0x2])] += 1;\n    emit Transfer(address(_punksOfferedForSale[varg0][0x2]), msg.sender, 1);\n    0x1a0b(varg0);\n    _pendingWithdrawals[address(_punksOfferedForSale[varg0][0x2])] += msg.value;\n    emit PunkBought(varg0, address(_punksOfferedForSale[varg0][0x2]), msg.sender, msg.value);\n    if (address(_pendingWithdrawals[address(address(_punksOfferedForSale[varg0][0x2]))][0x2]) == msg.sender) {\n        _pendingWithdrawals[msg.sender] += _pendingWithdrawals[address(_punksOfferedForSale[varg0][0x2])][3];\n        _pendingWithdrawals[msg.sender] = 0x0 | ~0xff & _pendingWithdrawals[msg.sender];\n        _pendingWithdrawals[msg.sender][1] = varg0;\n        _pendingWithdrawals[msg.sender][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingWithdrawals[msg.sender][0x2];\n        _pendingWithdrawals[msg.sender][3] = 0;\n        goto 0x2450x55e;\n    }\n}\n\nfunction transferPunk(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg1]) == msg.sender);\n    require(varg1 < 10000);\n    if (0xff & _punksOfferedForSale[varg1]) {\n        0x1a0b(varg1);\n    }\n    _punkIndexToAddress[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg1];\n    _punkIndexToAddress[msg.sender] += ~0;\n    _punkIndexToAddress[msg.sender] += 1;\n    emit Transfer(msg.sender, varg0, 1);\n    emit 0x5af636b70da6819000c49f85b21fa82081c632069bb626f30932034099107d8(msg.sender, varg0, varg1);\n    if (address(_punkBids[address(msg.sender)][0x2]) == varg0) {\n        v0 = varg0;\n        _pendingWithdrawals[v0] += _punkBids[msg.sender][3];\n        _pendingWithdrawals[v0] = 0x0 | ~0xff & _pendingWithdrawals[v0];\n        _pendingWithdrawals[v0][1] = varg1;\n        _pendingWithdrawals[v0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _pendingWithdrawals[v0][0x2];\n        _pendingWithdrawals[v0][3] = 0;\n    }\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v0.length;\n    v7 = v8 = v4.data;\n    v9 = v0.data;\n    if (v6) {\n        while (1) {\n            MEM[v7] = MEM[v9];\n            if (v5 <= 32) {\n                break;\n            }\n            v5 = v5 + ~31;\n            v7 += 32;\n            v9 += 32;\n        }\n    }\n    v10 = v11 = v6 + v8;\n    if (0x1f & v6) {\n        MEM[v11 - (0x1f & v6)] = ~(256 ** (32 - (0x1f & v6)) - 1) & MEM[v11 - (0x1f & v6)];\n    }\n    return v4;\n}\n\nfunction withdrawBidForPunk(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(varg0 < 10000);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]));\n    require(address(_punkIndexToAddress[varg0]) != msg.sender);\n    require(address(_punkBids[varg0][0x2]) == msg.sender);\n    emit PunkBidWithdrawn(varg0, msg.sender, _punkBids[varg0][3]);\n    _punkBids[varg0] = 0x0 | ~0xff & _punkBids[varg0];\n    _punkBids[varg0][1] = varg0;\n    _punkBids[varg0][2] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkBids[varg0][0x2];\n    _punkBids[varg0][3] = 0;\n    v0 = msg.sender.call().value(_punkBids[varg0][3]).gas(!_punkBids[varg0][3] * 2300);\n    assert(v0);\n}\n\nfunction setInitialOwner(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allInitialOwnersAssigned == msg.sender);\n    require(!_allPunksAssigned);\n    require(varg1 < 10000);\n    if (address(_punkIndexToAddress[varg1]) != varg0) {\n        if (!address(_punkIndexToAddress[varg1])) {\n            _punksRemainingToAssign += ~0;\n        } else {\n            _punkIndexToAddress[address(_punkIndexToAddress[varg1])] += ~0;\n        }\n        _punkIndexToAddress[varg1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg1];\n        _punkIndexToAddress[varg0] += 1;\n        emit Assign(varg0, varg1);\n        goto 0x2450x631;\n    }\n}\n\nfunction offerPunkForSaleToAddress(uint256 varg0, uint256 varg1, address varg2) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    v0 = new array[](1);\n    _punksOfferedForSale[varg0] = v0.length | ~0xff & _punksOfferedForSale[varg0];\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2];\n    _punksOfferedForSale[varg0][3] = varg1;\n    _punksOfferedForSale[varg0][4] = varg2 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x4];\n    emit PunkOffered(varg0, varg2, varg1);\n}\n\nfunction punksRemainingToAssign() public payable { \n    assert(!msg.value);\n    return _punksRemainingToAssign;\n}\n\nfunction offerPunkForSale(uint256 varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(address(_punkIndexToAddress[varg0]) == msg.sender);\n    require(varg0 < 10000);\n    v0 = new array[](1);\n    _punksOfferedForSale[varg0] = v0.length | ~0xff & _punksOfferedForSale[varg0];\n    _punksOfferedForSale[varg0][1] = varg0;\n    _punksOfferedForSale[varg0][2] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x2];\n    _punksOfferedForSale[varg0][3] = varg1;\n    _punksOfferedForSale[varg0][4] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _punksOfferedForSale[varg0][0x4];\n    emit PunkOffered(varg0, 0, varg1);\n}\n\nfunction getPunk(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_allPunksAssigned);\n    require(_punksRemainingToAssign);\n    require(!address(_punkIndexToAddress[varg0]));\n    require(varg0 < 10000);\n    _punkIndexToAddress[varg0] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _punkIndexToAddress[varg0];\n    _punkIndexToAddress[msg.sender] += 1;\n    _punksRemainingToAssign += ~0;\n    emit Assign(msg.sender, varg0);\n}\n\nfunction pendingWithdrawals(address varg0) public payable { \n    assert(!msg.value);\n    return _pendingWithdrawals[varg0];\n}\n\nfunction punkNoLongerForSale(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1a0b(varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x88f11f3 == function_selector) {\n            punksOfferedForSale(uint256);\n        } else if (0x91dbfd2 == function_selector) {\n            enterBidForPunk(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23165b75 == function_selector) {\n            acceptBidForPunk(uint256,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x39c5dde6 == function_selector) {\n            setInitialOwners(address[],uint256[]);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x51605d80 == function_selector) {\n            imageHash();\n        } else if (0x52f29a25 == function_selector) {\n            nextPunkIndexToAssign();\n        } else if (0x58178168 == function_selector) {\n            punkIndexToAddress(uint256);\n        } else if (0x5a3b7e42 == function_selector) {\n            standard();\n        } else if (0x6e743fa9 == function_selector) {\n            punkBids(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7ecedac9 == function_selector) {\n            allInitialOwnersAssigned();\n        } else if (0x8126c38a == function_selector) {\n            allPunksAssigned();\n        } else if (0x8264fe98 == function_selector) {\n            buyPunk(uint256);\n        } else if (0x8b72a2ec == function_selector) {\n            transferPunk(address,uint256);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x979bc638 == function_selector) {\n            withdrawBidForPunk(uint256);\n        } else if (0xa75a9049 == function_selector) {\n            setInitialOwner(address,uint256);\n        } else if (0xbf31196f == function_selector) {\n            offerPunkForSaleToAddress(uint256,uint256,address);\n        } else if (0xc0d6ce63 == function_selector) {\n            punksRemainingToAssign();\n        } else if (0xc44193c3 == function_selector) {\n            offerPunkForSale(uint256,uint256);\n        } else if (0xc81d1d5b == function_selector) {\n            getPunk(uint256);\n        } else if (0xf3f43703 == function_selector) {\n            pendingWithdrawals(address);\n        } else if (0xf6eeff1e == function_selector) {\n            punkNoLongerForSale(uint256);\n        }\n    }\n    throw();\n}\n.",
	"status": "1",
	"time_cost": 17.403162717819214,
	"usage": {
		"completion_tokens": 373,
		"prompt_tokens": 6462,
		"total_tokens": 6835
	}
}