{
	"address": "0x48028860a0bd4432e87c16ca80fa9b9c40144abe",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity version of the given EVM decompiled code:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Bank {\n  mapping (bytes32 => uint256) private _newAccount; \n  address private stor_0_0_19; \n  \n\n  function() external payable { \n      revert();\n  }\n\n  function newAccount(bytes32 varg0) public payable { \n      require(msg.data.length - 4 >= 32);\n      require(msg.value > 0x9184e72a000);\n      require(_newAccount[varg0] < 1);\n      _newAccount[varg0] = msg.value;\n  }\n\n  function deposit(bytes32 varg0) public payable { \n      require(msg.data.length - 4 >= 32);\n      require(msg.value > 0x9184e72a000);\n      require(_newAccount[varg0] > 1);\n      _newAccount[varg0] = _newAccount[varg0] + msg.value;\n  }\n\n  function withdraw(string memory varg0, address varg1) public { \n      bytes memory v0 = bytes(varg0);\n      require(v0.length <= 0x100000000);\n      bytes32 v14 = sha256(abi.encodePacked(varg0));\n      require(_newAccount[v14] > 0x9184e72a000);\n      _newAccount[v14] = 1;\n      bool sent = varg1.send(_newAccount[v14]);\n      require(sent, \"Failed to send Ether\");\n  }\n}\n```\n\nPlease note that this Solidity version is not a direct translation of the decompiled code. Some parts of the decompiled code were not clear, so they have been replaced with similar functionality. For instance, the while loops and bitwise operations have been removed, and replaced with higher-level Solidity syntax.\n\nThe contract is a simple bank contract with functions to create new accounts, deposit funds into the account, and withdraw funds from the account. The account balances are stored in a mapping `_newAccount` with the account address as the key.\n\nPlease also note that using `.send()` function is not recommended due to the potential for exceptions to be thrown. It would be safer to use the `.transfer()` function.",
				"role": "assistant"
			}
		}
	],
	"created": 1701462545,
	"id": "chatcmpl-8R4QDDVyIXbJKpncYINkaxJMG7VEZ",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 03:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _newAccount; // STORAGE[0x1]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction newAccount(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.value > 0x9184e72a000);\n    require(_newAccount[varg0] < 1);\n    _newAccount[varg0] = msg.value;\n}\n\nfunction deposit(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.value > 0x9184e72a000);\n    require(_newAccount[varg0] > 1);\n    _newAccount[varg0] = _newAccount[varg0] + msg.value;\n}\n\nfunction withdraw(string varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    MEM[v0.data + varg0.length] = 0;\n    v1 = v2 = 32 + MEM[64];\n    v3 = v4 = v0.length;\n    v5 = v6 = v0.data;\n    while (v3 >= 32) {\n        MEM[v1] = MEM[v5];\n        v1 = v1 + 32;\n        v5 = v5 + 32;\n        v3 = v3 - 32;\n    }\n    MEM[v1] = MEM[v5] & ~(256 ** (32 - v3) - 1) | MEM[v1] & 256 ** (32 - v3) - 1;\n    v7 = v8 = MEM[64];\n    v9 = v10 = v4 + v2 - MEM[64] - 32;\n    v11 = v12 = 32 + MEM[64];\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v7 = v7 + 32;\n        v11 = v11 + 32;\n        v9 = v9 - 32;\n    }\n    MEM[v7] = MEM[v11] & ~(256 ** (32 - v9) - 1) | MEM[v7] & 256 ** (32 - v9) - 1;\n    v13, v14 = sha256hash(MEM[(MEM[64]) len (v10 + v8 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v13); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_newAccount[v14] > 0x9184e72a000);\n    v15 = v16 = varg1;\n    v17 = v18 = 2300;\n    v19 = v20 = 1157;\n    v21 = v22 = 10;\n    v23 = v24 = 32 + MEM[64];\n    v25 = v26 = v0.length;\n    v27 = v28 = v0.data;\n    while (v25 >= 32) {\n        MEM[v23] = MEM[v27];\n        v23 = v23 + 32;\n        v27 = v27 + 32;\n        v25 = v25 - 32;\n    }\n    MEM[v23] = MEM[v27] & ~(256 ** (32 - v25) - 1) | MEM[v23] & 256 ** (32 - v25) - 1;\n    v29 = v30 = MEM[64];\n    v31 = v32 = v26 + v24 - MEM[64] - 32;\n    v33 = v34 = 32 + MEM[64];\n    while (v31 >= 32) {\n        MEM[v29] = MEM[v33];\n        v29 = v29 + 32;\n        v33 = v33 + 32;\n        v31 = v31 - 32;\n    }\n    MEM[v29] = MEM[v33] & ~(256 ** (32 - v31) - 1) | MEM[v29] & 256 ** (32 - v31) - 1;\n    v35, v36 = sha256hash(MEM[(MEM[64]) len (v32 + v30 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v35); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v37 = v38 = _newAccount[v36];\n    while (1) {\n        goto {'0x72d', '0x485'};\n        v39 = v40 = 32 + MEM[64];\n        v41 = v42 = v0.length;\n        v43 = v44 = v0.data;\n        while (v41 >= 32) {\n            MEM[v39] = MEM[v43];\n            v39 = v39 + 32;\n            v43 = v43 + 32;\n            v41 = v41 - 32;\n        }\n        MEM[v39] = MEM[v43] & ~(256 ** (32 - v41) - 1) | MEM[v39] & 256 ** (32 - v41) - 1;\n        v45 = v46 = MEM[64];\n        v47 = v48 = v42 + v40 - MEM[64] - 32;\n        v49 = v50 = 32 + MEM[64];\n        while (v47 >= 32) {\n            MEM[v45] = MEM[v49];\n            v45 = v45 + 32;\n            v49 = v49 + 32;\n            v47 = v47 - 32;\n        }\n        MEM[v45] = MEM[v49] & ~(256 ** (32 - v47) - 1) | MEM[v45] & 256 ** (32 - v47) - 1;\n        v51 = sha256hash(MEM[(MEM[64]) len (v48 + v46 - MEM[64])], MEM[(MEM[64]) len 32]);\n        require(v51); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v52 = v15.call().value(_newAccount[MEM[MEM[64]]] - v37 / 100 * (0xff & v21)).gas(!(_newAccount[MEM[MEM[64]]] - v37 / 100 * (0xff & v21)) * v17);\n        require(v52); // checks call status, propagates error data on error\n        v15 = v53 = stor_0_0_19;\n        v17 = v54 = 2300;\n        v19 = v55 = 1837;\n        v21 = v56 = 10;\n        v57 = v58 = 32 + MEM[64];\n        v59 = v60 = v0.length;\n        v61 = v62 = v0.data;\n        while (v59 >= 32) {\n            MEM[v57] = MEM[v61];\n            v57 = v57 + 32;\n            v61 = v61 + 32;\n            v59 = v59 - 32;\n        }\n        MEM[v57] = MEM[v61] & ~(256 ** (32 - v59) - 1) | MEM[v57] & 256 ** (32 - v59) - 1;\n        v63 = v64 = MEM[64];\n        v65 = v66 = v60 + v58 - MEM[64] - 32;\n        v67 = v68 = 32 + MEM[64];\n        while (v65 >= 32) {\n            MEM[v63] = MEM[v67];\n            v63 = v63 + 32;\n            v67 = v67 + 32;\n            v65 = v65 - 32;\n        }\n        MEM[v63] = MEM[v67] & ~(256 ** (32 - v65) - 1) | MEM[v63] & 256 ** (32 - v65) - 1;\n        v69 = sha256hash(MEM[(MEM[64]) len (v66 + v64 - MEM[64])], MEM[(MEM[64]) len 32]);\n        require(v69); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v37 = v70 = _newAccount[MEM[MEM[64]]];\n    }\n    v71 = v15.call().value(v37 / 100 * (0xff & v21)).gas(!(v37 / 100 * (0xff & v21)) * v17);\n    require(v71); // checks call status, propagates error data on error\n    v72 = v73 = 32 + MEM[64];\n    v74 = v75 = v0.length;\n    v76 = v77 = v0.data;\n    while (v74 >= 32) {\n        MEM[v72] = MEM[v76];\n        v72 = v72 + 32;\n        v76 = v76 + 32;\n        v74 = v74 - 32;\n    }\n    MEM[v72] = MEM[v76] & ~(256 ** (32 - v74) - 1) | MEM[v72] & 256 ** (32 - v74) - 1;\n    v78 = v79 = MEM[64];\n    v80 = v81 = v75 + v73 - MEM[64] - 32;\n    v82 = v83 = 32 + MEM[64];\n    while (v80 >= 32) {\n        MEM[v78] = MEM[v82];\n        v78 = v78 + 32;\n        v82 = v82 + 32;\n        v80 = v80 - 32;\n    }\n    MEM[v78] = MEM[v82] & ~(256 ** (32 - v80) - 1) | MEM[v78] & 256 ** (32 - v80) - 1;\n    v84, v85 = sha256hash(MEM[(MEM[64]) len (v81 + v79 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v84); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _newAccount[v85] = 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8a84a48c == function_selector >> 224) {\n            newAccount(bytes32);\n        } else if (0xb214faa5 == function_selector >> 224) {\n            deposit(bytes32);\n        } else if (0xdd48622e == function_selector >> 224) {\n            withdraw(string,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 03:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _newAccount; // STORAGE[0x1]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction newAccount(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.value > 0x9184e72a000);\n    require(_newAccount[varg0] < 1);\n    _newAccount[varg0] = msg.value;\n}\n\nfunction deposit(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.value > 0x9184e72a000);\n    require(_newAccount[varg0] > 1);\n    _newAccount[varg0] = _newAccount[varg0] + msg.value;\n}\n\nfunction withdraw(string varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    MEM[v0.data + varg0.length] = 0;\n    v1 = v2 = 32 + MEM[64];\n    v3 = v4 = v0.length;\n    v5 = v6 = v0.data;\n    while (v3 >= 32) {\n        MEM[v1] = MEM[v5];\n        v1 = v1 + 32;\n        v5 = v5 + 32;\n        v3 = v3 - 32;\n    }\n    MEM[v1] = MEM[v5] & ~(256 ** (32 - v3) - 1) | MEM[v1] & 256 ** (32 - v3) - 1;\n    v7 = v8 = MEM[64];\n    v9 = v10 = v4 + v2 - MEM[64] - 32;\n    v11 = v12 = 32 + MEM[64];\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v7 = v7 + 32;\n        v11 = v11 + 32;\n        v9 = v9 - 32;\n    }\n    MEM[v7] = MEM[v11] & ~(256 ** (32 - v9) - 1) | MEM[v7] & 256 ** (32 - v9) - 1;\n    v13, v14 = sha256hash(MEM[(MEM[64]) len (v10 + v8 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v13); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_newAccount[v14] > 0x9184e72a000);\n    v15 = v16 = varg1;\n    v17 = v18 = 2300;\n    v19 = v20 = 1157;\n    v21 = v22 = 10;\n    v23 = v24 = 32 + MEM[64];\n    v25 = v26 = v0.length;\n    v27 = v28 = v0.data;\n    while (v25 >= 32) {\n        MEM[v23] = MEM[v27];\n        v23 = v23 + 32;\n        v27 = v27 + 32;\n        v25 = v25 - 32;\n    }\n    MEM[v23] = MEM[v27] & ~(256 ** (32 - v25) - 1) | MEM[v23] & 256 ** (32 - v25) - 1;\n    v29 = v30 = MEM[64];\n    v31 = v32 = v26 + v24 - MEM[64] - 32;\n    v33 = v34 = 32 + MEM[64];\n    while (v31 >= 32) {\n        MEM[v29] = MEM[v33];\n        v29 = v29 + 32;\n        v33 = v33 + 32;\n        v31 = v31 - 32;\n    }\n    MEM[v29] = MEM[v33] & ~(256 ** (32 - v31) - 1) | MEM[v29] & 256 ** (32 - v31) - 1;\n    v35, v36 = sha256hash(MEM[(MEM[64]) len (v32 + v30 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v35); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v37 = v38 = _newAccount[v36];\n    while (1) {\n        goto {'0x72d', '0x485'};\n        v39 = v40 = 32 + MEM[64];\n        v41 = v42 = v0.length;\n        v43 = v44 = v0.data;\n        while (v41 >= 32) {\n            MEM[v39] = MEM[v43];\n            v39 = v39 + 32;\n            v43 = v43 + 32;\n            v41 = v41 - 32;\n        }\n        MEM[v39] = MEM[v43] & ~(256 ** (32 - v41) - 1) | MEM[v39] & 256 ** (32 - v41) - 1;\n        v45 = v46 = MEM[64];\n        v47 = v48 = v42 + v40 - MEM[64] - 32;\n        v49 = v50 = 32 + MEM[64];\n        while (v47 >= 32) {\n            MEM[v45] = MEM[v49];\n            v45 = v45 + 32;\n            v49 = v49 + 32;\n            v47 = v47 - 32;\n        }\n        MEM[v45] = MEM[v49] & ~(256 ** (32 - v47) - 1) | MEM[v45] & 256 ** (32 - v47) - 1;\n        v51 = sha256hash(MEM[(MEM[64]) len (v48 + v46 - MEM[64])], MEM[(MEM[64]) len 32]);\n        require(v51); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v52 = v15.call().value(_newAccount[MEM[MEM[64]]] - v37 / 100 * (0xff & v21)).gas(!(_newAccount[MEM[MEM[64]]] - v37 / 100 * (0xff & v21)) * v17);\n        require(v52); // checks call status, propagates error data on error\n        v15 = v53 = stor_0_0_19;\n        v17 = v54 = 2300;\n        v19 = v55 = 1837;\n        v21 = v56 = 10;\n        v57 = v58 = 32 + MEM[64];\n        v59 = v60 = v0.length;\n        v61 = v62 = v0.data;\n        while (v59 >= 32) {\n            MEM[v57] = MEM[v61];\n            v57 = v57 + 32;\n            v61 = v61 + 32;\n            v59 = v59 - 32;\n        }\n        MEM[v57] = MEM[v61] & ~(256 ** (32 - v59) - 1) | MEM[v57] & 256 ** (32 - v59) - 1;\n        v63 = v64 = MEM[64];\n        v65 = v66 = v60 + v58 - MEM[64] - 32;\n        v67 = v68 = 32 + MEM[64];\n        while (v65 >= 32) {\n            MEM[v63] = MEM[v67];\n            v63 = v63 + 32;\n            v67 = v67 + 32;\n            v65 = v65 - 32;\n        }\n        MEM[v63] = MEM[v67] & ~(256 ** (32 - v65) - 1) | MEM[v63] & 256 ** (32 - v65) - 1;\n        v69 = sha256hash(MEM[(MEM[64]) len (v66 + v64 - MEM[64])], MEM[(MEM[64]) len 32]);\n        require(v69); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v37 = v70 = _newAccount[MEM[MEM[64]]];\n    }\n    v71 = v15.call().value(v37 / 100 * (0xff & v21)).gas(!(v37 / 100 * (0xff & v21)) * v17);\n    require(v71); // checks call status, propagates error data on error\n    v72 = v73 = 32 + MEM[64];\n    v74 = v75 = v0.length;\n    v76 = v77 = v0.data;\n    while (v74 >= 32) {\n        MEM[v72] = MEM[v76];\n        v72 = v72 + 32;\n        v76 = v76 + 32;\n        v74 = v74 - 32;\n    }\n    MEM[v72] = MEM[v76] & ~(256 ** (32 - v74) - 1) | MEM[v72] & 256 ** (32 - v74) - 1;\n    v78 = v79 = MEM[64];\n    v80 = v81 = v75 + v73 - MEM[64] - 32;\n    v82 = v83 = 32 + MEM[64];\n    while (v80 >= 32) {\n        MEM[v78] = MEM[v82];\n        v78 = v78 + 32;\n        v82 = v82 + 32;\n        v80 = v80 - 32;\n    }\n    MEM[v78] = MEM[v82] & ~(256 ** (32 - v80) - 1) | MEM[v78] & 256 ** (32 - v80) - 1;\n    v84, v85 = sha256hash(MEM[(MEM[64]) len (v81 + v79 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v84); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _newAccount[v85] = 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8a84a48c == function_selector >> 224) {\n            newAccount(bytes32);\n        } else if (0xb214faa5 == function_selector >> 224) {\n            deposit(bytes32);\n        } else if (0xdd48622e == function_selector >> 224) {\n            withdraw(string,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 03:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _newAccount; // STORAGE[0x1]\naddress stor_0_0_19; // STORAGE[0x0] bytes 0 to 19\n\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction newAccount(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.value > 0x9184e72a000);\n    require(_newAccount[varg0] < 1);\n    _newAccount[varg0] = msg.value;\n}\n\nfunction deposit(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.value > 0x9184e72a000);\n    require(_newAccount[varg0] > 1);\n    _newAccount[varg0] = _newAccount[varg0] + msg.value;\n}\n\nfunction withdraw(string varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    MEM[v0.data + varg0.length] = 0;\n    v1 = v2 = 32 + MEM[64];\n    v3 = v4 = v0.length;\n    v5 = v6 = v0.data;\n    while (v3 >= 32) {\n        MEM[v1] = MEM[v5];\n        v1 = v1 + 32;\n        v5 = v5 + 32;\n        v3 = v3 - 32;\n    }\n    MEM[v1] = MEM[v5] & ~(256 ** (32 - v3) - 1) | MEM[v1] & 256 ** (32 - v3) - 1;\n    v7 = v8 = MEM[64];\n    v9 = v10 = v4 + v2 - MEM[64] - 32;\n    v11 = v12 = 32 + MEM[64];\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v7 = v7 + 32;\n        v11 = v11 + 32;\n        v9 = v9 - 32;\n    }\n    MEM[v7] = MEM[v11] & ~(256 ** (32 - v9) - 1) | MEM[v7] & 256 ** (32 - v9) - 1;\n    v13, v14 = sha256hash(MEM[(MEM[64]) len (v10 + v8 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v13); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_newAccount[v14] > 0x9184e72a000);\n    v15 = v16 = varg1;\n    v17 = v18 = 2300;\n    v19 = v20 = 1157;\n    v21 = v22 = 10;\n    v23 = v24 = 32 + MEM[64];\n    v25 = v26 = v0.length;\n    v27 = v28 = v0.data;\n    while (v25 >= 32) {\n        MEM[v23] = MEM[v27];\n        v23 = v23 + 32;\n        v27 = v27 + 32;\n        v25 = v25 - 32;\n    }\n    MEM[v23] = MEM[v27] & ~(256 ** (32 - v25) - 1) | MEM[v23] & 256 ** (32 - v25) - 1;\n    v29 = v30 = MEM[64];\n    v31 = v32 = v26 + v24 - MEM[64] - 32;\n    v33 = v34 = 32 + MEM[64];\n    while (v31 >= 32) {\n        MEM[v29] = MEM[v33];\n        v29 = v29 + 32;\n        v33 = v33 + 32;\n        v31 = v31 - 32;\n    }\n    MEM[v29] = MEM[v33] & ~(256 ** (32 - v31) - 1) | MEM[v29] & 256 ** (32 - v31) - 1;\n    v35, v36 = sha256hash(MEM[(MEM[64]) len (v32 + v30 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v35); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v37 = v38 = _newAccount[v36];\n    while (1) {\n        goto {'0x72d', '0x485'};\n        v39 = v40 = 32 + MEM[64];\n        v41 = v42 = v0.length;\n        v43 = v44 = v0.data;\n        while (v41 >= 32) {\n            MEM[v39] = MEM[v43];\n            v39 = v39 + 32;\n            v43 = v43 + 32;\n            v41 = v41 - 32;\n        }\n        MEM[v39] = MEM[v43] & ~(256 ** (32 - v41) - 1) | MEM[v39] & 256 ** (32 - v41) - 1;\n        v45 = v46 = MEM[64];\n        v47 = v48 = v42 + v40 - MEM[64] - 32;\n        v49 = v50 = 32 + MEM[64];\n        while (v47 >= 32) {\n            MEM[v45] = MEM[v49];\n            v45 = v45 + 32;\n            v49 = v49 + 32;\n            v47 = v47 - 32;\n        }\n        MEM[v45] = MEM[v49] & ~(256 ** (32 - v47) - 1) | MEM[v45] & 256 ** (32 - v47) - 1;\n        v51 = sha256hash(MEM[(MEM[64]) len (v48 + v46 - MEM[64])], MEM[(MEM[64]) len 32]);\n        require(v51); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v52 = v15.call().value(_newAccount[MEM[MEM[64]]] - v37 / 100 * (0xff & v21)).gas(!(_newAccount[MEM[MEM[64]]] - v37 / 100 * (0xff & v21)) * v17);\n        require(v52); // checks call status, propagates error data on error\n        v15 = v53 = stor_0_0_19;\n        v17 = v54 = 2300;\n        v19 = v55 = 1837;\n        v21 = v56 = 10;\n        v57 = v58 = 32 + MEM[64];\n        v59 = v60 = v0.length;\n        v61 = v62 = v0.data;\n        while (v59 >= 32) {\n            MEM[v57] = MEM[v61];\n            v57 = v57 + 32;\n            v61 = v61 + 32;\n            v59 = v59 - 32;\n        }\n        MEM[v57] = MEM[v61] & ~(256 ** (32 - v59) - 1) | MEM[v57] & 256 ** (32 - v59) - 1;\n        v63 = v64 = MEM[64];\n        v65 = v66 = v60 + v58 - MEM[64] - 32;\n        v67 = v68 = 32 + MEM[64];\n        while (v65 >= 32) {\n            MEM[v63] = MEM[v67];\n            v63 = v63 + 32;\n            v67 = v67 + 32;\n            v65 = v65 - 32;\n        }\n        MEM[v63] = MEM[v67] & ~(256 ** (32 - v65) - 1) | MEM[v63] & 256 ** (32 - v65) - 1;\n        v69 = sha256hash(MEM[(MEM[64]) len (v66 + v64 - MEM[64])], MEM[(MEM[64]) len 32]);\n        require(v69); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        v37 = v70 = _newAccount[MEM[MEM[64]]];\n    }\n    v71 = v15.call().value(v37 / 100 * (0xff & v21)).gas(!(v37 / 100 * (0xff & v21)) * v17);\n    require(v71); // checks call status, propagates error data on error\n    v72 = v73 = 32 + MEM[64];\n    v74 = v75 = v0.length;\n    v76 = v77 = v0.data;\n    while (v74 >= 32) {\n        MEM[v72] = MEM[v76];\n        v72 = v72 + 32;\n        v76 = v76 + 32;\n        v74 = v74 - 32;\n    }\n    MEM[v72] = MEM[v76] & ~(256 ** (32 - v74) - 1) | MEM[v72] & 256 ** (32 - v74) - 1;\n    v78 = v79 = MEM[64];\n    v80 = v81 = v75 + v73 - MEM[64] - 32;\n    v82 = v83 = 32 + MEM[64];\n    while (v80 >= 32) {\n        MEM[v78] = MEM[v82];\n        v78 = v78 + 32;\n        v82 = v82 + 32;\n        v80 = v80 - 32;\n    }\n    MEM[v78] = MEM[v82] & ~(256 ** (32 - v80) - 1) | MEM[v78] & 256 ** (32 - v80) - 1;\n    v84, v85 = sha256hash(MEM[(MEM[64]) len (v81 + v79 - MEM[64])], MEM[(MEM[64]) len 32]);\n    require(v84); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _newAccount[v85] = 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x8a84a48c == function_selector >> 224) {\n            newAccount(bytes32);\n        } else if (0xb214faa5 == function_selector >> 224) {\n            deposit(bytes32);\n        } else if (0xdd48622e == function_selector >> 224) {\n            withdraw(string,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 35.26214289665222,
	"usage": {
		"completion_tokens": 478,
		"prompt_tokens": 2598,
		"total_tokens": 3076
	}
}