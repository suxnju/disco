{
	"address": "0x12d5b7c26dd8dc6e2f71f5bf240d5e76452b2fe5",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst name = 'Direct Crypt Token PreSale'\nconst REFERRAL_MIN_LIMIT = 2 * 10^18\n\ndef storage:\n  stor0 is uint8 at storage 0 offset 160\n  stor0 is uint128 at storage 0 offset 160\n  owner is address at storage 0\n  ethPriceProviderAddress is address at storage 1\n  tokenAddress is address at storage 2\n  investorWhiteListAddress is address at storage 3\n  beneficiaryAddress is address at storage 4\n  hardCap is uint256 at storage 5\n  softCap is uint256 at storage 6\n  ethUsdRate is uint256 at storage 7\n  tokenPriceUsd is uint256 at storage 8\n  totalTokens is uint256 at storage 9\n  collected is uint256 at storage 10\n  tokensSold is uint256 at storage 11\n  investorCount is uint256 at storage 12\n  weiRefunded is uint256 at storage 13\n  startTime is uint256 at storage 14\n  endTime is uint256 at storage 15\n  softCapReached is uint8 at storage 16\n  crowdsaleFinished is uint8 at storage 16 offset 8\n  stor16 is uint256 at storage 16 offset 8\n  stor17 is mapping of uint8 at storage 17\n  deposited is mapping of uint256 at storage 18\n\ndef softCapReached(): # not payable\n  return bool(softCapReached)\n\ndef endTime(): # not payable\n  return endTime\n\ndef beneficiary(): # not payable\n  return beneficiaryAddress\n\ndef ethUsdRate(): # not payable\n  return ethUsdRate\n\ndef tokensSold(): # not payable\n  return tokensSold\n\ndef tokenPriceUsd(): # not payable\n  return tokenPriceUsd\n\ndef weiRefunded(): # not payable\n  return weiRefunded\n\ndef startTime(): # not payable\n  return startTime\n\ndef totalTokens(): # not payable\n  return totalTokens\n\ndef collected(): # not payable\n  return collected\n\ndef owner(): # not payable\n  return owner\n\ndef softCap(): # not payable\n  return softCap\n\ndef halted(): # not payable\n  return bool(uint8(stor0.field_160))\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\ndef investorCount(): # not payable\n  return investorCount\n\ndef investorWhiteList(): # not payable\n  return investorWhiteListAddress\n\ndef ethPriceProvider(): # not payable\n  return ethPriceProviderAddress\n\ndef crowdsaleFinished(): # not payable\n  return bool(crowdsaleFinished)\n\ndef hardCap(): # not payable\n  return hardCap\n\ndef token(): # not payable\n  return tokenAddress\n\n#\n#  Regular functions\n#\n\ndef setEthPriceProvider(address provider): # not payable\n  require caller == owner\n  require provider\n  ethPriceProviderAddress = provider\n\ndef unhalt(): # not payable\n  require caller == owner\n  require uint8(stor0.field_160)\n  Mask(96, 0, stor0.field_160) = 0\n\ndef setNewWhiteList(address newWhiteList): # not payable\n  require caller == owner\n  require newWhiteList\n  investorWhiteListAddress = newWhiteList\n\ndef halt(): # not payable\n  require caller == owner\n  require not uint8(stor0.field_160)\n  Mask(96, 0, stor0.field_160) = 1\n\ndef receiveEthPrice(uint256 ethUsdPrice): # not payable\n  require caller == ethPriceProviderAddress\n  require ethUsdPrice > 0\n  ethUsdRate = ethUsdPrice\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef refund(): # not payable\n  require block.timestamp >= endTime\n  require not uint8(stor0.field_160)\n  require not softCapReached\n  require not stor17[caller]\n  require deposited[caller] > 0\n  call caller with:\n     value deposited[caller] wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  deposited[caller] = 0\n  stor17[caller] = 1\n  require weiRefunded + deposited[caller] >= weiRefunded\n  weiRefunded += deposited[caller]\n  log Refunded(\n        address beneficiary=deposited[caller],\n        uint256 weiAmount=caller)\n\ndef withdraw(): # not payable\n  require caller == owner\n  require softCapReached\n  call beneficiaryAddress with:\n     value collected wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require ext_code.size(tokenAddress)\n  call tokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_code.size(tokenAddress)\n  call tokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args beneficiaryAddress, ext_call.return_data[0]\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  stor16 = 1\n\ndef _fallback(?) payable: # default function\n  require ext_code.size(investorWhiteListAddress)\n  call investorWhiteListAddress.isAllowed(address ) with:\n       gas gas_remaining wei\n      args caller\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require ext_call.return_data[0]\n  require block.timestamp >= startTime\n  require block.timestamp < endTime\n  require not uint8(stor0.field_160)\n  require not crowdsaleFinished\n  require collected + call.value >= collected\n  require collected + call.value <= hardCap\n  if call.value:\n      require call.value\n      require call.value * ethUsdRate / call.value == ethUsdRate\n      require tokenPriceUsd\n      require totalTokens >= tokensSold + (call.value * ethUsdRate / tokenPriceUsd)\n      if softCapReached:\n          if call.value:\n              require call.value\n              require call.value * ethUsdRate / call.value == ethUsdRate\n              require tokenPriceUsd\n              require ext_code.size(tokenAddress)\n              call tokenAddress.balanceOf(address account) with:\n                   gas gas_remaining wei\n                  args caller\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if ext_call.return_data[0]:\n                  require ext_code.size(investorWhiteListAddress)\n                  call investorWhiteListAddress.getReferralOf(address investor) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if call.value < 2 * 10^18:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, call.value * ethUsdRate / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  if not call.value * ethUsdRate / tokenPriceUsd:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, call.value * ethUsdRate / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  require call.value * ethUsdRate / tokenPriceUsd\n                  require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, call.value * ethUsdRate / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                  if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                          stop\n                      if not address(ext_call.return_data[0]):\n                          stop\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      log NewReferralTransfer(\n                            address investor=(5 * call.value * ethUsdRate / tokenPriceUsd / 100),\n                            address referral=caller,\n                            uint256 tokenAmount=address(ext_call.return_data[0]))\n                  else:\n                      if address(ext_call.return_data[0]):\n                          require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                          tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                      else:\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n              else:\n                  investorCount++\n                  require ext_code.size(investorWhiteListAddress)\n                  call investorWhiteListAddress.getReferralOf(address investor) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if call.value < 2 * 10^18:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, call.value * ethUsdRate / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  if not call.value * ethUsdRate / tokenPriceUsd:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, call.value * ethUsdRate / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  require call.value * ethUsdRate / tokenPriceUsd\n                  require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, call.value * ethUsdRate / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                  if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                          stop\n                      if not address(ext_call.return_data[0]):\n                          stop\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                  else:\n                      if address(ext_call.return_data[0]):\n                          require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                          tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                      else:\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n          else:\n              require tokenPriceUsd\n              require ext_code.size(tokenAddress)\n              call tokenAddress.balanceOf(address account) with:\n                   gas gas_remaining wei\n                  args caller\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if ext_call.return_data[0]:\n                  require ext_code.size(investorWhiteListAddress)\n                  call investorWhiteListAddress.getReferralOf(address investor) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if call.value < 2 * 10^18:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  if not 0 / tokenPriceUsd:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  require 0 / tokenPriceUsd\n                  require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, 0 / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                  if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          if address(ext_call.return_data[0]):\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              log NewReferralTransfer(\n                                    address investor=(5 * 0 / tokenPriceUsd / 100),\n                                    address referral=caller,\n                                    uint256 tokenAmount=address(ext_call.return_data[0]))\n                      stop\n                  if address(ext_call.return_data[0]):\n                      require 5 * 0 / tokenPriceUsd / 100 >= 0\n                      tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                          stop\n                      if address(ext_call.return_data[0]):\n                  else:\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                          stop\n                      if not address(ext_call.return_data[0]):\n                          stop\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      log NewReferralTransfer(\n                            address investor=(5 * 0 / tokenPriceUsd / 100),\n                            address referral=caller,\n                            uint256 tokenAmount=address(ext_call.return_data[0]))\n              else:\n                  investorCount++\n                  require ext_code.size(investorWhiteListAddress)\n                  call investorWhiteListAddress.getReferralOf(address investor) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if call.value < 2 * 10^18:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  if not 0 / tokenPriceUsd:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  require 0 / tokenPriceUsd\n                  require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, 0 / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                  if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                          stop\n                      if not address(ext_call.return_data[0]):\n                          stop\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      log NewReferralTransfer(\n                            address investor=(5 * 0 / tokenPriceUsd / 100),\n                            address referral=caller,\n                            uint256 tokenAmount=address(ext_call.return_data[0]))\n                  else:\n                      if address(ext_call.return_data[0]):\n                          require 5 * 0 / tokenPriceUsd / 100 >= 0\n                          tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * 0 / tokenPriceUsd / 100 > 0:\n                      else:\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          log NewReferralTransfer(\n                                address investor=(5 * 0 / tokenPriceUsd / 100),\n                                address referral=caller,\n                                uint256 tokenAmount=address(ext_call.return_data[0]))\n      else:\n          if collected < softCap:\n              require collected + call.value >= collected\n              if collected + call.value < softCap:\n                  if not call.value:\n                      require tokenPriceUsd\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.balanceOf(address account) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if ext_call.return_data[0]:\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require 0 / tokenPriceUsd\n                          require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if address(ext_call.return_data[0]):\n                          else:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                              else:\n                                  tokensSold += 0 / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=0 / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                                  if 5 * 0 / tokenPriceUsd / 100 > 0:\n                      else:\n                          investorCount++\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require 0 / tokenPriceUsd\n                          require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          else:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                              else:\n                                  tokensSold += 0 / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=0 / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                  else:\n                      require call.value\n                      require call.value * ethUsdRate / call.value == ethUsdRate\n                      require tokenPriceUsd\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.balanceOf(address account) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if ext_call.return_data[0]:\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not call.value * ethUsdRate / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require call.value * ethUsdRate / tokenPriceUsd\n                          require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          investorCount++\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not call.value * ethUsdRate / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          else:\n                              require call.value * ethUsdRate / tokenPriceUsd\n                              require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                                  if address(ext_call.return_data[0]):\n                                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                                      if deposited[caller] + call.value >= deposited[caller]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  revert\n                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n              else:\n                  softCapReached = 1\n                  log SoftCapReached(uint256 softCap=softCap)\n                  if call.value:\n                      require call.value\n                      require call.value * ethUsdRate / call.value == ethUsdRate\n                      require tokenPriceUsd\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.balanceOf(address account) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if not ext_call.return_data[0]:\n                          investorCount++\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not call.value * ethUsdRate / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                          else:\n                              require call.value * ethUsdRate / tokenPriceUsd\n                              require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not address(ext_call.return_data[0]):\n                                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      else:\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not call.value * ethUsdRate / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          else:\n                              require call.value * ethUsdRate / tokenPriceUsd\n                              require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                                  if address(ext_call.return_data[0]):\n                                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                                      if deposited[caller] + call.value >= deposited[caller]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  revert\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                  else:\n                      require tokenPriceUsd\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.balanceOf(address account) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if ext_call.return_data[0]:\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require 0 / tokenPriceUsd\n                          require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          else:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                              else:\n                                  tokensSold += 0 / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=0 / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                      else:\n                          investorCount++\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require 0 / tokenPriceUsd\n                          require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          if 5 * 0 / tokenPriceUsd / 100 > 0:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n          else:\n              if call.value:\n                  require call.value\n                  require call.value * ethUsdRate / call.value == ethUsdRate\n                  require tokenPriceUsd\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.balanceOf(address account) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if ext_call.return_data[0]:\n                      require ext_code.size(investorWhiteListAddress)\n                      call investorWhiteListAddress.getReferralOf(address investor) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if call.value < 2 * 10^18:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      if not call.value * ethUsdRate / tokenPriceUsd:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      require call.value * ethUsdRate / tokenPriceUsd\n                      require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, call.value * ethUsdRate / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                      else:\n                          if address(ext_call.return_data[0]):\n                              require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                              tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                          else:\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                  else:\n                      investorCount++\n                      require ext_code.size(investorWhiteListAddress)\n                      call investorWhiteListAddress.getReferralOf(address investor) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if call.value < 2 * 10^18:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      if not call.value * ethUsdRate / tokenPriceUsd:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      require call.value * ethUsdRate / tokenPriceUsd\n                      require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, call.value * ethUsdRate / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                          if address(ext_call.return_data[0]):\n                              require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                              tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                              require deposited[caller] + call.value >= deposited[caller]\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if address(ext_call.return_data[0]):\n                      else:\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n              else:\n                  require tokenPriceUsd\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.balanceOf(address account) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if ext_call.return_data[0]:\n                      require ext_code.size(investorWhiteListAddress)\n                      call investorWhiteListAddress.getReferralOf(address investor) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if call.value < 2 * 10^18:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      if not 0 / tokenPriceUsd:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      require 0 / tokenPriceUsd\n                      require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          log NewReferralTransfer(\n                                address investor=(5 * 0 / tokenPriceUsd / 100),\n                                address referral=caller,\n                                uint256 tokenAmount=address(ext_call.return_data[0]))\n                      else:\n                          if address(ext_call.return_data[0]):\n                              require 5 * 0 / tokenPriceUsd / 100 >= 0\n                              tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          else:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              log NewReferralTransfer(\n                                    address investor=(5 * 0 / tokenPriceUsd / 100),\n                                    address referral=caller,\n                                    uint256 tokenAmount=address(ext_call.return_data[0]))\n                  else:\n                      investorCount++\n                      require ext_code.size(investorWhiteListAddress)\n                      call investorWhiteListAddress.getReferralOf(address investor) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if call.value < 2 * 10^18:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      if not 0 / tokenPriceUsd:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      require 0 / tokenPriceUsd\n                      require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          log NewReferralTransfer(\n                                address investor=(5 * 0 / tokenPriceUsd / 100),\n                                address referral=caller,\n                                uint256 tokenAmount=address(ext_call.return_data[0]))\n                      else:\n                          if address(ext_call.return_data[0]):\n                              require 5 * 0 / tokenPriceUsd / 100 >= 0\n                              tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                          else:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n  else:\n      require tokenPriceUsd\n      require totalTokens >= tokensSold + (0 / tokenPriceUsd)\n      if softCapReached:\n          if not call.value:\n              require tokenPriceUsd\n              require ext_code.size(tokenAddress)\n              call tokenAddress.balanceOf(address account) with:\n                   gas gas_remaining wei\n                  args caller\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if ext_call.return_data[0]:\n                  require ext_code.size(investorWhiteListAddress)\n                  call investorWhiteListAddress.getReferralOf(address investor) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if call.value < 2 * 10^18:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  if not 0 / tokenPriceUsd:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  require 0 / tokenPriceUsd\n                  require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, 0 / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                  if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          if address(ext_call.return_data[0]):\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              log NewReferralTransfer(\n                                    address investor=(5 * 0 / tokenPriceUsd / 100),\n                                    address referral=caller,\n                                    uint256 tokenAmount=address(ext_call.return_data[0]))\n                      stop\n                  if not address(ext_call.return_data[0]):\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          if address(ext_call.return_data[0]):\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              log NewReferralTransfer(\n                                    address investor=(5 * 0 / tokenPriceUsd / 100),\n                                    address referral=caller,\n                                    uint256 tokenAmount=address(ext_call.return_data[0]))\n                      stop\n                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                  tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=0 / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                      stop\n                  if not address(ext_call.return_data[0]):\n                      stop\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              investorCount++\n              require ext_code.size(investorWhiteListAddress)\n              call investorWhiteListAddress.getReferralOf(address investor) with:\n                   gas gas_remaining wei\n                  args caller\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if call.value < 2 * 10^18:\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, 0 / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                  tokensSold += 0 / tokenPriceUsd\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=0 / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n              else:\n                  if not 0 / tokenPriceUsd:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                  else:\n                      require 0 / tokenPriceUsd\n                      require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          if address(ext_call.return_data[0]):\n                              require 5 * 0 / tokenPriceUsd / 100 >= 0\n                              tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          if address(ext_call.return_data[0]):\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              log NewReferralTransfer(\n                                    address investor=(5 * 0 / tokenPriceUsd / 100),\n                                    address referral=caller,\n                                    uint256 tokenAmount=address(ext_call.return_data[0]))\n              stop\n          require call.value\n          require call.value * ethUsdRate / call.value == ethUsdRate\n          require tokenPriceUsd\n          require ext_code.size(tokenAddress)\n          call tokenAddress.balanceOf(address account) with:\n               gas gas_remaining wei\n              args caller\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require return_data.size >= 32\n          if ext_call.return_data[0]:\n              require ext_code.size(investorWhiteListAddress)\n              call investorWhiteListAddress.getReferralOf(address investor) with:\n                   gas gas_remaining wei\n                  args caller\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if call.value < 2 * 10^18:\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, call.value * ethUsdRate / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  stop\n              if not call.value * ethUsdRate / tokenPriceUsd:\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, call.value * ethUsdRate / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  stop\n              require call.value * ethUsdRate / tokenPriceUsd\n              require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n              require collected + call.value >= collected\n              collected += call.value\n              require ext_code.size(tokenAddress)\n              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args caller, call.value * ethUsdRate / tokenPriceUsd\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                      if address(ext_call.return_data[0]):\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          log NewReferralTransfer(\n                                address investor=(5 * call.value * ethUsdRate / tokenPriceUsd / 100),\n                                address referral=caller,\n                                uint256 tokenAmount=address(ext_call.return_data[0]))\n                  stop\n              if address(ext_call.return_data[0]):\n                  require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                  tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                      stop\n                  if address(ext_call.return_data[0]):\n              else:\n                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                      stop\n                  if not address(ext_call.return_data[0]):\n                      stop\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  log NewReferralTransfer(\n                        address investor=(5 * call.value * ethUsdRate / tokenPriceUsd / 100),\n                        address referral=caller,\n                        uint256 tokenAmount=address(ext_call.return_data[0]))\n          else:\n              investorCount++\n              require ext_code.size(investorWhiteListAddress)\n              call investorWhiteListAddress.getReferralOf(address investor) with:\n                   gas gas_remaining wei\n                  args caller\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              if call.value < 2 * 10^18:\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, call.value * ethUsdRate / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  stop\n              if not call.value * ethUsdRate / tokenPriceUsd:\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, call.value * ethUsdRate / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  stop\n              require call.value * ethUsdRate / tokenPriceUsd\n              require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n              require collected + call.value >= collected\n              collected += call.value\n              require ext_code.size(tokenAddress)\n              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args caller, call.value * ethUsdRate / tokenPriceUsd\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                  require deposited[caller] + call.value >= deposited[caller]\n                  deposited[caller] += call.value\n                  log NewContribution(\n                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                        uint256 tokenAmount=call.value,\n                        uint256 etherAmount=caller)\n                  if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                      stop\n                  if not address(ext_call.return_data[0]):\n                      stop\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  log NewReferralTransfer(\n                        address investor=(5 * call.value * ethUsdRate / tokenPriceUsd / 100),\n                        address referral=caller,\n                        uint256 tokenAmount=address(ext_call.return_data[0]))\n              else:\n                  if address(ext_call.return_data[0]):\n                      require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                      tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                  else:\n                      tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=call.value * ethUsdRate / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                          stop\n                      if not address(ext_call.return_data[0]):\n                          stop\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      log NewReferralTransfer(\n                            address investor=(5 * call.value * ethUsdRate / tokenPriceUsd / 100),\n                            address referral=caller,\n                            uint256 tokenAmount=address(ext_call.return_data[0]))\n      else:\n          if collected < softCap:\n              require collected + call.value >= collected\n              if collected + call.value < softCap:\n                  if call.value:\n                      require call.value\n                      require call.value * ethUsdRate / call.value == ethUsdRate\n                      require tokenPriceUsd\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.balanceOf(address account) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if ext_call.return_data[0]:\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not call.value * ethUsdRate / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require call.value * ethUsdRate / tokenPriceUsd\n                          require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if address(ext_call.return_data[0]):\n                          else:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                              else:\n                                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                                  if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                      else:\n                          investorCount++\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not call.value * ethUsdRate / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require call.value * ethUsdRate / tokenPriceUsd\n                          require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                          else:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                              else:\n                                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                  else:\n                      require tokenPriceUsd\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.balanceOf(address account) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if ext_call.return_data[0]:\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require 0 / tokenPriceUsd\n                          require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                          else:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=0 / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                              else:\n                                  tokensSold += 0 / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=0 / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                                  if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                      stop\n                                  if not address(ext_call.return_data[0]):\n                                      stop\n                                  require ext_code.size(tokenAddress)\n                                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                       gas gas_remaining wei\n                                      args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                      else:\n                          investorCount++\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require 0 / tokenPriceUsd\n                          require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          if 5 * 0 / tokenPriceUsd / 100 > 0:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if address(ext_call.return_data[0]):\n                          else:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n              else:\n                  softCapReached = 1\n                  log SoftCapReached(uint256 softCap=softCap)\n                  if call.value:\n                      require call.value\n                      require call.value * ethUsdRate / call.value == ethUsdRate\n                      require tokenPriceUsd\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.balanceOf(address account) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if ext_call.return_data[0]:\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not call.value * ethUsdRate / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require call.value * ethUsdRate / tokenPriceUsd\n                          require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                          else:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                              else:\n                                  tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                      else:\n                          investorCount++\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not call.value * ethUsdRate / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, call.value * ethUsdRate / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require call.value * ethUsdRate / tokenPriceUsd\n                          require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                  else:\n                      require tokenPriceUsd\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.balanceOf(address account) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if not ext_call.return_data[0]:\n                          investorCount++\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require 0 / tokenPriceUsd\n                          require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if address(ext_call.return_data[0]):\n                          else:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                              else:\n                                  tokensSold += 0 / tokenPriceUsd\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  deposited[caller] += call.value\n                                  log NewContribution(\n                                        address holder=0 / tokenPriceUsd,\n                                        uint256 tokenAmount=call.value,\n                                        uint256 etherAmount=caller)\n                                  if 5 * 0 / tokenPriceUsd / 100 > 0:\n                      else:\n                          require ext_code.size(investorWhiteListAddress)\n                          call investorWhiteListAddress.getReferralOf(address investor) with:\n                               gas gas_remaining wei\n                              args caller\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          if call.value < 2 * 10^18:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              stop\n                          require 0 / tokenPriceUsd\n                          require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          if 5 * 0 / tokenPriceUsd / 100 > 0:\n                              if address(ext_call.return_data[0]):\n                                  require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                  tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                                  require deposited[caller] + call.value >= deposited[caller]\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if address(ext_call.return_data[0]):\n                          else:\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n          else:\n              if not call.value:\n                  require tokenPriceUsd\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.balanceOf(address account) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if ext_call.return_data[0]:\n                      require ext_code.size(investorWhiteListAddress)\n                      call investorWhiteListAddress.getReferralOf(address investor) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if call.value < 2 * 10^18:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, 0 / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                          tokensSold += 0 / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=0 / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                      else:\n                          if not 0 / tokenPriceUsd:\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                          else:\n                              require 0 / tokenPriceUsd\n                              require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                              require collected + call.value >= collected\n                              collected += call.value\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args caller, 0 / tokenPriceUsd\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                              if 5 * 0 / tokenPriceUsd / 100 > 0:\n                                  if address(ext_call.return_data[0]):\n                                      require 5 * 0 / tokenPriceUsd / 100 >= 0\n                                      tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                                      require deposited[caller] + call.value >= deposited[caller]\n                                      deposited[caller] += call.value\n                                      log NewContribution(\n                                            address holder=0 / tokenPriceUsd,\n                                            uint256 tokenAmount=call.value,\n                                            uint256 etherAmount=caller)\n                                      if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                                          stop\n                                      if not address(ext_call.return_data[0]):\n                                          stop\n                                      require ext_code.size(tokenAddress)\n                                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              tokensSold += 0 / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=0 / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * 0 / tokenPriceUsd / 100 > 0:\n                                  if address(ext_call.return_data[0]):\n                                      require ext_code.size(tokenAddress)\n                                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                           gas gas_remaining wei\n                                          args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                                      if not ext_call.success:\n                                          revert with ext_call.return_data[0 len return_data.size]\n                                      require return_data.size >= 32\n                                      log NewReferralTransfer(\n                                            address investor=(5 * 0 / tokenPriceUsd / 100),\n                                            address referral=caller,\n                                            uint256 tokenAmount=address(ext_call.return_data[0]))\n                      stop\n                  investorCount++\n                  require ext_code.size(investorWhiteListAddress)\n                  call investorWhiteListAddress.getReferralOf(address investor) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if call.value < 2 * 10^18:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  if not 0 / tokenPriceUsd:\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, 0 / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      stop\n                  require 0 / tokenPriceUsd\n                  require 5 * 0 / tokenPriceUsd / 0 / tokenPriceUsd == 5\n                  require collected + call.value >= collected\n                  collected += call.value\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args caller, 0 / tokenPriceUsd\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require tokensSold + (0 / tokenPriceUsd) >= tokensSold\n                  if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 > 0:\n                          if address(ext_call.return_data[0]):\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              log NewReferralTransfer(\n                                    address investor=(5 * 0 / tokenPriceUsd / 100),\n                                    address referral=caller,\n                                    uint256 tokenAmount=address(ext_call.return_data[0]))\n                      stop\n                  if address(ext_call.return_data[0]):\n                      require 5 * 0 / tokenPriceUsd / 100 >= 0\n                      tokensSold = tokensSold + (0 / tokenPriceUsd) + (5 * 0 / tokenPriceUsd / 100)\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                          stop\n                      if address(ext_call.return_data[0]):\n                  else:\n                      tokensSold += 0 / tokenPriceUsd\n                      require deposited[caller] + call.value >= deposited[caller]\n                      deposited[caller] += call.value\n                      log NewContribution(\n                            address holder=0 / tokenPriceUsd,\n                            uint256 tokenAmount=call.value,\n                            uint256 etherAmount=caller)\n                      if 5 * 0 / tokenPriceUsd / 100 <= 0:\n                          stop\n                      if not address(ext_call.return_data[0]):\n                          stop\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args address(ext_call.return_data[0]), 5 * 0 / tokenPriceUsd / 100\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      log NewReferralTransfer(\n                            address investor=(5 * 0 / tokenPriceUsd / 100),\n                            address referral=caller,\n                            uint256 tokenAmount=address(ext_call.return_data[0]))\n              else:\n                  require call.value\n                  require call.value * ethUsdRate / call.value == ethUsdRate\n                  require tokenPriceUsd\n                  require ext_code.size(tokenAddress)\n                  call tokenAddress.balanceOf(address account) with:\n                       gas gas_remaining wei\n                      args caller\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  if ext_call.return_data[0]:\n                      require ext_code.size(investorWhiteListAddress)\n                      call investorWhiteListAddress.getReferralOf(address investor) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if call.value < 2 * 10^18:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      if not call.value * ethUsdRate / tokenPriceUsd:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      require call.value * ethUsdRate / tokenPriceUsd\n                      require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, call.value * ethUsdRate / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          log NewReferralTransfer(\n                                address investor=(5 * call.value * ethUsdRate / tokenPriceUsd / 100),\n                                address referral=caller,\n                                uint256 tokenAmount=address(ext_call.return_data[0]))\n                      else:\n                          if address(ext_call.return_data[0]):\n                              require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                              tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 > 0:\n                          else:\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n                              require return_data.size >= 32\n                              log NewReferralTransfer(\n                                    address investor=(5 * call.value * ethUsdRate / tokenPriceUsd / 100),\n                                    address referral=caller,\n                                    uint256 tokenAmount=address(ext_call.return_data[0]))\n                  else:\n                      investorCount++\n                      require ext_code.size(investorWhiteListAddress)\n                      call investorWhiteListAddress.getReferralOf(address investor) with:\n                           gas gas_remaining wei\n                          args caller\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      if call.value < 2 * 10^18:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      if not call.value * ethUsdRate / tokenPriceUsd:\n                          require collected + call.value >= collected\n                          collected += call.value\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args caller, call.value * ethUsdRate / tokenPriceUsd\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          stop\n                      require call.value * ethUsdRate / tokenPriceUsd\n                      require 5 * call.value * ethUsdRate / tokenPriceUsd / call.value * ethUsdRate / tokenPriceUsd == 5\n                      require collected + call.value >= collected\n                      collected += call.value\n                      require ext_code.size(tokenAddress)\n                      call tokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args caller, call.value * ethUsdRate / tokenPriceUsd\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require tokensSold + (call.value * ethUsdRate / tokenPriceUsd) >= tokensSold\n                      if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                          tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                          require deposited[caller] + call.value >= deposited[caller]\n                          deposited[caller] += call.value\n                          log NewContribution(\n                                address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                uint256 tokenAmount=call.value,\n                                uint256 etherAmount=caller)\n                          if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                              stop\n                          if not address(ext_call.return_data[0]):\n                              stop\n                          require ext_code.size(tokenAddress)\n                          call tokenAddress.transfer(address recipient, uint256 amount) with:\n                               gas gas_remaining wei\n                              args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                          if not ext_call.success:\n                              revert with ext_call.return_data[0 len return_data.size]\n                          require return_data.size >= 32\n                          log NewReferralTransfer(\n                                address investor=(5 * call.value * ethUsdRate / tokenPriceUsd / 100),\n                                address referral=caller,\n                                uint256 tokenAmount=address(ext_call.return_data[0]))\n                      else:\n                          if address(ext_call.return_data[0]):\n                              require 5 * call.value * ethUsdRate / tokenPriceUsd / 100 >= 0\n                              tokensSold = tokensSold + (call.value * ethUsdRate / tokenPriceUsd) + (5 * call.value * ethUsdRate / tokenPriceUsd / 100)\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                          else:\n                              tokensSold += call.value * ethUsdRate / tokenPriceUsd\n                              require deposited[caller] + call.value >= deposited[caller]\n                              deposited[caller] += call.value\n                              log NewContribution(\n                                    address holder=call.value * ethUsdRate / tokenPriceUsd,\n                                    uint256 tokenAmount=call.value,\n                                    uint256 etherAmount=caller)\n                              if 5 * call.value * ethUsdRate / tokenPriceUsd / 100 <= 0:\n                                  stop\n                              if not address(ext_call.return_data[0]):\n                                  stop\n                              require ext_code.size(tokenAddress)\n                              call tokenAddress.transfer(address recipient, uint256 amount) with:\n                                   gas gas_remaining wei\n                                  args address(ext_call.return_data[0]), 5 * call.value * ethUsdRate / tokenPriceUsd / 100\n                              if not ext_call.success:\n                                  revert with ext_call.return_data[0 len return_data.size]\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 36268 tokens. Please reduce the length of the messages."
}