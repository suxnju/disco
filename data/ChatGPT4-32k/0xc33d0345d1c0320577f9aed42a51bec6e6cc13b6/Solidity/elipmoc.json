{
	"address": "0xc33d0345d1c0320577f9aed42a51bec6e6cc13b6",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here is a simplified Solidity version of the given decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract BitronCoin {\n    uint256 private _totalSupply;\n    uint256 private _price_tokn;\n    uint256 private _postico_startdate;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    uint8 private _stage;\n    address private _owner;\n    \n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Caller is not the owner\");\n        _;\n    }\n\n    function end_ICO() public onlyOwner {\n        _stage = 3;\n        _balanceOf[_owner] += _balanceOf[address(this)];\n        _balanceOf[address(this)] = 0;\n        emit Transfer(address(this), _owner, _balanceOf[address(this)]);\n    }\n\n    function approve(address to, uint256 value) public returns (bool) {\n        require(to != address(0), \"Cannot set allowance for zero address\");\n        _allowance[msg.sender][to] = value;\n        emit Approval(msg.sender, to, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(to != address(0), \"Cannot transfer to zero address\");\n        require(_balanceOf[from] >= value, \"Insufficient balance\");\n        require(_allowance[msg.sender][from] >= value, \"Insufficient allowance\");\n        \n        _balanceOf[from] -= value;\n        _allowance[msg.sender][from] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balanceOf[owner];\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(to != address(0), \"Cannot transfer to zero address\");\n        require(_balanceOf[msg.sender] >= value, \"Insufficient balance\");\n\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        require(owner != address(0), \"Owner address cannot be zero\");\n        require(spender != address(0), \"Spender address cannot be zero\");\n        return _allowance[owner][spender];\n    }\n    \n    // ... Other functions based on the decompiled code\n}\n```\n\nThis is a very simplified version of the given decompiled code and I've omitted a lot of parts for brevity. Also, please note that translating EVM Bytecode to Solidity is not a straightforward process and can be prone to errors. So, this code might not function exactly as the original contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701466027,
	"id": "chatcmpl-8R5KNtzxI07gwWrO0KZCE2gQpwveP",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 20:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 __price_tokn; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _postico_startdate; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _priceFactor; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xc]\nuint256 _bonus; // STORAGE[0xe]\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\nuint8 _stage; // STORAGE[0xf] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\naddress stor_6_1_20; // STORAGE[0x6] bytes 1 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(_stage <= 3);\n    require(_stage != 3);\n    v0 = v1 = !stor_6_0_0;\n    if (!stor_6_0_0) {\n        v0 = v2 = msg.sender != _owner;\n    }\n    require(v0);\n    v3 = 0x811(100, _priceFactor);\n    v4 = 0x811(v3, msg.value);\n    assert(__price_tokn);\n    stor_3 = v4 / __price_tokn;\n    require(msg.sender != 0);\n    v5 = v6 = _balanceOf[address(this)] >= stor_3;\n    if (v6) {\n        v5 = v7 = stor_3 > 0;\n    }\n    require(v5);\n    assert(stor_3 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - stor_3;\n    assert(_balanceOf[msg.sender] + stor_3 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + stor_3;\n    emit Transfer(address(this), msg.sender, stor_3);\n}\n\nfunction end_ICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stage = 3;\n    assert(_balanceOf[_owner] + _balanceOf[address(this)] >= _balanceOf[_owner]);\n    _balanceOf[_owner] = _balanceOf[_owner] + _balanceOf[address(this)];\n    _balanceOf[address(this)] = 0;\n    emit Transfer(address(this), _owner, _balanceOf[address(this)]);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (11) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffff & 'Bitron coin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setpricefactor(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _priceFactor = varg0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 >= 0;\n    }\n    require(v0);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _balanceOf[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction _price_tokn() public nonPayable { \n    return __price_tokn;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction postico_startdate() public nonPayable { \n    return _postico_startdate;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x42544f0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction drain() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = stor_6_1_20.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction _totalsupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 >= 0;\n    }\n    require(v0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction stage() public nonPayable { \n    assert(_stage <= 3);\n    return _stage;\n}\n\nfunction ResumeICO() public nonPayable { \n    require(msg.sender == _owner);\n    stor_6_0_0 = 0;\n}\n\nfunction PauseICO() public nonPayable { \n    require(msg.sender == _owner);\n    stor_6_0_0 = 1;\n}\n\nfunction start_POSTICO() public nonPayable { \n    require(msg.sender == _owner);\n    assert(_stage <= 3);\n    require(_stage == 0);\n    _stage = 1;\n    stor_6_0_0 = 0;\n    stor_9 = 0x108b2a2c28029094000000;\n    _balanceOf[address(this)] = stor_9;\n    _postico_startdate = block.timestamp;\n    stor_8 = block.timestamp + 0x76a700;\n    __price_tokn = 5;\n    emit Transfer(0, address(this), stor_9);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    v0 = v1 = varg0 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != 0;\n    }\n    require(v0);\n    return _allowance[varg1];\n}\n\nfunction priceFactor() public nonPayable { \n    return _priceFactor;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    assert(_balanceOf[varg0] + _balanceOf[_owner] >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[_owner];\n    _balanceOf[_owner] = 0;\n    _owner = varg0;\n    emit Transfer(msg.sender, varg0, _balanceOf[varg0]);\n}\n\nfunction 0x811(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x2c3d7f6 == function_selector) {\n            end_ICO();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xdf12532 == function_selector) {\n            setpricefactor(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x61f127dd == function_selector) {\n            _price_tokn();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9329f2fe == function_selector) {\n            postico_startdate();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9890220b == function_selector) {\n            drain();\n        } else if (0xa393dc44 == function_selector) {\n            _totalsupply();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc040e6b8 == function_selector) {\n            stage();\n        } else if (0xcd7a2c3b == function_selector) {\n            ResumeICO();\n        } else if (0xcf5ae516 == function_selector) {\n            PauseICO();\n        } else if (0xd0169f4c == function_selector) {\n            start_POSTICO();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xdfb2866d == function_selector) {\n            priceFactor();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 20:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 __price_tokn; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _postico_startdate; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _priceFactor; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xc]\nuint256 _bonus; // STORAGE[0xe]\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\nuint8 _stage; // STORAGE[0xf] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\naddress stor_6_1_20; // STORAGE[0x6] bytes 1 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(_stage <= 3);\n    require(_stage != 3);\n    v0 = v1 = !stor_6_0_0;\n    if (!stor_6_0_0) {\n        v0 = v2 = msg.sender != _owner;\n    }\n    require(v0);\n    v3 = 0x811(100, _priceFactor);\n    v4 = 0x811(v3, msg.value);\n    assert(__price_tokn);\n    stor_3 = v4 / __price_tokn;\n    require(msg.sender != 0);\n    v5 = v6 = _balanceOf[address(this)] >= stor_3;\n    if (v6) {\n        v5 = v7 = stor_3 > 0;\n    }\n    require(v5);\n    assert(stor_3 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - stor_3;\n    assert(_balanceOf[msg.sender] + stor_3 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + stor_3;\n    emit Transfer(address(this), msg.sender, stor_3);\n}\n\nfunction end_ICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stage = 3;\n    assert(_balanceOf[_owner] + _balanceOf[address(this)] >= _balanceOf[_owner]);\n    _balanceOf[_owner] = _balanceOf[_owner] + _balanceOf[address(this)];\n    _balanceOf[address(this)] = 0;\n    emit Transfer(address(this), _owner, _balanceOf[address(this)]);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (11) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffff & 'Bitron coin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setpricefactor(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _priceFactor = varg0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 >= 0;\n    }\n    require(v0);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _balanceOf[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction _price_tokn() public nonPayable { \n    return __price_tokn;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction postico_startdate() public nonPayable { \n    return _postico_startdate;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x42544f0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction drain() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = stor_6_1_20.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction _totalsupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 >= 0;\n    }\n    require(v0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction stage() public nonPayable { \n    assert(_stage <= 3);\n    return _stage;\n}\n\nfunction ResumeICO() public nonPayable { \n    require(msg.sender == _owner);\n    stor_6_0_0 = 0;\n}\n\nfunction PauseICO() public nonPayable { \n    require(msg.sender == _owner);\n    stor_6_0_0 = 1;\n}\n\nfunction start_POSTICO() public nonPayable { \n    require(msg.sender == _owner);\n    assert(_stage <= 3);\n    require(_stage == 0);\n    _stage = 1;\n    stor_6_0_0 = 0;\n    stor_9 = 0x108b2a2c28029094000000;\n    _balanceOf[address(this)] = stor_9;\n    _postico_startdate = block.timestamp;\n    stor_8 = block.timestamp + 0x76a700;\n    __price_tokn = 5;\n    emit Transfer(0, address(this), stor_9);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    v0 = v1 = varg0 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != 0;\n    }\n    require(v0);\n    return _allowance[varg1];\n}\n\nfunction priceFactor() public nonPayable { \n    return _priceFactor;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    assert(_balanceOf[varg0] + _balanceOf[_owner] >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[_owner];\n    _balanceOf[_owner] = 0;\n    _owner = varg0;\n    emit Transfer(msg.sender, varg0, _balanceOf[varg0]);\n}\n\nfunction 0x811(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x2c3d7f6 == function_selector) {\n            end_ICO();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xdf12532 == function_selector) {\n            setpricefactor(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x61f127dd == function_selector) {\n            _price_tokn();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9329f2fe == function_selector) {\n            postico_startdate();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9890220b == function_selector) {\n            drain();\n        } else if (0xa393dc44 == function_selector) {\n            _totalsupply();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc040e6b8 == function_selector) {\n            stage();\n        } else if (0xcd7a2c3b == function_selector) {\n            ResumeICO();\n        } else if (0xcf5ae516 == function_selector) {\n            PauseICO();\n        } else if (0xd0169f4c == function_selector) {\n            start_POSTICO();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xdfb2866d == function_selector) {\n            priceFactor();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 20:31 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 __price_tokn; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nuint256 _postico_startdate; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 _priceFactor; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xc]\nuint256 _bonus; // STORAGE[0xe]\nuint8 stor_6_0_0; // STORAGE[0x6] bytes 0 to 0\nuint8 _stage; // STORAGE[0xf] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\naddress stor_6_1_20; // STORAGE[0x6] bytes 1 to 20\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(_stage <= 3);\n    require(_stage != 3);\n    v0 = v1 = !stor_6_0_0;\n    if (!stor_6_0_0) {\n        v0 = v2 = msg.sender != _owner;\n    }\n    require(v0);\n    v3 = 0x811(100, _priceFactor);\n    v4 = 0x811(v3, msg.value);\n    assert(__price_tokn);\n    stor_3 = v4 / __price_tokn;\n    require(msg.sender != 0);\n    v5 = v6 = _balanceOf[address(this)] >= stor_3;\n    if (v6) {\n        v5 = v7 = stor_3 > 0;\n    }\n    require(v5);\n    assert(stor_3 <= _balanceOf[address(this)]);\n    _balanceOf[address(this)] = _balanceOf[address(this)] - stor_3;\n    assert(_balanceOf[msg.sender] + stor_3 >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + stor_3;\n    emit Transfer(address(this), msg.sender, stor_3);\n}\n\nfunction end_ICO() public nonPayable { \n    require(msg.sender == _owner);\n    _stage = 3;\n    assert(_balanceOf[_owner] + _balanceOf[address(this)] >= _balanceOf[_owner]);\n    _balanceOf[_owner] = _balanceOf[_owner] + _balanceOf[address(this)];\n    _balanceOf[address(this)] = 0;\n    emit Transfer(address(this), _owner, _balanceOf[address(this)]);\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (11) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffff & 'Bitron coin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setpricefactor(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _priceFactor = varg0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    v0 = v1 = _balanceOf[varg0] >= varg2;\n    if (v1) {\n        v0 = v2 = _allowance[msg.sender] >= varg2;\n    }\n    if (v0) {\n        v0 = v3 = varg2 >= 0;\n    }\n    require(v0);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    assert(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _balanceOf[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction _price_tokn() public nonPayable { \n    return __price_tokn;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction bonus() public nonPayable { \n    return _bonus;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction postico_startdate() public nonPayable { \n    return _postico_startdate;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x42544f0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction drain() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = stor_6_1_20.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction _totalsupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    v0 = v1 = _balanceOf[msg.sender] >= varg1;\n    if (v1) {\n        v0 = v2 = varg1 >= 0;\n    }\n    require(v0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction stage() public nonPayable { \n    assert(_stage <= 3);\n    return _stage;\n}\n\nfunction ResumeICO() public nonPayable { \n    require(msg.sender == _owner);\n    stor_6_0_0 = 0;\n}\n\nfunction PauseICO() public nonPayable { \n    require(msg.sender == _owner);\n    stor_6_0_0 = 1;\n}\n\nfunction start_POSTICO() public nonPayable { \n    require(msg.sender == _owner);\n    assert(_stage <= 3);\n    require(_stage == 0);\n    _stage = 1;\n    stor_6_0_0 = 0;\n    stor_9 = 0x108b2a2c28029094000000;\n    _balanceOf[address(this)] = stor_9;\n    _postico_startdate = block.timestamp;\n    stor_8 = block.timestamp + 0x76a700;\n    __price_tokn = 5;\n    emit Transfer(0, address(this), stor_9);\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    v0 = v1 = varg0 != 0;\n    if (v1) {\n        v0 = v2 = varg1 != 0;\n    }\n    require(v0);\n    return _allowance[varg1];\n}\n\nfunction priceFactor() public nonPayable { \n    return _priceFactor;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    assert(_balanceOf[varg0] + _balanceOf[_owner] >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + _balanceOf[_owner];\n    _balanceOf[_owner] = 0;\n    _owner = varg0;\n    emit Transfer(msg.sender, varg0, _balanceOf[varg0]);\n}\n\nfunction 0x811(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x2c3d7f6 == function_selector) {\n            end_ICO();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xdf12532 == function_selector) {\n            setpricefactor(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x61f127dd == function_selector) {\n            _price_tokn();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x75b4d78c == function_selector) {\n            bonus();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9329f2fe == function_selector) {\n            postico_startdate();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9890220b == function_selector) {\n            drain();\n        } else if (0xa393dc44 == function_selector) {\n            _totalsupply();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xc040e6b8 == function_selector) {\n            stage();\n        } else if (0xcd7a2c3b == function_selector) {\n            ResumeICO();\n        } else if (0xcf5ae516 == function_selector) {\n            PauseICO();\n        } else if (0xd0169f4c == function_selector) {\n            start_POSTICO();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xdfb2866d == function_selector) {\n            priceFactor();\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 26.15280318260193,
	"usage": {
		"completion_tokens": 665,
		"prompt_tokens": 2688,
		"total_tokens": 3353
	}
}