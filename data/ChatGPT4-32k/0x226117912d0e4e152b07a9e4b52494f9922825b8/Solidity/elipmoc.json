{
	"address": "0x226117912d0e4e152b07a9e4b52494f9922825b8",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code corresponding to your decompiled code:\n\n```solidity\npragma solidity ^0.5.8;\n\ncontract ERC20Token {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public freezeOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event Unfreeze(address indexed from, uint256 value);\n    event Freeze(address indexed from, uint256 value);\n\n    constructor(string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, uint256 initialSupply) public {\n        balanceOf[msg.sender] = initialSupply;\n        totalSupply = initialSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n        owner = msg.sender;\n    }\n    \n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function freeze(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        freezeOf[msg.sender] += _value;\n        emit Freeze(msg.sender, _value);\n        return true;\n    }\n\n    function unfreeze(uint256 _value) public returns (bool success) {\n        require(freezeOf[msg.sender] >= _value);\n        freezeOf[msg.sender] -= _value;\n        balanceOf[msg.sender] += _value;\n        emit Unfreeze(msg.sender, _value);\n        return true;\n    }\n\n    function withdrawEther(uint256 amount) public {\n        require(msg.sender == owner);\n        owner.transfer(amount);\n    }\n}\n```\nPlease note that the given decompiled code is approximate and not a perfect representation of the original Solidity code. Therefore, some features or nuances of the original code might not be reflected in the decompiled version and consequently in the Solidity version provided here.",
				"role": "assistant"
			}
		}
	],
	"created": 1701462464,
	"id": "chatcmpl-8R4OukjercntDw2DoMKRys1R1DzsY",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 06:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    v1 = v2 = v0 >= varg1;\n    if (v2) {\n        v1 = v3 = v0 >= varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    v0 = _SafeSub(varg2, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    v1 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    v2 = _SafeSub(varg2, _allowance[msg.sender]);\n    _allowance[msg.sender] = v2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    assert(v0);\n}\n\nfunction burn(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeSub(varg0, _totalSupply);\n    _totalSupply = v1;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.length;\n    v9 = v10 = v0.data;\n    if (v8 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v9];\n            if (v7 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v9 = v9 + 32;\n            v7 = v7 - 32;\n        }\n    }\n    v11 = v12 = v8 + v6;\n    if (0x1f & v8) {\n        MEM[v12 - (0x1f & v8)] = ~(256 ** (32 - (0x1f & v8)) - 1) & MEM[v12 - (0x1f & v8)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg0 != 0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    v0 = _SafeSub(varg1, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public payable { \n    assert(!msg.value);\n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v1;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    return _allowance[varg1];\n}\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.length;\n    v9 = v10 = v0.data;\n    if (v8 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v9];\n            if (v7 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v9 = v9 + 32;\n            v7 = v7 - 32;\n        }\n    }\n    v11 = v12 = v8 + v6;\n    if (0x1f & v8) {\n        MEM[v12 - (0x1f & v8)] = ~(256 ** (32 - (0x1f & v8)) - 1) & MEM[v12 - (0x1f & v8)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd4217c1 == function_selector) {\n            freezeOf(address);\n        } else if (0xd7a78db8 == function_selector) {\n            freeze(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 06:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    v1 = v2 = v0 >= varg1;\n    if (v2) {\n        v1 = v3 = v0 >= varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    v0 = _SafeSub(varg2, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    v1 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    v2 = _SafeSub(varg2, _allowance[msg.sender]);\n    _allowance[msg.sender] = v2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    assert(v0);\n}\n\nfunction burn(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeSub(varg0, _totalSupply);\n    _totalSupply = v1;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.length;\n    v9 = v10 = v0.data;\n    if (v8 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v9];\n            if (v7 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v9 = v9 + 32;\n            v7 = v7 - 32;\n        }\n    }\n    v11 = v12 = v8 + v6;\n    if (0x1f & v8) {\n        MEM[v12 - (0x1f & v8)] = ~(256 ** (32 - (0x1f & v8)) - 1) & MEM[v12 - (0x1f & v8)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg0 != 0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    v0 = _SafeSub(varg1, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public payable { \n    assert(!msg.value);\n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v1;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    return _allowance[varg1];\n}\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.length;\n    v9 = v10 = v0.data;\n    if (v8 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v9];\n            if (v7 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v9 = v9 + 32;\n            v7 = v7 - 32;\n        }\n    }\n    v11 = v12 = v8 + v6;\n    if (0x1f & v8) {\n        MEM[v12 - (0x1f & v8)] = ~(256 ** (32 - (0x1f & v8)) - 1) & MEM[v12 - (0x1f & v8)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd4217c1 == function_selector) {\n            freezeOf(address);\n        } else if (0xd7a78db8 == function_selector) {\n            freeze(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 06:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 + varg0;\n    v1 = v2 = v0 >= varg1;\n    if (v2) {\n        v1 = v3 = v0 >= varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public payable { \n    assert(!msg.value);\n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    assert(!msg.value);\n    require(varg1 != 0);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    v0 = _SafeSub(varg2, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    v1 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    v2 = _SafeSub(varg2, _allowance[msg.sender]);\n    _allowance[msg.sender] = v2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public payable { \n    assert(!msg.value);\n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == _owner);\n    v0 = _owner.call().value(varg0).gas(!varg0 * 2300);\n    assert(v0);\n}\n\nfunction burn(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeSub(varg0, _totalSupply);\n    _totalSupply = v1;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public payable { \n    assert(!msg.value);\n    return _balanceOf[varg0];\n}\n\nfunction owner() public payable { \n    assert(!msg.value);\n    return _owner;\n}\n\nfunction symbol() public payable { \n    assert(!msg.value);\n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.length;\n    v9 = v10 = v0.data;\n    if (v8 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v9];\n            if (v7 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v9 = v9 + 32;\n            v7 = v7 - 32;\n        }\n    }\n    v11 = v12 = v8 + v6;\n    if (0x1f & v8) {\n        MEM[v12 - (0x1f & v8)] = ~(256 ** (32 - (0x1f & v8)) - 1) & MEM[v12 - (0x1f & v8)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    assert(!msg.value);\n    require(varg0 != 0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    v0 = _SafeSub(varg1, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public payable { \n    assert(!msg.value);\n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v1;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    return _allowance[varg1];\n}\n\nfunction name() public payable { \n    assert(!msg.value);\n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.length;\n    v9 = v10 = v0.data;\n    if (v8 != 0) {\n        while (1) {\n            MEM[v5] = MEM[v9];\n            if (v7 <= 32) {\n                break;\n            }\n            v5 = v5 + 32;\n            v9 = v9 + 32;\n            v7 = v7 - 32;\n        }\n    }\n    v11 = v12 = v8 + v6;\n    if (0x1f & v8) {\n        MEM[v12 - (0x1f & v8)] = ~(256 ** (32 - (0x1f & v8)) - 1) & MEM[v12 - (0x1f & v8)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd4217c1 == function_selector) {\n            freezeOf(address);\n        } else if (0xd7a78db8 == function_selector) {\n            freeze(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 33.339192152023315,
	"usage": {
		"completion_tokens": 710,
		"prompt_tokens": 2333,
		"total_tokens": 3043
	}
}