{
	"address": "0xe1f5c6fd86628e299955a84f44e2dfca47aaaaa4",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract that represents the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract ProxyContract {\n    address private _fallback;\n    address private _upgradeTo;\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\n    event Upgraded(address indexed newImplementation);\n\n    function implementation() public view returns (address) {\n        return _fallback;\n    }\n\n    function changeAdmin(address newAdmin) public {\n        require(msg.sender == _upgradeTo, 'Only the admin can change the admin.');\n        require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address');\n        emit AdminChanged(_upgradeTo, newAdmin);\n        _upgradeTo = newAdmin;\n    }\n\n    function admin() public view returns (address) {\n        return _upgradeTo;\n    }\n\n    fallback() external payable {\n        require(msg.sender != _upgradeTo, 'Cannot call fallback function from the proxy admin');\n        (bool success,) = _fallback.delegatecall(msg.data);\n        require(success, 'Fallback call failed.');\n    }\n\n    function upgradeTo(address newImplementation) public {\n        require(msg.sender == _upgradeTo, 'Only the admin can upgrade the contract.');\n        require(newImplementation != address(0), 'Cannot upgrade to the zero address');\n        require(isContract(newImplementation), 'Cannot set a proxy implementation to a non-contract address');\n        _fallback = newImplementation;\n        emit Upgraded(newImplementation);\n    }\n\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable {\n        upgradeTo(newImplementation);\n        (bool success,) = newImplementation.delegatecall(data);\n        require(success, 'Call after upgrade failed.');\n    }\n\n    function isContract(address _addr) private view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n}\n```\nPlease note that this is a simplified version of the decompiled code. Solidity does not support direct manipulation of the EVM memory like the decompiled code, so some of the lower-level elements have been abstracted away. Also, function names like `0x3a7` and `0x5bd` are not supported in Solidity, so they have been removed. This version should provide similar functionality as the decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701456396,
	"id": "chatcmpl-8R2p28b3TlBflibkIAxO9Is1ccHcv",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.14 11:32 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fallback; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc]\nuint256 _upgradeTo; // STORAGE[0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103]\n\n// Events\nAdminChanged(address, address);\nUpgraded(address);\n\nfunction implementation() public nonPayable { \n    v0 = 0x3a7();\n    return address(v0);\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        require(varg0 != 0, 'Cannot change the admin of a proxy to the zero address');\n        emit AdminChanged(address(_upgradeTo), varg0);\n        _upgradeTo = varg0;\n        exit;\n    }\n}\n\nfunction admin() public nonPayable { \n    v0 = 0x5bd();\n    return address(v0);\n}\n\nfunction 0x3a7() private { \n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _fallback;\n    }\n}\n\nfunction 0x5bd() private { \n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _upgradeTo;\n    }\n}\n\nfunction 0x615() private { \n    require(msg.sender != address(_upgradeTo), 'Cannot call fallback function from the proxy admin');\n    return ;\n}\n\nfunction fallback() public payable { \n    0x615();\n    v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v0 != 0); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        0x778(varg0);\n        exit;\n    }\n}\n\nfunction 0x778(uint256 varg0) private { \n    require(varg0.code.size > 0, 'Cannot set a proxy implementation to a non-contract address');\n    _fallback = varg0;\n    emit Upgraded(address(varg0));\n    return ;\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        0x778(varg0);\n        v1, v2 = varg0.delegatecall(MEM[(MEM[64]) len (MEM[64] + (?).length - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);\n        if (RETURNDATASIZE() != 0) {\n            v3 = new bytes[](RETURNDATASIZE());\n            v2 = v3.data;\n            RETURNDATACOPY(v2, 0, RETURNDATASIZE());\n        }\n        require(v1);\n        exit;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x3659cfe6 == function_selector) {\n            upgradeTo(address);\n        } else if (0x4f1ef286 == function_selector) {\n            upgradeToAndCall(address,bytes);\n        } else if (0x5c60da1b == function_selector) {\n            implementation();\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 11:32 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fallback; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc]\nuint256 _upgradeTo; // STORAGE[0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103]\n\n// Events\nAdminChanged(address, address);\nUpgraded(address);\n\nfunction implementation() public nonPayable { \n    v0 = 0x3a7();\n    return address(v0);\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        require(varg0 != 0, 'Cannot change the admin of a proxy to the zero address');\n        emit AdminChanged(address(_upgradeTo), varg0);\n        _upgradeTo = varg0;\n        exit;\n    }\n}\n\nfunction admin() public nonPayable { \n    v0 = 0x5bd();\n    return address(v0);\n}\n\nfunction 0x3a7() private { \n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _fallback;\n    }\n}\n\nfunction 0x5bd() private { \n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _upgradeTo;\n    }\n}\n\nfunction 0x615() private { \n    require(msg.sender != address(_upgradeTo), 'Cannot call fallback function from the proxy admin');\n    return ;\n}\n\nfunction fallback() public payable { \n    0x615();\n    v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v0 != 0); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        0x778(varg0);\n        exit;\n    }\n}\n\nfunction 0x778(uint256 varg0) private { \n    require(varg0.code.size > 0, 'Cannot set a proxy implementation to a non-contract address');\n    _fallback = varg0;\n    emit Upgraded(address(varg0));\n    return ;\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        0x778(varg0);\n        v1, v2 = varg0.delegatecall(MEM[(MEM[64]) len (MEM[64] + (?).length - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);\n        if (RETURNDATASIZE() != 0) {\n            v3 = new bytes[](RETURNDATASIZE());\n            v2 = v3.data;\n            RETURNDATACOPY(v2, 0, RETURNDATASIZE());\n        }\n        require(v1);\n        exit;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x3659cfe6 == function_selector) {\n            upgradeTo(address);\n        } else if (0x4f1ef286 == function_selector) {\n            upgradeToAndCall(address,bytes);\n        } else if (0x5c60da1b == function_selector) {\n            implementation();\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 11:32 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fallback; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc]\nuint256 _upgradeTo; // STORAGE[0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103]\n\n// Events\nAdminChanged(address, address);\nUpgraded(address);\n\nfunction implementation() public nonPayable { \n    v0 = 0x3a7();\n    return address(v0);\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        require(varg0 != 0, 'Cannot change the admin of a proxy to the zero address');\n        emit AdminChanged(address(_upgradeTo), varg0);\n        _upgradeTo = varg0;\n        exit;\n    }\n}\n\nfunction admin() public nonPayable { \n    v0 = 0x5bd();\n    return address(v0);\n}\n\nfunction 0x3a7() private { \n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _fallback;\n    }\n}\n\nfunction 0x5bd() private { \n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _upgradeTo;\n    }\n}\n\nfunction 0x615() private { \n    require(msg.sender != address(_upgradeTo), 'Cannot call fallback function from the proxy admin');\n    return ;\n}\n\nfunction fallback() public payable { \n    0x615();\n    v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v0 != 0); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        0x778(varg0);\n        exit;\n    }\n}\n\nfunction 0x778(uint256 varg0) private { \n    require(varg0.code.size > 0, 'Cannot set a proxy implementation to a non-contract address');\n    _fallback = varg0;\n    emit Upgraded(address(varg0));\n    return ;\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= 0x100000000);\n    require(4 + varg1 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg1 + (?).length > 4 + (msg.data.length - 4))));\n    if (msg.sender != address(_upgradeTo)) {\n        0x615();\n        v0 = _fallback.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v0 != 0); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        0x778(varg0);\n        v1, v2 = varg0.delegatecall(MEM[(MEM[64]) len (MEM[64] + (?).length - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);\n        if (RETURNDATASIZE() != 0) {\n            v3 = new bytes[](RETURNDATASIZE());\n            v2 = v3.data;\n            RETURNDATACOPY(v2, 0, RETURNDATASIZE());\n        }\n        require(v1);\n        exit;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x3659cfe6 == function_selector) {\n            upgradeTo(address);\n        } else if (0x4f1ef286 == function_selector) {\n            upgradeToAndCall(address,bytes);\n        } else if (0x5c60da1b == function_selector) {\n            implementation();\n        } else if (0x8f283970 == function_selector) {\n            changeAdmin(address);\n        } else if (0xf851a440 == function_selector) {\n            admin();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 31.983707904815674,
	"usage": {
		"completion_tokens": 487,
		"prompt_tokens": 1388,
		"total_tokens": 1875
	}
}