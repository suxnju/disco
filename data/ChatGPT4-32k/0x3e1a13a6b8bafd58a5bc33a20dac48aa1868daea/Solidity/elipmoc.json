{
	"address": "0x3e1a13a6b8bafd58a5bc33a20dac48aa1868daea",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract that corresponds to the decompiled code:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    uint256 private _mintarget; \n    mapping (address => uint256) private _balances; \n    mapping (address => uint256) private _targets;\n    address private _owner; \n\n    event Reserved(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function withdrawMoney(uint256 amount) public { \n        require(amount > 0 && _targets[msg.sender] >= amount && _balances[msg.sender] >= amount, \"Invalid operation\");\n        _balances[msg.sender] -= amount;\n        _balances[_owner] += (amount * 2) / 100;\n        \n        (bool success,) = msg.sender.call.value(amount - (amount * 2) / 100)(\"\");\n        require(success, \"Withdraw failed\");\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function targets(address user) public view returns(uint256) { \n        return _targets[user];\n    }\n\n    function owner() public view returns(address) { \n        return _owner;\n    }\n\n    function mintarget() public view returns(uint256) { \n        return _mintarget;\n    }\n\n    function setTarget(uint256 target) public { \n        require(target >= _mintarget && _balances[msg.sender] > 0, \"Invalid operation\");\n        _targets[msg.sender] = target;\n    }\n\n    receive() external payable { \n        _balances[msg.sender] += msg.value;\n        _targets[msg.sender] = _mintarget;\n        \n        emit Reserved(msg.sender, msg.value);\n    }\n\n    function setMinTarget(uint256 target) public { \n        require(msg.sender == _owner, \"Only owner can set the minimum target\");\n        _mintarget = target;\n    }\n\n    function balances(address user) public view returns(uint256) { \n        return _balances[user];\n    }\n}\n```\n\nPlease note that the exact functionality might differ slightly from the original contract as the decompiled code is not complete. And also, the Solidity version used in the pragma statement may need to be adjusted depending on the version used in the original contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701468794,
	"id": "chatcmpl-8R630C6AoczehAqNMRsUGimGs5hB7",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 01:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _mintarget; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _targets; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nReserved(address, uint256);\nWithdrawn(address, uint256);\n\nfunction withdrawMoney(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 <= 0;\n    if (varg0 > 0) {\n        v0 = v2 = _targets[msg.sender] < _targets[msg.sender];\n    }\n    if (!v0) {\n        v0 = v3 = _balances[msg.sender] < varg0;\n    }\n    require(!v0);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _balances[_owner] = _balances[_owner] + (varg0 << 1) / 100;\n    v4 = msg.sender.call().value(varg0 - (varg0 << 1) / 100).gas(!(varg0 - (varg0 << 1) / 100) * 2300);\n    require(v4);\n    emit Withdrawn(msg.sender, varg0);\n    return 1;\n}\n\nfunction targets(address varg0) public nonPayable { \n    return _targets[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction mintarget() public nonPayable { \n    return _mintarget;\n}\n\nfunction setTarget(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 < _mintarget;\n    if (varg0 >= _mintarget) {\n        v0 = v2 = _balances[msg.sender] <= 0;\n    }\n    require(!v0);\n    _targets[msg.sender] = varg0;\n    return 1;\n}\n\nfunction fallback() public payable { \n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    _targets[msg.sender] = _mintarget;\n    emit Reserved(msg.sender, msg.value);\n}\n\nfunction setMinTarget(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _mintarget = varg0;\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x248e1993 == function_selector) {\n            setMinTarget(uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x54876921 == function_selector) {\n            withdrawMoney(uint256);\n        } else if (0x562c4784 == function_selector) {\n            targets(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x977ab3c2 == function_selector) {\n            mintarget();\n        } else if (0xb480eac0 == function_selector) {\n            setTarget(uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 01:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _mintarget; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _targets; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nReserved(address, uint256);\nWithdrawn(address, uint256);\n\nfunction withdrawMoney(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 <= 0;\n    if (varg0 > 0) {\n        v0 = v2 = _targets[msg.sender] < _targets[msg.sender];\n    }\n    if (!v0) {\n        v0 = v3 = _balances[msg.sender] < varg0;\n    }\n    require(!v0);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _balances[_owner] = _balances[_owner] + (varg0 << 1) / 100;\n    v4 = msg.sender.call().value(varg0 - (varg0 << 1) / 100).gas(!(varg0 - (varg0 << 1) / 100) * 2300);\n    require(v4);\n    emit Withdrawn(msg.sender, varg0);\n    return 1;\n}\n\nfunction targets(address varg0) public nonPayable { \n    return _targets[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction mintarget() public nonPayable { \n    return _mintarget;\n}\n\nfunction setTarget(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 < _mintarget;\n    if (varg0 >= _mintarget) {\n        v0 = v2 = _balances[msg.sender] <= 0;\n    }\n    require(!v0);\n    _targets[msg.sender] = varg0;\n    return 1;\n}\n\nfunction fallback() public payable { \n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    _targets[msg.sender] = _mintarget;\n    emit Reserved(msg.sender, msg.value);\n}\n\nfunction setMinTarget(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _mintarget = varg0;\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x248e1993 == function_selector) {\n            setMinTarget(uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x54876921 == function_selector) {\n            withdrawMoney(uint256);\n        } else if (0x562c4784 == function_selector) {\n            targets(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x977ab3c2 == function_selector) {\n            mintarget();\n        } else if (0xb480eac0 == function_selector) {\n            setTarget(uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 01:20 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _mintarget; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _targets; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\n\n// Events\nReserved(address, uint256);\nWithdrawn(address, uint256);\n\nfunction withdrawMoney(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 <= 0;\n    if (varg0 > 0) {\n        v0 = v2 = _targets[msg.sender] < _targets[msg.sender];\n    }\n    if (!v0) {\n        v0 = v3 = _balances[msg.sender] < varg0;\n    }\n    require(!v0);\n    _balances[msg.sender] = _balances[msg.sender] - varg0;\n    _balances[_owner] = _balances[_owner] + (varg0 << 1) / 100;\n    v4 = msg.sender.call().value(varg0 - (varg0 << 1) / 100).gas(!(varg0 - (varg0 << 1) / 100) * 2300);\n    require(v4);\n    emit Withdrawn(msg.sender, varg0);\n    return 1;\n}\n\nfunction targets(address varg0) public nonPayable { \n    return _targets[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction mintarget() public nonPayable { \n    return _mintarget;\n}\n\nfunction setTarget(uint256 varg0) public nonPayable { \n    v0 = v1 = varg0 < _mintarget;\n    if (varg0 >= _mintarget) {\n        v0 = v2 = _balances[msg.sender] <= 0;\n    }\n    require(!v0);\n    _targets[msg.sender] = varg0;\n    return 1;\n}\n\nfunction fallback() public payable { \n    _balances[msg.sender] = _balances[msg.sender] + msg.value;\n    _targets[msg.sender] = _mintarget;\n    emit Reserved(msg.sender, msg.value);\n}\n\nfunction setMinTarget(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _mintarget = varg0;\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x248e1993 == function_selector) {\n            setMinTarget(uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x54876921 == function_selector) {\n            withdrawMoney(uint256);\n        } else if (0x562c4784 == function_selector) {\n            targets(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x977ab3c2 == function_selector) {\n            mintarget();\n        } else if (0xb480eac0 == function_selector) {\n            setTarget(uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 17.098857641220093,
	"usage": {
		"completion_tokens": 459,
		"prompt_tokens": 836,
		"total_tokens": 1295
	}
}