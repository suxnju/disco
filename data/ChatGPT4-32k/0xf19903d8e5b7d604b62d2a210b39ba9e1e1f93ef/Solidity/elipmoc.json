{
	"address": "0xf19903d8e5b7d604b62d2a210b39ba9e1e1f93ef",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity version of the decompiled EVM bytecode might look something like this. Note that some parts of the code (like handling the incoming function call parameters and the internal memory management) are abstracted away by Solidity and therefore don't appear in the Solidity code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract TokenContract {\n    uint256[] private _symbol;\n    uint256[] private _name;\n    uint256 private __totalSupply;\n    uint256 private _unitsOneEthCanBuy;\n    uint256 private _totalEthInWei;\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    address private _owner;\n    uint8 private _decimals;\n    address private _newOwner;\n    address private _fundsWallet;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function fallback() external payable {\n        _totalEthInWei += msg.value;\n        if (_balances[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n            _balances[_fundsWallet] -= msg.value * _unitsOneEthCanBuy;\n            _balances[msg.sender] += msg.value * _unitsOneEthCanBuy;\n            emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n            (bool success,) = _fundsWallet.call{value: msg.value, gas: msg.value * 2300}(\"\");\n            require(success);\n        }\n    }\n\n    function name() external view returns (string memory) {\n        // The logic to convert the _name array into a string is omitted for brevity.\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return __totalSupply;\n    }\n\n    function fundsWallet() external view returns (address) {\n        return _fundsWallet;\n    }\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool) {\n        require(value <= _balances[from]);\n        _balances[from] -= value;\n        require(value <= _allowances[msg.sender][from]);\n        _allowances[msg.sender][from] -= value;\n        require(_balances[to] + value >= _balances[to]);\n        _balances[to] += value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == _newOwner);\n        emit OwnershipTransferred(_owner, _newOwner);\n        _owner = _newOwner;\n        _newOwner = address(0);\n    }\n\n    function owner() external view returns (address) {\n        return _owner;\n    }\n\n    function totalEthInWei() external view returns (uint256) {\n        return _totalEthInWei;\n    }\n\n    function symbol() external view returns (string memory) {\n        // The logic to convert the _symbol array into a string is omitted for brevity.\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        require(value <= _balances[msg.sender]);\n        _balances[msg.sender] -= value;\n        require(_balances[to] + value >= _balances[to]);\n        _balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        (bool success,) = spender.call(data);\n        require(success);\n        return true;\n    }\n\n    function newOwner() external view returns (address) {\n        return _newOwner;\n    }\n\n    function transferAnyERC20Token(address tokenAddress, uint256 amount) external {\n        require(msg.sender == _owner);\n        // Logic to transfer tokens from the contract to the owner is omitted.\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferOwnership(address newOwner) external {\n        require(msg.sender == _owner);\n        _newOwner = newOwner;\n    }\n}\n```\nPlease note that the original bytecode decompiled code doesn't seem to have a constructor. Also, please note that the logic to convert `uint256[]` to `string` in `name()` and `symbol()` methods are complicated and omitted in this example. You might want to simply use `string` type for `_name` and `_symbol` in your actual Solidity contract, unless there are specific reasons to use `uint256[]`.",
				"role": "assistant"
			}
		}
	],
	"created": 1701465876,
	"id": "chatcmpl-8R5Hwo2dARZBB3SZBsWoAN7A5mpwg",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 13:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256 __totalSupply; // STORAGE[0x5]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x6]\nuint256 _totalEthInWei; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _fundsWallet; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_totalSupply[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _totalSupply[_fundsWallet] = _totalSupply[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _totalSupply[msg.sender] = _totalSupply[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = _fundsWallet.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply - _totalSupply[0];\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _totalSupply[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _totalSupply[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg1;\n    require(_totalSupply[varg0] + varg1 >= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferAnyERC20Token(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(_owner, varg1).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xdc39d06d == function_selector) {\n            transferAnyERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 13:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256 __totalSupply; // STORAGE[0x5]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x6]\nuint256 _totalEthInWei; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _fundsWallet; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_totalSupply[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _totalSupply[_fundsWallet] = _totalSupply[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _totalSupply[msg.sender] = _totalSupply[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = _fundsWallet.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply - _totalSupply[0];\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _totalSupply[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _totalSupply[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg1;\n    require(_totalSupply[varg0] + varg1 >= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferAnyERC20Token(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(_owner, varg1).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xdc39d06d == function_selector) {\n            transferAnyERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 13:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256 __totalSupply; // STORAGE[0x5]\nuint256 _unitsOneEthCanBuy; // STORAGE[0x6]\nuint256 _totalEthInWei; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0xa]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x4] bytes 0 to 0\naddress _newOwner; // STORAGE[0x1] bytes 0 to 19\naddress _fundsWallet; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction fallback() public payable { \n    _totalEthInWei = _totalEthInWei + msg.value;\n    if (_totalSupply[_fundsWallet] >= msg.value * _unitsOneEthCanBuy) {\n        _totalSupply[_fundsWallet] = _totalSupply[_fundsWallet] - msg.value * _unitsOneEthCanBuy;\n        _totalSupply[msg.sender] = _totalSupply[msg.sender] + msg.value * _unitsOneEthCanBuy;\n        emit Transfer(_fundsWallet, msg.sender, msg.value * _unitsOneEthCanBuy);\n        v0 = _fundsWallet.call().value(msg.value).gas(!msg.value * 2300);\n        require(v0);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply - _totalSupply[0];\n}\n\nfunction fundsWallet() public nonPayable { \n    return _fundsWallet;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _totalSupply[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction unitsOneEthCanBuy() public nonPayable { \n    return _unitsOneEthCanBuy;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _totalSupply[varg0];\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _newOwner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n    _newOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalEthInWei() public nonPayable { \n    return _totalEthInWei;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg1;\n    require(_totalSupply[varg0] + varg1 >= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[100 + MEM[64] + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v3 = v4 = v0.length + (100 + MEM[64]);\n    if (0x1f & v0.length) {\n        MEM[v4 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v4 - (0x1f & v0.length)];\n    }\n    v5 = varg0.receiveApproval(msg.sender, varg1, address(this)).gas(msg.gas - 25710);\n    require(v5);\n    return 1;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferAnyERC20Token(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    MEM[32 + MEM[64]] = 0;\n    require(varg0.code.size);\n    v0, v1 = varg0.transfer(_owner, varg1).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x2194f3a2 == function_selector) {\n            fundsWallet();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3eaaf86b == function_selector) {\n            _totalSupply();\n        } else if (0x65f2bc2e == function_selector) {\n            unitsOneEthCanBuy();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79ba5097 == function_selector) {\n            acceptOwnership();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x933ba413 == function_selector) {\n            totalEthInWei();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xd4ee1d90 == function_selector) {\n            newOwner();\n        } else if (0xdc39d06d == function_selector) {\n            transferAnyERC20Token(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 46.48825287818909,
	"usage": {
		"completion_tokens": 1082,
		"prompt_tokens": 2407,
		"total_tokens": 3489
	}
}