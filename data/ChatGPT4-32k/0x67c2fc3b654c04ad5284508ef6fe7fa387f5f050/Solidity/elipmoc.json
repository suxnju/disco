{
	"address": "0x67c2fc3b654c04ad5284508ef6fe7fa387f5f050",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code from the decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.19;\n\ncontract Token {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) private _isBot;\n    uint256 private _totalSupply;\n    address private _owner;\n\n    event MaxTxAmountUpdated(uint256 maxTxAmount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function name() public pure returns (string memory) {\n        return \"Token Name\";\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"TKN\";\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 9;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _allowances[msg.sender][spender] = _allowances[msg.sender][spender] + addedValue;\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        uint256 oldValue = _allowances[msg.sender][spender];\n        if (subtractedValue >= oldValue) {\n            _allowances[msg.sender][spender] = 0;\n        } else {\n            _allowances[msg.sender][spender] = oldValue - subtractedValue;\n        }\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n        return true;\n    }\n}\n```\n\nPlease note that this code is a simplified version and doesn't include all the functionalities of the original contract, such as the 'isBot', 'maxTxAmount' and 'openTrading' functions. Furthermore, the 'name' and 'symbol' functions are placeholders and need to be replaced with the actual token name and symbol. The same applies to the 'totalSupply' value. The 'decimals' function is also a placeholder and should be replaced with the actual number of decimals the token uses.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495453,
	"id": "chatcmpl-8VP81YqZxIEbX3EgCqiVyYbWDqV2V",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.20 08:44 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nMaxTxAmountUpdated(uint256);\nOwnershipTransferred(address, address);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x5f5e100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction RemoveLimit() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x5f5e100;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x5f5e100;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x5f5e100);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(v0 * 0x5f5e100, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction delBot(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(0) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction addsBot(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(1) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3525;\n        v10 = v11 = 100;\n        v12 = v13 = 8993;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x1259. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x2346', '0x2321'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x1029', '0xdc5'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= stor_6 + 3, Panic(17)); // arithmetic overflow or underflow\n                        if (stor_6 + 3 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4137;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9030;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    v56[v57.length] = 0;\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x12d0. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x2346', '0x2321'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x7d1db4a5 > function_selector >> 224) {\n        if (0x2d53e1bd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x2d53e1bd == function_selector >> 224) {\n            RemoveLimit();\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xbf474bed > function_selector >> 224) {\n        if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else if (0x95d89b41 == function_selector >> 224) {\n            symbol();\n        } else {\n            require(0xa9059cbb == function_selector >> 224);\n            transfer(address,uint256);\n        }\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else if (0xc97c1821 == function_selector >> 224) {\n        delBot(address[]);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xe644f514 == function_selector >> 224);\n        addsBot(address[]);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 08:44 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nMaxTxAmountUpdated(uint256);\nOwnershipTransferred(address, address);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x5f5e100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction RemoveLimit() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x5f5e100;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x5f5e100;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x5f5e100);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(v0 * 0x5f5e100, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction delBot(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(0) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction addsBot(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(1) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3525;\n        v10 = v11 = 100;\n        v12 = v13 = 8993;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x1259. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x2346', '0x2321'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x1029', '0xdc5'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= stor_6 + 3, Panic(17)); // arithmetic overflow or underflow\n                        if (stor_6 + 3 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4137;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9030;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    v56[v57.length] = 0;\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x12d0. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x2346', '0x2321'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x7d1db4a5 > function_selector >> 224) {\n        if (0x2d53e1bd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x2d53e1bd == function_selector >> 224) {\n            RemoveLimit();\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xbf474bed > function_selector >> 224) {\n        if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else if (0x95d89b41 == function_selector >> 224) {\n            symbol();\n        } else {\n            require(0xa9059cbb == function_selector >> 224);\n            transfer(address,uint256);\n        }\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else if (0xc97c1821 == function_selector >> 224) {\n        delBot(address[]);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xe644f514 == function_selector >> 224);\n        addsBot(address[]);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 08:44 UTC\n// Compiled using the solidity compiler version 0.8.19\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nMaxTxAmountUpdated(uint256);\nOwnershipTransferred(address, address);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x5f5e100;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction RemoveLimit() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x5f5e100;\n    v1 = _SafeExp(10, uint8(9));\n    require((v1 == v1 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x5f5e100;\n    v2 = _SafeExp(10, uint8(9));\n    require((v2 == v2 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x5f5e100);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    require((v0 == v0 * 0x5f5e100 / 0x5f5e100) | !0x5f5e100, Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(v0 * 0x5f5e100, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).createPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    owner_14 = bytes12(owner_14) | address(v6);\n    v7, /* uint256 */ v8, /* uint256 */ v9, /* uint256 */ v10 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v11, /* bool */ v12 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v12 == bool(v12));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction delBot(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(0) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction addsBot(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    require(32 + ((varg0.length << 5) + (4 + varg0)) <= msg.data.length);\n    v3 = v4 = varg0.data;\n    while (v3 < 32 + ((varg0.length << 5) + (4 + varg0))) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v3 += 32;\n        v1 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        require(v5 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v5])] = bool(1) | bytes31(_isBot[address(v0[v5])]);\n        require(v5 + 1, Panic(17)); // arithmetic overflow or underflow\n        v5 += 1;\n    }\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3525;\n        v10 = v11 = 100;\n        v12 = v13 = 8993;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x1259. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x2346', '0x2321'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x1029', '0xdc5'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= stor_6 + 3, Panic(17)); // arithmetic overflow or underflow\n                        if (stor_6 + 3 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4137;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9030;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    v56[v57.length] = 0;\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x12d0. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x2346', '0x2321'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x7d1db4a5 > function_selector >> 224) {\n        if (0x2d53e1bd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x2d53e1bd == function_selector >> 224) {\n            RemoveLimit();\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xbf474bed > function_selector >> 224) {\n        if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else if (0x95d89b41 == function_selector >> 224) {\n            symbol();\n        } else {\n            require(0xa9059cbb == function_selector >> 224);\n            transfer(address,uint256);\n        }\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else if (0xc97c1821 == function_selector >> 224) {\n        delBot(address[]);\n    } else if (0xdd62ed3e == function_selector >> 224) {\n        allowance(address,address);\n    } else {\n        require(0xe644f514 == function_selector >> 224);\n        addsBot(address[]);\n    }\n}\n.",
	"status": "1",
	"time_cost": 84.04237961769104,
	"usage": {
		"completion_tokens": 830,
		"prompt_tokens": 6455,
		"total_tokens": 7285
	}
}