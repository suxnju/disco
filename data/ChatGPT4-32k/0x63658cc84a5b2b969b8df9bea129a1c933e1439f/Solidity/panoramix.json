{
	"address": "0x63658cc84a5b2b969b8df9bea129a1c933e1439f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Apologies for any confusion, but the code you've provided is a decompiled code from EVM bytecode, which doesn't exactly map to a Solidity contract. However, the code seems to refer to a token contract (perhaps an ERC721, given the presence of functions like `tokenOfOwnerByIndex`, `totalSupply`, `approve`, etc.). \n\nHere is a simple example of what an ERC721 contract might look like in Solidity, for reference:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyToken is ERC721, Ownable {\n    uint public nextTokenId;\n    address public admin;\n\n    constructor() ERC721(\"My Token\", \"MTK\") {\n        admin = msg.sender;\n    }\n\n    function mint(address to) external {\n        require(msg.sender == admin, \"only admin\");\n        _mint(to, nextTokenId);\n        nextTokenId++;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return \"https://fungibles.com/token/\";\n    }\n}\n```\n\nPlease note that this is a very basic example and does not include all the methods from the decompiled code you provided. You would need to extend this with the appropriate methods as per your specific requirements.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471611,
	"id": "chatcmpl-8MudPF7TTn9fdDaLRjaqX5LSBqUze",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of uint8 at storage 0\n  ownerOf is mapping of address at storage 1\n  approved is mapping of address at storage 2\n  balanceOf is mapping of uint256 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  tokenOfOwnerByIndex is array of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  tokenByIndex is array of uint256 at storage 7\n  stor8 is mapping of uint256 at storage 8\n  name is array of uint256 at storage 9\n  symbol is array of uint256 at storage 10\n  stor11 is mapping of struct at storage 11\n  owner is address at storage 12\n  liveTokenId is uint256 at storage 13\n  price is uint256 at storage 14\n  info is array of uint256 at storage 15\n  infohasnotbeenset is uint8 at storage 16\n  baseTokenURI is array of struct at storage 17\n\ndef supportsInterface(bytes4 interfaceId): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor0[Mask(32, 224, interfaceId)])\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef getApproved(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  return approved[tokenId]\n\ndef totalSupply(): # not payable\n  return tokenByIndex.length\n\ndef tokenOfOwnerByIndex(address owner, uint256 index): # not payable\n  require calldata.size - 4 >= 64\n  require owner\n  require index < balanceOf[address(owner)]\n  require index < tokenOfOwnerByIndex[address(owner)]\n  return tokenOfOwnerByIndex[address(owner)][index]\n\ndef info(): # not payable\n  return info[0 len info.length]\n\ndef tokenByIndex(uint256 index): # not payable\n  require calldata.size - 4 >= 32\n  require index < tokenByIndex.length\n  return tokenByIndex[index]\n\ndef ownerOf(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  return ownerOf[tokenId]\n\ndef balanceOf(address account): # not payable\n  require calldata.size - 4 >= 32\n  require account\n  return balanceOf[address(account)]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef price(): # not payable\n  return price\n\ndef infohasnotbeenset(): # not payable\n  return bool(infohasnotbeenset)\n\ndef liveTokenId(): # not payable\n  return liveTokenId\n\ndef baseTokenURI(): # not payable\n  return baseTokenURI[0 len baseTokenURI.length].field_0\n\ndef isApprovedForAll(address owner, address operator): # not payable\n  require calldata.size - 4 >= 64\n  return bool(stor4[address(owner)][address(operator)])\n\n#\n#  Regular functions\n#\n\ndef isOwner(): # not payable\n  return (caller == owner)\n\ndef renounceOwnership(): # not payable\n  require caller == owner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef transferOwnership(address newOwner): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef setApprovalForAll(address operator, bool approved): # not payable\n  require calldata.size - 4 >= 64\n  require operator != caller\n  stor4[caller][address(operator)] = uint8(approved)\n  log ApprovalForAll(\n        address owner=approved,\n        address operator=caller,\n        bool approved=operator)\n\ndef changeBaseTokenURI(string _uri): # not payable\n  require calldata.size - 4 >= 32\n  require _uri <= unknown10000000()\n  require _uri + 36 <= calldata.size\n  require _uri.length <= unknown10000000() and _uri + _uri.length + 36 <= calldata.size\n  require caller == owner\n  baseTokenURI[].field_0 = Array(len=_uri.length, data=_uri[all])\n\ndef changeInfo(string newstring): # not payable\n  require calldata.size - 4 >= 32\n  require newstring <= unknown10000000()\n  require newstring + 36 <= calldata.size\n  require newstring.length <= unknown10000000() and newstring + newstring.length + 36 <= calldata.size\n  require caller == owner\n  require infohasnotbeenset\n  info[] = Array(len=newstring.length, data=newstring[all])\n  infohasnotbeenset = 0\n\ndef approve(address spender, uint256 amount): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[amount]\n  require spender != ownerOf[amount]\n  if ownerOf[amount] != caller:\n      require stor4[stor1[amount]][caller]\n  approved[amount] = spender\n  log Approval(\n        address owner=ownerOf[amount],\n        address spender=spender,\n        uint256 value=amount)\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[amount]\n  require ownerOf[amount]\n  if ownerOf[amount] != caller:\n      if approved[amount] != caller:\n          require stor4[stor1[amount]][caller]\n  require ownerOf[amount] == sender\n  require recipient\n  if approved[amount]:\n      approved[amount] = 0\n  require 1 <= balanceOf[address(sender)]\n  balanceOf[address(sender)]--\n  balanceOf[address(recipient)]++\n  ownerOf[amount] = recipient\n  log Transfer(\n        address from=sender,\n        address to=recipient,\n        uint256 value=amount)\n  require 1 <= tokenOfOwnerByIndex[address(sender)]\n  if stor6[amount] != tokenOfOwnerByIndex[address(sender)] - 1:\n      require tokenOfOwnerByIndex[address(sender)] - 1 < tokenOfOwnerByIndex[address(sender)]\n      require stor6[amount] < tokenOfOwnerByIndex[address(sender)]\n      tokenOfOwnerByIndex[address(sender)][stor6[amount]] = tokenOfOwnerByIndex[address(sender)][tokenOfOwnerByIndex[address(sender)]]\n      stor6[stor5[address(sender)][stor5[address(sender)]]] = stor6[amount]\n  tokenOfOwnerByIndex[address(sender)]--\n  if tokenOfOwnerByIndex[address(sender)] > tokenOfOwnerByIndex[address(sender)] - 1:\n      idx = tokenOfOwnerByIndex[address(sender)] - 1\n      while tokenOfOwnerByIndex[address(sender)] > idx:\n          tokenOfOwnerByIndex[address(sender)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[amount] = tokenOfOwnerByIndex[address(recipient)]\n  tokenOfOwnerByIndex[address(recipient)]++\n  tokenOfOwnerByIndex[address(recipient)][tokenOfOwnerByIndex[address(recipient)]] = amount\n\ndef _fallback(?) payable: # default function\n  if call.value >= price:\n      call 0x4257d02e2854c9c86d6975fcd14a1af4fa65a652 with:\n         value call.value / 2 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      call 0x2ea533314069dc9b4df29e72bd1dfb64cc68456d with:\n         value call.value / 2 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[128] = call.value\n      log PaymentReceived(\n            address from=caller,\n            uint256 amount=call.value)\n      require liveTokenId <= 360\n      liveTokenId++\n      require caller\n      require not ownerOf[stor13]\n      ownerOf[stor13] = caller\n      balanceOf[caller]++\n      log Transfer(\n            address from=0,\n            address to=caller,\n            uint256 value=liveTokenId)\n      stor6[stor13] = tokenOfOwnerByIndex[caller]\n      tokenOfOwnerByIndex[caller]++\n      tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = liveTokenId\n      stor8[stor13] = tokenByIndex.length\n      tokenByIndex.length++\n      tokenByIndex[tokenByIndex.length] = liveTokenId\n      if not liveTokenId:\n          require ownerOf[stor13]\n          stor11[stor13].field_0 = 0\n          stor11[stor13].field_1 = 1\n          stor11[stor13].field_8 = '0' / 256\n          idx = 0\n          while stor11[stor13].length + 31 / 32 > idx:\n              stor11[stor13][idx].field_0 = 0\n              idx = idx + 1\n              continue \n      else:\n          s = 0\n          idx = liveTokenId\n          while idx:\n              s = s + 1\n              idx = idx / 10\n              continue \n          mem[96] = s\n          if s:\n              mem[128 len s] = code.data[11315 len s]\n          t = s - 1\n          idx = liveTokenId\n          while idx:\n              require t < mem[96]\n              mem[t + 128 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256\n              t = t - 1\n              idx = idx / 10\n              continue \n          require ownerOf[stor13]\n          stor11[stor13][].field_0 = Array(len=mem[96], data=mem[128 len mem[96]])\n      log TokenMinted(\n            address owner=caller,\n            uint256 quantity=liveTokenId)\n      price += price / 75\n\ndef safeTransferFrom(address from, address to, uint256 tokenId): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[tokenId]\n  require ownerOf[tokenId]\n  if ownerOf[tokenId] != caller:\n      if approved[tokenId] != caller:\n          require stor4[stor1[tokenId]][caller]\n  require ownerOf[tokenId] == from\n  require to\n  if approved[tokenId]:\n      approved[tokenId] = 0\n  require 1 <= balanceOf[address(from)]\n  balanceOf[address(from)]--\n  balanceOf[address(to)]++\n  ownerOf[tokenId] = to\n  log Transfer(\n        address from=from,\n        address to=to,\n        uint256 value=tokenId)\n  require 1 <= tokenOfOwnerByIndex[address(from)]\n  if stor6[tokenId] != tokenOfOwnerByIndex[address(from)] - 1:\n      require tokenOfOwnerByIndex[address(from)] - 1 < tokenOfOwnerByIndex[address(from)]\n      require stor6[tokenId] < tokenOfOwnerByIndex[address(from)]\n      tokenOfOwnerByIndex[address(from)][stor6[tokenId]] = tokenOfOwnerByIndex[address(from)][tokenOfOwnerByIndex[address(from)]]\n      stor6[stor5[address(from)][stor5[address(from)]]] = stor6[tokenId]\n  tokenOfOwnerByIndex[address(from)]--\n  if tokenOfOwnerByIndex[address(from)] > tokenOfOwnerByIndex[address(from)] - 1:\n      idx = tokenOfOwnerByIndex[address(from)] - 1\n      while tokenOfOwnerByIndex[address(from)] > idx:\n          tokenOfOwnerByIndex[address(from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[tokenId] = tokenOfOwnerByIndex[address(to)]\n  tokenOfOwnerByIndex[address(to)]++\n  tokenOfOwnerByIndex[address(to)][tokenOfOwnerByIndex[address(to)]] = tokenId\n  if ext_code.size(to) > 0:\n      require ext_code.size(to)\n      call to.onERC721Received(address , address , uint256 , bytes ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), address(from), tokenId, 128, 0\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require Mask(32, 224, ext_call.return_data[0]) == 0x150b7a0200000000000000000000000000000000000000000000000000000000\n\ndef createToken(address newowner): # not payable\n  require calldata.size - 4 >= 32\n  if 0x1003d51fef31e52262b1e699f03c789ca6dbefdc != caller:\n      require caller == owner\n  require liveTokenId <= 360\n  liveTokenId++\n  require newowner\n  require not ownerOf[stor13]\n  ownerOf[stor13] = newowner\n  balanceOf[address(newowner)]++\n  log Transfer(\n        address from=0,\n        address to=newowner,\n        uint256 value=liveTokenId)\n  stor6[stor13] = tokenOfOwnerByIndex[address(newowner)]\n  tokenOfOwnerByIndex[address(newowner)]++\n  tokenOfOwnerByIndex[address(newowner)][tokenOfOwnerByIndex[address(newowner)]] = liveTokenId\n  stor8[stor13] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = liveTokenId\n  if not liveTokenId:\n      require ownerOf[stor13]\n      stor11[stor13].field_0 = 0\n      stor11[stor13].field_1 = 1\n      stor11[stor13].field_8 = '0' / 256\n      idx = 0\n      while stor11[stor13].length + 31 / 32 > idx:\n          stor11[stor13][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      log TokenMinted(\n            address owner=address(newowner),\n            uint256 quantity=liveTokenId)\n      price += price / 75\n      return '0'\n  s = 0\n  idx = liveTokenId\n  while idx:\n      s = s + 1\n      idx = idx / 10\n      continue \n  mem[96] = s\n  mem[64] = ceil32(s) + 128\n  if s:\n      mem[128 len s] = code.data[11315 len s]\n  t = s - 1\n  idx = liveTokenId\n  while idx:\n      require t < mem[96]\n      mem[t + 128 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256\n      t = t - 1\n      idx = idx / 10\n      continue \n  require ownerOf[stor13]\n  mem[0] = sha3(liveTokenId, 11)\n  stor11[stor13][].field_0 = Array(len=mem[96], data=mem[128 len mem[96]])\n  log TokenMinted(\n        address owner=address(newowner),\n        uint256 quantity=liveTokenId)\n  price += price / 75\n  mem[mem[64]] = 32\n  mem[mem[64] + 32] = mem[96]\n  mem[mem[64] + 64 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]\n  if not mem[96] % 32:\n      return 32, mem[mem[64] + 32 len mem[96] + 32]\n  mem[floor32(mem[96]) + mem[64] + 64] = mem[floor32(mem[96]) + mem[64] + -(mem[96] % 32) + 96 len mem[96] % 32]\n  return Array(len=mem[96], data=mem[mem[64] + 64 len floor32(mem[96]) + 32])\n\ndef safeTransferFrom(address from, address to, uint256 tokenId, bytes _data): # not payable\n  require calldata.size - 4 >= 128\n  require _data <= unknown10000000()\n  require _data + 36 <= calldata.size\n  require _data.length <= unknown10000000() and _data + _data.length + 36 <= calldata.size\n  require ownerOf[tokenId]\n  require ownerOf[tokenId]\n  if ownerOf[tokenId] != caller:\n      if approved[tokenId] != caller:\n          require stor4[stor1[tokenId]][caller]\n  require ownerOf[tokenId] == from\n  require to\n  if approved[tokenId]:\n      approved[tokenId] = 0\n  require 1 <= balanceOf[address(from)]\n  balanceOf[address(from)]--\n  balanceOf[address(to)]++\n  ownerOf[tokenId] = to\n  log Transfer(\n        address from=from,\n        address to=to,\n        uint256 value=tokenId)\n  require 1 <= tokenOfOwnerByIndex[address(from)]\n  if stor6[tokenId] != tokenOfOwnerByIndex[address(from)] - 1:\n      require tokenOfOwnerByIndex[address(from)] - 1 < tokenOfOwnerByIndex[address(from)]\n      require stor6[tokenId] < tokenOfOwnerByIndex[address(from)]\n      tokenOfOwnerByIndex[address(from)][stor6[tokenId]] = tokenOfOwnerByIndex[address(from)][tokenOfOwnerByIndex[address(from)]]\n      stor6[stor5[address(from)][stor5[address(from)]]] = stor6[tokenId]\n  tokenOfOwnerByIndex[address(from)]--\n  if tokenOfOwnerByIndex[address(from)] > tokenOfOwnerByIndex[address(from)] - 1:\n      idx = tokenOfOwnerByIndex[address(from)] - 1\n      while tokenOfOwnerByIndex[address(from)] > idx:\n          tokenOfOwnerByIndex[address(from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[tokenId] = tokenOfOwnerByIndex[address(to)]\n  tokenOfOwnerByIndex[address(to)]++\n  tokenOfOwnerByIndex[address(to)][tokenOfOwnerByIndex[address(to)]] = tokenId\n  if ext_code.size(to) > 0:\n      require ext_code.size(to)\n      call to with:\n           gas gas_remaining wei\n          args caller, address(from), tokenId, Array(len=_data.length, data=_data[all])\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require Mask(32, 224, ext_call.return_data[0]) == 0x150b7a0200000000000000000000000000000000000000000000000000000000\n\ndef tokenURI(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  mem[96] = baseTokenURI.length\n  mem[128] = uint256(baseTokenURI.field_0)\n  idx = 128\n  s = 0\n  while baseTokenURI.length + 96 > idx:\n      mem[idx + 32] = baseTokenURI[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  require ownerOf[tokenId]\n  mem[32] = 11\n  _223 = ceil32(baseTokenURI.length) + 128\n  mem[64] = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  mem[ceil32(baseTokenURI.length) + 128] = stor11[tokenId].length\n  mem[0] = sha3(tokenId, 11)\n  mem[ceil32(baseTokenURI.length) + 160] = stor11[tokenId].field_0\n  idx = ceil32(baseTokenURI.length) + 160\n  s = 0\n  while ceil32(baseTokenURI.length) + stor11[tokenId].length + 128 > idx:\n      mem[idx + 32] = stor11[tokenId][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  _378 = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  _379 = baseTokenURI.length\n  mem[ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 192 len floor32(baseTokenURI.length)] = mem[128 len floor32(baseTokenURI.length)]\n  mem[ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + floor32(baseTokenURI.length) + -baseTokenURI.length % 32 + 224 len baseTokenURI.length % 32] = mem[floor32(baseTokenURI.length) + -baseTokenURI.length % 32 + 160 len baseTokenURI.length % 32]\n  _451 = stor11[tokenId].length\n  mem[_379 + _378 + 32 len floor32(stor11[tokenId].length)] = mem[ceil32(baseTokenURI.length) + 160 len floor32(stor11[tokenId].length)]\n  mem[_379 + _378 + floor32(stor11[tokenId].length) + 32] = mem[ceil32(baseTokenURI.length) + floor32(stor11[tokenId].length) + -stor11[tokenId].length % 32 + 192 len stor11[tokenId].length % 32] or Mask(8 * -stor11[tokenId].length % 32 + 32, -(8 * -stor11[tokenId].length % 32 + 32) + 256, mem[_379 + _378 + floor32(stor11[tokenId].length) + 32])\n  _518 = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  mem[64] = stor11[tokenId].length + _379 + _378 + 32\n  mem[stor11[tokenId].length + _379 + _378 + 32] = 32\n  mem[stor11[tokenId].length + _379 + _378 + 64] = mem[_518]\n  _534 = mem[_518]\n  mem[stor11[tokenId].length + _379 + _378 + 96 len ceil32(mem[_518])] = mem[_518 + 32 len ceil32(mem[_518])]\n  if not _534 % 32:\n      return 32, mem[stor11[tokenId].length + _379 + _378 + 64 len _534 + 32]\n  mem[floor32(_534) + stor11[tokenId].length + _379 + _378 + 96] = mem[floor32(_534) + stor11[tokenId].length + _379 + _378 + -(_534 % 32) + 128 len _534 % 32]\n  return 32, mem[stor11[tokenId].length + _379 + _378 + 64 len floor32(_534) + 64]\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of uint8 at storage 0\n  ownerOf is mapping of address at storage 1\n  approved is mapping of address at storage 2\n  balanceOf is mapping of uint256 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  tokenOfOwnerByIndex is array of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  tokenByIndex is array of uint256 at storage 7\n  stor8 is mapping of uint256 at storage 8\n  name is array of uint256 at storage 9\n  symbol is array of uint256 at storage 10\n  stor11 is mapping of struct at storage 11\n  owner is address at storage 12\n  liveTokenId is uint256 at storage 13\n  price is uint256 at storage 14\n  info is array of uint256 at storage 15\n  infohasnotbeenset is uint8 at storage 16\n  baseTokenURI is array of struct at storage 17\n\ndef supportsInterface(bytes4 interfaceId): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor0[Mask(32, 224, interfaceId)])\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef getApproved(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  return approved[tokenId]\n\ndef totalSupply(): # not payable\n  return tokenByIndex.length\n\ndef tokenOfOwnerByIndex(address owner, uint256 index): # not payable\n  require calldata.size - 4 >= 64\n  require owner\n  require index < balanceOf[address(owner)]\n  require index < tokenOfOwnerByIndex[address(owner)]\n  return tokenOfOwnerByIndex[address(owner)][index]\n\ndef info(): # not payable\n  return info[0 len info.length]\n\ndef tokenByIndex(uint256 index): # not payable\n  require calldata.size - 4 >= 32\n  require index < tokenByIndex.length\n  return tokenByIndex[index]\n\ndef ownerOf(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  return ownerOf[tokenId]\n\ndef balanceOf(address account): # not payable\n  require calldata.size - 4 >= 32\n  require account\n  return balanceOf[address(account)]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef price(): # not payable\n  return price\n\ndef infohasnotbeenset(): # not payable\n  return bool(infohasnotbeenset)\n\ndef liveTokenId(): # not payable\n  return liveTokenId\n\ndef baseTokenURI(): # not payable\n  return baseTokenURI[0 len baseTokenURI.length].field_0\n\ndef isApprovedForAll(address owner, address operator): # not payable\n  require calldata.size - 4 >= 64\n  return bool(stor4[address(owner)][address(operator)])\n\n#\n#  Regular functions\n#\n\ndef isOwner(): # not payable\n  return (caller == owner)\n\ndef renounceOwnership(): # not payable\n  require caller == owner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef transferOwnership(address newOwner): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef setApprovalForAll(address operator, bool approved): # not payable\n  require calldata.size - 4 >= 64\n  require operator != caller\n  stor4[caller][address(operator)] = uint8(approved)\n  log ApprovalForAll(\n        address owner=approved,\n        address operator=caller,\n        bool approved=operator)\n\ndef changeBaseTokenURI(string _uri): # not payable\n  require calldata.size - 4 >= 32\n  require _uri <= unknown10000000()\n  require _uri + 36 <= calldata.size\n  require _uri.length <= unknown10000000() and _uri + _uri.length + 36 <= calldata.size\n  require caller == owner\n  baseTokenURI[].field_0 = Array(len=_uri.length, data=_uri[all])\n\ndef changeInfo(string newstring): # not payable\n  require calldata.size - 4 >= 32\n  require newstring <= unknown10000000()\n  require newstring + 36 <= calldata.size\n  require newstring.length <= unknown10000000() and newstring + newstring.length + 36 <= calldata.size\n  require caller == owner\n  require infohasnotbeenset\n  info[] = Array(len=newstring.length, data=newstring[all])\n  infohasnotbeenset = 0\n\ndef approve(address spender, uint256 amount): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[amount]\n  require spender != ownerOf[amount]\n  if ownerOf[amount] != caller:\n      require stor4[stor1[amount]][caller]\n  approved[amount] = spender\n  log Approval(\n        address owner=ownerOf[amount],\n        address spender=spender,\n        uint256 value=amount)\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[amount]\n  require ownerOf[amount]\n  if ownerOf[amount] != caller:\n      if approved[amount] != caller:\n          require stor4[stor1[amount]][caller]\n  require ownerOf[amount] == sender\n  require recipient\n  if approved[amount]:\n      approved[amount] = 0\n  require 1 <= balanceOf[address(sender)]\n  balanceOf[address(sender)]--\n  balanceOf[address(recipient)]++\n  ownerOf[amount] = recipient\n  log Transfer(\n        address from=sender,\n        address to=recipient,\n        uint256 value=amount)\n  require 1 <= tokenOfOwnerByIndex[address(sender)]\n  if stor6[amount] != tokenOfOwnerByIndex[address(sender)] - 1:\n      require tokenOfOwnerByIndex[address(sender)] - 1 < tokenOfOwnerByIndex[address(sender)]\n      require stor6[amount] < tokenOfOwnerByIndex[address(sender)]\n      tokenOfOwnerByIndex[address(sender)][stor6[amount]] = tokenOfOwnerByIndex[address(sender)][tokenOfOwnerByIndex[address(sender)]]\n      stor6[stor5[address(sender)][stor5[address(sender)]]] = stor6[amount]\n  tokenOfOwnerByIndex[address(sender)]--\n  if tokenOfOwnerByIndex[address(sender)] > tokenOfOwnerByIndex[address(sender)] - 1:\n      idx = tokenOfOwnerByIndex[address(sender)] - 1\n      while tokenOfOwnerByIndex[address(sender)] > idx:\n          tokenOfOwnerByIndex[address(sender)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[amount] = tokenOfOwnerByIndex[address(recipient)]\n  tokenOfOwnerByIndex[address(recipient)]++\n  tokenOfOwnerByIndex[address(recipient)][tokenOfOwnerByIndex[address(recipient)]] = amount\n\ndef _fallback(?) payable: # default function\n  if call.value >= price:\n      call 0x4257d02e2854c9c86d6975fcd14a1af4fa65a652 with:\n         value call.value / 2 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      call 0x2ea533314069dc9b4df29e72bd1dfb64cc68456d with:\n         value call.value / 2 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[128] = call.value\n      log PaymentReceived(\n            address from=caller,\n            uint256 amount=call.value)\n      require liveTokenId <= 360\n      liveTokenId++\n      require caller\n      require not ownerOf[stor13]\n      ownerOf[stor13] = caller\n      balanceOf[caller]++\n      log Transfer(\n            address from=0,\n            address to=caller,\n            uint256 value=liveTokenId)\n      stor6[stor13] = tokenOfOwnerByIndex[caller]\n      tokenOfOwnerByIndex[caller]++\n      tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = liveTokenId\n      stor8[stor13] = tokenByIndex.length\n      tokenByIndex.length++\n      tokenByIndex[tokenByIndex.length] = liveTokenId\n      if not liveTokenId:\n          require ownerOf[stor13]\n          stor11[stor13].field_0 = 0\n          stor11[stor13].field_1 = 1\n          stor11[stor13].field_8 = '0' / 256\n          idx = 0\n          while stor11[stor13].length + 31 / 32 > idx:\n              stor11[stor13][idx].field_0 = 0\n              idx = idx + 1\n              continue \n      else:\n          s = 0\n          idx = liveTokenId\n          while idx:\n              s = s + 1\n              idx = idx / 10\n              continue \n          mem[96] = s\n          if s:\n              mem[128 len s] = code.data[11315 len s]\n          t = s - 1\n          idx = liveTokenId\n          while idx:\n              require t < mem[96]\n              mem[t + 128 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256\n              t = t - 1\n              idx = idx / 10\n              continue \n          require ownerOf[stor13]\n          stor11[stor13][].field_0 = Array(len=mem[96], data=mem[128 len mem[96]])\n      log TokenMinted(\n            address owner=caller,\n            uint256 quantity=liveTokenId)\n      price += price / 75\n\ndef safeTransferFrom(address from, address to, uint256 tokenId): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[tokenId]\n  require ownerOf[tokenId]\n  if ownerOf[tokenId] != caller:\n      if approved[tokenId] != caller:\n          require stor4[stor1[tokenId]][caller]\n  require ownerOf[tokenId] == from\n  require to\n  if approved[tokenId]:\n      approved[tokenId] = 0\n  require 1 <= balanceOf[address(from)]\n  balanceOf[address(from)]--\n  balanceOf[address(to)]++\n  ownerOf[tokenId] = to\n  log Transfer(\n        address from=from,\n        address to=to,\n        uint256 value=tokenId)\n  require 1 <= tokenOfOwnerByIndex[address(from)]\n  if stor6[tokenId] != tokenOfOwnerByIndex[address(from)] - 1:\n      require tokenOfOwnerByIndex[address(from)] - 1 < tokenOfOwnerByIndex[address(from)]\n      require stor6[tokenId] < tokenOfOwnerByIndex[address(from)]\n      tokenOfOwnerByIndex[address(from)][stor6[tokenId]] = tokenOfOwnerByIndex[address(from)][tokenOfOwnerByIndex[address(from)]]\n      stor6[stor5[address(from)][stor5[address(from)]]] = stor6[tokenId]\n  tokenOfOwnerByIndex[address(from)]--\n  if tokenOfOwnerByIndex[address(from)] > tokenOfOwnerByIndex[address(from)] - 1:\n      idx = tokenOfOwnerByIndex[address(from)] - 1\n      while tokenOfOwnerByIndex[address(from)] > idx:\n          tokenOfOwnerByIndex[address(from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[tokenId] = tokenOfOwnerByIndex[address(to)]\n  tokenOfOwnerByIndex[address(to)]++\n  tokenOfOwnerByIndex[address(to)][tokenOfOwnerByIndex[address(to)]] = tokenId\n  if ext_code.size(to) > 0:\n      require ext_code.size(to)\n      call to.onERC721Received(address , address , uint256 , bytes ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), address(from), tokenId, 128, 0\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require Mask(32, 224, ext_call.return_data[0]) == 0x150b7a0200000000000000000000000000000000000000000000000000000000\n\ndef createToken(address newowner): # not payable\n  require calldata.size - 4 >= 32\n  if 0x1003d51fef31e52262b1e699f03c789ca6dbefdc != caller:\n      require caller == owner\n  require liveTokenId <= 360\n  liveTokenId++\n  require newowner\n  require not ownerOf[stor13]\n  ownerOf[stor13] = newowner\n  balanceOf[address(newowner)]++\n  log Transfer(\n        address from=0,\n        address to=newowner,\n        uint256 value=liveTokenId)\n  stor6[stor13] = tokenOfOwnerByIndex[address(newowner)]\n  tokenOfOwnerByIndex[address(newowner)]++\n  tokenOfOwnerByIndex[address(newowner)][tokenOfOwnerByIndex[address(newowner)]] = liveTokenId\n  stor8[stor13] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = liveTokenId\n  if not liveTokenId:\n      require ownerOf[stor13]\n      stor11[stor13].field_0 = 0\n      stor11[stor13].field_1 = 1\n      stor11[stor13].field_8 = '0' / 256\n      idx = 0\n      while stor11[stor13].length + 31 / 32 > idx:\n          stor11[stor13][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      log TokenMinted(\n            address owner=address(newowner),\n            uint256 quantity=liveTokenId)\n      price += price / 75\n      return '0'\n  s = 0\n  idx = liveTokenId\n  while idx:\n      s = s + 1\n      idx = idx / 10\n      continue \n  mem[96] = s\n  mem[64] = ceil32(s) + 128\n  if s:\n      mem[128 len s] = code.data[11315 len s]\n  t = s - 1\n  idx = liveTokenId\n  while idx:\n      require t < mem[96]\n      mem[t + 128 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256\n      t = t - 1\n      idx = idx / 10\n      continue \n  require ownerOf[stor13]\n  mem[0] = sha3(liveTokenId, 11)\n  stor11[stor13][].field_0 = Array(len=mem[96], data=mem[128 len mem[96]])\n  log TokenMinted(\n        address owner=address(newowner),\n        uint256 quantity=liveTokenId)\n  price += price / 75\n  mem[mem[64]] = 32\n  mem[mem[64] + 32] = mem[96]\n  mem[mem[64] + 64 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]\n  if not mem[96] % 32:\n      return 32, mem[mem[64] + 32 len mem[96] + 32]\n  mem[floor32(mem[96]) + mem[64] + 64] = mem[floor32(mem[96]) + mem[64] + -(mem[96] % 32) + 96 len mem[96] % 32]\n  return Array(len=mem[96], data=mem[mem[64] + 64 len floor32(mem[96]) + 32])\n\ndef safeTransferFrom(address from, address to, uint256 tokenId, bytes _data): # not payable\n  require calldata.size - 4 >= 128\n  require _data <= unknown10000000()\n  require _data + 36 <= calldata.size\n  require _data.length <= unknown10000000() and _data + _data.length + 36 <= calldata.size\n  require ownerOf[tokenId]\n  require ownerOf[tokenId]\n  if ownerOf[tokenId] != caller:\n      if approved[tokenId] != caller:\n          require stor4[stor1[tokenId]][caller]\n  require ownerOf[tokenId] == from\n  require to\n  if approved[tokenId]:\n      approved[tokenId] = 0\n  require 1 <= balanceOf[address(from)]\n  balanceOf[address(from)]--\n  balanceOf[address(to)]++\n  ownerOf[tokenId] = to\n  log Transfer(\n        address from=from,\n        address to=to,\n        uint256 value=tokenId)\n  require 1 <= tokenOfOwnerByIndex[address(from)]\n  if stor6[tokenId] != tokenOfOwnerByIndex[address(from)] - 1:\n      require tokenOfOwnerByIndex[address(from)] - 1 < tokenOfOwnerByIndex[address(from)]\n      require stor6[tokenId] < tokenOfOwnerByIndex[address(from)]\n      tokenOfOwnerByIndex[address(from)][stor6[tokenId]] = tokenOfOwnerByIndex[address(from)][tokenOfOwnerByIndex[address(from)]]\n      stor6[stor5[address(from)][stor5[address(from)]]] = stor6[tokenId]\n  tokenOfOwnerByIndex[address(from)]--\n  if tokenOfOwnerByIndex[address(from)] > tokenOfOwnerByIndex[address(from)] - 1:\n      idx = tokenOfOwnerByIndex[address(from)] - 1\n      while tokenOfOwnerByIndex[address(from)] > idx:\n          tokenOfOwnerByIndex[address(from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[tokenId] = tokenOfOwnerByIndex[address(to)]\n  tokenOfOwnerByIndex[address(to)]++\n  tokenOfOwnerByIndex[address(to)][tokenOfOwnerByIndex[address(to)]] = tokenId\n  if ext_code.size(to) > 0:\n      require ext_code.size(to)\n      call to with:\n           gas gas_remaining wei\n          args caller, address(from), tokenId, Array(len=_data.length, data=_data[all])\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require Mask(32, 224, ext_call.return_data[0]) == 0x150b7a0200000000000000000000000000000000000000000000000000000000\n\ndef tokenURI(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  mem[96] = baseTokenURI.length\n  mem[128] = uint256(baseTokenURI.field_0)\n  idx = 128\n  s = 0\n  while baseTokenURI.length + 96 > idx:\n      mem[idx + 32] = baseTokenURI[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  require ownerOf[tokenId]\n  mem[32] = 11\n  _223 = ceil32(baseTokenURI.length) + 128\n  mem[64] = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  mem[ceil32(baseTokenURI.length) + 128] = stor11[tokenId].length\n  mem[0] = sha3(tokenId, 11)\n  mem[ceil32(baseTokenURI.length) + 160] = stor11[tokenId].field_0\n  idx = ceil32(baseTokenURI.length) + 160\n  s = 0\n  while ceil32(baseTokenURI.length) + stor11[tokenId].length + 128 > idx:\n      mem[idx + 32] = stor11[tokenId][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  _378 = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  _379 = baseTokenURI.length\n  mem[ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 192 len floor32(baseTokenURI.length)] = mem[128 len floor32(baseTokenURI.length)]\n  mem[ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + floor32(baseTokenURI.length) + -baseTokenURI.length % 32 + 224 len baseTokenURI.length % 32] = mem[floor32(baseTokenURI.length) + -baseTokenURI.length % 32 + 160 len baseTokenURI.length % 32]\n  _451 = stor11[tokenId].length\n  mem[_379 + _378 + 32 len floor32(stor11[tokenId].length)] = mem[ceil32(baseTokenURI.length) + 160 len floor32(stor11[tokenId].length)]\n  mem[_379 + _378 + floor32(stor11[tokenId].length) + 32] = mem[ceil32(baseTokenURI.length) + floor32(stor11[tokenId].length) + -stor11[tokenId].length % 32 + 192 len stor11[tokenId].length % 32] or Mask(8 * -stor11[tokenId].length % 32 + 32, -(8 * -stor11[tokenId].length % 32 + 32) + 256, mem[_379 + _378 + floor32(stor11[tokenId].length) + 32])\n  _518 = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  mem[64] = stor11[tokenId].length + _379 + _378 + 32\n  mem[stor11[tokenId].length + _379 + _378 + 32] = 32\n  mem[stor11[tokenId].length + _379 + _378 + 64] = mem[_518]\n  _534 = mem[_518]\n  mem[stor11[tokenId].length + _379 + _378 + 96 len ceil32(mem[_518])] = mem[_518 + 32 len ceil32(mem[_518])]\n  if not _534 % 32:\n      return 32, mem[stor11[tokenId].length + _379 + _378 + 64 len _534 + 32]\n  mem[floor32(_534) + stor11[tokenId].length + _379 + _378 + 96] = mem[floor32(_534) + stor11[tokenId].length + _379 + _378 + -(_534 % 32) + 128 len _534 % 32]\n  return 32, mem[stor11[tokenId].length + _379 + _378 + 64 len floor32(_534) + 64]\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is mapping of uint8 at storage 0\n  ownerOf is mapping of address at storage 1\n  approved is mapping of address at storage 2\n  balanceOf is mapping of uint256 at storage 3\n  stor4 is mapping of uint8 at storage 4\n  tokenOfOwnerByIndex is array of uint256 at storage 5\n  stor6 is mapping of uint256 at storage 6\n  tokenByIndex is array of uint256 at storage 7\n  stor8 is mapping of uint256 at storage 8\n  name is array of uint256 at storage 9\n  symbol is array of uint256 at storage 10\n  stor11 is mapping of struct at storage 11\n  owner is address at storage 12\n  liveTokenId is uint256 at storage 13\n  price is uint256 at storage 14\n  info is array of uint256 at storage 15\n  infohasnotbeenset is uint8 at storage 16\n  baseTokenURI is array of struct at storage 17\n\ndef supportsInterface(bytes4 interfaceId): # not payable\n  require calldata.size - 4 >= 32\n  return bool(stor0[Mask(32, 224, interfaceId)])\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef getApproved(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  return approved[tokenId]\n\ndef totalSupply(): # not payable\n  return tokenByIndex.length\n\ndef tokenOfOwnerByIndex(address owner, uint256 index): # not payable\n  require calldata.size - 4 >= 64\n  require owner\n  require index < balanceOf[address(owner)]\n  require index < tokenOfOwnerByIndex[address(owner)]\n  return tokenOfOwnerByIndex[address(owner)][index]\n\ndef info(): # not payable\n  return info[0 len info.length]\n\ndef tokenByIndex(uint256 index): # not payable\n  require calldata.size - 4 >= 32\n  require index < tokenByIndex.length\n  return tokenByIndex[index]\n\ndef ownerOf(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  return ownerOf[tokenId]\n\ndef balanceOf(address account): # not payable\n  require calldata.size - 4 >= 32\n  require account\n  return balanceOf[address(account)]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef price(): # not payable\n  return price\n\ndef infohasnotbeenset(): # not payable\n  return bool(infohasnotbeenset)\n\ndef liveTokenId(): # not payable\n  return liveTokenId\n\ndef baseTokenURI(): # not payable\n  return baseTokenURI[0 len baseTokenURI.length].field_0\n\ndef isApprovedForAll(address owner, address operator): # not payable\n  require calldata.size - 4 >= 64\n  return bool(stor4[address(owner)][address(operator)])\n\n#\n#  Regular functions\n#\n\ndef isOwner(): # not payable\n  return (caller == owner)\n\ndef renounceOwnership(): # not payable\n  require caller == owner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=0)\n  owner = 0\n\ndef transferOwnership(address newOwner): # not payable\n  require calldata.size - 4 >= 32\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef setApprovalForAll(address operator, bool approved): # not payable\n  require calldata.size - 4 >= 64\n  require operator != caller\n  stor4[caller][address(operator)] = uint8(approved)\n  log ApprovalForAll(\n        address owner=approved,\n        address operator=caller,\n        bool approved=operator)\n\ndef changeBaseTokenURI(string _uri): # not payable\n  require calldata.size - 4 >= 32\n  require _uri <= unknown10000000()\n  require _uri + 36 <= calldata.size\n  require _uri.length <= unknown10000000() and _uri + _uri.length + 36 <= calldata.size\n  require caller == owner\n  baseTokenURI[].field_0 = Array(len=_uri.length, data=_uri[all])\n\ndef changeInfo(string newstring): # not payable\n  require calldata.size - 4 >= 32\n  require newstring <= unknown10000000()\n  require newstring + 36 <= calldata.size\n  require newstring.length <= unknown10000000() and newstring + newstring.length + 36 <= calldata.size\n  require caller == owner\n  require infohasnotbeenset\n  info[] = Array(len=newstring.length, data=newstring[all])\n  infohasnotbeenset = 0\n\ndef approve(address spender, uint256 amount): # not payable\n  require calldata.size - 4 >= 64\n  require ownerOf[amount]\n  require spender != ownerOf[amount]\n  if ownerOf[amount] != caller:\n      require stor4[stor1[amount]][caller]\n  approved[amount] = spender\n  log Approval(\n        address owner=ownerOf[amount],\n        address spender=spender,\n        uint256 value=amount)\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[amount]\n  require ownerOf[amount]\n  if ownerOf[amount] != caller:\n      if approved[amount] != caller:\n          require stor4[stor1[amount]][caller]\n  require ownerOf[amount] == sender\n  require recipient\n  if approved[amount]:\n      approved[amount] = 0\n  require 1 <= balanceOf[address(sender)]\n  balanceOf[address(sender)]--\n  balanceOf[address(recipient)]++\n  ownerOf[amount] = recipient\n  log Transfer(\n        address from=sender,\n        address to=recipient,\n        uint256 value=amount)\n  require 1 <= tokenOfOwnerByIndex[address(sender)]\n  if stor6[amount] != tokenOfOwnerByIndex[address(sender)] - 1:\n      require tokenOfOwnerByIndex[address(sender)] - 1 < tokenOfOwnerByIndex[address(sender)]\n      require stor6[amount] < tokenOfOwnerByIndex[address(sender)]\n      tokenOfOwnerByIndex[address(sender)][stor6[amount]] = tokenOfOwnerByIndex[address(sender)][tokenOfOwnerByIndex[address(sender)]]\n      stor6[stor5[address(sender)][stor5[address(sender)]]] = stor6[amount]\n  tokenOfOwnerByIndex[address(sender)]--\n  if tokenOfOwnerByIndex[address(sender)] > tokenOfOwnerByIndex[address(sender)] - 1:\n      idx = tokenOfOwnerByIndex[address(sender)] - 1\n      while tokenOfOwnerByIndex[address(sender)] > idx:\n          tokenOfOwnerByIndex[address(sender)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[amount] = tokenOfOwnerByIndex[address(recipient)]\n  tokenOfOwnerByIndex[address(recipient)]++\n  tokenOfOwnerByIndex[address(recipient)][tokenOfOwnerByIndex[address(recipient)]] = amount\n\ndef _fallback(?) payable: # default function\n  if call.value >= price:\n      call 0x4257d02e2854c9c86d6975fcd14a1af4fa65a652 with:\n         value call.value / 2 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      call 0x2ea533314069dc9b4df29e72bd1dfb64cc68456d with:\n         value call.value / 2 wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[128] = call.value\n      log PaymentReceived(\n            address from=caller,\n            uint256 amount=call.value)\n      require liveTokenId <= 360\n      liveTokenId++\n      require caller\n      require not ownerOf[stor13]\n      ownerOf[stor13] = caller\n      balanceOf[caller]++\n      log Transfer(\n            address from=0,\n            address to=caller,\n            uint256 value=liveTokenId)\n      stor6[stor13] = tokenOfOwnerByIndex[caller]\n      tokenOfOwnerByIndex[caller]++\n      tokenOfOwnerByIndex[caller][tokenOfOwnerByIndex[caller]] = liveTokenId\n      stor8[stor13] = tokenByIndex.length\n      tokenByIndex.length++\n      tokenByIndex[tokenByIndex.length] = liveTokenId\n      if not liveTokenId:\n          require ownerOf[stor13]\n          stor11[stor13].field_0 = 0\n          stor11[stor13].field_1 = 1\n          stor11[stor13].field_8 = '0' / 256\n          idx = 0\n          while stor11[stor13].length + 31 / 32 > idx:\n              stor11[stor13][idx].field_0 = 0\n              idx = idx + 1\n              continue \n      else:\n          s = 0\n          idx = liveTokenId\n          while idx:\n              s = s + 1\n              idx = idx / 10\n              continue \n          mem[96] = s\n          if s:\n              mem[128 len s] = code.data[11315 len s]\n          t = s - 1\n          idx = liveTokenId\n          while idx:\n              require t < mem[96]\n              mem[t + 128 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256\n              t = t - 1\n              idx = idx / 10\n              continue \n          require ownerOf[stor13]\n          stor11[stor13][].field_0 = Array(len=mem[96], data=mem[128 len mem[96]])\n      log TokenMinted(\n            address owner=caller,\n            uint256 quantity=liveTokenId)\n      price += price / 75\n\ndef safeTransferFrom(address from, address to, uint256 tokenId): # not payable\n  require calldata.size - 4 >= 96\n  require ownerOf[tokenId]\n  require ownerOf[tokenId]\n  if ownerOf[tokenId] != caller:\n      if approved[tokenId] != caller:\n          require stor4[stor1[tokenId]][caller]\n  require ownerOf[tokenId] == from\n  require to\n  if approved[tokenId]:\n      approved[tokenId] = 0\n  require 1 <= balanceOf[address(from)]\n  balanceOf[address(from)]--\n  balanceOf[address(to)]++\n  ownerOf[tokenId] = to\n  log Transfer(\n        address from=from,\n        address to=to,\n        uint256 value=tokenId)\n  require 1 <= tokenOfOwnerByIndex[address(from)]\n  if stor6[tokenId] != tokenOfOwnerByIndex[address(from)] - 1:\n      require tokenOfOwnerByIndex[address(from)] - 1 < tokenOfOwnerByIndex[address(from)]\n      require stor6[tokenId] < tokenOfOwnerByIndex[address(from)]\n      tokenOfOwnerByIndex[address(from)][stor6[tokenId]] = tokenOfOwnerByIndex[address(from)][tokenOfOwnerByIndex[address(from)]]\n      stor6[stor5[address(from)][stor5[address(from)]]] = stor6[tokenId]\n  tokenOfOwnerByIndex[address(from)]--\n  if tokenOfOwnerByIndex[address(from)] > tokenOfOwnerByIndex[address(from)] - 1:\n      idx = tokenOfOwnerByIndex[address(from)] - 1\n      while tokenOfOwnerByIndex[address(from)] > idx:\n          tokenOfOwnerByIndex[address(from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[tokenId] = tokenOfOwnerByIndex[address(to)]\n  tokenOfOwnerByIndex[address(to)]++\n  tokenOfOwnerByIndex[address(to)][tokenOfOwnerByIndex[address(to)]] = tokenId\n  if ext_code.size(to) > 0:\n      require ext_code.size(to)\n      call to.onERC721Received(address , address , uint256 , bytes ) with:\n           gas gas_remaining wei\n          args 0, uint32(caller), address(from), tokenId, 128, 0\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require Mask(32, 224, ext_call.return_data[0]) == 0x150b7a0200000000000000000000000000000000000000000000000000000000\n\ndef createToken(address newowner): # not payable\n  require calldata.size - 4 >= 32\n  if 0x1003d51fef31e52262b1e699f03c789ca6dbefdc != caller:\n      require caller == owner\n  require liveTokenId <= 360\n  liveTokenId++\n  require newowner\n  require not ownerOf[stor13]\n  ownerOf[stor13] = newowner\n  balanceOf[address(newowner)]++\n  log Transfer(\n        address from=0,\n        address to=newowner,\n        uint256 value=liveTokenId)\n  stor6[stor13] = tokenOfOwnerByIndex[address(newowner)]\n  tokenOfOwnerByIndex[address(newowner)]++\n  tokenOfOwnerByIndex[address(newowner)][tokenOfOwnerByIndex[address(newowner)]] = liveTokenId\n  stor8[stor13] = tokenByIndex.length\n  tokenByIndex.length++\n  tokenByIndex[tokenByIndex.length] = liveTokenId\n  if not liveTokenId:\n      require ownerOf[stor13]\n      stor11[stor13].field_0 = 0\n      stor11[stor13].field_1 = 1\n      stor11[stor13].field_8 = '0' / 256\n      idx = 0\n      while stor11[stor13].length + 31 / 32 > idx:\n          stor11[stor13][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      log TokenMinted(\n            address owner=address(newowner),\n            uint256 quantity=liveTokenId)\n      price += price / 75\n      return '0'\n  s = 0\n  idx = liveTokenId\n  while idx:\n      s = s + 1\n      idx = idx / 10\n      continue \n  mem[96] = s\n  mem[64] = ceil32(s) + 128\n  if s:\n      mem[128 len s] = code.data[11315 len s]\n  t = s - 1\n  idx = liveTokenId\n  while idx:\n      require t < mem[96]\n      mem[t + 128 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256\n      t = t - 1\n      idx = idx / 10\n      continue \n  require ownerOf[stor13]\n  mem[0] = sha3(liveTokenId, 11)\n  stor11[stor13][].field_0 = Array(len=mem[96], data=mem[128 len mem[96]])\n  log TokenMinted(\n        address owner=address(newowner),\n        uint256 quantity=liveTokenId)\n  price += price / 75\n  mem[mem[64]] = 32\n  mem[mem[64] + 32] = mem[96]\n  mem[mem[64] + 64 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]\n  if not mem[96] % 32:\n      return 32, mem[mem[64] + 32 len mem[96] + 32]\n  mem[floor32(mem[96]) + mem[64] + 64] = mem[floor32(mem[96]) + mem[64] + -(mem[96] % 32) + 96 len mem[96] % 32]\n  return Array(len=mem[96], data=mem[mem[64] + 64 len floor32(mem[96]) + 32])\n\ndef safeTransferFrom(address from, address to, uint256 tokenId, bytes _data): # not payable\n  require calldata.size - 4 >= 128\n  require _data <= unknown10000000()\n  require _data + 36 <= calldata.size\n  require _data.length <= unknown10000000() and _data + _data.length + 36 <= calldata.size\n  require ownerOf[tokenId]\n  require ownerOf[tokenId]\n  if ownerOf[tokenId] != caller:\n      if approved[tokenId] != caller:\n          require stor4[stor1[tokenId]][caller]\n  require ownerOf[tokenId] == from\n  require to\n  if approved[tokenId]:\n      approved[tokenId] = 0\n  require 1 <= balanceOf[address(from)]\n  balanceOf[address(from)]--\n  balanceOf[address(to)]++\n  ownerOf[tokenId] = to\n  log Transfer(\n        address from=from,\n        address to=to,\n        uint256 value=tokenId)\n  require 1 <= tokenOfOwnerByIndex[address(from)]\n  if stor6[tokenId] != tokenOfOwnerByIndex[address(from)] - 1:\n      require tokenOfOwnerByIndex[address(from)] - 1 < tokenOfOwnerByIndex[address(from)]\n      require stor6[tokenId] < tokenOfOwnerByIndex[address(from)]\n      tokenOfOwnerByIndex[address(from)][stor6[tokenId]] = tokenOfOwnerByIndex[address(from)][tokenOfOwnerByIndex[address(from)]]\n      stor6[stor5[address(from)][stor5[address(from)]]] = stor6[tokenId]\n  tokenOfOwnerByIndex[address(from)]--\n  if tokenOfOwnerByIndex[address(from)] > tokenOfOwnerByIndex[address(from)] - 1:\n      idx = tokenOfOwnerByIndex[address(from)] - 1\n      while tokenOfOwnerByIndex[address(from)] > idx:\n          tokenOfOwnerByIndex[address(from)][idx] = 0\n          idx = idx + 1\n          continue \n  stor6[tokenId] = tokenOfOwnerByIndex[address(to)]\n  tokenOfOwnerByIndex[address(to)]++\n  tokenOfOwnerByIndex[address(to)][tokenOfOwnerByIndex[address(to)]] = tokenId\n  if ext_code.size(to) > 0:\n      require ext_code.size(to)\n      call to with:\n           gas gas_remaining wei\n          args caller, address(from), tokenId, Array(len=_data.length, data=_data[all])\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >= 32\n      require Mask(32, 224, ext_call.return_data[0]) == 0x150b7a0200000000000000000000000000000000000000000000000000000000\n\ndef tokenURI(uint256 tokenId): # not payable\n  require calldata.size - 4 >= 32\n  require ownerOf[tokenId]\n  mem[96] = baseTokenURI.length\n  mem[128] = uint256(baseTokenURI.field_0)\n  idx = 128\n  s = 0\n  while baseTokenURI.length + 96 > idx:\n      mem[idx + 32] = baseTokenURI[s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  require ownerOf[tokenId]\n  mem[32] = 11\n  _223 = ceil32(baseTokenURI.length) + 128\n  mem[64] = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  mem[ceil32(baseTokenURI.length) + 128] = stor11[tokenId].length\n  mem[0] = sha3(tokenId, 11)\n  mem[ceil32(baseTokenURI.length) + 160] = stor11[tokenId].field_0\n  idx = ceil32(baseTokenURI.length) + 160\n  s = 0\n  while ceil32(baseTokenURI.length) + stor11[tokenId].length + 128 > idx:\n      mem[idx + 32] = stor11[tokenId][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  _378 = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  _379 = baseTokenURI.length\n  mem[ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 192 len floor32(baseTokenURI.length)] = mem[128 len floor32(baseTokenURI.length)]\n  mem[ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + floor32(baseTokenURI.length) + -baseTokenURI.length % 32 + 224 len baseTokenURI.length % 32] = mem[floor32(baseTokenURI.length) + -baseTokenURI.length % 32 + 160 len baseTokenURI.length % 32]\n  _451 = stor11[tokenId].length\n  mem[_379 + _378 + 32 len floor32(stor11[tokenId].length)] = mem[ceil32(baseTokenURI.length) + 160 len floor32(stor11[tokenId].length)]\n  mem[_379 + _378 + floor32(stor11[tokenId].length) + 32] = mem[ceil32(baseTokenURI.length) + floor32(stor11[tokenId].length) + -stor11[tokenId].length % 32 + 192 len stor11[tokenId].length % 32] or Mask(8 * -stor11[tokenId].length % 32 + 32, -(8 * -stor11[tokenId].length % 32 + 32) + 256, mem[_379 + _378 + floor32(stor11[tokenId].length) + 32])\n  _518 = ceil32(baseTokenURI.length) + ceil32(stor11[tokenId].length) + 160\n  mem[64] = stor11[tokenId].length + _379 + _378 + 32\n  mem[stor11[tokenId].length + _379 + _378 + 32] = 32\n  mem[stor11[tokenId].length + _379 + _378 + 64] = mem[_518]\n  _534 = mem[_518]\n  mem[stor11[tokenId].length + _379 + _378 + 96 len ceil32(mem[_518])] = mem[_518 + 32 len ceil32(mem[_518])]\n  if not _534 % 32:\n      return 32, mem[stor11[tokenId].length + _379 + _378 + 64 len _534 + 32]\n  mem[floor32(_534) + stor11[tokenId].length + _379 + _378 + 96] = mem[floor32(_534) + stor11[tokenId].length + _379 + _378 + -(_534 % 32) + 128 len _534 % 32]\n  return 32, mem[stor11[tokenId].length + _379 + _378 + 64 len floor32(_534) + 64]\n\n.",
	"status": "1",
	"time_cost": 29.444544315338135,
	"usage": {
		"completion_tokens": 300,
		"prompt_tokens": 5403,
		"total_tokens": 5703
	}
}