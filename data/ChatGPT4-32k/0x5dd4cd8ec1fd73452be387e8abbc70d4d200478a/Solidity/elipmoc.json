{
	"address": "0x5dd4cd8ec1fd73452be387e8abbc70d4d200478a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled EVM Bytecode provided, here is a Solidity code example that would correspond to it:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyTokenContract {\n    mapping (address => uint256) private _userTokenBalance;\n    address private _getTokenAddress;\n    address private _tokenStakingContractAddress;\n    address private _augurUniverseAddress;\n    uint256 private _totalTokenBalance;\n    uint256 private _stakedTokensReceivable;\n    uint256 private _approvedTokensPayable;\n\n    event TokenWithdrawal(address indexed to, uint256 value);\n    event UserBalanceChange(address indexed to, uint256 value, uint256 difference);\n    event AccessLevelSet(address indexed to, uint256 level, address indexed admin);\n    event AccessRevoked(address indexed to, uint256 level, address indexed admin);\n\n    function withdrawTokens(address to, uint256 value) public {\n        require(value <= _userTokenBalance[to], \"Withdraw amount greater than current balance\");\n        _userTokenBalance[to] -= value;\n        _totalTokenBalance -= value;\n        emit TokenWithdrawal(to, value);\n        emit UserBalanceChange(to, _userTokenBalance[to], value);\n    }\n\n    // Other functions go here...\n\n    function setTokenContract(address newAddress) public {\n        _getTokenAddress = newAddress;\n    }\n    \n    // Other functions go here...\n}\n```\n\nPlease note that the given bytecode was decompiled into pseudo-code and not specific to any language. It's not possible to convert this pseudo-code back into accurate Solidity code without making some assumptions about the original contract's structure and functionality. The provided Solidity code is a very basic and partial interpretation of the decompiled code, focusing on the `withdrawTokens` and `setTokenContract` functions. Other functions and details should be reconstructed based on the specific needs and understanding of the original contract's functionality.",
				"role": "assistant"
			}
		}
	],
	"created": 1702473495,
	"id": "chatcmpl-8VJPrblACDnrUkGE2iFPtaHBtUu5a",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 12:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _myAccessLevel; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _userTokenBalance; // STORAGE[0x1]\nuint256 _totalTokenBalance; // STORAGE[0x2]\nuint256 _stakedTokensReceivable; // STORAGE[0x3]\nuint256 _approvedTokensPayable; // STORAGE[0x4]\naddress _getTokenAddress; // STORAGE[0x5] bytes 0 to 19\naddress _tokenStakingContractAddress; // STORAGE[0x6] bytes 0 to 19\naddress _augurUniverseAddress; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nTokenWithdrawal(address, uint256);\nUserBalanceChange(address, uint256, uint256);\nAccessLevelSet(address, uint256, address);\nAccessRevoked(address, uint256, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdrawTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _userTokenBalance[varg0], 'Withdraw amount greater than current balance');\n    assert(varg1 <= _userTokenBalance[varg0]);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'error during token transfer', 27);\n    _userTokenBalance[varg0] = _userTokenBalance[varg0] - varg1;\n    assert(varg1 <= _totalTokenBalance);\n    _totalTokenBalance = _totalTokenBalance - varg1;\n    emit TokenWithdrawal(varg0, varg1, varg1);\n    emit UserBalanceChange(varg0, _userTokenBalance[varg0], _userTokenBalance[varg0] - varg1);\n    return 0;\n}\n\nfunction proxyDepositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 + _userTokenBalance[varg0] >= _userTokenBalance[varg0]);\n    _userTokenBalance[varg0] += varg1;\n    assert(varg1 + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += varg1;\n    emit UserBalanceChange(varg0, _userTokenBalance[varg0], varg1 + _userTokenBalance[varg0]);\n}\n\nfunction getTokenAddress() public nonPayable { \n    return _getTokenAddress;\n}\n\nfunction augurUniverseAddress() public nonPayable { \n    return _augurUniverseAddress;\n}\n\nfunction userTokenBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userTokenBalance[varg0];\n}\n\nfunction accessLevel(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _myAccessLevel[varg0];\n}\n\nfunction depositToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(varg0, this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] + _userTokenBalance[varg0] >= _userTokenBalance[varg0]);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.transferFrom(varg0, this, MEM[MEM[64]]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'transfer failed', 15);\n    _userTokenBalance[varg0] += MEM[MEM[64]];\n    assert(MEM[MEM[64]] + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += MEM[MEM[64]];\n    emit UserBalanceChange(varg0, MEM[MEM[64]] + _userTokenBalance[varg0], MEM[MEM[64]] + _userTokenBalance[varg0]);\n}\n\nfunction setTokenStakingContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _tokenStakingContractAddress = varg0;\n}\n\nfunction setAccessLevel(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(4 > _myAccessLevel[varg0], 'Cannot setAccessLevel for Admin Level Access User');\n    v0 = v1 = varg1 < 0;\n    if (varg1 >= 0) {\n        v0 = v2 = varg1 > 4;\n    }\n    require(!v0, 'erroneous access level');\n    _myAccessLevel[varg0] = varg1;\n    emit AccessLevelSet(varg0, varg1, msg.sender);\n}\n\nfunction totalTokenBalance() public nonPayable { \n    return _totalTokenBalance;\n}\n\nfunction makeDeposit() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(msg.sender, this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] + _userTokenBalance[msg.sender] >= _userTokenBalance[msg.sender]);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.transferFrom(msg.sender, this, MEM[MEM[64]]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'transfer failed');\n    _userTokenBalance[msg.sender] += MEM[MEM[64]];\n    assert(MEM[MEM[64]] + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += MEM[MEM[64]];\n    emit UserBalanceChange(msg.sender, _userTokenBalance[msg.sender], MEM[MEM[64]] + _userTokenBalance[msg.sender]);\n}\n\nfunction delegatedAllowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction checkTotalBalanceExternal() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1, v3;\n}\n\nfunction getAccessLevel(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _myAccessLevel[varg0];\n}\n\nfunction makeWithdrawal(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _userTokenBalance[msg.sender], 'Withdraw amount greater than current balance');\n    assert(varg0 <= _userTokenBalance[msg.sender]);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(msg.sender, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'error during token transfer', 27);\n    _userTokenBalance[msg.sender] = _userTokenBalance[msg.sender] - varg0;\n    assert(varg0 <= _totalTokenBalance);\n    _totalTokenBalance = _totalTokenBalance - varg0;\n    emit TokenWithdrawal(msg.sender, varg0, varg0);\n    emit UserBalanceChange(msg.sender, _userTokenBalance[msg.sender], _userTokenBalance[msg.sender] - varg0);\n    emit TokenWithdrawal(msg.sender, varg0);\n}\n\nfunction delegatedDecreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.decreaseApproval(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction setAugurUniverse(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _augurUniverseAddress = varg0;\n}\n\nfunction delegatedStake(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_tokenStakingContractAddress.code.size);\n    v0, v1 = _tokenStakingContractAddress.stake(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'staking must be successful');\n    _stakedTokensReceivable += varg0;\n    _approvedTokensPayable = _approvedTokensPayable - varg0;\n    return 0;\n}\n\nfunction delegatedTotalSupply() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.totalSupply().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction revokeAccess(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(4 > _myAccessLevel[varg0], 'admin cannot revoke their own access', 'admin cannot revoke their own access');\n    _myAccessLevel[varg0] = 0;\n    emit AccessRevoked(varg0, _myAccessLevel[varg0], msg.sender);\n}\n\nfunction delegatedApprove(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.approve(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction tokenStakingContractAddress() public nonPayable { \n    return _tokenStakingContractAddress;\n}\n\nfunction depositEther() public payable { \n}\n\nfunction myAccessLevel() public nonPayable { \n    return _myAccessLevel[msg.sender];\n}\n\nfunction delegatedTokenTransfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction delegatedBalanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction setTokenContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _getTokenAddress = varg0;\n}\n\nfunction balanceChecks() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(_tokenStakingContractAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _stakedTokensReceivable, _approvedTokensPayable, _totalTokenBalance, v1;\n}\n\nfunction delegatedTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transferFrom(varg0, varg1, varg2).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction delegatedApproveSpender(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.approve(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'approval must be successful');\n    _approvedTokensPayable += varg1;\n    return 0;\n}\n\nfunction delegatedIncreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.increaseApproval(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction stakedTokensReceivable() public nonPayable { \n    return _stakedTokensReceivable;\n}\n\nfunction getUserTokenBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userTokenBalance[varg0];\n}\n\nfunction token() public nonPayable { \n    return _getTokenAddress;\n}\n\nfunction approvedTokensPayable() public nonPayable { \n    return _approvedTokensPayable;\n}\n\nfunction delegatedCreateYesNoMarket(uint256 varg0, uint256 varg1, address varg2, address varg3, bytes32 varg4, string varg5, string varg6) public payable { \n    require(msg.data.length - 4 >= 224);\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg5, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg6 <= 0x100000000);\n    require(4 + varg6 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg6 + (?).length > 4 + (msg.data.length - 4))));\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg6, (?).length);\n    MEM[v1.data + (?).length] = 0;\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v3 + v2.data] = MEM[v3 + v0.data];\n        v3 += 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v2.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v2.data - (0x1f & v0.length)];\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v1.data];\n        v6 += 32;\n    }\n    v8 = v9 = v1.length + v5.data;\n    if (0x1f & v1.length) {\n        MEM[v9 - (0x1f & v1.length)] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v9 - (0x1f & v1.length)];\n    }\n    require(_augurUniverseAddress.code.size);\n    v10 = _augurUniverseAddress.createYesNoMarket(varg0, varg1, varg2, varg3, varg4, v2, v5).gas(msg.gas);\n    require(v10); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6b091f9) {\n            withdrawTokens(address,uint256);\n        } else if (0xe758845 == function_selector) {\n            proxyDepositToken(address,uint256);\n        } else if (0x10fe9ae8 == function_selector) {\n            getTokenAddress();\n        } else if (0x2154511c == function_selector) {\n            augurUniverseAddress();\n        } else if (0x29a87023 == function_selector) {\n            userTokenBalance(address);\n        } else if (0x2f259a00 == function_selector) {\n            accessLevel(address);\n        } else if (0x2fd55265 == function_selector) {\n            depositToken(address);\n        } else if (0x34dc64e5 == function_selector) {\n            setTokenStakingContract(address);\n        } else if (0x3a7327a3 == function_selector) {\n            setAccessLevel(address,uint256);\n        } else if (0x3d4b2c2c == function_selector) {\n            totalTokenBalance();\n        } else if (0x40732c89 == function_selector) {\n            makeDeposit();\n        } else if (0x43c93e35 == function_selector) {\n            delegatedAllowance(address,address);\n        } else if (0x5b885273 == function_selector) {\n            checkTotalBalanceExternal();\n        } else if (0x5bc008a0 == function_selector) {\n            getAccessLevel(address);\n        } else if (0x63e52aee == function_selector) {\n            makeWithdrawal(uint256);\n        } else if (0x66b8901c == function_selector) {\n            delegatedDecreaseApproval(address,uint256);\n        } else if (0x66df8a4a == function_selector) {\n            setAugurUniverse(address);\n        } else if (0x6a2746bc == function_selector) {\n            delegatedStake(uint256);\n        } else if (0x6c8a3b5c == function_selector) {\n            delegatedTotalSupply();\n        } else if (0x85e68531 == function_selector) {\n            revokeAccess(address);\n        } else if (0x943a0ae3 == function_selector) {\n            delegatedApprove(address,uint256);\n        } else if (0x963cf966 == function_selector) {\n            tokenStakingContractAddress();\n        } else if (0x98ea5fca == function_selector) {\n            depositEther();\n        } else if (0x9f674eb3 == function_selector) {\n            myAccessLevel();\n        } else if (0xa056ad96 == function_selector) {\n            delegatedTokenTransfer(address,uint256);\n        } else if (0xad2709e2 == function_selector) {\n            delegatedBalanceOf(address);\n        } else if (0xbbcd5bbe == function_selector) {\n            setTokenContract(address);\n        } else if (0xc652de8e == function_selector) {\n            balanceChecks();\n        } else if (0xcb402289 == function_selector) {\n            delegatedTransferFrom(address,address,uint256);\n        } else if (0xd0be5971 == function_selector) {\n            delegatedApproveSpender(address,uint256);\n        } else if (0xd7a81031 == function_selector) {\n            delegatedIncreaseApproval(address,uint256);\n        } else if (0xdd4db26f == function_selector) {\n            stakedTokensReceivable();\n        } else if (0xf5aec88c == function_selector) {\n            getUserTokenBalance(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfe61406b == function_selector) {\n            approvedTokensPayable();\n        } else if (0xfebcbf31 == function_selector) {\n            delegatedCreateYesNoMarket(uint256,uint256,address,address,bytes32,string,string);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 12:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _myAccessLevel; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _userTokenBalance; // STORAGE[0x1]\nuint256 _totalTokenBalance; // STORAGE[0x2]\nuint256 _stakedTokensReceivable; // STORAGE[0x3]\nuint256 _approvedTokensPayable; // STORAGE[0x4]\naddress _getTokenAddress; // STORAGE[0x5] bytes 0 to 19\naddress _tokenStakingContractAddress; // STORAGE[0x6] bytes 0 to 19\naddress _augurUniverseAddress; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nTokenWithdrawal(address, uint256);\nUserBalanceChange(address, uint256, uint256);\nAccessLevelSet(address, uint256, address);\nAccessRevoked(address, uint256, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdrawTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _userTokenBalance[varg0], 'Withdraw amount greater than current balance');\n    assert(varg1 <= _userTokenBalance[varg0]);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'error during token transfer', 27);\n    _userTokenBalance[varg0] = _userTokenBalance[varg0] - varg1;\n    assert(varg1 <= _totalTokenBalance);\n    _totalTokenBalance = _totalTokenBalance - varg1;\n    emit TokenWithdrawal(varg0, varg1, varg1);\n    emit UserBalanceChange(varg0, _userTokenBalance[varg0], _userTokenBalance[varg0] - varg1);\n    return 0;\n}\n\nfunction proxyDepositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 + _userTokenBalance[varg0] >= _userTokenBalance[varg0]);\n    _userTokenBalance[varg0] += varg1;\n    assert(varg1 + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += varg1;\n    emit UserBalanceChange(varg0, _userTokenBalance[varg0], varg1 + _userTokenBalance[varg0]);\n}\n\nfunction getTokenAddress() public nonPayable { \n    return _getTokenAddress;\n}\n\nfunction augurUniverseAddress() public nonPayable { \n    return _augurUniverseAddress;\n}\n\nfunction userTokenBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userTokenBalance[varg0];\n}\n\nfunction accessLevel(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _myAccessLevel[varg0];\n}\n\nfunction depositToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(varg0, this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] + _userTokenBalance[varg0] >= _userTokenBalance[varg0]);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.transferFrom(varg0, this, MEM[MEM[64]]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'transfer failed', 15);\n    _userTokenBalance[varg0] += MEM[MEM[64]];\n    assert(MEM[MEM[64]] + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += MEM[MEM[64]];\n    emit UserBalanceChange(varg0, MEM[MEM[64]] + _userTokenBalance[varg0], MEM[MEM[64]] + _userTokenBalance[varg0]);\n}\n\nfunction setTokenStakingContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _tokenStakingContractAddress = varg0;\n}\n\nfunction setAccessLevel(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(4 > _myAccessLevel[varg0], 'Cannot setAccessLevel for Admin Level Access User');\n    v0 = v1 = varg1 < 0;\n    if (varg1 >= 0) {\n        v0 = v2 = varg1 > 4;\n    }\n    require(!v0, 'erroneous access level');\n    _myAccessLevel[varg0] = varg1;\n    emit AccessLevelSet(varg0, varg1, msg.sender);\n}\n\nfunction totalTokenBalance() public nonPayable { \n    return _totalTokenBalance;\n}\n\nfunction makeDeposit() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(msg.sender, this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] + _userTokenBalance[msg.sender] >= _userTokenBalance[msg.sender]);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.transferFrom(msg.sender, this, MEM[MEM[64]]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'transfer failed');\n    _userTokenBalance[msg.sender] += MEM[MEM[64]];\n    assert(MEM[MEM[64]] + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += MEM[MEM[64]];\n    emit UserBalanceChange(msg.sender, _userTokenBalance[msg.sender], MEM[MEM[64]] + _userTokenBalance[msg.sender]);\n}\n\nfunction delegatedAllowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction checkTotalBalanceExternal() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1, v3;\n}\n\nfunction getAccessLevel(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _myAccessLevel[varg0];\n}\n\nfunction makeWithdrawal(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _userTokenBalance[msg.sender], 'Withdraw amount greater than current balance');\n    assert(varg0 <= _userTokenBalance[msg.sender]);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(msg.sender, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'error during token transfer', 27);\n    _userTokenBalance[msg.sender] = _userTokenBalance[msg.sender] - varg0;\n    assert(varg0 <= _totalTokenBalance);\n    _totalTokenBalance = _totalTokenBalance - varg0;\n    emit TokenWithdrawal(msg.sender, varg0, varg0);\n    emit UserBalanceChange(msg.sender, _userTokenBalance[msg.sender], _userTokenBalance[msg.sender] - varg0);\n    emit TokenWithdrawal(msg.sender, varg0);\n}\n\nfunction delegatedDecreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.decreaseApproval(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction setAugurUniverse(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _augurUniverseAddress = varg0;\n}\n\nfunction delegatedStake(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_tokenStakingContractAddress.code.size);\n    v0, v1 = _tokenStakingContractAddress.stake(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'staking must be successful');\n    _stakedTokensReceivable += varg0;\n    _approvedTokensPayable = _approvedTokensPayable - varg0;\n    return 0;\n}\n\nfunction delegatedTotalSupply() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.totalSupply().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction revokeAccess(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(4 > _myAccessLevel[varg0], 'admin cannot revoke their own access', 'admin cannot revoke their own access');\n    _myAccessLevel[varg0] = 0;\n    emit AccessRevoked(varg0, _myAccessLevel[varg0], msg.sender);\n}\n\nfunction delegatedApprove(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.approve(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction tokenStakingContractAddress() public nonPayable { \n    return _tokenStakingContractAddress;\n}\n\nfunction depositEther() public payable { \n}\n\nfunction myAccessLevel() public nonPayable { \n    return _myAccessLevel[msg.sender];\n}\n\nfunction delegatedTokenTransfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction delegatedBalanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction setTokenContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _getTokenAddress = varg0;\n}\n\nfunction balanceChecks() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(_tokenStakingContractAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _stakedTokensReceivable, _approvedTokensPayable, _totalTokenBalance, v1;\n}\n\nfunction delegatedTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transferFrom(varg0, varg1, varg2).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction delegatedApproveSpender(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.approve(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'approval must be successful');\n    _approvedTokensPayable += varg1;\n    return 0;\n}\n\nfunction delegatedIncreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.increaseApproval(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction stakedTokensReceivable() public nonPayable { \n    return _stakedTokensReceivable;\n}\n\nfunction getUserTokenBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userTokenBalance[varg0];\n}\n\nfunction token() public nonPayable { \n    return _getTokenAddress;\n}\n\nfunction approvedTokensPayable() public nonPayable { \n    return _approvedTokensPayable;\n}\n\nfunction delegatedCreateYesNoMarket(uint256 varg0, uint256 varg1, address varg2, address varg3, bytes32 varg4, string varg5, string varg6) public payable { \n    require(msg.data.length - 4 >= 224);\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg5, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg6 <= 0x100000000);\n    require(4 + varg6 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg6 + (?).length > 4 + (msg.data.length - 4))));\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg6, (?).length);\n    MEM[v1.data + (?).length] = 0;\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v3 + v2.data] = MEM[v3 + v0.data];\n        v3 += 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v2.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v2.data - (0x1f & v0.length)];\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v1.data];\n        v6 += 32;\n    }\n    v8 = v9 = v1.length + v5.data;\n    if (0x1f & v1.length) {\n        MEM[v9 - (0x1f & v1.length)] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v9 - (0x1f & v1.length)];\n    }\n    require(_augurUniverseAddress.code.size);\n    v10 = _augurUniverseAddress.createYesNoMarket(varg0, varg1, varg2, varg3, varg4, v2, v5).gas(msg.gas);\n    require(v10); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6b091f9) {\n            withdrawTokens(address,uint256);\n        } else if (0xe758845 == function_selector) {\n            proxyDepositToken(address,uint256);\n        } else if (0x10fe9ae8 == function_selector) {\n            getTokenAddress();\n        } else if (0x2154511c == function_selector) {\n            augurUniverseAddress();\n        } else if (0x29a87023 == function_selector) {\n            userTokenBalance(address);\n        } else if (0x2f259a00 == function_selector) {\n            accessLevel(address);\n        } else if (0x2fd55265 == function_selector) {\n            depositToken(address);\n        } else if (0x34dc64e5 == function_selector) {\n            setTokenStakingContract(address);\n        } else if (0x3a7327a3 == function_selector) {\n            setAccessLevel(address,uint256);\n        } else if (0x3d4b2c2c == function_selector) {\n            totalTokenBalance();\n        } else if (0x40732c89 == function_selector) {\n            makeDeposit();\n        } else if (0x43c93e35 == function_selector) {\n            delegatedAllowance(address,address);\n        } else if (0x5b885273 == function_selector) {\n            checkTotalBalanceExternal();\n        } else if (0x5bc008a0 == function_selector) {\n            getAccessLevel(address);\n        } else if (0x63e52aee == function_selector) {\n            makeWithdrawal(uint256);\n        } else if (0x66b8901c == function_selector) {\n            delegatedDecreaseApproval(address,uint256);\n        } else if (0x66df8a4a == function_selector) {\n            setAugurUniverse(address);\n        } else if (0x6a2746bc == function_selector) {\n            delegatedStake(uint256);\n        } else if (0x6c8a3b5c == function_selector) {\n            delegatedTotalSupply();\n        } else if (0x85e68531 == function_selector) {\n            revokeAccess(address);\n        } else if (0x943a0ae3 == function_selector) {\n            delegatedApprove(address,uint256);\n        } else if (0x963cf966 == function_selector) {\n            tokenStakingContractAddress();\n        } else if (0x98ea5fca == function_selector) {\n            depositEther();\n        } else if (0x9f674eb3 == function_selector) {\n            myAccessLevel();\n        } else if (0xa056ad96 == function_selector) {\n            delegatedTokenTransfer(address,uint256);\n        } else if (0xad2709e2 == function_selector) {\n            delegatedBalanceOf(address);\n        } else if (0xbbcd5bbe == function_selector) {\n            setTokenContract(address);\n        } else if (0xc652de8e == function_selector) {\n            balanceChecks();\n        } else if (0xcb402289 == function_selector) {\n            delegatedTransferFrom(address,address,uint256);\n        } else if (0xd0be5971 == function_selector) {\n            delegatedApproveSpender(address,uint256);\n        } else if (0xd7a81031 == function_selector) {\n            delegatedIncreaseApproval(address,uint256);\n        } else if (0xdd4db26f == function_selector) {\n            stakedTokensReceivable();\n        } else if (0xf5aec88c == function_selector) {\n            getUserTokenBalance(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfe61406b == function_selector) {\n            approvedTokensPayable();\n        } else if (0xfebcbf31 == function_selector) {\n            delegatedCreateYesNoMarket(uint256,uint256,address,address,bytes32,string,string);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 12:22 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _myAccessLevel; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _userTokenBalance; // STORAGE[0x1]\nuint256 _totalTokenBalance; // STORAGE[0x2]\nuint256 _stakedTokensReceivable; // STORAGE[0x3]\nuint256 _approvedTokensPayable; // STORAGE[0x4]\naddress _getTokenAddress; // STORAGE[0x5] bytes 0 to 19\naddress _tokenStakingContractAddress; // STORAGE[0x6] bytes 0 to 19\naddress _augurUniverseAddress; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nTokenWithdrawal(address, uint256);\nUserBalanceChange(address, uint256, uint256);\nAccessLevelSet(address, uint256, address);\nAccessRevoked(address, uint256, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction withdrawTokens(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _userTokenBalance[varg0], 'Withdraw amount greater than current balance');\n    assert(varg1 <= _userTokenBalance[varg0]);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'error during token transfer', 27);\n    _userTokenBalance[varg0] = _userTokenBalance[varg0] - varg1;\n    assert(varg1 <= _totalTokenBalance);\n    _totalTokenBalance = _totalTokenBalance - varg1;\n    emit TokenWithdrawal(varg0, varg1, varg1);\n    emit UserBalanceChange(varg0, _userTokenBalance[varg0], _userTokenBalance[varg0] - varg1);\n    return 0;\n}\n\nfunction proxyDepositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 + _userTokenBalance[varg0] >= _userTokenBalance[varg0]);\n    _userTokenBalance[varg0] += varg1;\n    assert(varg1 + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += varg1;\n    emit UserBalanceChange(varg0, _userTokenBalance[varg0], varg1 + _userTokenBalance[varg0]);\n}\n\nfunction getTokenAddress() public nonPayable { \n    return _getTokenAddress;\n}\n\nfunction augurUniverseAddress() public nonPayable { \n    return _augurUniverseAddress;\n}\n\nfunction userTokenBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userTokenBalance[varg0];\n}\n\nfunction accessLevel(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _myAccessLevel[varg0];\n}\n\nfunction depositToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(varg0, this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] + _userTokenBalance[varg0] >= _userTokenBalance[varg0]);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.transferFrom(varg0, this, MEM[MEM[64]]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'transfer failed', 15);\n    _userTokenBalance[varg0] += MEM[MEM[64]];\n    assert(MEM[MEM[64]] + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += MEM[MEM[64]];\n    emit UserBalanceChange(varg0, MEM[MEM[64]] + _userTokenBalance[varg0], MEM[MEM[64]] + _userTokenBalance[varg0]);\n}\n\nfunction setTokenStakingContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _tokenStakingContractAddress = varg0;\n}\n\nfunction setAccessLevel(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(4 > _myAccessLevel[varg0], 'Cannot setAccessLevel for Admin Level Access User');\n    v0 = v1 = varg1 < 0;\n    if (varg1 >= 0) {\n        v0 = v2 = varg1 > 4;\n    }\n    require(!v0, 'erroneous access level');\n    _myAccessLevel[varg0] = varg1;\n    emit AccessLevelSet(varg0, varg1, msg.sender);\n}\n\nfunction totalTokenBalance() public nonPayable { \n    return _totalTokenBalance;\n}\n\nfunction makeDeposit() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(msg.sender, this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(MEM[MEM[64]] + _userTokenBalance[msg.sender] >= _userTokenBalance[msg.sender]);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.transferFrom(msg.sender, this, MEM[MEM[64]]).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'transfer failed');\n    _userTokenBalance[msg.sender] += MEM[MEM[64]];\n    assert(MEM[MEM[64]] + _totalTokenBalance >= _totalTokenBalance);\n    _totalTokenBalance += MEM[MEM[64]];\n    emit UserBalanceChange(msg.sender, _userTokenBalance[msg.sender], MEM[MEM[64]] + _userTokenBalance[msg.sender]);\n}\n\nfunction delegatedAllowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.allowance(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction checkTotalBalanceExternal() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(this).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_getTokenAddress.code.size);\n    v2, v3 = _getTokenAddress.balanceOf(this).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1, v3;\n}\n\nfunction getAccessLevel(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _myAccessLevel[varg0];\n}\n\nfunction makeWithdrawal(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= _userTokenBalance[msg.sender], 'Withdraw amount greater than current balance');\n    assert(varg0 <= _userTokenBalance[msg.sender]);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(msg.sender, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(MEM[MEM[64]], 'error during token transfer', 27);\n    _userTokenBalance[msg.sender] = _userTokenBalance[msg.sender] - varg0;\n    assert(varg0 <= _totalTokenBalance);\n    _totalTokenBalance = _totalTokenBalance - varg0;\n    emit TokenWithdrawal(msg.sender, varg0, varg0);\n    emit UserBalanceChange(msg.sender, _userTokenBalance[msg.sender], _userTokenBalance[msg.sender] - varg0);\n    emit TokenWithdrawal(msg.sender, varg0);\n}\n\nfunction delegatedDecreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.decreaseApproval(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction setAugurUniverse(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _augurUniverseAddress = varg0;\n}\n\nfunction delegatedStake(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_tokenStakingContractAddress.code.size);\n    v0, v1 = _tokenStakingContractAddress.stake(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'staking must be successful');\n    _stakedTokensReceivable += varg0;\n    _approvedTokensPayable = _approvedTokensPayable - varg0;\n    return 0;\n}\n\nfunction delegatedTotalSupply() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.totalSupply().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction revokeAccess(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(4 > _myAccessLevel[varg0], 'admin cannot revoke their own access', 'admin cannot revoke their own access');\n    _myAccessLevel[varg0] = 0;\n    emit AccessRevoked(varg0, _myAccessLevel[varg0], msg.sender);\n}\n\nfunction delegatedApprove(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.approve(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction tokenStakingContractAddress() public nonPayable { \n    return _tokenStakingContractAddress;\n}\n\nfunction depositEther() public payable { \n}\n\nfunction myAccessLevel() public nonPayable { \n    return _myAccessLevel[msg.sender];\n}\n\nfunction delegatedTokenTransfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transfer(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction delegatedBalanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction setTokenContract(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    _getTokenAddress = varg0;\n}\n\nfunction balanceChecks() public nonPayable { \n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.balanceOf(_tokenStakingContractAddress).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return _stakedTokensReceivable, _approvedTokensPayable, _totalTokenBalance, v1;\n}\n\nfunction delegatedTransferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.transferFrom(varg0, varg1, varg2).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction delegatedApproveSpender(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.approve(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v1, 'approval must be successful');\n    _approvedTokensPayable += varg1;\n    return 0;\n}\n\nfunction delegatedIncreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(4 == _myAccessLevel[msg.sender], 'Access level 4 required');\n    require(_getTokenAddress.code.size);\n    v0, v1 = _getTokenAddress.increaseApproval(varg0, varg1).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction stakedTokensReceivable() public nonPayable { \n    return _stakedTokensReceivable;\n}\n\nfunction getUserTokenBalance(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userTokenBalance[varg0];\n}\n\nfunction token() public nonPayable { \n    return _getTokenAddress;\n}\n\nfunction approvedTokensPayable() public nonPayable { \n    return _approvedTokensPayable;\n}\n\nfunction delegatedCreateYesNoMarket(uint256 varg0, uint256 varg1, address varg2, address varg3, bytes32 varg4, string varg5, string varg6) public payable { \n    require(msg.data.length - 4 >= 224);\n    require(varg5 <= 0x100000000);\n    require(4 + varg5 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg5 + (?).length > 4 + (msg.data.length - 4))));\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg5, (?).length);\n    MEM[v0.data + (?).length] = 0;\n    require(varg6 <= 0x100000000);\n    require(4 + varg6 + 32 <= 4 + (msg.data.length - 4));\n    require(!(((?).length > 0x100000000) | (36 + varg6 + (?).length > 4 + (msg.data.length - 4))));\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg6, (?).length);\n    MEM[v1.data + (?).length] = 0;\n    v2 = new array[](v0.length);\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        MEM[v3 + v2.data] = MEM[v3 + v0.data];\n        v3 += 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v2.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v2.data - (0x1f & v0.length)];\n    }\n    v5 = new array[](v1.length);\n    v6 = v7 = 0;\n    while (v6 < v1.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v1.data];\n        v6 += 32;\n    }\n    v8 = v9 = v1.length + v5.data;\n    if (0x1f & v1.length) {\n        MEM[v9 - (0x1f & v1.length)] = ~(256 ** (32 - (0x1f & v1.length)) - 1) & MEM[v9 - (0x1f & v1.length)];\n    }\n    require(_augurUniverseAddress.code.size);\n    v10 = _augurUniverseAddress.createYesNoMarket(varg0, varg1, varg2, varg3, varg4, v2, v5).gas(msg.gas);\n    require(v10); // checks call status, propagates error data on error\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6b091f9) {\n            withdrawTokens(address,uint256);\n        } else if (0xe758845 == function_selector) {\n            proxyDepositToken(address,uint256);\n        } else if (0x10fe9ae8 == function_selector) {\n            getTokenAddress();\n        } else if (0x2154511c == function_selector) {\n            augurUniverseAddress();\n        } else if (0x29a87023 == function_selector) {\n            userTokenBalance(address);\n        } else if (0x2f259a00 == function_selector) {\n            accessLevel(address);\n        } else if (0x2fd55265 == function_selector) {\n            depositToken(address);\n        } else if (0x34dc64e5 == function_selector) {\n            setTokenStakingContract(address);\n        } else if (0x3a7327a3 == function_selector) {\n            setAccessLevel(address,uint256);\n        } else if (0x3d4b2c2c == function_selector) {\n            totalTokenBalance();\n        } else if (0x40732c89 == function_selector) {\n            makeDeposit();\n        } else if (0x43c93e35 == function_selector) {\n            delegatedAllowance(address,address);\n        } else if (0x5b885273 == function_selector) {\n            checkTotalBalanceExternal();\n        } else if (0x5bc008a0 == function_selector) {\n            getAccessLevel(address);\n        } else if (0x63e52aee == function_selector) {\n            makeWithdrawal(uint256);\n        } else if (0x66b8901c == function_selector) {\n            delegatedDecreaseApproval(address,uint256);\n        } else if (0x66df8a4a == function_selector) {\n            setAugurUniverse(address);\n        } else if (0x6a2746bc == function_selector) {\n            delegatedStake(uint256);\n        } else if (0x6c8a3b5c == function_selector) {\n            delegatedTotalSupply();\n        } else if (0x85e68531 == function_selector) {\n            revokeAccess(address);\n        } else if (0x943a0ae3 == function_selector) {\n            delegatedApprove(address,uint256);\n        } else if (0x963cf966 == function_selector) {\n            tokenStakingContractAddress();\n        } else if (0x98ea5fca == function_selector) {\n            depositEther();\n        } else if (0x9f674eb3 == function_selector) {\n            myAccessLevel();\n        } else if (0xa056ad96 == function_selector) {\n            delegatedTokenTransfer(address,uint256);\n        } else if (0xad2709e2 == function_selector) {\n            delegatedBalanceOf(address);\n        } else if (0xbbcd5bbe == function_selector) {\n            setTokenContract(address);\n        } else if (0xc652de8e == function_selector) {\n            balanceChecks();\n        } else if (0xcb402289 == function_selector) {\n            delegatedTransferFrom(address,address,uint256);\n        } else if (0xd0be5971 == function_selector) {\n            delegatedApproveSpender(address,uint256);\n        } else if (0xd7a81031 == function_selector) {\n            delegatedIncreaseApproval(address,uint256);\n        } else if (0xdd4db26f == function_selector) {\n            stakedTokensReceivable();\n        } else if (0xf5aec88c == function_selector) {\n            getUserTokenBalance(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfe61406b == function_selector) {\n            approvedTokensPayable();\n        } else if (0xfebcbf31 == function_selector) {\n            delegatedCreateYesNoMarket(uint256,uint256,address,address,bytes32,string,string);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 21.253668069839478,
	"usage": {
		"completion_tokens": 393,
		"prompt_tokens": 5113,
		"total_tokens": 5506
	}
}