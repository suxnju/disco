{
	"address": "0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.05 13:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _isPaused; // STORAGE[0x0] bytes 0 to 0\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _cardPresaleCounter; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _getBuyCount; // STORAGE[0x6]\nuint256 _fallback; // STORAGE[0x7]\nuint256 _addrAdmin; // STORAGE[0x0] bytes 1 to 20\nuint256 _addrService; // STORAGE[0x1] bytes 0 to 19\nuint256 _addrFinance; // STORAGE[0x2] bytes 0 to 19\nuint256 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\nuint256 stor_3145c75015e7a856ecd94c41432ef3cb669d6360af23433588937fefdfac825_0_1; // STORAGE[0x3145c75015e7a856ecd94c41432ef3cb669d6360af23433588937fefdfac825] bytes 0 to 1\nuint256 stor_69400f22b28c6c362558d92f66163cec5671cba50b61abd2eecfcd0eaeac518_0_1; // STORAGE[0x69400f22b28c6c362558d92f66163cec5671cba50b61abd2eecfcd0eaeac518] bytes 0 to 1\nuint256 _getCardCanPresaleCount; // STORAGE[0x1471eb6eb2c5e789fc3de43f8ce62938c7d1836ec861730447e2ada8fd81017b] bytes 0 to 1\nuint256 stor_1759eeb783be12e6871ee15567296c25cea65699ad38e9965540ba6254a9037f_0_1; // STORAGE[0x1759eeb783be12e6871ee15567296c25cea65699ad38e9965540ba6254a9037f] bytes 0 to 1\nuint256 stor_3dfec54401578e5ad10d5cfe74972cfc24c82740aaca9c2d34cbb4be4a761cc5_0_1; // STORAGE[0x3dfec54401578e5ad10d5cfe74972cfc24c82740aaca9c2d34cbb4be4a761cc5] bytes 0 to 1\nuint256 stor_3eec716f11ba9e820c81ca75eb978ffb45831ef8b7a53e5e422c26008e1ca6d5_0_1; // STORAGE[0x3eec716f11ba9e820c81ca75eb978ffb45831ef8b7a53e5e422c26008e1ca6d5] bytes 0 to 1\nuint256 stor_40f28f99a40bc9f6beea1013afdbc3cdcc689eb76b82c4de06c0acf1e1932ed5_0_1; // STORAGE[0x40f28f99a40bc9f6beea1013afdbc3cdcc689eb76b82c4de06c0acf1e1932ed5] bytes 0 to 1\nuint256 stor_458b30c2d72bfd2c6317304a4594ecbafe5f729d3111b65fdc3a33bd48e5432d_0_1; // STORAGE[0x458b30c2d72bfd2c6317304a4594ecbafe5f729d3111b65fdc3a33bd48e5432d] bytes 0 to 1\nuint256 stor_58f00e8ecc6f5419941dd0bafec65a4cc188d31713fb1fe224257460930df8af_0_1; // STORAGE[0x58f00e8ecc6f5419941dd0bafec65a4cc188d31713fb1fe224257460930df8af] bytes 0 to 1\nuint256 stor_5cc25df4297f13907c2e8c8bb7612ac7d899f1e24c7e8664c22a89192ac286a7_0_1; // STORAGE[0x5cc25df4297f13907c2e8c8bb7612ac7d899f1e24c7e8664c22a89192ac286a7] bytes 0 to 1\nuint256 stor_783638979e3582b3ffd6d53fc06c949ac31d1ac75a5e2c3531fbe1f91045eb53_0_1; // STORAGE[0x783638979e3582b3ffd6d53fc06c949ac31d1ac75a5e2c3531fbe1f91045eb53] bytes 0 to 1\nuint256 stor_872ac8b0ab547ba6ba6686d487265a409b97d09cf043f98287b4b34e7bc04a71_0_1; // STORAGE[0x872ac8b0ab547ba6ba6686d487265a409b97d09cf043f98287b4b34e7bc04a71] bytes 0 to 1\nuint256 stor_89832631fb3c3307a103ba2c84ab569c64d6182a18893dcd163f0f1c2090733a_0_1; // STORAGE[0x89832631fb3c3307a103ba2c84ab569c64d6182a18893dcd163f0f1c2090733a] bytes 0 to 1\nuint256 stor_8b32256db898364c465749decac34aee435952ffe1739257aa5b0235e266d9c5_0_1; // STORAGE[0x8b32256db898364c465749decac34aee435952ffe1739257aa5b0235e266d9c5] bytes 0 to 1\nuint256 stor_a18b128af1c8fc61ff46f02d146e54546f34d340574cf2cef6a753cba6b6701d_0_1; // STORAGE[0xa18b128af1c8fc61ff46f02d146e54546f34d340574cf2cef6a753cba6b6701d] bytes 0 to 1\nuint256 stor_a9bc9a3a348c357ba16b37005d7e6b3236198c0e939f4af8c5f19b8deeb8ebc0_0_1; // STORAGE[0xa9bc9a3a348c357ba16b37005d7e6b3236198c0e939f4af8c5f19b8deeb8ebc0] bytes 0 to 1\nuint256 stor_ae2f6b16f0e0ac80673d6caef460ba44e001264158bf422be5bc239018ccc677_0_1; // STORAGE[0xae2f6b16f0e0ac80673d6caef460ba44e001264158bf422be5bc239018ccc677] bytes 0 to 1\nuint256 stor_b4e18992ad424cdedc46668609f2bafcf665a8d99577618d5923c69264d9cf5f_0_1; // STORAGE[0xb4e18992ad424cdedc46668609f2bafcf665a8d99577618d5923c69264d9cf5f] bytes 0 to 1\nuint256 stor_b8657d180a4d2444fb942e94a4266075e5a1b59d96d88e88cf308d6927f00ff2_0_1; // STORAGE[0xb8657d180a4d2444fb942e94a4266075e5a1b59d96d88e88cf308d6927f00ff2] bytes 0 to 1\nuint256 stor_c0a4a8be475dfebc377ebef2d7c4ff47656f572a08dd92b81017efcdba0febe1_0_1; // STORAGE[0xc0a4a8be475dfebc377ebef2d7c4ff47656f572a08dd92b81017efcdba0febe1] bytes 0 to 1\nuint256 stor_d1ccbf1f9f869f51cd81e6f099f905636b057f682c706fe990614b1120516928_0_1; // STORAGE[0xd1ccbf1f9f869f51cd81e6f099f905636b057f682c706fe990614b1120516928] bytes 0 to 1\nuint256 stor_dcae836ed36bf3d20474cfcca00229d5b3b00239a2a956d8ca4bf29e25a7143c_0_1; // STORAGE[0xdcae836ed36bf3d20474cfcca00229d5b3b00239a2a956d8ca4bf29e25a7143c] bytes 0 to 1\nuint256 stor_eddb6698d7c569ff62ff64f1f1492bf14a54594835ba0faac91f84b4f5d81460_0_1; // STORAGE[0xeddb6698d7c569ff62ff64f1f1492bf14a54594835ba0faac91f84b4f5d81460] bytes 0 to 1\nuint256 stor_f907e7e6656fa73566b18c1215272fe9fca2c55c552e62c923e21e000ac4b4e6_0_1; // STORAGE[0xf907e7e6656fa73566b18c1215272fe9fca2c55c552e62c923e21e000ac4b4e6] bytes 0 to 1\nuint256 stor_fb33122aa9f93cc639ebe80a7bc4784c11e6053dde89c6f4f7e268c6a623da1e_0_1; // STORAGE[0xfb33122aa9f93cc639ebe80a7bc4784c11e6053dde89c6f4f7e268c6a623da1e] bytes 0 to 1\n\n// Events\nCardPreSelled(address, uint16);\nJackpot(address, uint256, uint16);\nAdminTransferred(address, address);\n\nfunction jackpotBalance() public nonPayable { \n    return _fallback;\n}\n\nfunction cardPresale(uint16 varg0) public payable { \n    v0 = new struct(5);\n    MEM[v0 len 160] = this.code[this.code.size len 160];\n    require(!_isPaused);\n    require(uint16(_cardPresaleCounter[uint16(uint16(varg0))]) > 0);\n    require(msg.value == 0x3782dace9d90000);\n    v1 = v2 = 0;\n    while (v1 < 160) {\n        MEM[v1 + (36 + MEM[64])] = MEM[v1 + MEM[64]];\n        v1 += 32;\n    }\n    require(stor_4_0_19.code.size);\n    v3 = stor_4_0_19.createCard(msg.sender, uint16(10000 + uint16(varg0)), varg0, 6, 0, 1, 1).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _getBuyCount[msg.sender] = _getBuyCount[msg.sender] + 1;\n    STORAGE[(_getBuyCount[msg.sender] >> 4) + keccak256(keccak256(msg.sender, 6))] = varg0 * 256 ** ((_getBuyCount[msg.sender] & 0xf) << 1) | STORAGE[(_getBuyCount[msg.sender] >> 4) + keccak256(keccak256(msg.sender, 6))] & ~(0xffff * 256 ** ((_getBuyCount[msg.sender] & 0xf) << 1));\n    _cardPresaleCounter[varg0] = uint16(uint16(_cardPresaleCounter[uint16(uint16(varg0))]) + ~0) | ~0xffff & _cardPresaleCounter[varg0];\n    emit CardPreSelled(msg.sender, varg0);\n    _fallback += (msg.value << 1) / 10;\n    v4 = _addrFinance.call().value((address(this)).balance - ((msg.value << 1) / 10 + _fallback)).gas(2300 * !((address(this)).balance - ((msg.value << 1) / 10 + _fallback)));\n    require(v4); // checks call status, propagates error data on error\n    stor_3 = keccak256(stor_3, block.blockhash(block.number + ~0), address(block.coinbase), block.difficulty);\n    if (99 == keccak256(stor_3, block.blockhash(block.number + ~0), address(block.coinbase), block.difficulty) % 100) {\n        emit Jackpot(msg.sender, _fallback, 2);\n        v5 = msg.sender.call().value(_fallback).gas(2300 * !_fallback);\n        require(v5); // checks call status, propagates error data on error\n    }\n}\n\nfunction doUnpause() public nonPayable { \n    require(_addrAdmin == msg.sender);\n    require(_isPaused);\n    _isPaused = 0;\n}\n\nfunction setELHeroTokenAddr(address varg0) public nonPayable { \n    require(_addrAdmin == msg.sender);\n    stor_4_0_19 = varg0;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = v1 = _addrFinance == msg.sender;\n    if (_addrFinance != msg.sender) {\n        v0 = _addrAdmin == msg.sender;\n    }\n    require(v0);\n    v2 = _addrFinance.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction doPause() public nonPayable { \n    require(_addrAdmin == msg.sender);\n    require(!_isPaused);\n    _isPaused = 1;\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    require(_addrAdmin == msg.sender);\n    require(varg0);\n    emit AdminTransferred(_addrAdmin, varg0);\n    _addrAdmin = varg0;\n}\n\nfunction getCardCanPresaleCount() public nonPayable { \n    MEM[(MEM[64]) len 800] = this.code[this.code.size len 800];\n    MEM[0] = 25;\n    MEM[32] = 5;\n    v0 = v1 = 0;\n    while (v0 < 800) {\n        MEM[v0 + MEM[64]] = MEM[v0 + MEM[64]];\n        v0 += 32;\n    }\n    return _getCardCanPresaleCount, stor_89832631fb3c3307a103ba2c84ab569c64d6182a18893dcd163f0f1c2090733a_0_1, stor_a9bc9a3a348c357ba16b37005d7e6b3236198c0e939f4af8c5f19b8deeb8ebc0_0_1, stor_3eec716f11ba9e820c81ca75eb978ffb45831ef8b7a53e5e422c26008e1ca6d5_0_1, stor_458b30c2d72bfd2c6317304a4594ecbafe5f729d3111b65fdc3a33bd48e5432d_0_1, stor_69400f22b28c6c362558d92f66163cec5671cba50b61abd2eecfcd0eaeac518_0_1, stor_eddb6698d7c569ff62ff64f1f1492bf14a54594835ba0faac91f84b4f5d81460_0_1, stor_fb33122aa9f93cc639ebe80a7bc4784c11e6053dde89c6f4f7e268c6a623da1e_0_1, stor_c0a4a8be475dfebc377ebef2d7c4ff47656f572a08dd92b81017efcdba0febe1_0_1, stor_a18b128af1c8fc61ff46f02d146e54546f34d340574cf2cef6a753cba6b6701d_0_1, stor_40f28f99a40bc9f6beea1013afdbc3cdcc689eb76b82c4de06c0acf1e1932ed5_0_1, stor_f907e7e6656fa73566b18c1215272fe9fca2c55c552e62c923e21e000ac4b4e6_0_1, stor_3145c75015e7a856ecd94c41432ef3cb669d6360af23433588937fefdfac825_0_1, stor_783638979e3582b3ffd6d53fc06c949ac31d1ac75a5e2c3531fbe1f91045eb53_0_1, stor_58f00e8ecc6f5419941dd0bafec65a4cc188d31713fb1fe224257460930df8af_0_1, stor_8b32256db898364c465749decac34aee435952ffe1739257aa5b0235e266d9c5_0_1, stor_b4e18992ad424cdedc46668609f2bafcf665a8d99577618d5923c69264d9cf5f_0_1, stor_d1ccbf1f9f869f51cd81e6f099f905636b057f682c706fe990614b1120516928_0_1, stor_872ac8b0ab547ba6ba6686d487265a409b97d09cf043f98287b4b34e7bc04a71_0_1, stor_3dfec54401578e5ad10d5cfe74972cfc24c82740aaca9c2d34cbb4be4a761cc5_0_1, stor_dcae836ed36bf3d20474cfcca00229d5b3b00239a2a956d8ca4bf29e25a7143c_0_1, stor_b8657d180a4d2444fb942e94a4266075e5a1b59d96d88e88cf308d6927f00ff2_0_1, stor_1759eeb783be12e6871ee15567296c25cea65699ad38e9965540ba6254a9037f_0_1, stor_5cc25df4297f13907c2e8c8bb7612ac7d899f1e24c7e8664c22a89192ac286a7_0_1, stor_ae2f6b16f0e0ac80673d6caef460ba44e001264158bf422be5bc239018ccc677_0_1;\n}\n\nfunction addrFinance() public nonPayable { \n    return _addrFinance;\n}\n\nfunction setFinance(address varg0) public nonPayable { \n    v0 = v1 = _addrFinance == msg.sender;\n    if (_addrFinance != msg.sender) {\n        v0 = v2 = _addrAdmin == msg.sender;\n    }\n    require(v0);\n    require(varg0);\n    _addrFinance = varg0;\n}\n\nfunction isPaused() public nonPayable { \n    return _isPaused;\n}\n\nfunction eventPirze(address varg0, uint8 varg1) public nonPayable { \n    v0 = new struct(5);\n    MEM[v0 len 160] = this.code[this.code.size len 160];\n    require(_addrAdmin == msg.sender);\n    v1 = v2 = 20 == 0xff & (varg1 & 0xff);\n    if (20 != 0xff & (varg1 & 0xff)) {\n        v1 = v3 = 21 == 0xff & (varg1 & 0xff);\n    }\n    require(v1);\n    require(uint16(_cardPresaleCounter[varg1 & 0xff & 0xff]) > 0);\n    v4 = v5 = 0;\n    while (v4 < 160) {\n        MEM[v4 + (MEM[64] + 36)] = MEM[v4 + MEM[64]];\n        v4 += 32;\n    }\n    require(stor_4_0_19.code.size);\n    v6 = stor_4_0_19.createCard(varg0, uint16((varg1 & 0xff & 0xff) + 10000), varg1 & 0xff & 0xff, 6, v5, 1, 1).gas(msg.gas);\n    require(v6); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    _getBuyCount[varg0] = _getBuyCount[varg0] + 1;\n    STORAGE[(_getBuyCount[varg0] >> 4) + keccak256(keccak256(varg0, 6))] = (0xff & (varg1 & 0xff)) * 256 ** ((_getBuyCount[varg0] & 0xf) << 1) | STORAGE[(_getBuyCount[varg0] >> 4) + keccak256(keccak256(varg0, 6))] & ~(256 ** ((_getBuyCount[varg0] & 0xf) << 1) * 0xffff);\n    _cardPresaleCounter[0xff & (varg1 & 0xff)] = uint16(~0 + uint16(_cardPresaleCounter[varg1 & 0xff & 0xff])) | ~0xffff & _cardPresaleCounter[0xff & (varg1 & 0xff)];\n}\n\nfunction setService(address varg0) public nonPayable { \n    v0 = v1 = _addrService == msg.sender;\n    if (_addrService != msg.sender) {\n        v0 = v2 = _addrAdmin == msg.sender;\n    }\n    require(v0);\n    require(varg0);\n    _addrService = varg0;\n}\n\nfunction addrAdmin() public nonPayable { \n    return _addrAdmin;\n}\n\nfunction addrService() public nonPayable { \n    return _addrService;\n}\n\nfunction getBuyCount(address varg0) public nonPayable { \n    return uint32(_getBuyCount[address(address(varg0))]);\n}\n\nfunction getBuyArray(address varg0) public nonPayable { \n    v0 = v1 = MEM[64] + 32;\n    if (_getBuyCount[varg0]) {\n        v2 = v3 = 0;\n        do {\n            MEM[v0] = uint16(STORAGE[v4] / 256 ** v2);\n            v0 += 32;\n            v4 += 3 + v2 >> 5;\n            v2 = (2 + v2) * (1 - (3 + v2 >> 5));\n        } while (v1 + (_getBuyCount[varg0] << 5) <= v0);\n    }\n    v5 = new array[](_getBuyCount[varg0]);\n    v6 = v7 = 0;\n    while (v6 < _getBuyCount[varg0] << 5) {\n        v5[v6] = MEM[v6 + (32 + MEM[64])];\n        v6 += 32;\n    }\n    return v5;\n}\n\nfunction cardPresaleCounter(uint16 varg0) public nonPayable { \n    return uint16(_cardPresaleCounter[uint16(varg0)]);\n}\n\nfunction () public payable { \n    require(msg.value > 0);\n    _fallback += msg.value;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x40da8f4) {\n            jackpotBalance();\n        } else if (0x1d90c509 == uint32(function_selector >> 224)) {\n            cardPresale(uint16);\n        } else if (0x30efb8d3 == uint32(function_selector >> 224)) {\n            doUnpause();\n        } else if (0x3c21fa2e == uint32(function_selector >> 224)) {\n            setELHeroTokenAddr(address);\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x67d0661d == uint32(function_selector >> 224)) {\n            doPause();\n        } else if (0x704b6c02 == uint32(function_selector >> 224)) {\n            setAdmin(address);\n        } else if (0x735b38a3 == uint32(function_selector >> 224)) {\n            getCardCanPresaleCount();\n        } else if (0x82cb9df9 == uint32(function_selector >> 224)) {\n            addrFinance();\n        } else if (0x9b8d3064 == uint32(function_selector >> 224)) {\n            setFinance(address);\n        } else if (0xb187bd26 == uint32(function_selector >> 224)) {\n            isPaused();\n        } else if (0xb94f5a6e == uint32(function_selector >> 224)) {\n            eventPirze(address,uint8);\n        } else if (0xbf8bdac1 == uint32(function_selector >> 224)) {\n            setService(address);\n        } else if (0xbfae2f0e == uint32(function_selector >> 224)) {\n            addrAdmin();\n        } else if (0xcdd977e0 == uint32(function_selector >> 224)) {\n            addrService();\n        } else if (0xd489c0bf == uint32(function_selector >> 224)) {\n            getBuyCount(address);\n        } else if (0xe5d3d9d7 == uint32(function_selector >> 224)) {\n            getBuyArray(address);\n        } else if (0xeb57d9a6 == uint32(function_selector >> 224)) {\n            cardPresaleCounter(uint16);\n        }\n    }\n    ();\n}\n",
	"language": "Solidity",
	"status": "Connection error."
}