{
	"address": "0x449335a73eaa9456a47494cfbf2b27588febf3ae",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract that closely resembles the given decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract AutomobileCoin {\n    uint256 private _totalSupply;\n    uint256 private _rate;\n    uint256 private _totalFundingSupply;\n    uint256 private _maxSupply;\n    mapping(address => uint256) private _balanceOf;\n    mapping(address => mapping(address => uint256)) private _allowance;\n    address private _owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _owner = msg.sender;\n        _totalSupply = 0;\n        _rate = 1;\n        _maxSupply = 1000000;\n    }\n\n    function name() public pure returns (string memory) {\n        return \"AutomobileCoin\";\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(to != address(0));\n        require(value <= _allowance[from][msg.sender]);\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function rate() public view returns (uint256) {\n        return _rate;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function maxSupply() public view returns (uint256) {\n        return _maxSupply;\n    }\n\n    function setRate(uint256 newRate) public {\n        require(msg.sender == _owner);\n        _rate = newRate;\n    }\n\n    function version() public pure returns (string memory) {\n        return \"1.0\";\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function withdrawCoinToOwner(uint256 value) public {\n        require(msg.sender == _owner);\n        _totalSupply -= value;\n        _balanceOf[_owner] += value;\n        emit Transfer(address(0), _owner, value);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"AUB\";\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(to != address(0));\n        require(value <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function totalFundingSupply() public view returns (uint256) {\n        return _totalFundingSupply;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    fallback() external payable {\n        _totalSupply += msg.value * _rate;\n        _balanceOf[msg.sender] += msg.value * _rate;\n        emit Transfer(address(0), msg.sender, msg.value * _rate);\n        _totalFundingSupply += msg.value;\n    }\n}\n```\n\nPlease keep in mind that decompiled code doesn't always perfectly represent the original Solidity contract, so it's crucial to thoroughly test this contract before using it for any production purposes.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469692,
	"id": "chatcmpl-8R6HU8aNPlbIjcDhGGDxzujNQeGV6",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 16:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _rate; // STORAGE[0x2]\nuint256 _totalFundingSupply; // STORAGE[0x3]\nuint256 _mAX_SUPPLY; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (14) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffff & 'Automobilecoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    assert(varg2 <= _allowance[varg0]);\n    _balanceOf[varg0] = _allowance[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return _mAX_SUPPLY;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rate = varg0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x312e300000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawCoinToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x686(1, varg0, msg.sender);\n}\n\nfunction etherProceeds() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4155420000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalFundingSupply() public nonPayable { \n    return _totalFundingSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x686(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x793(varg0, varg1);\n    assert(_totalSupply + v0 >= _totalSupply);\n    assert(_mAX_SUPPLY >= _totalSupply + v0);\n    v1 = 0x793(varg0, varg1);\n    assert(_totalSupply + v1 >= _totalSupply);\n    _totalSupply = _totalSupply + v1;\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] + v1;\n    emit Transfer(0, address(varg2), v1);\n    return ;\n}\n\nfunction 0x793(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x686(_rate, msg.value, msg.sender);\n    v0 = 0x793(_rate, msg.value);\n    assert(_totalFundingSupply + v0 >= _totalFundingSupply);\n    _totalFundingSupply = _totalFundingSupply + v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x32cb6b0c == function_selector) {\n            MAX_SUPPLY();\n        } else if (0x34fcf437 == function_selector) {\n            setRate(uint256);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7943f2ec == function_selector) {\n            withdrawCoinToOwner(uint256);\n        } else if (0x801aba56 == function_selector) {\n            etherProceeds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xa93b5331 == function_selector) {\n            totalFundingSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 16:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _rate; // STORAGE[0x2]\nuint256 _totalFundingSupply; // STORAGE[0x3]\nuint256 _mAX_SUPPLY; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (14) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffff & 'Automobilecoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    assert(varg2 <= _allowance[varg0]);\n    _balanceOf[varg0] = _allowance[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return _mAX_SUPPLY;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rate = varg0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x312e300000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawCoinToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x686(1, varg0, msg.sender);\n}\n\nfunction etherProceeds() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4155420000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalFundingSupply() public nonPayable { \n    return _totalFundingSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x686(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x793(varg0, varg1);\n    assert(_totalSupply + v0 >= _totalSupply);\n    assert(_mAX_SUPPLY >= _totalSupply + v0);\n    v1 = 0x793(varg0, varg1);\n    assert(_totalSupply + v1 >= _totalSupply);\n    _totalSupply = _totalSupply + v1;\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] + v1;\n    emit Transfer(0, address(varg2), v1);\n    return ;\n}\n\nfunction 0x793(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x686(_rate, msg.value, msg.sender);\n    v0 = 0x793(_rate, msg.value);\n    assert(_totalFundingSupply + v0 >= _totalFundingSupply);\n    _totalFundingSupply = _totalFundingSupply + v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x32cb6b0c == function_selector) {\n            MAX_SUPPLY();\n        } else if (0x34fcf437 == function_selector) {\n            setRate(uint256);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7943f2ec == function_selector) {\n            withdrawCoinToOwner(uint256);\n        } else if (0x801aba56 == function_selector) {\n            etherProceeds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xa93b5331 == function_selector) {\n            totalFundingSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 16:40 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _rate; // STORAGE[0x2]\nuint256 _totalFundingSupply; // STORAGE[0x3]\nuint256 _mAX_SUPPLY; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\nOwnershipTransferred(address, address);\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (14) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffff & 'Automobilecoin';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    assert(varg2 <= _allowance[varg0]);\n    _balanceOf[varg0] = _allowance[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return _mAX_SUPPLY;\n}\n\nfunction setRate(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rate = varg0;\n}\n\nfunction version() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x312e300000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction withdrawCoinToOwner(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    0x686(1, varg0, msg.sender);\n}\n\nfunction etherProceeds() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = msg.sender.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v0.data + v2] = MEM[v1.data + v2];\n        v2 = v2 + 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4155420000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalFundingSupply() public nonPayable { \n    return _totalFundingSupply;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction 0x686(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x793(varg0, varg1);\n    assert(_totalSupply + v0 >= _totalSupply);\n    assert(_mAX_SUPPLY >= _totalSupply + v0);\n    v1 = 0x793(varg0, varg1);\n    assert(_totalSupply + v1 >= _totalSupply);\n    _totalSupply = _totalSupply + v1;\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] + v1;\n    emit Transfer(0, address(varg2), v1);\n    return ;\n}\n\nfunction 0x793(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    0x686(_rate, msg.value, msg.sender);\n    v0 = 0x793(_rate, msg.value);\n    assert(_totalFundingSupply + v0 >= _totalFundingSupply);\n    _totalFundingSupply = _totalFundingSupply + v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2c4e722e == function_selector) {\n            rate();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x32cb6b0c == function_selector) {\n            MAX_SUPPLY();\n        } else if (0x34fcf437 == function_selector) {\n            setRate(uint256);\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7943f2ec == function_selector) {\n            withdrawCoinToOwner(uint256);\n        } else if (0x801aba56 == function_selector) {\n            etherProceeds();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xa93b5331 == function_selector) {\n            totalFundingSupply();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 32.16914367675781,
	"usage": {
		"completion_tokens": 842,
		"prompt_tokens": 1992,
		"total_tokens": 2834
	}
}