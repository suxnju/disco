{
	"address": "0xd46ddc98c63f9705ca6689e7036dc3ce981fb335",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, a Solidity version of the contract could look similar to the following:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract ContractName {\n    // Variables\n    mapping(address => uint) private balances;\n    mapping(address => mapping (address => uint)) private allowed;\n    uint256 public totalSupply;\n\n    // Events\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n    // Fallback function\n    function () external payable {\n        require(msg.value > 0);\n        // Further logic here\n    }\n\n    // Functions\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function transfer(address to, uint tokens) public returns (bool success) {\n        require(balances[msg.sender] >= tokens);\n        balances[msg.sender] = balances[msg.sender] - tokens;\n        balances[to] = balances[to] + tokens;\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        require(tokens <= balances[from]);\n        require(tokens <= allowed[from][msg.sender]);\n\n        balances[from] = balances[from] - tokens;\n        allowed[from][msg.sender] = allowed[from][msg.sender] - tokens;\n        balances[to] = balances[to] + tokens;\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n}\n```\n\nPlease note, this is a simplified version of the contract based on the provided decompiled code. You may need to adjust it according to your specific requirements. For example, the contract doesn't include a constructor to initialize the total supply and assign it to an owner, it doesn't include a function to withdraw funds that have been sent to the contract, and it doesn't include any access control to restrict who can call certain functions. Also, the provided decompiled code seems to contain multiple mappings and variables that are not used in the decompiled Solidity code above.",
				"role": "assistant"
			}
		}
	],
	"created": 1701462093,
	"id": "chatcmpl-8R4IvYQgZoYGDqyQrF3y3xizIiL9b",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 09:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 _trancheLevel; // STORAGE[0x7]\nuint256 _circulatingSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 _trancheOneSaleOpenTime; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _trancheOneBalances; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _trancheTokens; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _trancheRate; // STORAGE[0x12]\nuint8 _decimals; // STORAGE[0x1] bytes 0 to 0\nuint8 _fallback; // STORAGE[0xd] bytes 0 to 0\nuint8 stor_d_1_1; // STORAGE[0xd] bytes 1 to 1\nuint8 stor_d_2_2; // STORAGE[0xd] bytes 2 to 2\nuint8 _initialTranches; // STORAGE[0xd] bytes 3 to 3\nuint8 stor_d_4_4; // STORAGE[0xd] bytes 4 to 4\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint160 _feesAddr; // STORAGE[0x4] bytes 0 to 19\naddress owner_5_0_19; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.value > 0;\n    if (v1) {\n        v0 = v2 = _fallback;\n    }\n    require(v0);\n    0xbd1(0, msg.value);\n}\n\nfunction trancheLevel() public nonPayable { \n    return _trancheLevel;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction balanceInSpecificTranche(uint256 varg0) public nonPayable { \n    return _trancheTokens[varg0];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction rateOfSpecificTranche(uint256 varg0) public nonPayable { \n    return _trancheRate[varg0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_balances[varg0] >= varg2);\n    require(varg2 <= _balances[varg0]);\n    _balances[varg0] = _balances[varg0] - varg2;\n    require(varg2 <= _balances[msg.sender]);\n    _allowance[msg.sender] = _balances[msg.sender] - varg2;\n    require(_balances[varg1] + varg2 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction receiveEth() public nonPayable { \n    return _fallback;\n}\n\nfunction trancheRate(uint256 varg0) public nonPayable { \n    return _trancheRate[varg0];\n}\n\nfunction trancheOneBalances(address varg0) public nonPayable { \n    return _trancheOneBalances[varg0];\n}\n\nfunction updateTrancheRate(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    require(v0);\n    _trancheRate[varg0] = varg1;\n}\n\nfunction trancheOneBalanceOf(address varg0) public nonPayable { \n    return _trancheOneBalances[varg0];\n}\n\nfunction toggleReceiveEth() public nonPayable { \n    require(msg.sender == _owner);\n    if (_fallback != 1) {\n        _fallback = 1;\n    } else {\n        _fallback = 0;\n    }\n}\n\nfunction feesAddr() public nonPayable { \n    return _feesAddr;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction initialTranches() public nonPayable { \n    return _initialTranches;\n}\n\nfunction trancheOneSaleOpenTime() public nonPayable { \n    return _trancheOneSaleOpenTime;\n}\n\nfunction balanceInTranche() public nonPayable { \n    return _trancheTokens[_trancheLevel];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction closeTrancheAddition() public nonPayable { \n    require(msg.sender == _owner);\n    stor_d_2_2 = 0;\n}\n\nfunction circulatingSupply() public nonPayable { \n    return _circulatingSupply;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateFeeAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = varg0 >= 0;\n    if (v1) {\n        v0 = v2 = varg0 <= 100;\n    }\n    require(v0);\n    stor_b = varg0 * 100;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (block.timestamp < _trancheOneSaleOpenTime) {\n            require(_balances[msg.sender] <= _balances[msg.sender]);\n            require(varg1 <= _balances[msg.sender] - _balances[msg.sender]);\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n    } else {\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        require(varg1 <= _circulatingSupply);\n        _circulatingSupply = _circulatingSupply - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction otcPurchaseAndEscrow(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balances[varg1] + varg0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg0;\n    require(_balances[msg.sender] + varg0 >= _balances[msg.sender]);\n    _trancheOneBalances[msg.sender] = _balances[msg.sender] + varg0;\n    emit Transfer(address(this), varg1, varg0);\n}\n\nfunction payFeesToggle() public nonPayable { \n    require(msg.sender == _owner);\n    if (!stor_d_1_1) {\n        stor_d_1_1 = 1;\n    } else {\n        stor_d_1_1 = 0;\n    }\n}\n\nfunction otcPurchase(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balances[varg1] + varg0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg0;\n    emit Transfer(address(this), varg1, varg0);\n}\n\nfunction safeWithdrawal(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg1 <= (address(this)).balance);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction addTrancheRateAndTokens(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    if (v0) {\n        v0 = v3 = stor_d_2_2 == 1;\n    }\n    require(v0);\n    require(varg1 + _circulatingSupply >= varg1);\n    require(varg1 + _circulatingSupply <= _totalSupply);\n    _trancheTokens[varg0] = varg1;\n    _trancheTokens[varg0] = varg2;\n    stor_9 += 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction changeTrancheAdmin(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    require(v0);\n    owner_5_0_19 = varg0;\n}\n\nfunction trancheTokens(uint256 varg0) public nonPayable { \n    return _trancheTokens[varg0];\n}\n\nfunction changeFeesAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _feesAddr = varg0;\n}\n\nfunction 0xbd1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    stor_a += 1;\n    v2 = v3 = _trancheLevel <= stor_9;\n    if (v3) {\n        v2 = v4 = stor_a <= stor_9;\n    }\n    if (v2) {\n        v5 = _SafeMul(_trancheRate[_trancheLevel], varg1);\n        assert(0xde0b6b3a7640000);\n        v0 = v5 / 0xde0b6b3a7640000;\n    }\n    v6 = v7 = v0 >= _trancheTokens[_trancheLevel];\n    if (v7) {\n        v6 = v8 = stor_a <= stor_9;\n    }\n    if (!v6) {\n        v9 = v10 = _trancheTokens[_trancheLevel] >= v0;\n        if (v10) {\n            v9 = v11 = v0 > 0;\n        }\n        if (v9) {\n            v9 = v12 = stor_a <= stor_9;\n        }\n        if (!v9) {\n            v13 = v14 = 0;\n            if (stor_d_1_1) {\n                v13 = v14 + varg0 * stor_b / 10000;\n                require(v13 >= v14);\n            }\n            v15 = _balances[msg.sender] + varg0;\n            require(v15 >= _balances[msg.sender]);\n            _balances[msg.sender] = v15;\n            require(v13 <= _balances[stor_9]);\n            _trancheTokens[stor_9] = _balances[stor_9] - v13;\n            require(_balances[_feesAddr] + v13 >= _balances[_feesAddr]);\n            _balances[_feesAddr] = _balances[_feesAddr] + v13;\n            if (stor_d_4_4) {\n                require(_trancheOneBalances[_feesAddr] + v13 >= _trancheOneBalances[_feesAddr]);\n                _trancheOneBalances[_feesAddr] = _trancheOneBalances[_feesAddr] + v13;\n            }\n            emit Transfer(address(this), msg.sender, varg0);\n            emit Transfer(address(this), _feesAddr, v13);\n            stor_a = 0;\n        } else {\n            require(v0 <= _trancheTokens[_trancheLevel]);\n            _trancheTokens[_trancheLevel] = _trancheTokens[_trancheLevel] - v0;\n            v16 = varg0 + v0;\n            require(v16 >= varg0);\n            require(_circulatingSupply + v0 >= _circulatingSupply);\n            _circulatingSupply = _circulatingSupply + v0;\n            if (_trancheLevel == 1) {\n                require(_trancheOneBalances[msg.sender] + v16 >= _trancheOneBalances[msg.sender]);\n                _trancheOneBalances[msg.sender] = _trancheOneBalances[msg.sender] + v16;\n            }\n            0xbd1(v16, 0);\n        }\n    } else {\n        v17 = _SafeMul(0xde0b6b3a7640000, _trancheTokens[_trancheLevel]);\n        assert(_trancheRate[_trancheLevel]);\n        require(v17 / _trancheRate[_trancheLevel] <= varg1);\n        v18 = varg0 + _trancheTokens[_trancheLevel];\n        require(v18 >= varg0);\n        if (_trancheLevel == 1) {\n            require(_trancheOneBalances[msg.sender] + _trancheTokens[_trancheLevel] >= _trancheOneBalances[msg.sender]);\n            _trancheOneBalances[msg.sender] = _trancheOneBalances[msg.sender] + _trancheTokens[_trancheLevel];\n        }\n        require(_circulatingSupply + v0 >= _circulatingSupply);\n        _circulatingSupply = _circulatingSupply + v0;\n        _trancheTokens[_trancheLevel] = 0;\n        _trancheLevel += 1;\n        if (_trancheLevel == 2) {\n            stor_d_4_4 = 0;\n        }\n        0xbd1(v18, varg1 - v17 / _trancheRate[_trancheLevel]);\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xe58cac == function_selector) {\n            trancheLevel();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc18e1c9 == function_selector) {\n            balanceInSpecificTranche(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1b4d18c1 == function_selector) {\n            rateOfSpecificTranche(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4185f8eb == function_selector) {\n            receiveEth();\n        } else if (0x478fe603 == function_selector) {\n            trancheRate(uint256);\n        } else if (0x4b3db03f == function_selector) {\n            trancheOneBalances(address);\n        } else if (0x4bf768f3 == function_selector) {\n            updateTrancheRate(uint256,uint256);\n        } else if (0x4c46e52c == function_selector) {\n            trancheOneBalanceOf(address);\n        } else if (0x626ebe39 == function_selector) {\n            toggleReceiveEth();\n        } else if (0x64ba7150 == function_selector) {\n            feesAddr();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7b056e67 == function_selector) {\n            initialTranches();\n        } else if (0x86a4012d == function_selector) {\n            trancheOneSaleOpenTime();\n        } else if (0x8b294960 == function_selector) {\n            balanceInTranche();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8ed0ac8b == function_selector) {\n            closeTrancheAddition();\n        } else if (0x9358928b == function_selector) {\n            circulatingSupply();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ea55bb0 == function_selector) {\n            updateFeeAmount(uint256);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb60b3c59 == function_selector) {\n            otcPurchaseAndEscrow(uint256,address);\n        } else if (0xc42edd61 == function_selector) {\n            payFeesToggle();\n        } else if (0xd0c32dd3 == function_selector) {\n            otcPurchase(uint256,address);\n        } else if (0xd34dd1f0 == function_selector) {\n            safeWithdrawal(address,uint256);\n        } else if (0xd6c3453c == function_selector) {\n            addTrancheRateAndTokens(uint256,uint256,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe2df0463 == function_selector) {\n            changeTrancheAdmin(address);\n        } else if (0xf9497eed == function_selector) {\n            trancheTokens(uint256);\n        } else if (0xfeec7680 == function_selector) {\n            changeFeesAddress(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 09:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 _trancheLevel; // STORAGE[0x7]\nuint256 _circulatingSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 _trancheOneSaleOpenTime; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _trancheOneBalances; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _trancheTokens; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _trancheRate; // STORAGE[0x12]\nuint8 _decimals; // STORAGE[0x1] bytes 0 to 0\nuint8 _fallback; // STORAGE[0xd] bytes 0 to 0\nuint8 stor_d_1_1; // STORAGE[0xd] bytes 1 to 1\nuint8 stor_d_2_2; // STORAGE[0xd] bytes 2 to 2\nuint8 _initialTranches; // STORAGE[0xd] bytes 3 to 3\nuint8 stor_d_4_4; // STORAGE[0xd] bytes 4 to 4\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint160 _feesAddr; // STORAGE[0x4] bytes 0 to 19\naddress owner_5_0_19; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.value > 0;\n    if (v1) {\n        v0 = v2 = _fallback;\n    }\n    require(v0);\n    0xbd1(0, msg.value);\n}\n\nfunction trancheLevel() public nonPayable { \n    return _trancheLevel;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction balanceInSpecificTranche(uint256 varg0) public nonPayable { \n    return _trancheTokens[varg0];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction rateOfSpecificTranche(uint256 varg0) public nonPayable { \n    return _trancheRate[varg0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_balances[varg0] >= varg2);\n    require(varg2 <= _balances[varg0]);\n    _balances[varg0] = _balances[varg0] - varg2;\n    require(varg2 <= _balances[msg.sender]);\n    _allowance[msg.sender] = _balances[msg.sender] - varg2;\n    require(_balances[varg1] + varg2 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction receiveEth() public nonPayable { \n    return _fallback;\n}\n\nfunction trancheRate(uint256 varg0) public nonPayable { \n    return _trancheRate[varg0];\n}\n\nfunction trancheOneBalances(address varg0) public nonPayable { \n    return _trancheOneBalances[varg0];\n}\n\nfunction updateTrancheRate(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    require(v0);\n    _trancheRate[varg0] = varg1;\n}\n\nfunction trancheOneBalanceOf(address varg0) public nonPayable { \n    return _trancheOneBalances[varg0];\n}\n\nfunction toggleReceiveEth() public nonPayable { \n    require(msg.sender == _owner);\n    if (_fallback != 1) {\n        _fallback = 1;\n    } else {\n        _fallback = 0;\n    }\n}\n\nfunction feesAddr() public nonPayable { \n    return _feesAddr;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction initialTranches() public nonPayable { \n    return _initialTranches;\n}\n\nfunction trancheOneSaleOpenTime() public nonPayable { \n    return _trancheOneSaleOpenTime;\n}\n\nfunction balanceInTranche() public nonPayable { \n    return _trancheTokens[_trancheLevel];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction closeTrancheAddition() public nonPayable { \n    require(msg.sender == _owner);\n    stor_d_2_2 = 0;\n}\n\nfunction circulatingSupply() public nonPayable { \n    return _circulatingSupply;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateFeeAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = varg0 >= 0;\n    if (v1) {\n        v0 = v2 = varg0 <= 100;\n    }\n    require(v0);\n    stor_b = varg0 * 100;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (block.timestamp < _trancheOneSaleOpenTime) {\n            require(_balances[msg.sender] <= _balances[msg.sender]);\n            require(varg1 <= _balances[msg.sender] - _balances[msg.sender]);\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n    } else {\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        require(varg1 <= _circulatingSupply);\n        _circulatingSupply = _circulatingSupply - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction otcPurchaseAndEscrow(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balances[varg1] + varg0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg0;\n    require(_balances[msg.sender] + varg0 >= _balances[msg.sender]);\n    _trancheOneBalances[msg.sender] = _balances[msg.sender] + varg0;\n    emit Transfer(address(this), varg1, varg0);\n}\n\nfunction payFeesToggle() public nonPayable { \n    require(msg.sender == _owner);\n    if (!stor_d_1_1) {\n        stor_d_1_1 = 1;\n    } else {\n        stor_d_1_1 = 0;\n    }\n}\n\nfunction otcPurchase(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balances[varg1] + varg0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg0;\n    emit Transfer(address(this), varg1, varg0);\n}\n\nfunction safeWithdrawal(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg1 <= (address(this)).balance);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction addTrancheRateAndTokens(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    if (v0) {\n        v0 = v3 = stor_d_2_2 == 1;\n    }\n    require(v0);\n    require(varg1 + _circulatingSupply >= varg1);\n    require(varg1 + _circulatingSupply <= _totalSupply);\n    _trancheTokens[varg0] = varg1;\n    _trancheTokens[varg0] = varg2;\n    stor_9 += 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction changeTrancheAdmin(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    require(v0);\n    owner_5_0_19 = varg0;\n}\n\nfunction trancheTokens(uint256 varg0) public nonPayable { \n    return _trancheTokens[varg0];\n}\n\nfunction changeFeesAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _feesAddr = varg0;\n}\n\nfunction 0xbd1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    stor_a += 1;\n    v2 = v3 = _trancheLevel <= stor_9;\n    if (v3) {\n        v2 = v4 = stor_a <= stor_9;\n    }\n    if (v2) {\n        v5 = _SafeMul(_trancheRate[_trancheLevel], varg1);\n        assert(0xde0b6b3a7640000);\n        v0 = v5 / 0xde0b6b3a7640000;\n    }\n    v6 = v7 = v0 >= _trancheTokens[_trancheLevel];\n    if (v7) {\n        v6 = v8 = stor_a <= stor_9;\n    }\n    if (!v6) {\n        v9 = v10 = _trancheTokens[_trancheLevel] >= v0;\n        if (v10) {\n            v9 = v11 = v0 > 0;\n        }\n        if (v9) {\n            v9 = v12 = stor_a <= stor_9;\n        }\n        if (!v9) {\n            v13 = v14 = 0;\n            if (stor_d_1_1) {\n                v13 = v14 + varg0 * stor_b / 10000;\n                require(v13 >= v14);\n            }\n            v15 = _balances[msg.sender] + varg0;\n            require(v15 >= _balances[msg.sender]);\n            _balances[msg.sender] = v15;\n            require(v13 <= _balances[stor_9]);\n            _trancheTokens[stor_9] = _balances[stor_9] - v13;\n            require(_balances[_feesAddr] + v13 >= _balances[_feesAddr]);\n            _balances[_feesAddr] = _balances[_feesAddr] + v13;\n            if (stor_d_4_4) {\n                require(_trancheOneBalances[_feesAddr] + v13 >= _trancheOneBalances[_feesAddr]);\n                _trancheOneBalances[_feesAddr] = _trancheOneBalances[_feesAddr] + v13;\n            }\n            emit Transfer(address(this), msg.sender, varg0);\n            emit Transfer(address(this), _feesAddr, v13);\n            stor_a = 0;\n        } else {\n            require(v0 <= _trancheTokens[_trancheLevel]);\n            _trancheTokens[_trancheLevel] = _trancheTokens[_trancheLevel] - v0;\n            v16 = varg0 + v0;\n            require(v16 >= varg0);\n            require(_circulatingSupply + v0 >= _circulatingSupply);\n            _circulatingSupply = _circulatingSupply + v0;\n            if (_trancheLevel == 1) {\n                require(_trancheOneBalances[msg.sender] + v16 >= _trancheOneBalances[msg.sender]);\n                _trancheOneBalances[msg.sender] = _trancheOneBalances[msg.sender] + v16;\n            }\n            0xbd1(v16, 0);\n        }\n    } else {\n        v17 = _SafeMul(0xde0b6b3a7640000, _trancheTokens[_trancheLevel]);\n        assert(_trancheRate[_trancheLevel]);\n        require(v17 / _trancheRate[_trancheLevel] <= varg1);\n        v18 = varg0 + _trancheTokens[_trancheLevel];\n        require(v18 >= varg0);\n        if (_trancheLevel == 1) {\n            require(_trancheOneBalances[msg.sender] + _trancheTokens[_trancheLevel] >= _trancheOneBalances[msg.sender]);\n            _trancheOneBalances[msg.sender] = _trancheOneBalances[msg.sender] + _trancheTokens[_trancheLevel];\n        }\n        require(_circulatingSupply + v0 >= _circulatingSupply);\n        _circulatingSupply = _circulatingSupply + v0;\n        _trancheTokens[_trancheLevel] = 0;\n        _trancheLevel += 1;\n        if (_trancheLevel == 2) {\n            stor_d_4_4 = 0;\n        }\n        0xbd1(v18, varg1 - v17 / _trancheRate[_trancheLevel]);\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xe58cac == function_selector) {\n            trancheLevel();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc18e1c9 == function_selector) {\n            balanceInSpecificTranche(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1b4d18c1 == function_selector) {\n            rateOfSpecificTranche(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4185f8eb == function_selector) {\n            receiveEth();\n        } else if (0x478fe603 == function_selector) {\n            trancheRate(uint256);\n        } else if (0x4b3db03f == function_selector) {\n            trancheOneBalances(address);\n        } else if (0x4bf768f3 == function_selector) {\n            updateTrancheRate(uint256,uint256);\n        } else if (0x4c46e52c == function_selector) {\n            trancheOneBalanceOf(address);\n        } else if (0x626ebe39 == function_selector) {\n            toggleReceiveEth();\n        } else if (0x64ba7150 == function_selector) {\n            feesAddr();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7b056e67 == function_selector) {\n            initialTranches();\n        } else if (0x86a4012d == function_selector) {\n            trancheOneSaleOpenTime();\n        } else if (0x8b294960 == function_selector) {\n            balanceInTranche();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8ed0ac8b == function_selector) {\n            closeTrancheAddition();\n        } else if (0x9358928b == function_selector) {\n            circulatingSupply();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ea55bb0 == function_selector) {\n            updateFeeAmount(uint256);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb60b3c59 == function_selector) {\n            otcPurchaseAndEscrow(uint256,address);\n        } else if (0xc42edd61 == function_selector) {\n            payFeesToggle();\n        } else if (0xd0c32dd3 == function_selector) {\n            otcPurchase(uint256,address);\n        } else if (0xd34dd1f0 == function_selector) {\n            safeWithdrawal(address,uint256);\n        } else if (0xd6c3453c == function_selector) {\n            addTrancheRateAndTokens(uint256,uint256,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe2df0463 == function_selector) {\n            changeTrancheAdmin(address);\n        } else if (0xf9497eed == function_selector) {\n            trancheTokens(uint256);\n        } else if (0xfeec7680 == function_selector) {\n            changeFeesAddress(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 09:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x6]\nuint256 _trancheLevel; // STORAGE[0x7]\nuint256 _circulatingSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 _trancheOneSaleOpenTime; // STORAGE[0xc]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0xe]\nmapping (uint256 => [uint256]) _trancheOneBalances; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x10]\nmapping (uint256 => [uint256]) _trancheTokens; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _trancheRate; // STORAGE[0x12]\nuint8 _decimals; // STORAGE[0x1] bytes 0 to 0\nuint8 _fallback; // STORAGE[0xd] bytes 0 to 0\nuint8 stor_d_1_1; // STORAGE[0xd] bytes 1 to 1\nuint8 stor_d_2_2; // STORAGE[0xd] bytes 2 to 2\nuint8 _initialTranches; // STORAGE[0xd] bytes 3 to 3\nuint8 stor_d_4_4; // STORAGE[0xd] bytes 4 to 4\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint160 _feesAddr; // STORAGE[0x4] bytes 0 to 19\naddress owner_5_0_19; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction fallback() public payable { \n    v0 = v1 = msg.value > 0;\n    if (v1) {\n        v0 = v2 = _fallback;\n    }\n    require(v0);\n    0xbd1(0, msg.value);\n}\n\nfunction trancheLevel() public nonPayable { \n    return _trancheLevel;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg1 * varg0;\n    v1 = v2 = varg1 == 0;\n    if (varg1 != 0) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    require(v1);\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction balanceInSpecificTranche(uint256 varg0) public nonPayable { \n    return _trancheTokens[varg0];\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction rateOfSpecificTranche(uint256 varg0) public nonPayable { \n    return _trancheRate[varg0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_balances[varg0] >= varg2);\n    require(varg2 <= _balances[varg0]);\n    _balances[varg0] = _balances[varg0] - varg2;\n    require(varg2 <= _balances[msg.sender]);\n    _allowance[msg.sender] = _balances[msg.sender] - varg2;\n    require(_balances[varg1] + varg2 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction receiveEth() public nonPayable { \n    return _fallback;\n}\n\nfunction trancheRate(uint256 varg0) public nonPayable { \n    return _trancheRate[varg0];\n}\n\nfunction trancheOneBalances(address varg0) public nonPayable { \n    return _trancheOneBalances[varg0];\n}\n\nfunction updateTrancheRate(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    require(v0);\n    _trancheRate[varg0] = varg1;\n}\n\nfunction trancheOneBalanceOf(address varg0) public nonPayable { \n    return _trancheOneBalances[varg0];\n}\n\nfunction toggleReceiveEth() public nonPayable { \n    require(msg.sender == _owner);\n    if (_fallback != 1) {\n        _fallback = 1;\n    } else {\n        _fallback = 0;\n    }\n}\n\nfunction feesAddr() public nonPayable { \n    return _feesAddr;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction initialTranches() public nonPayable { \n    return _initialTranches;\n}\n\nfunction trancheOneSaleOpenTime() public nonPayable { \n    return _trancheOneSaleOpenTime;\n}\n\nfunction balanceInTranche() public nonPayable { \n    return _trancheTokens[_trancheLevel];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction closeTrancheAddition() public nonPayable { \n    require(msg.sender == _owner);\n    stor_d_2_2 = 0;\n}\n\nfunction circulatingSupply() public nonPayable { \n    return _circulatingSupply;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction updateFeeAmount(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = varg0 >= 0;\n    if (v1) {\n        v0 = v2 = varg0 <= 100;\n    }\n    require(v0);\n    stor_b = varg0 * 100;\n}\n\nfunction changeOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _owner = varg0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balances[msg.sender] >= varg1);\n    if (varg0 != address(this)) {\n        if (block.timestamp < _trancheOneSaleOpenTime) {\n            require(_balances[msg.sender] <= _balances[msg.sender]);\n            require(varg1 <= _balances[msg.sender] - _balances[msg.sender]);\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        } else {\n            require(varg1 <= _balances[msg.sender]);\n            _balances[msg.sender] = _balances[msg.sender] - varg1;\n            require(_balances[varg0] + varg1 >= _balances[varg0]);\n            _balances[varg0] = _balances[varg0] + varg1;\n            emit Transfer(msg.sender, varg0, varg1);\n        }\n    } else {\n        require(varg1 <= _balances[msg.sender]);\n        _balances[msg.sender] = _balances[msg.sender] - varg1;\n        require(varg1 <= _circulatingSupply);\n        _circulatingSupply = _circulatingSupply - varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n    }\n}\n\nfunction otcPurchaseAndEscrow(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balances[varg1] + varg0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg0;\n    require(_balances[msg.sender] + varg0 >= _balances[msg.sender]);\n    _trancheOneBalances[msg.sender] = _balances[msg.sender] + varg0;\n    emit Transfer(address(this), varg1, varg0);\n}\n\nfunction payFeesToggle() public nonPayable { \n    require(msg.sender == _owner);\n    if (!stor_d_1_1) {\n        stor_d_1_1 = 1;\n    } else {\n        stor_d_1_1 = 0;\n    }\n}\n\nfunction otcPurchase(uint256 varg0, address varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_balances[varg1] + varg0 >= _balances[varg1]);\n    _balances[varg1] = _balances[varg1] + varg0;\n    emit Transfer(address(this), varg1, varg0);\n}\n\nfunction safeWithdrawal(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg1 <= (address(this)).balance);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction addTrancheRateAndTokens(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    if (v0) {\n        v0 = v3 = stor_d_2_2 == 1;\n    }\n    require(v0);\n    require(varg1 + _circulatingSupply >= varg1);\n    require(varg1 + _circulatingSupply <= _totalSupply);\n    _trancheTokens[varg0] = varg1;\n    _trancheTokens[varg0] = varg2;\n    stor_9 += 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction changeTrancheAdmin(address varg0) public nonPayable { \n    v0 = v1 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v2 = msg.sender == owner_5_0_19;\n    }\n    require(v0);\n    owner_5_0_19 = varg0;\n}\n\nfunction trancheTokens(uint256 varg0) public nonPayable { \n    return _trancheTokens[varg0];\n}\n\nfunction changeFeesAddress(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _feesAddr = varg0;\n}\n\nfunction 0xbd1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = 0;\n    stor_a += 1;\n    v2 = v3 = _trancheLevel <= stor_9;\n    if (v3) {\n        v2 = v4 = stor_a <= stor_9;\n    }\n    if (v2) {\n        v5 = _SafeMul(_trancheRate[_trancheLevel], varg1);\n        assert(0xde0b6b3a7640000);\n        v0 = v5 / 0xde0b6b3a7640000;\n    }\n    v6 = v7 = v0 >= _trancheTokens[_trancheLevel];\n    if (v7) {\n        v6 = v8 = stor_a <= stor_9;\n    }\n    if (!v6) {\n        v9 = v10 = _trancheTokens[_trancheLevel] >= v0;\n        if (v10) {\n            v9 = v11 = v0 > 0;\n        }\n        if (v9) {\n            v9 = v12 = stor_a <= stor_9;\n        }\n        if (!v9) {\n            v13 = v14 = 0;\n            if (stor_d_1_1) {\n                v13 = v14 + varg0 * stor_b / 10000;\n                require(v13 >= v14);\n            }\n            v15 = _balances[msg.sender] + varg0;\n            require(v15 >= _balances[msg.sender]);\n            _balances[msg.sender] = v15;\n            require(v13 <= _balances[stor_9]);\n            _trancheTokens[stor_9] = _balances[stor_9] - v13;\n            require(_balances[_feesAddr] + v13 >= _balances[_feesAddr]);\n            _balances[_feesAddr] = _balances[_feesAddr] + v13;\n            if (stor_d_4_4) {\n                require(_trancheOneBalances[_feesAddr] + v13 >= _trancheOneBalances[_feesAddr]);\n                _trancheOneBalances[_feesAddr] = _trancheOneBalances[_feesAddr] + v13;\n            }\n            emit Transfer(address(this), msg.sender, varg0);\n            emit Transfer(address(this), _feesAddr, v13);\n            stor_a = 0;\n        } else {\n            require(v0 <= _trancheTokens[_trancheLevel]);\n            _trancheTokens[_trancheLevel] = _trancheTokens[_trancheLevel] - v0;\n            v16 = varg0 + v0;\n            require(v16 >= varg0);\n            require(_circulatingSupply + v0 >= _circulatingSupply);\n            _circulatingSupply = _circulatingSupply + v0;\n            if (_trancheLevel == 1) {\n                require(_trancheOneBalances[msg.sender] + v16 >= _trancheOneBalances[msg.sender]);\n                _trancheOneBalances[msg.sender] = _trancheOneBalances[msg.sender] + v16;\n            }\n            0xbd1(v16, 0);\n        }\n    } else {\n        v17 = _SafeMul(0xde0b6b3a7640000, _trancheTokens[_trancheLevel]);\n        assert(_trancheRate[_trancheLevel]);\n        require(v17 / _trancheRate[_trancheLevel] <= varg1);\n        v18 = varg0 + _trancheTokens[_trancheLevel];\n        require(v18 >= varg0);\n        if (_trancheLevel == 1) {\n            require(_trancheOneBalances[msg.sender] + _trancheTokens[_trancheLevel] >= _trancheOneBalances[msg.sender]);\n            _trancheOneBalances[msg.sender] = _trancheOneBalances[msg.sender] + _trancheTokens[_trancheLevel];\n        }\n        require(_circulatingSupply + v0 >= _circulatingSupply);\n        _circulatingSupply = _circulatingSupply + v0;\n        _trancheTokens[_trancheLevel] = 0;\n        _trancheLevel += 1;\n        if (_trancheLevel == 2) {\n            stor_d_4_4 = 0;\n        }\n        0xbd1(v18, varg1 - v17 / _trancheRate[_trancheLevel]);\n    }\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xe58cac == function_selector) {\n            trancheLevel();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc18e1c9 == function_selector) {\n            balanceInSpecificTranche(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1b4d18c1 == function_selector) {\n            rateOfSpecificTranche(uint256);\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4185f8eb == function_selector) {\n            receiveEth();\n        } else if (0x478fe603 == function_selector) {\n            trancheRate(uint256);\n        } else if (0x4b3db03f == function_selector) {\n            trancheOneBalances(address);\n        } else if (0x4bf768f3 == function_selector) {\n            updateTrancheRate(uint256,uint256);\n        } else if (0x4c46e52c == function_selector) {\n            trancheOneBalanceOf(address);\n        } else if (0x626ebe39 == function_selector) {\n            toggleReceiveEth();\n        } else if (0x64ba7150 == function_selector) {\n            feesAddr();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7b056e67 == function_selector) {\n            initialTranches();\n        } else if (0x86a4012d == function_selector) {\n            trancheOneSaleOpenTime();\n        } else if (0x8b294960 == function_selector) {\n            balanceInTranche();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8ed0ac8b == function_selector) {\n            closeTrancheAddition();\n        } else if (0x9358928b == function_selector) {\n            circulatingSupply();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9ea55bb0 == function_selector) {\n            updateFeeAmount(uint256);\n        } else if (0xa6f9dae1 == function_selector) {\n            changeOwner(address);\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb60b3c59 == function_selector) {\n            otcPurchaseAndEscrow(uint256,address);\n        } else if (0xc42edd61 == function_selector) {\n            payFeesToggle();\n        } else if (0xd0c32dd3 == function_selector) {\n            otcPurchase(uint256,address);\n        } else if (0xd34dd1f0 == function_selector) {\n            safeWithdrawal(address,uint256);\n        } else if (0xd6c3453c == function_selector) {\n            addTrancheRateAndTokens(uint256,uint256,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe2df0463 == function_selector) {\n            changeTrancheAdmin(address);\n        } else if (0xf9497eed == function_selector) {\n            trancheTokens(uint256);\n        } else if (0xfeec7680 == function_selector) {\n            changeFeesAddress(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 18.289998054504395,
	"usage": {
		"completion_tokens": 504,
		"prompt_tokens": 4910,
		"total_tokens": 5414
	}
}