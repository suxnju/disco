{
	"address": "0x0acbcc45dde258b18c11b16b06bdc64fd91913ac",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity code for the given decompiled code:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract MyContract {\n    uint256 public _withdraw;\n    mapping (uint256 => uint256) public owner_3;\n    uint256 public _totalSupply;\n    uint256 public _totalFunds;\n    uint256 public _currentPrice;\n    uint256 public _countMembers;\n    uint8 public _currentState;\n    address public _owner;\n    uint160 public _newOwner;\n    address public _token;\n    address public _beneficiary;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Transfer(address indexed from, uint256 value);\n\n    function fallback() public payable {\n        require(_currentState <= 3);\n        require(_currentState == 1);\n        require(msg.value > 0);\n        v0 = _SafeMul(0xde0b6b3a7640000, msg.value);\n        require(_currentPrice > 0);\n        \n        if (!(0xff & owner_3[msg.sender])) {\n            require(1 + _countMembers >= _countMembers);\n            _countMembers += 1;\n            owner_3[msg.sender] = 0x1 | ~0xff & owner_3[msg.sender];\n        }\n        require(msg.value + _totalFunds >= _totalFunds);\n        _totalFunds += msg.value;\n    }\n\n    function _SafeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n        return c;\n    }\n\n    // Other functions go here\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        _newOwner = newOwner;\n    }\n\n    function acceptOwnership() public {\n        require(msg.sender == _newOwner);\n        emit OwnershipTransferred(_owner, _newOwner);\n        _owner = _newOwner;\n    }\n\n    function setTokenPrice(uint256 newPrice) public {\n        require(msg.sender == _owner);\n        require(_currentState <= 3);\n        require(_currentState != 2);\n        _currentPrice = newPrice;\n    }\n\n    // More functions based on the decompiled code\n}\n```\n\nPlease note that this is a partial implementation of the contract based on the provided decompiled code. You might need to add the rest of the functions and fill in the logic based on the decompiled code. Also you might need to adjust the Solidity version according to your needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1701460707,
	"id": "chatcmpl-8R3wZJgvXZTVhgo1uihPPEJgtBFNZ",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.14 05:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _withdraw; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalFunds; // STORAGE[0x6]\nuint256 _currentPrice; // STORAGE[0x7]\nuint256 _countMembers; // STORAGE[0x9]\nuint8 _currentState; // STORAGE[0x4] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\nuint160 _newOwner; // STORAGE[0x2] bytes 0 to 19\naddress _token; // STORAGE[0x4] bytes 1 to 20\naddress _beneficiary; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\nTransfer(address, uint256);\n\nfunction fallback() public payable { \n    assert(_currentState <= 3);\n    require(_currentState == 1);\n    require(msg.value);\n    v0 = _SafeMul(0xde0b6b3a7640000, msg.value);\n    assert(_currentPrice);\n    0x8d8(v0 / _currentPrice);\n    if (!(0xff & owner_3[msg.sender])) {\n        assert(1 + _countMembers >= _countMembers);\n        _countMembers += 1;\n        owner_3[msg.sender] = 0x1 | ~0xff & owner_3[msg.sender];\n    }\n    assert(msg.value + _totalFunds >= _totalFunds);\n    _totalFunds += msg.value;\n    0x916(v0 / _currentPrice, msg.sender);\n}\n\nfunction currentState() public nonPayable { \n    assert(_currentState <= 3);\n    return _currentState;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction countMembers() public nonPayable { \n    return _countMembers;\n}\n\nfunction DECIMALS() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_withdraw <= 0);\n    _withdraw = ~0;\n    require(msg.sender == _owner);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = v2 = varg0 <= this.balance;\n    }\n    require(v0);\n    v3 = _beneficiary.call().value(varg0).gas(2300 * !varg0);\n    require(v3); // checks call status, propagates error data on error\n    _withdraw = _withdraw;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return 0xafc6a015291b40248000000;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction sendToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState == 1);\n    v0 = _SafeMul(0xde0b6b3a7640000, varg1);\n    0x8d8(v0);\n    0x916(v0, varg0);\n}\n\nfunction setTokenPriceAsRatio(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    assert(varg0);\n    _currentPrice = 0xde0b6b3a7640000 / varg0;\n}\n\nfunction setState(uint8 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    assert(_currentState <= 3);\n    v0 = v1 = _currentState == 0;\n    if (v1) {\n        assert(varg0 & 0xff <= 3);\n        v0 = v2 = varg0 & 0xff == 1;\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v3 = _currentState == 1;\n        if (v3) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v4 = varg0 & 0xff == 2;\n        }\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v5 = _currentState == 1;\n        if (v5) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v6 = varg0 & 0xff == 3;\n        }\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v7 = _currentState == 3;\n        if (v7) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v8 = varg0 & 0xff == 1;\n        }\n    }\n    require(v0);\n    assert(varg0 & 0xff <= 3);\n    if (varg0 & 0xff == 2) {\n        require(_withdraw <= 0);\n        _withdraw = ~0;\n        require(_token.code.size);\n        v9 = _token.start().gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        _withdraw = _withdraw;\n    }\n    assert(varg0 & 0xff <= 3);\n    _currentState = varg0;\n}\n\nfunction getCountMembers() public nonPayable { \n    return _countMembers;\n}\n\nfunction setTokenPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    _currentPrice = varg0;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalFunds() public nonPayable { \n    return _totalFunds;\n}\n\nfunction currentPrice() public nonPayable { \n    return _currentPrice;\n}\n\nfunction initialize(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState == 0);\n    require(varg0);\n    _token = varg0;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x8d8(uint256 varg0) private { \n    v0 = varg0 + _totalSupply;\n    assert(v0 >= _totalSupply);\n    require(v0 <= 0xafc6a015291b40248000000);\n    return ;\n}\n\nfunction 0x916(uint256 varg0, uint256 varg1) private { \n    require(_withdraw <= 0);\n    _withdraw = ~0;\n    v0 = varg0 + _totalSupply;\n    assert(v0 >= _totalSupply);\n    _totalSupply = v0;\n    v1 = address(varg1);\n    require(_token.code.size);\n    v2 = _token.mint(v1, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    emit Transfer(address(varg1), varg0);\n    _withdraw = _withdraw;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc3f6acf) {\n            currentState();\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x2cd046eb == v0) {\n            countMembers();\n        } else {\n            if (0x2e0f2625 != v0) {\n                if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x32cb6b0c == v0) {\n                    MAX_SUPPLY();\n                } else if (0x38af3eed == v0) {\n                    beneficiary();\n                } else if (0x412664ae == v0) {\n                    sendToken(address,uint256);\n                } else if (0x4f871922 == v0) {\n                    setTokenPriceAsRatio(uint256);\n                } else if (0x56de96db == v0) {\n                    setState(uint8);\n                } else if (0x66b5e2d8 == v0) {\n                    getCountMembers();\n                } else if (0x6a61e5fc == v0) {\n                    setTokenPrice(uint256);\n                } else if (0x79ba5097 == v0) {\n                    acceptOwnership();\n                } else if (0x8da5cb5b == v0) {\n                    owner();\n                } else if (0x968ed600 == v0) {\n                    totalFunds();\n                } else if (0x9d1b464a == v0) {\n                    currentPrice();\n                } else if (0xc4d66de8 == v0) {\n                    initialize(address);\n                } else if (0xd387cad9 != v0) {\n                    if (0xd4ee1d90 == v0) {\n                        newOwner();\n                    } else if (0xf2fde38b == v0) {\n                        transferOwnership(address);\n                    } else if (0xfc0c546a == v0) {\n                        token();\n                    }\n                }\n            }\n            DECIMALS();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 05:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _withdraw; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalFunds; // STORAGE[0x6]\nuint256 _currentPrice; // STORAGE[0x7]\nuint256 _countMembers; // STORAGE[0x9]\nuint8 _currentState; // STORAGE[0x4] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\nuint160 _newOwner; // STORAGE[0x2] bytes 0 to 19\naddress _token; // STORAGE[0x4] bytes 1 to 20\naddress _beneficiary; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\nTransfer(address, uint256);\n\nfunction fallback() public payable { \n    assert(_currentState <= 3);\n    require(_currentState == 1);\n    require(msg.value);\n    v0 = _SafeMul(0xde0b6b3a7640000, msg.value);\n    assert(_currentPrice);\n    0x8d8(v0 / _currentPrice);\n    if (!(0xff & owner_3[msg.sender])) {\n        assert(1 + _countMembers >= _countMembers);\n        _countMembers += 1;\n        owner_3[msg.sender] = 0x1 | ~0xff & owner_3[msg.sender];\n    }\n    assert(msg.value + _totalFunds >= _totalFunds);\n    _totalFunds += msg.value;\n    0x916(v0 / _currentPrice, msg.sender);\n}\n\nfunction currentState() public nonPayable { \n    assert(_currentState <= 3);\n    return _currentState;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction countMembers() public nonPayable { \n    return _countMembers;\n}\n\nfunction DECIMALS() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_withdraw <= 0);\n    _withdraw = ~0;\n    require(msg.sender == _owner);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = v2 = varg0 <= this.balance;\n    }\n    require(v0);\n    v3 = _beneficiary.call().value(varg0).gas(2300 * !varg0);\n    require(v3); // checks call status, propagates error data on error\n    _withdraw = _withdraw;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return 0xafc6a015291b40248000000;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction sendToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState == 1);\n    v0 = _SafeMul(0xde0b6b3a7640000, varg1);\n    0x8d8(v0);\n    0x916(v0, varg0);\n}\n\nfunction setTokenPriceAsRatio(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    assert(varg0);\n    _currentPrice = 0xde0b6b3a7640000 / varg0;\n}\n\nfunction setState(uint8 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    assert(_currentState <= 3);\n    v0 = v1 = _currentState == 0;\n    if (v1) {\n        assert(varg0 & 0xff <= 3);\n        v0 = v2 = varg0 & 0xff == 1;\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v3 = _currentState == 1;\n        if (v3) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v4 = varg0 & 0xff == 2;\n        }\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v5 = _currentState == 1;\n        if (v5) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v6 = varg0 & 0xff == 3;\n        }\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v7 = _currentState == 3;\n        if (v7) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v8 = varg0 & 0xff == 1;\n        }\n    }\n    require(v0);\n    assert(varg0 & 0xff <= 3);\n    if (varg0 & 0xff == 2) {\n        require(_withdraw <= 0);\n        _withdraw = ~0;\n        require(_token.code.size);\n        v9 = _token.start().gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        _withdraw = _withdraw;\n    }\n    assert(varg0 & 0xff <= 3);\n    _currentState = varg0;\n}\n\nfunction getCountMembers() public nonPayable { \n    return _countMembers;\n}\n\nfunction setTokenPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    _currentPrice = varg0;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalFunds() public nonPayable { \n    return _totalFunds;\n}\n\nfunction currentPrice() public nonPayable { \n    return _currentPrice;\n}\n\nfunction initialize(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState == 0);\n    require(varg0);\n    _token = varg0;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x8d8(uint256 varg0) private { \n    v0 = varg0 + _totalSupply;\n    assert(v0 >= _totalSupply);\n    require(v0 <= 0xafc6a015291b40248000000);\n    return ;\n}\n\nfunction 0x916(uint256 varg0, uint256 varg1) private { \n    require(_withdraw <= 0);\n    _withdraw = ~0;\n    v0 = varg0 + _totalSupply;\n    assert(v0 >= _totalSupply);\n    _totalSupply = v0;\n    v1 = address(varg1);\n    require(_token.code.size);\n    v2 = _token.mint(v1, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    emit Transfer(address(varg1), varg0);\n    _withdraw = _withdraw;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc3f6acf) {\n            currentState();\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x2cd046eb == v0) {\n            countMembers();\n        } else {\n            if (0x2e0f2625 != v0) {\n                if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x32cb6b0c == v0) {\n                    MAX_SUPPLY();\n                } else if (0x38af3eed == v0) {\n                    beneficiary();\n                } else if (0x412664ae == v0) {\n                    sendToken(address,uint256);\n                } else if (0x4f871922 == v0) {\n                    setTokenPriceAsRatio(uint256);\n                } else if (0x56de96db == v0) {\n                    setState(uint8);\n                } else if (0x66b5e2d8 == v0) {\n                    getCountMembers();\n                } else if (0x6a61e5fc == v0) {\n                    setTokenPrice(uint256);\n                } else if (0x79ba5097 == v0) {\n                    acceptOwnership();\n                } else if (0x8da5cb5b == v0) {\n                    owner();\n                } else if (0x968ed600 == v0) {\n                    totalFunds();\n                } else if (0x9d1b464a == v0) {\n                    currentPrice();\n                } else if (0xc4d66de8 == v0) {\n                    initialize(address);\n                } else if (0xd387cad9 != v0) {\n                    if (0xd4ee1d90 == v0) {\n                        newOwner();\n                    } else if (0xf2fde38b == v0) {\n                        transferOwnership(address);\n                    } else if (0xfc0c546a == v0) {\n                        token();\n                    }\n                }\n            }\n            DECIMALS();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 05:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _withdraw; // STORAGE[0x0]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalFunds; // STORAGE[0x6]\nuint256 _currentPrice; // STORAGE[0x7]\nuint256 _countMembers; // STORAGE[0x9]\nuint8 _currentState; // STORAGE[0x4] bytes 0 to 0\naddress _owner; // STORAGE[0x1] bytes 0 to 19\nuint160 _newOwner; // STORAGE[0x2] bytes 0 to 19\naddress _token; // STORAGE[0x4] bytes 1 to 20\naddress _beneficiary; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\nTransfer(address, uint256);\n\nfunction fallback() public payable { \n    assert(_currentState <= 3);\n    require(_currentState == 1);\n    require(msg.value);\n    v0 = _SafeMul(0xde0b6b3a7640000, msg.value);\n    assert(_currentPrice);\n    0x8d8(v0 / _currentPrice);\n    if (!(0xff & owner_3[msg.sender])) {\n        assert(1 + _countMembers >= _countMembers);\n        _countMembers += 1;\n        owner_3[msg.sender] = 0x1 | ~0xff & owner_3[msg.sender];\n    }\n    assert(msg.value + _totalFunds >= _totalFunds);\n    _totalFunds += msg.value;\n    0x916(v0 / _currentPrice, msg.sender);\n}\n\nfunction currentState() public nonPayable { \n    assert(_currentState <= 3);\n    return _currentState;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction countMembers() public nonPayable { \n    return _countMembers;\n}\n\nfunction DECIMALS() public nonPayable { \n    return 0xde0b6b3a7640000;\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(_withdraw <= 0);\n    _withdraw = ~0;\n    require(msg.sender == _owner);\n    v0 = v1 = varg0 > 0;\n    if (v1) {\n        v0 = v2 = varg0 <= this.balance;\n    }\n    require(v0);\n    v3 = _beneficiary.call().value(varg0).gas(2300 * !varg0);\n    require(v3); // checks call status, propagates error data on error\n    _withdraw = _withdraw;\n}\n\nfunction MAX_SUPPLY() public nonPayable { \n    return 0xafc6a015291b40248000000;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction sendToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState == 1);\n    v0 = _SafeMul(0xde0b6b3a7640000, varg1);\n    0x8d8(v0);\n    0x916(v0, varg0);\n}\n\nfunction setTokenPriceAsRatio(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    assert(varg0);\n    _currentPrice = 0xde0b6b3a7640000 / varg0;\n}\n\nfunction setState(uint8 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    assert(_currentState <= 3);\n    v0 = v1 = _currentState == 0;\n    if (v1) {\n        assert(varg0 & 0xff <= 3);\n        v0 = v2 = varg0 & 0xff == 1;\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v3 = _currentState == 1;\n        if (v3) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v4 = varg0 & 0xff == 2;\n        }\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v5 = _currentState == 1;\n        if (v5) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v6 = varg0 & 0xff == 3;\n        }\n    }\n    if (!v0) {\n        assert(_currentState <= 3);\n        v0 = v7 = _currentState == 3;\n        if (v7) {\n            assert(varg0 & 0xff <= 3);\n            v0 = v8 = varg0 & 0xff == 1;\n        }\n    }\n    require(v0);\n    assert(varg0 & 0xff <= 3);\n    if (varg0 & 0xff == 2) {\n        require(_withdraw <= 0);\n        _withdraw = ~0;\n        require(_token.code.size);\n        v9 = _token.start().gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        _withdraw = _withdraw;\n    }\n    assert(varg0 & 0xff <= 3);\n    _currentState = varg0;\n}\n\nfunction getCountMembers() public nonPayable { \n    return _countMembers;\n}\n\nfunction setTokenPrice(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState != 2);\n    _currentPrice = varg0;\n}\n\nfunction acceptOwnership() public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnershipTransferred(_owner, _newOwner);\n    _owner = _newOwner;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction totalFunds() public nonPayable { \n    return _totalFunds;\n}\n\nfunction currentPrice() public nonPayable { \n    return _currentPrice;\n}\n\nfunction initialize(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    assert(_currentState <= 3);\n    require(_currentState == 0);\n    require(varg0);\n    _token = varg0;\n}\n\nfunction newOwner() public nonPayable { \n    return _newOwner;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _newOwner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction 0x8d8(uint256 varg0) private { \n    v0 = varg0 + _totalSupply;\n    assert(v0 >= _totalSupply);\n    require(v0 <= 0xafc6a015291b40248000000);\n    return ;\n}\n\nfunction 0x916(uint256 varg0, uint256 varg1) private { \n    require(_withdraw <= 0);\n    _withdraw = ~0;\n    v0 = varg0 + _totalSupply;\n    assert(v0 >= _totalSupply);\n    _totalSupply = v0;\n    v1 = address(varg1);\n    require(_token.code.size);\n    v2 = _token.mint(v1, varg0).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    emit Transfer(address(varg1), varg0);\n    _withdraw = _withdraw;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0xc3f6acf) {\n            currentState();\n        } else if (0x18160ddd == v0) {\n            totalSupply();\n        } else if (0x2cd046eb == v0) {\n            countMembers();\n        } else {\n            if (0x2e0f2625 != v0) {\n                if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x32cb6b0c == v0) {\n                    MAX_SUPPLY();\n                } else if (0x38af3eed == v0) {\n                    beneficiary();\n                } else if (0x412664ae == v0) {\n                    sendToken(address,uint256);\n                } else if (0x4f871922 == v0) {\n                    setTokenPriceAsRatio(uint256);\n                } else if (0x56de96db == v0) {\n                    setState(uint8);\n                } else if (0x66b5e2d8 == v0) {\n                    getCountMembers();\n                } else if (0x6a61e5fc == v0) {\n                    setTokenPrice(uint256);\n                } else if (0x79ba5097 == v0) {\n                    acceptOwnership();\n                } else if (0x8da5cb5b == v0) {\n                    owner();\n                } else if (0x968ed600 == v0) {\n                    totalFunds();\n                } else if (0x9d1b464a == v0) {\n                    currentPrice();\n                } else if (0xc4d66de8 == v0) {\n                    initialize(address);\n                } else if (0xd387cad9 != v0) {\n                    if (0xd4ee1d90 == v0) {\n                        newOwner();\n                    } else if (0xf2fde38b == v0) {\n                        transferOwnership(address);\n                    } else if (0xfc0c546a == v0) {\n                        token();\n                    }\n                }\n            }\n            DECIMALS();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 33.85613203048706,
	"usage": {
		"completion_tokens": 542,
		"prompt_tokens": 2399,
		"total_tokens": 2941
	}
}