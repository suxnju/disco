{
	"address": "0xa9e4e3b1da2462752aea980698c335e70e9ab26c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a simplified Solidity version of the provided decompiled code:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract Contract {\n    \n    uint256 stor_0;\n    uint256 ___function_selector__;\n    uint256 _currentFeePercentage;\n    uint256 _currentMultiplier;\n    uint256 stor_4;\n    address payable _changeFeePercentage;\n    uint256[] _totalParticipants;\n    \n    function feesSeperateFromBalanceApproximately() public payable returns (uint256) { \n        return ___function_selector__ / 0xde0b6b3a7640000;\n    }\n\n    function collectPercentOfFees(uint256 _pcent) public payable {\n        require(msg.sender == _changeFeePercentage, \"Not authorized\");\n        require(_pcent <= 100, \"Percentage cannot be more than 100\");\n        _changeFeePercentage.transfer(_pcent * (___function_selector__ / 100));\n        ___function_selector__ = ___function_selector__ - _pcent * (___function_selector__ / 100);\n    }\n\n    function collectAllFees() public payable {\n        require(msg.sender == _changeFeePercentage, \"Not authorized\");\n        _changeFeePercentage.transfer(___function_selector__);\n        ___function_selector__ = 0;\n    }\n\n    function currentMultiplier() public view returns (uint256) {\n        return _currentMultiplier;\n    }\n\n    function currentFeePercentage() public view returns (uint256) {\n        return _currentFeePercentage;\n    }\n\n    function participantDetails(uint256 varg0) public view returns (uint256, uint256) { \n        require(varg0 < _totalParticipants.length, \"Invalid index\");\n        return (0, 0);\n    }\n\n    function totalParticipants() public view returns (uint256) {\n        return _totalParticipants.length;\n    }\n\n    function changeOwner(address payable varg0) public payable { \n        require(msg.sender == _changeFeePercentage, \"Not authorized\");\n        _changeFeePercentage = varg0;\n    }\n\n    function collectFeesInEther(uint256 _amt) public payable { \n        require(msg.sender == _changeFeePercentage, \"Not authorized\");\n        _changeFeePercentage.transfer(0xde0b6b3a7640000 * _amt);\n        ___function_selector__ = ___function_selector__ - 0xde0b6b3a7640000 * _amt;\n    }\n\n    function changeMultiplier(uint256 _mult) public payable { \n        require(msg.sender == _changeFeePercentage, \"Not authorized\");\n        require(_mult >= 120 && _mult <= 300, \"Multiplier out of bounds\");\n        _currentMultiplier = _mult;\n    }\n\n    function numberOfParticipantsWaitingForPayout() public view returns (uint256) { \n        return _totalParticipants.length - stor_4;\n    }\n\n    function changeFeePercentage(uint256 varg0) public payable { \n        require(msg.sender == _changeFeePercentage, \"Not authorized\");\n        require(varg0 <= 10, \"Fee percentage cannot be more than 10\");\n        _currentFeePercentage = varg0;\n    }\n\n    function currentPyramidBalanceApproximately() public view returns (uint256) { \n        return stor_0 / 0xde0b6b3a7640000;\n    }\n}\n```\n\nNote: The original decompiled code has several pseudocode-like elements that do not have direct equivalents in Solidity (e.g., \"goto\", \"exit\", \"throw()\", etc.). I've attempted to translate these into their likely Solidity counterparts (e.g., \"require\" for checks, \"transfer\" for sending ETH, etc.). However, without further context of the original contract's behavior, this is a best-effort conversion.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040019,
	"id": "chatcmpl-8Ci4B6ncHl7pADvGfktV3qzA9uHcX",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.07.03 23:00 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 ___function_selector__; // STORAGE[0x1]\nuint256 _currentFeePercentage; // STORAGE[0x2]\nuint256 _currentMultiplier; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 _changeFeePercentage; // STORAGE[0x5]\nuint256[] _totalParticipants; // STORAGE[0x6]\n\n\nfunction feesSeperateFromBalanceApproximately() public payable { \n    return ___function_selector__ / 0xde0b6b3a7640000;\n}\n\nfunction collectPercentOfFees(uint256 _pcent) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        v0 = v1 = 0 == ___function_selector__;\n        if (0 != ___function_selector__) {\n            v0 = v2 = _pcent > 100;\n        }\n        assert(!v0);\n        v3 = address(_changeFeePercentage).call().value(_pcent * (___function_selector__ / 100));\n        ___function_selector__ = ___function_selector__ - _pcent * (___function_selector__ / 100);\n    }\n}\n\nfunction nextPayoutWhenPyramidBalanceTotalsApproximately() public payable { \n    throw();\n}\n\nfunction collectAllFees() public payable { \n    if (msg.sender != address(_changeFeePercentage)) {\n        goto 0x3b40x1ac;\n    } else {\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(___function_selector__);\n        ___function_selector__ = 0;\n    }\n}\n\nfunction 0x1b0() private { \n    if (msg.sender != address(_changeFeePercentage)) {\n        return ;\n    } else {\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(___function_selector__);\n        ___function_selector__ = 0;\n        return ;\n    }\n}\n\nfunction currentMultiplier() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = _currentMultiplier;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (31) {\n        MEM[v3 - 31] = ~0xff & MEM[v3 - 31];\n    }\n    return _currentMultiplier, v0;\n}\n\nfunction currentFeePercentage() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = _currentFeePercentage;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (4) {\n        MEM[v3 - 4] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v3 - 4];\n    }\n    return _currentFeePercentage, v0;\n}\n\nfunction participantDetails(uint256 varg0) public payable { \n    assert(varg0 > _totalParticipants.length);\n    return 0, 0;\n}\n\nfunction totalParticipants() public payable { \n    return _totalParticipants.length;\n}\n\nfunction changeOwner(address varg0) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        _changeFeePercentage = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _changeFeePercentage;\n        goto 0x3b40x2d3;\n    }\n}\n\nfunction collectFeesInEther(uint256 _amt) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        if (0xde0b6b3a7640000 * _amt > ___function_selector__) {\n            0x1b0();\n        }\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(0xde0b6b3a7640000 * _amt);\n        ___function_selector__ = ___function_selector__ - 0xde0b6b3a7640000 * _amt;\n    }\n}\n\nfunction changeMultiplier(uint256 _mult) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        v0 = v1 = _mult > 300;\n        if (_mult <= 300) {\n            v0 = v2 = _mult < 120;\n        }\n        assert(!v0);\n        _currentMultiplier = _mult;\n    }\n}\n\nfunction numberOfParticipantsWaitingForPayout() public payable { \n    return _totalParticipants.length - stor_4;\n}\n\nfunction changeFeePercentage(uint256 varg0) public payable { \n    if (address(_changeFeePercentage) == msg.sender) {\n        assert(varg0 <= 10);\n        _currentFeePercentage = varg0;\n    }\n}\n\nfunction currentPyramidBalanceApproximately() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = stor_0 / 0xde0b6b3a7640000;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (10) {\n        MEM[v3 - 10] = ~0xffffffffffffffffffffffffffffffffffffffffffff & MEM[v3 - 10];\n    }\n    return stor_0 / 0xde0b6b3a7640000, v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x9dfdc71) {\n            0x09dfdc71();\n        } else if (0x253459e3 == function_selector >> 224) {\n            0x253459e3();\n        } else if (0x4229616d == function_selector >> 224) {\n            0x4229616d();\n        } else if (0x57d4021b == function_selector >> 224) {\n            0x57d4021b();\n        } else if (0x686f2c90 == function_selector >> 224) {\n            collectAllFees();\n        } else if (0x6fbaaa1e == function_selector >> 224) {\n            currentMultiplier();\n        } else if (0x8a5fb3ca == function_selector >> 224) {\n            currentFeePercentage();\n        } else if (0x9dbc4f9b == function_selector >> 224) {\n            participantDetails(uint256);\n        } else if (0xa26dbf26 == function_selector >> 224) {\n            totalParticipants();\n        } else if (0xa6f9dae1 == function_selector >> 224) {\n            changeOwner(address);\n        } else if (0xb4022950 == function_selector >> 224) {\n            0xb4022950();\n        } else if (0xced92670 == function_selector >> 224) {\n            0xced92670();\n        } else if (0xd11f13df == function_selector >> 224) {\n            numberOfParticipantsWaitingForPayout();\n        } else if (0xfae14192 == function_selector >> 224) {\n            changeFeePercentage(uint256);\n        }\n    }\n    if (msg.value >= 0xde0b6b3a7640000) {\n        v0 = v1 = _currentFeePercentage;\n        if (msg.value >= 0x2b5e3af16b1880000) {\n            v0 = v2 = v1 >> 1;\n        }\n        _totalParticipants.length += 1;\n        if (!_totalParticipants.length <= 1 + _totalParticipants.length) {\n            v3 = v4 = keccak256(6) + (1 + _totalParticipants.length << 1);\n            while (keccak256(6) + (_totalParticipants.length << 1) > v3) {\n                STORAGE[v3] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v3];\n                v3 += 1;\n                STORAGE[v3] = 0;\n            }\n        }\n        MEM[64] += 64;\n        MEM[MEM[64]] = msg.sender;\n        MEM[32 + MEM[64]] = msg.value * _currentMultiplier / 100;\n        _totalParticipants[_totalParticipants.length << 1] = ~0xffffffffffffffffffffffffffffffffffffffff & _totalParticipants[_totalParticipants.length << 1] | msg.sender;\n        STORAGE[1 + ((_totalParticipants.length << 1) + keccak256(6))] = msg.value * _currentMultiplier / 100;\n        if (10 != _totalParticipants.length) {\n            if (25 == _totalParticipants.length) {\n                _currentMultiplier = 150;\n            }\n        } else {\n            _currentMultiplier = 200;\n        }\n        stor_0 = stor_0 + msg.value * (100 - v0) / 100;\n        ___function_selector__ += v0 * msg.value / 100;\n        throw();\n    } else {\n        ___function_selector__ += msg.value;\n        exit;\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.07.03 23:00 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 ___function_selector__; // STORAGE[0x1]\nuint256 _currentFeePercentage; // STORAGE[0x2]\nuint256 _currentMultiplier; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 _changeFeePercentage; // STORAGE[0x5]\nuint256[] _totalParticipants; // STORAGE[0x6]\n\n\nfunction feesSeperateFromBalanceApproximately() public payable { \n    return ___function_selector__ / 0xde0b6b3a7640000;\n}\n\nfunction collectPercentOfFees(uint256 _pcent) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        v0 = v1 = 0 == ___function_selector__;\n        if (0 != ___function_selector__) {\n            v0 = v2 = _pcent > 100;\n        }\n        assert(!v0);\n        v3 = address(_changeFeePercentage).call().value(_pcent * (___function_selector__ / 100));\n        ___function_selector__ = ___function_selector__ - _pcent * (___function_selector__ / 100);\n    }\n}\n\nfunction nextPayoutWhenPyramidBalanceTotalsApproximately() public payable { \n    throw();\n}\n\nfunction collectAllFees() public payable { \n    if (msg.sender != address(_changeFeePercentage)) {\n        goto 0x3b40x1ac;\n    } else {\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(___function_selector__);\n        ___function_selector__ = 0;\n    }\n}\n\nfunction 0x1b0() private { \n    if (msg.sender != address(_changeFeePercentage)) {\n        return ;\n    } else {\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(___function_selector__);\n        ___function_selector__ = 0;\n        return ;\n    }\n}\n\nfunction currentMultiplier() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = _currentMultiplier;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (31) {\n        MEM[v3 - 31] = ~0xff & MEM[v3 - 31];\n    }\n    return _currentMultiplier, v0;\n}\n\nfunction currentFeePercentage() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = _currentFeePercentage;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (4) {\n        MEM[v3 - 4] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v3 - 4];\n    }\n    return _currentFeePercentage, v0;\n}\n\nfunction participantDetails(uint256 varg0) public payable { \n    assert(varg0 > _totalParticipants.length);\n    return 0, 0;\n}\n\nfunction totalParticipants() public payable { \n    return _totalParticipants.length;\n}\n\nfunction changeOwner(address varg0) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        _changeFeePercentage = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _changeFeePercentage;\n        goto 0x3b40x2d3;\n    }\n}\n\nfunction collectFeesInEther(uint256 _amt) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        if (0xde0b6b3a7640000 * _amt > ___function_selector__) {\n            0x1b0();\n        }\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(0xde0b6b3a7640000 * _amt);\n        ___function_selector__ = ___function_selector__ - 0xde0b6b3a7640000 * _amt;\n    }\n}\n\nfunction changeMultiplier(uint256 _mult) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        v0 = v1 = _mult > 300;\n        if (_mult <= 300) {\n            v0 = v2 = _mult < 120;\n        }\n        assert(!v0);\n        _currentMultiplier = _mult;\n    }\n}\n\nfunction numberOfParticipantsWaitingForPayout() public payable { \n    return _totalParticipants.length - stor_4;\n}\n\nfunction changeFeePercentage(uint256 varg0) public payable { \n    if (address(_changeFeePercentage) == msg.sender) {\n        assert(varg0 <= 10);\n        _currentFeePercentage = varg0;\n    }\n}\n\nfunction currentPyramidBalanceApproximately() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = stor_0 / 0xde0b6b3a7640000;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (10) {\n        MEM[v3 - 10] = ~0xffffffffffffffffffffffffffffffffffffffffffff & MEM[v3 - 10];\n    }\n    return stor_0 / 0xde0b6b3a7640000, v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x9dfdc71) {\n            0x09dfdc71();\n        } else if (0x253459e3 == function_selector >> 224) {\n            0x253459e3();\n        } else if (0x4229616d == function_selector >> 224) {\n            0x4229616d();\n        } else if (0x57d4021b == function_selector >> 224) {\n            0x57d4021b();\n        } else if (0x686f2c90 == function_selector >> 224) {\n            collectAllFees();\n        } else if (0x6fbaaa1e == function_selector >> 224) {\n            currentMultiplier();\n        } else if (0x8a5fb3ca == function_selector >> 224) {\n            currentFeePercentage();\n        } else if (0x9dbc4f9b == function_selector >> 224) {\n            participantDetails(uint256);\n        } else if (0xa26dbf26 == function_selector >> 224) {\n            totalParticipants();\n        } else if (0xa6f9dae1 == function_selector >> 224) {\n            changeOwner(address);\n        } else if (0xb4022950 == function_selector >> 224) {\n            0xb4022950();\n        } else if (0xced92670 == function_selector >> 224) {\n            0xced92670();\n        } else if (0xd11f13df == function_selector >> 224) {\n            numberOfParticipantsWaitingForPayout();\n        } else if (0xfae14192 == function_selector >> 224) {\n            changeFeePercentage(uint256);\n        }\n    }\n    if (msg.value >= 0xde0b6b3a7640000) {\n        v0 = v1 = _currentFeePercentage;\n        if (msg.value >= 0x2b5e3af16b1880000) {\n            v0 = v2 = v1 >> 1;\n        }\n        _totalParticipants.length += 1;\n        if (!_totalParticipants.length <= 1 + _totalParticipants.length) {\n            v3 = v4 = keccak256(6) + (1 + _totalParticipants.length << 1);\n            while (keccak256(6) + (_totalParticipants.length << 1) > v3) {\n                STORAGE[v3] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v3];\n                v3 += 1;\n                STORAGE[v3] = 0;\n            }\n        }\n        MEM[64] += 64;\n        MEM[MEM[64]] = msg.sender;\n        MEM[32 + MEM[64]] = msg.value * _currentMultiplier / 100;\n        _totalParticipants[_totalParticipants.length << 1] = ~0xffffffffffffffffffffffffffffffffffffffff & _totalParticipants[_totalParticipants.length << 1] | msg.sender;\n        STORAGE[1 + ((_totalParticipants.length << 1) + keccak256(6))] = msg.value * _currentMultiplier / 100;\n        if (10 != _totalParticipants.length) {\n            if (25 == _totalParticipants.length) {\n                _currentMultiplier = 150;\n            }\n        } else {\n            _currentMultiplier = 200;\n        }\n        stor_0 = stor_0 + msg.value * (100 - v0) / 100;\n        ___function_selector__ += v0 * msg.value / 100;\n        throw();\n    } else {\n        ___function_selector__ += msg.value;\n        exit;\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.07.03 23:00 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_0; // STORAGE[0x0]\nuint256 ___function_selector__; // STORAGE[0x1]\nuint256 _currentFeePercentage; // STORAGE[0x2]\nuint256 _currentMultiplier; // STORAGE[0x3]\nuint256 stor_4; // STORAGE[0x4]\nuint256 _changeFeePercentage; // STORAGE[0x5]\nuint256[] _totalParticipants; // STORAGE[0x6]\n\n\nfunction feesSeperateFromBalanceApproximately() public payable { \n    return ___function_selector__ / 0xde0b6b3a7640000;\n}\n\nfunction collectPercentOfFees(uint256 _pcent) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        v0 = v1 = 0 == ___function_selector__;\n        if (0 != ___function_selector__) {\n            v0 = v2 = _pcent > 100;\n        }\n        assert(!v0);\n        v3 = address(_changeFeePercentage).call().value(_pcent * (___function_selector__ / 100));\n        ___function_selector__ = ___function_selector__ - _pcent * (___function_selector__ / 100);\n    }\n}\n\nfunction nextPayoutWhenPyramidBalanceTotalsApproximately() public payable { \n    throw();\n}\n\nfunction collectAllFees() public payable { \n    if (msg.sender != address(_changeFeePercentage)) {\n        goto 0x3b40x1ac;\n    } else {\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(___function_selector__);\n        ___function_selector__ = 0;\n    }\n}\n\nfunction 0x1b0() private { \n    if (msg.sender != address(_changeFeePercentage)) {\n        return ;\n    } else {\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(___function_selector__);\n        ___function_selector__ = 0;\n        return ;\n    }\n}\n\nfunction currentMultiplier() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = _currentMultiplier;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (31) {\n        MEM[v3 - 31] = ~0xff & MEM[v3 - 31];\n    }\n    return _currentMultiplier, v0;\n}\n\nfunction currentFeePercentage() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = _currentFeePercentage;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (4) {\n        MEM[v3 - 4] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v3 - 4];\n    }\n    return _currentFeePercentage, v0;\n}\n\nfunction participantDetails(uint256 varg0) public payable { \n    assert(varg0 > _totalParticipants.length);\n    return 0, 0;\n}\n\nfunction totalParticipants() public payable { \n    return _totalParticipants.length;\n}\n\nfunction changeOwner(address varg0) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        _changeFeePercentage = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _changeFeePercentage;\n        goto 0x3b40x2d3;\n    }\n}\n\nfunction collectFeesInEther(uint256 _amt) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        if (0xde0b6b3a7640000 * _amt > ___function_selector__) {\n            0x1b0();\n        }\n        assert(0 != ___function_selector__);\n        v0 = address(_changeFeePercentage).call().value(0xde0b6b3a7640000 * _amt);\n        ___function_selector__ = ___function_selector__ - 0xde0b6b3a7640000 * _amt;\n    }\n}\n\nfunction changeMultiplier(uint256 _mult) public payable { \n    if (msg.sender == address(_changeFeePercentage)) {\n        v0 = v1 = _mult > 300;\n        if (_mult <= 300) {\n            v0 = v2 = _mult < 120;\n        }\n        assert(!v0);\n        _currentMultiplier = _mult;\n    }\n}\n\nfunction numberOfParticipantsWaitingForPayout() public payable { \n    return _totalParticipants.length - stor_4;\n}\n\nfunction changeFeePercentage(uint256 varg0) public payable { \n    if (address(_changeFeePercentage) == msg.sender) {\n        assert(varg0 <= 10);\n        _currentFeePercentage = varg0;\n    }\n}\n\nfunction currentPyramidBalanceApproximately() public payable { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = stor_0 / 0xde0b6b3a7640000;\n    v0 = new array[](v1.length);\n    v2 = v3 = v1.length + v0.data;\n    if (10) {\n        MEM[v3 - 10] = ~0xffffffffffffffffffffffffffffffffffffffffffff & MEM[v3 - 10];\n    }\n    return stor_0 / 0xde0b6b3a7640000, v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x9dfdc71) {\n            0x09dfdc71();\n        } else if (0x253459e3 == function_selector >> 224) {\n            0x253459e3();\n        } else if (0x4229616d == function_selector >> 224) {\n            0x4229616d();\n        } else if (0x57d4021b == function_selector >> 224) {\n            0x57d4021b();\n        } else if (0x686f2c90 == function_selector >> 224) {\n            collectAllFees();\n        } else if (0x6fbaaa1e == function_selector >> 224) {\n            currentMultiplier();\n        } else if (0x8a5fb3ca == function_selector >> 224) {\n            currentFeePercentage();\n        } else if (0x9dbc4f9b == function_selector >> 224) {\n            participantDetails(uint256);\n        } else if (0xa26dbf26 == function_selector >> 224) {\n            totalParticipants();\n        } else if (0xa6f9dae1 == function_selector >> 224) {\n            changeOwner(address);\n        } else if (0xb4022950 == function_selector >> 224) {\n            0xb4022950();\n        } else if (0xced92670 == function_selector >> 224) {\n            0xced92670();\n        } else if (0xd11f13df == function_selector >> 224) {\n            numberOfParticipantsWaitingForPayout();\n        } else if (0xfae14192 == function_selector >> 224) {\n            changeFeePercentage(uint256);\n        }\n    }\n    if (msg.value >= 0xde0b6b3a7640000) {\n        v0 = v1 = _currentFeePercentage;\n        if (msg.value >= 0x2b5e3af16b1880000) {\n            v0 = v2 = v1 >> 1;\n        }\n        _totalParticipants.length += 1;\n        if (!_totalParticipants.length <= 1 + _totalParticipants.length) {\n            v3 = v4 = keccak256(6) + (1 + _totalParticipants.length << 1);\n            while (keccak256(6) + (_totalParticipants.length << 1) > v3) {\n                STORAGE[v3] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v3];\n                v3 += 1;\n                STORAGE[v3] = 0;\n            }\n        }\n        MEM[64] += 64;\n        MEM[MEM[64]] = msg.sender;\n        MEM[32 + MEM[64]] = msg.value * _currentMultiplier / 100;\n        _totalParticipants[_totalParticipants.length << 1] = ~0xffffffffffffffffffffffffffffffffffffffff & _totalParticipants[_totalParticipants.length << 1] | msg.sender;\n        STORAGE[1 + ((_totalParticipants.length << 1) + keccak256(6))] = msg.value * _currentMultiplier / 100;\n        if (10 != _totalParticipants.length) {\n            if (25 == _totalParticipants.length) {\n                _currentMultiplier = 150;\n            }\n        } else {\n            _currentMultiplier = 200;\n        }\n        stor_0 = stor_0 + msg.value * (100 - v0) / 100;\n        ___function_selector__ += v0 * msg.value / 100;\n        throw();\n    } else {\n        ___function_selector__ += msg.value;\n        exit;\n    }\n}\n.",
	"status": "1",
	"time_cost": 34.96187996864319,
	"usage": {
		"completion_tokens": 775,
		"prompt_tokens": 2062,
		"total_tokens": 2837
	}
}