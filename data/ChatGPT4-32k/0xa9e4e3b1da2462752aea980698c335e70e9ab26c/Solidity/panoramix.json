{
	"address": "0xa9e4e3b1da2462752aea980698c335e70e9ab26c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code generated from the decompiled code. Please note that the decompiled code is not fully comprehensive, so some assumptions have been made:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Pyramid {\n    struct Participant {\n        address addr;\n        uint256 balance;\n    }\n\n    uint256 public stor0;\n    uint256 public stor1;\n    uint256 public stor2;\n    uint256 public stor3 = 120;\n    uint256 public stor4;\n    address public stor5;\n    Participant[] public stor6;\n    uint256 constant storF652 = 0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40;\n\n    modifier onlyOwner {\n        require(msg.sender == stor5);\n        _;\n    }\n\n    function totalParticipants() public view returns (uint256) {\n        return stor6.length;\n    }\n\n    function feesSeperateFromBalanceApproximately() public view returns (uint256) {\n        return stor1 / 10**18;\n    }\n\n    function numberOfParticipantsWaitingForPayout() public view returns (uint256) {\n        return stor6.length - stor4;\n    }\n\n    function nextPayoutWhenPyramidBalanceTotalsApproximately() public view returns (uint256) {\n        require(stor4 < stor6.length);\n        return stor6[stor4].balance / 10**18;\n    }\n\n    function changeMultiplier(uint256 _mult) public payable onlyOwner {\n        require(_mult <= 300 && _mult >= 120);\n        stor3 = _mult;\n    }\n\n    function changeOwner(address _newOwner) public payable onlyOwner {\n        stor5 = _newOwner;\n    }\n\n    function changeFeePercentage(uint256 _percentage) public payable onlyOwner {\n        require(_percentage <= 10);\n        stor2 = _percentage;\n    }\n\n    function collectAllFees() public payable onlyOwner {\n        require(stor1 > 0);\n        payable(stor5).transfer(stor1);\n        stor1 = 0;\n    }\n\n    function participantDetails(uint256 orderInPyramid) public view returns (address, uint256) {\n        require(orderInPyramid < stor6.length);\n        return (stor6[orderInPyramid].addr, stor6[orderInPyramid].balance / 10**18);\n    }\n\n    function collectPercentOfFees(uint256 _pcent) public payable onlyOwner {\n        require(stor1 > 0 && _pcent <= 100);\n        payable(stor5).transfer(_pcent * stor1 / 100);\n        stor1 -= _pcent * stor1 / 100;\n    }\n\n    function currentFeePercentage() public view returns (uint256) {\n        return stor2;\n    }\n\n    function currentPyramidBalanceApproximately() public view returns (uint256) {\n        return stor0 / 10**18;\n    }\n\n    function collectFeesInEther(uint256 _amt) public payable onlyOwner {\n        require(stor1 > 0);\n        if (10**18 * _amt <= stor1) {\n            payable(stor5).transfer(10**18 * _amt);\n            stor1 -= 10**18 * _amt;\n        } else {\n            payable(stor5).transfer(stor1);\n            stor1 = 0;\n        }\n    }\n\n    function currentMultiplier() public view returns (uint256) {\n        return stor3;\n    }\n\n    fallback() external payable {\n        if (msg.value < 10**18) {\n            stor1 += msg.value;\n        } else {\n            stor6.push(Participant(msg.sender, msg.value * stor3 / 100));\n            if (stor6.length <= 25) {\n                stor0 += (100 * msg.value) - (stor2 * msg.value) / 100;\n                stor1 += stor2 * msg.value / 100;\n                if (stor0 > storF652) {\n                    require(stor4 < stor6.length);\n                    payable(stor6[stor4].addr).transfer(stor6[stor4].balance);\n                    stor0 -= stor6[stor4].balance;\n                    stor4++;\n                    while (stor0 > storF652 && stor4 < stor6.length) {\n                        payable(stor6[stor4].addr).transfer(stor6[stor4].balance);\n                        stor0 -= stor6[stor4].balance;\n                        stor4++;\n                    }\n                }\n                if (stor6.length == 10) {\n                    stor3 = 200;\n                } else if (stor6.length == 25) {\n                    stor3 = 150;\n                }\n            }\n        }\n    }\n}\n```\nThe contract functions mainly revolve around managing participants (or addresses) in a pyramid scheme. It maintains a list of participants, their balances, an owner of the contract, and other state variables. The contract allows the owner to collect fees, change the fee percentage, and modify other parameters. It also has a fallback function that handles incoming ether transfers.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472949,
	"id": "chatcmpl-8MuyzbpTZIHqoBGUp6HPMJneJ1dtz",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor0 is uint256 at storage 0\n  stor1 is uint256 at storage 1\n  stor2 is uint256 at storage 2 offset 1\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor5 is address at storage 5\n  stor5 is uint256 at storage 5\n  stor6 is array of struct at storage 6\n  stor111414077815863400510004064629973595961579173665589224203503662149373724986688 is array of uint256 at storage 0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\n\ndef totalParticipants() payable: \n  return stor6.length\n\n#\n#  Regular functions\n#\n\ndef feesSeperateFromBalanceApproximately() payable: \n  return (stor1 / 10^18)\n\ndef numberOfParticipantsWaitingForPayout() payable: \n  return (stor6.length - stor4)\n\ndef nextPayoutWhenPyramidBalanceTotalsApproximately() payable: \n  require stor4 < stor6.length\n  return (stor[code.data[2457 len 32] + (2 * stor4)] / 10^18)\n\ndef changeMultiplier(uint256 _mult) payable: \n  if caller == address(stor5):\n      require _mult <= 300\n      require _mult >= 120\n      stor3 = _mult\n\ndef changeOwner(address _newOwner) payable: \n  if caller == address(stor5):\n      uint256(stor5) = _newOwner or Mask(96, 160, uint256(stor5))\n\ndef changeFeePercentage(uint256 _percentage) payable: \n  if address(stor5) == caller:\n      require _percentage <= 10\n      uint256(stor2.field_0) = _percentage\n\ndef collectAllFees() payable: \n  if caller == address(stor5):\n      require stor1\n      call address(stor5) with:\n         value stor1 wei\n           gas 0 wei\n      stor1 = 0\n\ndef participantDetails(uint256 orderInPyramid) payable: \n  if orderInPyramid > stor6.length:\n      return 0\n  require orderInPyramid < stor6.length\n  return address(stor6[orderInPyramid].field_0), stor[code.data[2457 len 32] + (2 * orderInPyramid)] / 10^18\n\ndef collectPercentOfFees(uint256 _pcent) payable: \n  if caller == address(stor5):\n      require stor1\n      require _pcent <= 100\n      call address(stor5) with:\n         value _pcent * stor1 / 100 wei\n           gas 0 wei\n      stor1 += -1 * _pcent * stor1 / 100\n\ndef currentFeePercentage() payable: \n  mem[544] = mem[572 len 4]\n  return uint256(stor2.field_0), \n         Array(len=132, data=0x5653686f776e20696e202520666f726d2e204665652069732068616c766564283530252920666f7220616d6f756e747320657175616c206f722067726561746572207468616e203530206574686572732e2028466565206d6179206368616e67652c206275742069732063617070656420746f2061206d6178696d756d206f66, mem[544])\n\ndef currentPyramidBalanceApproximately() payable: \n  mem[672] = mem[694 len 10]\n  return stor0 / 10^18, \n         64,\n         202,\n         0x29416c6c2062616c616e63652076616c75657320617265206d6561737572656420696e204574686572732c206e6f746520746861742064756520746f206e6f20646563696d616c20706c6163696e672c2074686573652076616c7565732073686f7720757020617320696e746567657273206f6e6c792c2077697468696e2074686520636f6e747261637420697473656c6620796f752077696c6c206765742074686520657861637420646563696d616c2076616c756520796f752061726520,\n         mem[672]\n\ndef collectFeesInEther(uint256 _amt) payable: \n  if caller == address(stor5):\n      require stor1\n      if 10^18 * _amt <= stor1:\n      else:\n          if address(stor5) != caller:\n          else:\n              call address(stor5) with:\n                 value stor1 wei\n                   gas 0 wei\n              stor1 = 0\n      call address(stor5) with:\n         value 10^18 * _amt wei\n           gas 0 wei\n      stor1 += -1 * 10^18 * _amt\n\ndef currentMultiplier() payable: \n  mem[800] = 0x20436170706564206174203378206d617820616e6420312e3278206d696e, mem[831 len 1]\n  return stor3, \n         Array(len=287, data=0x6f54686973206d756c7469706c696572206170706c69657320746f20796f7520617320736f6f6e206173207472616e73616374696f6e2069732072656365697665642c206d6179206265206c6f776572656420746f2068617374656e207061796f757473206f7220696e63726561736564206966207061796f75747320617265206661737420656e6f7567682e2044756520746f206e6f20666c6f6174206f7220646563696d616c732c206d756c7469706c696572206973207831303020666f722061206672616374696f6e616c206d756c7469706c69657220652e672e203235302069732061637475616c6c79206120322e3578206d756c7469706c696572, mem[800])\n\ndef _fallback(?) payable: # default function\n  if call.value < 10^18:\n      stor1 += call.value\n  else:\n      stor6.length++\n      if call.value < 50 * 10^18:\n          if not stor6.length > stor6.length + 1:\n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                  stor1 += uint256(stor2.field_0) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var17001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var17001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var18001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n          else:\n              idx = 2 * stor6.length + 1\n              while 2 * stor6.length > idx:\n                  address(stor6[idx].field_0) = 0\n                  stor6[idx].field_256 = 0\n                  idx = idx + 1\n                  continue \n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                  stor1 += uint256(stor2.field_0) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var21001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var21001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var22001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n      else:\n          if not stor6.length > stor6.length + 1:\n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                  stor1 += uint255(stor2.field_1) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var18001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var18001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var19001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n          else:\n              idx = 2 * stor6.length + 1\n              while 2 * stor6.length > idx:\n                  address(stor6[idx].field_0) = 0\n                  stor6[idx].field_256 = 0\n                  idx = idx + 1\n                  continue \n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                  stor1 += uint255(stor2.field_1) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var22001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var22001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var23001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is uint256 at storage 0\n  stor1 is uint256 at storage 1\n  stor2 is uint256 at storage 2 offset 1\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor5 is address at storage 5\n  stor5 is uint256 at storage 5\n  stor6 is array of struct at storage 6\n  stor111414077815863400510004064629973595961579173665589224203503662149373724986688 is array of uint256 at storage 0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\n\ndef totalParticipants() payable: \n  return stor6.length\n\n#\n#  Regular functions\n#\n\ndef feesSeperateFromBalanceApproximately() payable: \n  return (stor1 / 10^18)\n\ndef numberOfParticipantsWaitingForPayout() payable: \n  return (stor6.length - stor4)\n\ndef nextPayoutWhenPyramidBalanceTotalsApproximately() payable: \n  require stor4 < stor6.length\n  return (stor[code.data[2457 len 32] + (2 * stor4)] / 10^18)\n\ndef changeMultiplier(uint256 _mult) payable: \n  if caller == address(stor5):\n      require _mult <= 300\n      require _mult >= 120\n      stor3 = _mult\n\ndef changeOwner(address _newOwner) payable: \n  if caller == address(stor5):\n      uint256(stor5) = _newOwner or Mask(96, 160, uint256(stor5))\n\ndef changeFeePercentage(uint256 _percentage) payable: \n  if address(stor5) == caller:\n      require _percentage <= 10\n      uint256(stor2.field_0) = _percentage\n\ndef collectAllFees() payable: \n  if caller == address(stor5):\n      require stor1\n      call address(stor5) with:\n         value stor1 wei\n           gas 0 wei\n      stor1 = 0\n\ndef participantDetails(uint256 orderInPyramid) payable: \n  if orderInPyramid > stor6.length:\n      return 0\n  require orderInPyramid < stor6.length\n  return address(stor6[orderInPyramid].field_0), stor[code.data[2457 len 32] + (2 * orderInPyramid)] / 10^18\n\ndef collectPercentOfFees(uint256 _pcent) payable: \n  if caller == address(stor5):\n      require stor1\n      require _pcent <= 100\n      call address(stor5) with:\n         value _pcent * stor1 / 100 wei\n           gas 0 wei\n      stor1 += -1 * _pcent * stor1 / 100\n\ndef currentFeePercentage() payable: \n  mem[544] = mem[572 len 4]\n  return uint256(stor2.field_0), \n         Array(len=132, data=0x5653686f776e20696e202520666f726d2e204665652069732068616c766564283530252920666f7220616d6f756e747320657175616c206f722067726561746572207468616e203530206574686572732e2028466565206d6179206368616e67652c206275742069732063617070656420746f2061206d6178696d756d206f66, mem[544])\n\ndef currentPyramidBalanceApproximately() payable: \n  mem[672] = mem[694 len 10]\n  return stor0 / 10^18, \n         64,\n         202,\n         0x29416c6c2062616c616e63652076616c75657320617265206d6561737572656420696e204574686572732c206e6f746520746861742064756520746f206e6f20646563696d616c20706c6163696e672c2074686573652076616c7565732073686f7720757020617320696e746567657273206f6e6c792c2077697468696e2074686520636f6e747261637420697473656c6620796f752077696c6c206765742074686520657861637420646563696d616c2076616c756520796f752061726520,\n         mem[672]\n\ndef collectFeesInEther(uint256 _amt) payable: \n  if caller == address(stor5):\n      require stor1\n      if 10^18 * _amt <= stor1:\n      else:\n          if address(stor5) != caller:\n          else:\n              call address(stor5) with:\n                 value stor1 wei\n                   gas 0 wei\n              stor1 = 0\n      call address(stor5) with:\n         value 10^18 * _amt wei\n           gas 0 wei\n      stor1 += -1 * 10^18 * _amt\n\ndef currentMultiplier() payable: \n  mem[800] = 0x20436170706564206174203378206d617820616e6420312e3278206d696e, mem[831 len 1]\n  return stor3, \n         Array(len=287, data=0x6f54686973206d756c7469706c696572206170706c69657320746f20796f7520617320736f6f6e206173207472616e73616374696f6e2069732072656365697665642c206d6179206265206c6f776572656420746f2068617374656e207061796f757473206f7220696e63726561736564206966207061796f75747320617265206661737420656e6f7567682e2044756520746f206e6f20666c6f6174206f7220646563696d616c732c206d756c7469706c696572206973207831303020666f722061206672616374696f6e616c206d756c7469706c69657220652e672e203235302069732061637475616c6c79206120322e3578206d756c7469706c696572, mem[800])\n\ndef _fallback(?) payable: # default function\n  if call.value < 10^18:\n      stor1 += call.value\n  else:\n      stor6.length++\n      if call.value < 50 * 10^18:\n          if not stor6.length > stor6.length + 1:\n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                  stor1 += uint256(stor2.field_0) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var17001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var17001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var18001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n          else:\n              idx = 2 * stor6.length + 1\n              while 2 * stor6.length > idx:\n                  address(stor6[idx].field_0) = 0\n                  stor6[idx].field_256 = 0\n                  idx = idx + 1\n                  continue \n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                  stor1 += uint256(stor2.field_0) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var21001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var21001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var22001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n      else:\n          if not stor6.length > stor6.length + 1:\n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                  stor1 += uint255(stor2.field_1) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var18001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var18001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var19001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n          else:\n              idx = 2 * stor6.length + 1\n              while 2 * stor6.length > idx:\n                  address(stor6[idx].field_0) = 0\n                  stor6[idx].field_256 = 0\n                  idx = idx + 1\n                  continue \n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                  stor1 += uint255(stor2.field_1) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var22001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var22001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var23001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is uint256 at storage 0\n  stor1 is uint256 at storage 1\n  stor2 is uint256 at storage 2 offset 1\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor5 is address at storage 5\n  stor5 is uint256 at storage 5\n  stor6 is array of struct at storage 6\n  stor111414077815863400510004064629973595961579173665589224203503662149373724986688 is array of uint256 at storage 0xf652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d40\n\ndef totalParticipants() payable: \n  return stor6.length\n\n#\n#  Regular functions\n#\n\ndef feesSeperateFromBalanceApproximately() payable: \n  return (stor1 / 10^18)\n\ndef numberOfParticipantsWaitingForPayout() payable: \n  return (stor6.length - stor4)\n\ndef nextPayoutWhenPyramidBalanceTotalsApproximately() payable: \n  require stor4 < stor6.length\n  return (stor[code.data[2457 len 32] + (2 * stor4)] / 10^18)\n\ndef changeMultiplier(uint256 _mult) payable: \n  if caller == address(stor5):\n      require _mult <= 300\n      require _mult >= 120\n      stor3 = _mult\n\ndef changeOwner(address _newOwner) payable: \n  if caller == address(stor5):\n      uint256(stor5) = _newOwner or Mask(96, 160, uint256(stor5))\n\ndef changeFeePercentage(uint256 _percentage) payable: \n  if address(stor5) == caller:\n      require _percentage <= 10\n      uint256(stor2.field_0) = _percentage\n\ndef collectAllFees() payable: \n  if caller == address(stor5):\n      require stor1\n      call address(stor5) with:\n         value stor1 wei\n           gas 0 wei\n      stor1 = 0\n\ndef participantDetails(uint256 orderInPyramid) payable: \n  if orderInPyramid > stor6.length:\n      return 0\n  require orderInPyramid < stor6.length\n  return address(stor6[orderInPyramid].field_0), stor[code.data[2457 len 32] + (2 * orderInPyramid)] / 10^18\n\ndef collectPercentOfFees(uint256 _pcent) payable: \n  if caller == address(stor5):\n      require stor1\n      require _pcent <= 100\n      call address(stor5) with:\n         value _pcent * stor1 / 100 wei\n           gas 0 wei\n      stor1 += -1 * _pcent * stor1 / 100\n\ndef currentFeePercentage() payable: \n  mem[544] = mem[572 len 4]\n  return uint256(stor2.field_0), \n         Array(len=132, data=0x5653686f776e20696e202520666f726d2e204665652069732068616c766564283530252920666f7220616d6f756e747320657175616c206f722067726561746572207468616e203530206574686572732e2028466565206d6179206368616e67652c206275742069732063617070656420746f2061206d6178696d756d206f66, mem[544])\n\ndef currentPyramidBalanceApproximately() payable: \n  mem[672] = mem[694 len 10]\n  return stor0 / 10^18, \n         64,\n         202,\n         0x29416c6c2062616c616e63652076616c75657320617265206d6561737572656420696e204574686572732c206e6f746520746861742064756520746f206e6f20646563696d616c20706c6163696e672c2074686573652076616c7565732073686f7720757020617320696e746567657273206f6e6c792c2077697468696e2074686520636f6e747261637420697473656c6620796f752077696c6c206765742074686520657861637420646563696d616c2076616c756520796f752061726520,\n         mem[672]\n\ndef collectFeesInEther(uint256 _amt) payable: \n  if caller == address(stor5):\n      require stor1\n      if 10^18 * _amt <= stor1:\n      else:\n          if address(stor5) != caller:\n          else:\n              call address(stor5) with:\n                 value stor1 wei\n                   gas 0 wei\n              stor1 = 0\n      call address(stor5) with:\n         value 10^18 * _amt wei\n           gas 0 wei\n      stor1 += -1 * 10^18 * _amt\n\ndef currentMultiplier() payable: \n  mem[800] = 0x20436170706564206174203378206d617820616e6420312e3278206d696e, mem[831 len 1]\n  return stor3, \n         Array(len=287, data=0x6f54686973206d756c7469706c696572206170706c69657320746f20796f7520617320736f6f6e206173207472616e73616374696f6e2069732072656365697665642c206d6179206265206c6f776572656420746f2068617374656e207061796f757473206f7220696e63726561736564206966207061796f75747320617265206661737420656e6f7567682e2044756520746f206e6f20666c6f6174206f7220646563696d616c732c206d756c7469706c696572206973207831303020666f722061206672616374696f6e616c206d756c7469706c69657220652e672e203235302069732061637475616c6c79206120322e3578206d756c7469706c696572, mem[800])\n\ndef _fallback(?) payable: # default function\n  if call.value < 10^18:\n      stor1 += call.value\n  else:\n      stor6.length++\n      if call.value < 50 * 10^18:\n          if not stor6.length > stor6.length + 1:\n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                  stor1 += uint256(stor2.field_0) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var17001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var17001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var18001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n          else:\n              idx = 2 * stor6.length + 1\n              while 2 * stor6.length > idx:\n                  address(stor6[idx].field_0) = 0\n                  stor6[idx].field_256 = 0\n                  idx = idx + 1\n                  continue \n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                  stor1 += uint256(stor2.field_0) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var21001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var21001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint256(stor2.field_0) * call.value) / 100\n                      stor1 += uint256(stor2.field_0) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var22001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n      else:\n          if not stor6.length > stor6.length + 1:\n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                  stor1 += uint255(stor2.field_1) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var18001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var18001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var19001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n          else:\n              idx = 2 * stor6.length + 1\n              while 2 * stor6.length > idx:\n                  address(stor6[idx].field_0) = 0\n                  stor6[idx].field_256 = 0\n                  idx = idx + 1\n                  continue \n              address(stor6[stor6.length].field_0) = caller\n              stor6[stor6.length].field_256 = call.value * stor3 / 100\n              if 10 == stor6.length:\n                  stor3 = 200\n                  stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                  stor1 += uint255(stor2.field_1) * call.value / 100\n                  if stor0 > storF652[stor4]:\n                      require stor4 < stor6.length\n                      call address(stor6[stor4].field_0) with:\n                         value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                           gas 0 wei\n                      stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                      stor4++\n                      s = var22001\n                      while stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          mem[0] = 6\n                          s = stor[code.data[2457 len 32] + (2 * stor4)]\n                          continue \n              else:\n                  if stor6.length != 25:\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var22001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n                  else:\n                      stor3 = 150\n                      stor0 += (100 * call.value) - (uint255(stor2.field_1) * call.value) / 100\n                      stor1 += uint255(stor2.field_1) * call.value / 100\n                      if stor0 > storF652[stor4]:\n                          require stor4 < stor6.length\n                          call address(stor6[stor4].field_0) with:\n                             value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                               gas 0 wei\n                          stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                          stor4++\n                          s = var23001\n                          while stor0 > storF652[stor4]:\n                              require stor4 < stor6.length\n                              call address(stor6[stor4].field_0) with:\n                                 value stor[code.data[2457 len 32] + (2 * stor4)] wei\n                                   gas 0 wei\n                              stor0 -= stor[code.data[2457 len 32] + (2 * stor4)]\n                              stor4++\n                              mem[0] = 6\n                              s = stor[code.data[2457 len 32] + (2 * stor4)]\n                              continue \n\n.",
	"status": "1",
	"time_cost": 75.50492906570435,
	"usage": {
		"completion_tokens": 1064,
		"prompt_tokens": 5204,
		"total_tokens": 6268
	}
}