{
	"address": "0x2b73cb82aebd4c261cae319d2f9eafedbf72abb6",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's a rough Solidity contract based on the provided decompiled code.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\ncontract TokenContract {\n    mapping (address => uint256) private _balanceOf;\n    string public _name;\n    string public _symbol;\n    uint256 public _totalSupply;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    uint256 public _direct_drop_rate;\n    uint256 public _direct_drop_range_start;\n    uint256 public _direct_drop_range_end;\n    uint256 public _air_drop_rate;\n    uint256 public _air_drop_count;\n    mapping (address => uint256) private owner_13;\n    uint256 public _air_drop_range_start;\n    uint256 public _air_drop_range_end;\n    address public _admin_address;\n    uint8 public _decimals;\n    bool public _direct_drop_switch;\n    bool public _air_drop_switch;\n    address public _account_address;\n    bool public _air_drop_range;\n    address public _direct_drop_address;\n    address public _direct_drop_withdraw_address;\n    address public _air_drop_address;\n    bool public _direct_drop_range;\n\n    event TokenPurchase(address indexed buyer, address recipient, uint256 value, uint256 amount);\n    event TokenGiven(address indexed sender, address recipient, uint256 value, uint256 rate);\n    event Approval(address indexed owner, address spender, uint256 value);\n    event Transfer(address indexed from, address to, uint256 value);\n    event Burn(address indexed burner, uint256 value);\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 totalSupply,\n        address admin_address\n    ) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n        _admin_address = admin_address;\n        _balanceOf[admin_address] = totalSupply;\n    }\n\n    // ... other functions based on the provided decompiled code ...\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // ... other functions based on the provided decompiled code ...\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        require(value <= _balanceOf[from], \"Insufficient balance.\");\n        require(value <= _allowance[from][msg.sender], \"Insufficient allowance.\");\n\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from][msg.sender] -= value;\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    // ... other functions based on the provided decompiled code ...\n}\n```\n\nPlease note that this is a rough translation of the decompiled code, and there may be some inaccuracies. For example, it is not entirely clear from your given decompiled code how some of the variables (e.g., `varg0`, `varg1`, `v0`, `v1`, etc.) are used or what they represent. Therefore, some assumptions were made in the conversion process. To ensure that the contract behaves as expected, you should carefully review and test the Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701463702,
	"id": "chatcmpl-8R4isssqFi8V8NxBdCLUn3ad6YuvT",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 21:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint256 _direct_drop_rate; // STORAGE[0xa]\nuint256 _direct_drop_range_start; // STORAGE[0xd]\nuint256 _direct_drop_range_end; // STORAGE[0xe]\nuint256 _air_drop_rate; // STORAGE[0x10]\nuint256 _air_drop_count; // STORAGE[0x12]\nmapping (uint256 => [uint256]) owner_13; // STORAGE[0x13]\nuint256 _air_drop_range_start; // STORAGE[0x15]\nuint256 _air_drop_range_end; // STORAGE[0x16]\naddress _admin_address; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _direct_drop_switch; // STORAGE[0x9] bytes 0 to 0\nuint8 _air_drop_switch; // STORAGE[0xf] bytes 0 to 0\nuint160 _account_address; // STORAGE[0x1] bytes 0 to 19\nuint8 _air_drop_range; // STORAGE[0x14] bytes 0 to 0\nuint160 _direct_drop_address; // STORAGE[0xb] bytes 0 to 19\naddress _direct_drop_withdraw_address; // STORAGE[0xc] bytes 0 to 19\nuint160 _air_drop_address; // STORAGE[0x11] bytes 0 to 19\nuint8 _direct_drop_range; // STORAGE[0xc] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nTokenGiven(address, address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction 0x101c(uint256 varg0) private { \n    require(_air_drop_switch);\n    require(address(varg0) != 0);\n    if (_air_drop_range) {\n        v0 = v1 = block.timestamp >= _air_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _air_drop_range_end;\n        }\n        require(v0);\n    }\n    if (_air_drop_count > 0) {\n        v3 = address(varg0);\n        require(owner_13[v3] <= _air_drop_count);\n    }\n    v4 = 0x26a6(_air_drop_rate, 10 ** _decimals);\n    require(_balanceOf[_air_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v5] >= _balanceOf[_air_drop_address]);\n    assert(v4 <= _balanceOf[_air_drop_address]);\n    _balanceOf[_air_drop_address] = _balanceOf[_air_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v8] >= _balanceOf[_air_drop_address]);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v5] == _balanceOf[_air_drop_address] + _balanceOf[v8]);\n    emit TokenGiven(msg.sender, address(varg0), msg.value, _air_drop_rate);\n    return 1;\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        v0 = 0x101c(msg.sender);\n    } else {\n        v1 = 0xb99(msg.sender);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction direct_drop_withdraw_address() public nonPayable { \n    return _direct_drop_withdraw_address;\n}\n\nfunction 0x26a6(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction withDraw() public nonPayable { \n    v0 = v1 = msg.sender == _admin_address;\n    if (msg.sender != _admin_address) {\n        v0 = msg.sender == _direct_drop_withdraw_address;\n    }\n    require(v0);\n    require((address(this)).balance > 0);\n    v2 = _direct_drop_withdraw_address.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction air_drop_switch() public nonPayable { \n    return _air_drop_switch;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction air_drop_range() public nonPayable { \n    return _air_drop_range;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction direct_drop_rate() public nonPayable { \n    return _direct_drop_rate;\n}\n\nfunction direct_drop_range_end() public nonPayable { \n    return _direct_drop_range_end;\n}\n\nfunction direct_drop_switch() public nonPayable { \n    return _direct_drop_switch;\n}\n\nfunction setDirectDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _direct_drop_switch = varg0;\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction air_drop_address() public nonPayable { \n    return _air_drop_address;\n}\n\nfunction direct_drop_range_start() public nonPayable { \n    return _direct_drop_range_start;\n}\n\nfunction air_drop_rate() public nonPayable { \n    return _air_drop_rate;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction account_address() public nonPayable { \n    return _account_address;\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    require(varg0 != 0);\n    _admin_address = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setAirDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _air_drop_switch = varg0;\n    return 1;\n}\n\nfunction air_drop_range_end() public nonPayable { \n    return _air_drop_range_end;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction air_drop_count() public nonPayable { \n    return _air_drop_count;\n}\n\nfunction airDrop(address varg0) public payable { \n    v0 = 0x101c(varg0);\n    return v0;\n}\n\nfunction direct_drop_address() public nonPayable { \n    return _direct_drop_address;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction air_drop_range_start() public nonPayable { \n    return _air_drop_range_start;\n}\n\nfunction direct_drop_range() public nonPayable { \n    return _direct_drop_range;\n}\n\nfunction buyTokens(address varg0) public payable { \n    v0 = 0xb99(varg0);\n    return v0;\n}\n\nfunction admin_address() public nonPayable { \n    return _admin_address;\n}\n\nfunction 0xb99(uint256 varg0) private { \n    require(_direct_drop_switch);\n    require(address(varg0) != 0);\n    if (_direct_drop_range) {\n        v0 = v1 = block.timestamp >= _direct_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _direct_drop_range_end;\n        }\n        require(v0);\n    }\n    v3 = 0x26a6(_direct_drop_rate, msg.value);\n    assert(0xde0b6b3a7640000);\n    v4 = 0x26a6(v3 / 0xde0b6b3a7640000, 10 ** _decimals);\n    require(_balanceOf[_direct_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] >= _balanceOf[_direct_drop_address]);\n    assert(v4 <= _balanceOf[_direct_drop_address]);\n    _balanceOf[_direct_drop_address] = _balanceOf[_direct_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v8] >= _balanceOf[_direct_drop_address]);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] == _balanceOf[_direct_drop_address] + _balanceOf[v8]);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3 / 0xde0b6b3a7640000);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x9451cb2 == function_selector) {\n            direct_drop_withdraw_address();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xfdb1c10 == function_selector) {\n            withDraw();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x212c01fa == function_selector) {\n            air_drop_switch();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2ed37872 == function_selector) {\n            air_drop_range();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x324f8ac9 == function_selector) {\n            direct_drop_rate();\n        } else if (0x32d76483 == function_selector) {\n            direct_drop_range_end();\n        } else if (0x3381601e == function_selector) {\n            direct_drop_switch();\n        } else if (0x41ec2ec6 == function_selector) {\n            setDirectDrop(bool);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x42ac2950 == function_selector) {\n            air_drop_address();\n        } else if (0x44272b2f == function_selector) {\n            direct_drop_range_start();\n        } else if (0x4e11826b == function_selector) {\n            air_drop_rate();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x661be157 == function_selector) {\n            account_address();\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa2368e11 == function_selector) {\n            setAirDrop(bool);\n        } else if (0xa65137dc == function_selector) {\n            air_drop_range_end();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbf6b319a == function_selector) {\n            air_drop_count();\n        } else if (0xcd18d5a4 == function_selector) {\n            airDrop(address);\n        } else if (0xd373f4ee == function_selector) {\n            direct_drop_address();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe63614b0 == function_selector) {\n            air_drop_range_start();\n        } else if (0xec78aa0f == function_selector) {\n            direct_drop_range();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2e62772 == function_selector) {\n            admin_address();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 21:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint256 _direct_drop_rate; // STORAGE[0xa]\nuint256 _direct_drop_range_start; // STORAGE[0xd]\nuint256 _direct_drop_range_end; // STORAGE[0xe]\nuint256 _air_drop_rate; // STORAGE[0x10]\nuint256 _air_drop_count; // STORAGE[0x12]\nmapping (uint256 => [uint256]) owner_13; // STORAGE[0x13]\nuint256 _air_drop_range_start; // STORAGE[0x15]\nuint256 _air_drop_range_end; // STORAGE[0x16]\naddress _admin_address; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _direct_drop_switch; // STORAGE[0x9] bytes 0 to 0\nuint8 _air_drop_switch; // STORAGE[0xf] bytes 0 to 0\nuint160 _account_address; // STORAGE[0x1] bytes 0 to 19\nuint8 _air_drop_range; // STORAGE[0x14] bytes 0 to 0\nuint160 _direct_drop_address; // STORAGE[0xb] bytes 0 to 19\naddress _direct_drop_withdraw_address; // STORAGE[0xc] bytes 0 to 19\nuint160 _air_drop_address; // STORAGE[0x11] bytes 0 to 19\nuint8 _direct_drop_range; // STORAGE[0xc] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nTokenGiven(address, address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction 0x101c(uint256 varg0) private { \n    require(_air_drop_switch);\n    require(address(varg0) != 0);\n    if (_air_drop_range) {\n        v0 = v1 = block.timestamp >= _air_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _air_drop_range_end;\n        }\n        require(v0);\n    }\n    if (_air_drop_count > 0) {\n        v3 = address(varg0);\n        require(owner_13[v3] <= _air_drop_count);\n    }\n    v4 = 0x26a6(_air_drop_rate, 10 ** _decimals);\n    require(_balanceOf[_air_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v5] >= _balanceOf[_air_drop_address]);\n    assert(v4 <= _balanceOf[_air_drop_address]);\n    _balanceOf[_air_drop_address] = _balanceOf[_air_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v8] >= _balanceOf[_air_drop_address]);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v5] == _balanceOf[_air_drop_address] + _balanceOf[v8]);\n    emit TokenGiven(msg.sender, address(varg0), msg.value, _air_drop_rate);\n    return 1;\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        v0 = 0x101c(msg.sender);\n    } else {\n        v1 = 0xb99(msg.sender);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction direct_drop_withdraw_address() public nonPayable { \n    return _direct_drop_withdraw_address;\n}\n\nfunction 0x26a6(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction withDraw() public nonPayable { \n    v0 = v1 = msg.sender == _admin_address;\n    if (msg.sender != _admin_address) {\n        v0 = msg.sender == _direct_drop_withdraw_address;\n    }\n    require(v0);\n    require((address(this)).balance > 0);\n    v2 = _direct_drop_withdraw_address.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction air_drop_switch() public nonPayable { \n    return _air_drop_switch;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction air_drop_range() public nonPayable { \n    return _air_drop_range;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction direct_drop_rate() public nonPayable { \n    return _direct_drop_rate;\n}\n\nfunction direct_drop_range_end() public nonPayable { \n    return _direct_drop_range_end;\n}\n\nfunction direct_drop_switch() public nonPayable { \n    return _direct_drop_switch;\n}\n\nfunction setDirectDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _direct_drop_switch = varg0;\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction air_drop_address() public nonPayable { \n    return _air_drop_address;\n}\n\nfunction direct_drop_range_start() public nonPayable { \n    return _direct_drop_range_start;\n}\n\nfunction air_drop_rate() public nonPayable { \n    return _air_drop_rate;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction account_address() public nonPayable { \n    return _account_address;\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    require(varg0 != 0);\n    _admin_address = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setAirDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _air_drop_switch = varg0;\n    return 1;\n}\n\nfunction air_drop_range_end() public nonPayable { \n    return _air_drop_range_end;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction air_drop_count() public nonPayable { \n    return _air_drop_count;\n}\n\nfunction airDrop(address varg0) public payable { \n    v0 = 0x101c(varg0);\n    return v0;\n}\n\nfunction direct_drop_address() public nonPayable { \n    return _direct_drop_address;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction air_drop_range_start() public nonPayable { \n    return _air_drop_range_start;\n}\n\nfunction direct_drop_range() public nonPayable { \n    return _direct_drop_range;\n}\n\nfunction buyTokens(address varg0) public payable { \n    v0 = 0xb99(varg0);\n    return v0;\n}\n\nfunction admin_address() public nonPayable { \n    return _admin_address;\n}\n\nfunction 0xb99(uint256 varg0) private { \n    require(_direct_drop_switch);\n    require(address(varg0) != 0);\n    if (_direct_drop_range) {\n        v0 = v1 = block.timestamp >= _direct_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _direct_drop_range_end;\n        }\n        require(v0);\n    }\n    v3 = 0x26a6(_direct_drop_rate, msg.value);\n    assert(0xde0b6b3a7640000);\n    v4 = 0x26a6(v3 / 0xde0b6b3a7640000, 10 ** _decimals);\n    require(_balanceOf[_direct_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] >= _balanceOf[_direct_drop_address]);\n    assert(v4 <= _balanceOf[_direct_drop_address]);\n    _balanceOf[_direct_drop_address] = _balanceOf[_direct_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v8] >= _balanceOf[_direct_drop_address]);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] == _balanceOf[_direct_drop_address] + _balanceOf[v8]);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3 / 0xde0b6b3a7640000);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x9451cb2 == function_selector) {\n            direct_drop_withdraw_address();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xfdb1c10 == function_selector) {\n            withDraw();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x212c01fa == function_selector) {\n            air_drop_switch();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2ed37872 == function_selector) {\n            air_drop_range();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x324f8ac9 == function_selector) {\n            direct_drop_rate();\n        } else if (0x32d76483 == function_selector) {\n            direct_drop_range_end();\n        } else if (0x3381601e == function_selector) {\n            direct_drop_switch();\n        } else if (0x41ec2ec6 == function_selector) {\n            setDirectDrop(bool);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x42ac2950 == function_selector) {\n            air_drop_address();\n        } else if (0x44272b2f == function_selector) {\n            direct_drop_range_start();\n        } else if (0x4e11826b == function_selector) {\n            air_drop_rate();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x661be157 == function_selector) {\n            account_address();\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa2368e11 == function_selector) {\n            setAirDrop(bool);\n        } else if (0xa65137dc == function_selector) {\n            air_drop_range_end();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbf6b319a == function_selector) {\n            air_drop_count();\n        } else if (0xcd18d5a4 == function_selector) {\n            airDrop(address);\n        } else if (0xd373f4ee == function_selector) {\n            direct_drop_address();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe63614b0 == function_selector) {\n            air_drop_range_start();\n        } else if (0xec78aa0f == function_selector) {\n            direct_drop_range();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2e62772 == function_selector) {\n            admin_address();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 21:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x8]\nuint256 _direct_drop_rate; // STORAGE[0xa]\nuint256 _direct_drop_range_start; // STORAGE[0xd]\nuint256 _direct_drop_range_end; // STORAGE[0xe]\nuint256 _air_drop_rate; // STORAGE[0x10]\nuint256 _air_drop_count; // STORAGE[0x12]\nmapping (uint256 => [uint256]) owner_13; // STORAGE[0x13]\nuint256 _air_drop_range_start; // STORAGE[0x15]\nuint256 _air_drop_range_end; // STORAGE[0x16]\naddress _admin_address; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint8 _direct_drop_switch; // STORAGE[0x9] bytes 0 to 0\nuint8 _air_drop_switch; // STORAGE[0xf] bytes 0 to 0\nuint160 _account_address; // STORAGE[0x1] bytes 0 to 19\nuint8 _air_drop_range; // STORAGE[0x14] bytes 0 to 0\nuint160 _direct_drop_address; // STORAGE[0xb] bytes 0 to 19\naddress _direct_drop_withdraw_address; // STORAGE[0xc] bytes 0 to 19\nuint160 _air_drop_address; // STORAGE[0x11] bytes 0 to 19\nuint8 _direct_drop_range; // STORAGE[0xc] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nTokenGiven(address, address, uint256, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction 0x101c(uint256 varg0) private { \n    require(_air_drop_switch);\n    require(address(varg0) != 0);\n    if (_air_drop_range) {\n        v0 = v1 = block.timestamp >= _air_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _air_drop_range_end;\n        }\n        require(v0);\n    }\n    if (_air_drop_count > 0) {\n        v3 = address(varg0);\n        require(owner_13[v3] <= _air_drop_count);\n    }\n    v4 = 0x26a6(_air_drop_rate, 10 ** _decimals);\n    require(_balanceOf[_air_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v5] >= _balanceOf[_air_drop_address]);\n    assert(v4 <= _balanceOf[_air_drop_address]);\n    _balanceOf[_air_drop_address] = _balanceOf[_air_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v8] >= _balanceOf[_air_drop_address]);\n    assert(_balanceOf[_air_drop_address] + _balanceOf[v5] == _balanceOf[_air_drop_address] + _balanceOf[v8]);\n    emit TokenGiven(msg.sender, address(varg0), msg.value, _air_drop_rate);\n    return 1;\n}\n\nfunction fallback() public payable { \n    if (msg.value <= 0) {\n        v0 = 0x101c(msg.sender);\n    } else {\n        v1 = 0xb99(msg.sender);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction direct_drop_withdraw_address() public nonPayable { \n    return _direct_drop_withdraw_address;\n}\n\nfunction 0x26a6(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction withDraw() public nonPayable { \n    v0 = v1 = msg.sender == _admin_address;\n    if (msg.sender != _admin_address) {\n        v0 = msg.sender == _direct_drop_withdraw_address;\n    }\n    require(v0);\n    require((address(this)).balance > 0);\n    v2 = _direct_drop_withdraw_address.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction air_drop_switch() public nonPayable { \n    return _air_drop_switch;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1 != 0);\n    require(varg2 <= _balanceOf[varg0]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] + varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction air_drop_range() public nonPayable { \n    return _air_drop_range;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction direct_drop_rate() public nonPayable { \n    return _direct_drop_rate;\n}\n\nfunction direct_drop_range_end() public nonPayable { \n    return _direct_drop_range_end;\n}\n\nfunction direct_drop_switch() public nonPayable { \n    return _direct_drop_switch;\n}\n\nfunction setDirectDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _direct_drop_switch = varg0;\n    return 1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    emit Transfer(msg.sender, 0, varg0);\n}\n\nfunction air_drop_address() public nonPayable { \n    return _air_drop_address;\n}\n\nfunction direct_drop_range_start() public nonPayable { \n    return _direct_drop_range_start;\n}\n\nfunction air_drop_rate() public nonPayable { \n    return _air_drop_rate;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction account_address() public nonPayable { \n    return _account_address;\n}\n\nfunction setAdmin(address varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    require(varg0 != 0);\n    _admin_address = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setAirDrop(bool varg0) public nonPayable { \n    require(msg.sender == _admin_address);\n    _air_drop_switch = varg0;\n    return 1;\n}\n\nfunction air_drop_range_end() public nonPayable { \n    return _air_drop_range_end;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0 != 0);\n    require(varg1 <= _balanceOf[msg.sender]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction air_drop_count() public nonPayable { \n    return _air_drop_count;\n}\n\nfunction airDrop(address varg0) public payable { \n    v0 = 0x101c(varg0);\n    return v0;\n}\n\nfunction direct_drop_address() public nonPayable { \n    return _direct_drop_address;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    assert(_allowance[varg0] + varg1 >= _allowance[varg0]);\n    _allowance[varg0] = _allowance[varg0] + varg1;\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction air_drop_range_start() public nonPayable { \n    return _air_drop_range_start;\n}\n\nfunction direct_drop_range() public nonPayable { \n    return _direct_drop_range;\n}\n\nfunction buyTokens(address varg0) public payable { \n    v0 = 0xb99(varg0);\n    return v0;\n}\n\nfunction admin_address() public nonPayable { \n    return _admin_address;\n}\n\nfunction 0xb99(uint256 varg0) private { \n    require(_direct_drop_switch);\n    require(address(varg0) != 0);\n    if (_direct_drop_range) {\n        v0 = v1 = block.timestamp >= _direct_drop_range_start;\n        if (v1) {\n            v0 = v2 = block.timestamp <= _direct_drop_range_end;\n        }\n        require(v0);\n    }\n    v3 = 0x26a6(_direct_drop_rate, msg.value);\n    assert(0xde0b6b3a7640000);\n    v4 = 0x26a6(v3 / 0xde0b6b3a7640000, 10 ** _decimals);\n    require(_balanceOf[_direct_drop_address] >= v4);\n    assert(v4 > 0);\n    v5 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] >= _balanceOf[_direct_drop_address]);\n    assert(v4 <= _balanceOf[_direct_drop_address]);\n    _balanceOf[_direct_drop_address] = _balanceOf[_direct_drop_address] - v4;\n    v6 = address(varg0);\n    assert(_balanceOf[v6] + v4 >= _balanceOf[v6]);\n    v7 = address(varg0);\n    _balanceOf[v7] = _balanceOf[v6] + v4;\n    v8 = address(varg0);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v8] >= _balanceOf[_direct_drop_address]);\n    assert(_balanceOf[_direct_drop_address] + _balanceOf[v5] == _balanceOf[_direct_drop_address] + _balanceOf[v8]);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v3 / 0xde0b6b3a7640000);\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x9451cb2 == function_selector) {\n            direct_drop_withdraw_address();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xfdb1c10 == function_selector) {\n            withDraw();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x212c01fa == function_selector) {\n            air_drop_switch();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2ed37872 == function_selector) {\n            air_drop_range();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x324f8ac9 == function_selector) {\n            direct_drop_rate();\n        } else if (0x32d76483 == function_selector) {\n            direct_drop_range_end();\n        } else if (0x3381601e == function_selector) {\n            direct_drop_switch();\n        } else if (0x41ec2ec6 == function_selector) {\n            setDirectDrop(bool);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x42ac2950 == function_selector) {\n            air_drop_address();\n        } else if (0x44272b2f == function_selector) {\n            direct_drop_range_start();\n        } else if (0x4e11826b == function_selector) {\n            air_drop_rate();\n        } else if (0x66188463 == function_selector) {\n            decreaseApproval(address,uint256);\n        } else if (0x661be157 == function_selector) {\n            account_address();\n        } else if (0x704b6c02 == function_selector) {\n            setAdmin(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa2368e11 == function_selector) {\n            setAirDrop(bool);\n        } else if (0xa65137dc == function_selector) {\n            air_drop_range_end();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xbf6b319a == function_selector) {\n            air_drop_count();\n        } else if (0xcd18d5a4 == function_selector) {\n            airDrop(address);\n        } else if (0xd373f4ee == function_selector) {\n            direct_drop_address();\n        } else if (0xd73dd623 == function_selector) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe63614b0 == function_selector) {\n            air_drop_range_start();\n        } else if (0xec78aa0f == function_selector) {\n            direct_drop_range();\n        } else if (0xec8ac4d8 == function_selector) {\n            buyTokens(address);\n        } else if (0xf2e62772 == function_selector) {\n            admin_address();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 42.14781641960144,
	"usage": {
		"completion_tokens": 701,
		"prompt_tokens": 4153,
		"total_tokens": 4854
	}
}