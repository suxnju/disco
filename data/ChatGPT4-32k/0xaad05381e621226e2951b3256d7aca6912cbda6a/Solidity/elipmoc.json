{
	"address": "0xaad05381e621226e2951b3256d7aca6912cbda6a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, the Solidity contract could potentially look something like this:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract CoinDogs {\n\n    mapping (address => uint256) private _balanceOf;\n    uint256 private _totalSupply;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    uint256 private _price;\n    uint256 private _collectedTokens;\n    uint256 private _collectedEthers;\n    uint256 private _startTime;\n    uint256 private _weiRaised;\n    uint256 private _tokensSold;\n    bool private _isFinished;\n    address private _owner;\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Burn(address indexed from, uint256 value);\n\n    constructor() public {\n        _owner = msg.sender;\n        _totalSupply = 1000000;\n        _startTime = now;\n        _isFinished = false;\n        _price = 1 ether;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint) {\n        return _balanceOf[tokenOwner];\n    }\n\n    function allowance(address tokenOwner, address spender) public view returns (uint) {\n        return _allowance[tokenOwner][spender];\n    }\n\n    function transfer(address to, uint tokens) public returns (bool) {\n        require(_balanceOf[msg.sender] >= tokens);\n        _balanceOf[msg.sender] -= tokens;\n        _balanceOf[to] += tokens;\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function approve(address spender, uint tokens) public returns (bool) {\n        _allowance[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint tokens) public returns (bool) {\n        require(tokens <= _balanceOf[from]);\n        require(tokens <= _allowance[from][msg.sender]);\n        _balanceOf[from] -= tokens;\n        _allowance[from][msg.sender] -= tokens;\n        _balanceOf[to] += tokens;\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(_balanceOf[msg.sender] >= _value);\n        _balanceOf[msg.sender] -= _value;\n        _totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function() external payable {\n        require(now >= _startTime);\n        require(!_isFinished);\n        require(msg.value >= _price);\n        uint tokens = msg.value / _price;\n        _balanceOf[msg.sender] += tokens;\n        _tokensSold += tokens;\n        _collectedEthers += msg.value;\n        emit Transfer(address(0), msg.sender, tokens);\n    }\n}\n``` \n\nNotice: This contract is a simple example and does not include all functionality from the decompiled code. Also, there are some variables and functions in the decompiled code that aren't included because their purpose is unclear or they seem to be unused. Be sure to thoroughly test any smart contract code in a safe environment before deploying it on the main network.",
				"role": "assistant"
			}
		}
	],
	"created": 1701470326,
	"id": "chatcmpl-8R6RibcrpCz3TfaWkJG7TIixnB0ve",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 02:54 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _price; // STORAGE[0x4]\nuint256 _collectedTokens; // STORAGE[0x5]\nuint256 _collectedEthers; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _weiRaised; // STORAGE[0x8]\nuint256 _tokensSold; // STORAGE[0x9]\nuint8 _isFinished; // STORAGE[0xa] bytes 0 to 0\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint256 stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8; // STORAGE[0xcaeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8]\n\n// Events\nApproval(address, address, uint256);\nBurn(address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(block.timestamp >= _startTime);\n    assert(!_isFinished);\n    assert(_price);\n    assert(msg.value / _price + _tokensSold >= _tokensSold);\n    assert(msg.value / _price + _tokensSold <= _totalSupply);\n    assert(_totalSupply - (msg.value / _price + _tokensSold) >= 0);\n    assert(msg.value >= _price);\n    assert(_price);\n    MEM[0] = 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02;\n    MEM[32] = 0;\n    assert(msg.value / _price <= stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8);\n    stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8 = stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8 - msg.value / _price;\n    assert(msg.value / _price + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value / _price;\n    assert(msg.value / _price + _collectedTokens >= _collectedTokens);\n    _collectedTokens += msg.value / _price;\n    assert(msg.value + _collectedEthers >= _collectedEthers);\n    _collectedEthers += msg.value;\n    assert(msg.value + _weiRaised >= _weiRaised);\n    _weiRaised += msg.value;\n    assert(msg.value / _price + _tokensSold >= _tokensSold);\n    _tokensSold += msg.value / _price;\n    emit Transfer(0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02, msg.sender, msg.value / _price);\n}\n\nfunction collectedEthers() public nonPayable { \n    return _collectedEthers;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'COINDOGS';\n    }\n    return v0;\n}\n\nfunction stop() public nonPayable { \n    assert(msg.sender == _owner);\n    _isFinished = 1;\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1);\n    v0 = v1 = varg2 <= _balanceOf[varg0];\n    if (varg2 <= _balanceOf[varg0]) {\n        v0 = v2 = _balanceOf[varg1] + varg2 >= _balanceOf[varg1];\n    }\n    require(v0);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction INITIAL_SUPPLY() public nonPayable { \n    return 0x17d7840;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0xa45();\n    return v0;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xed2(varg0, msg.sender);\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction collectedTokens() public nonPayable { \n    return _collectedTokens;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _allowance[msg.sender]);\n    assert(varg1 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    0xed2(varg1, varg0);\n}\n\nfunction isFinished() public nonPayable { \n    return _isFinished;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x444f470000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction changePrice(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.sender == _owner);\n    _price = varg0;\n}\n\nfunction tokenOwner() public nonPayable { \n    return 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0);\n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = v2 = _balanceOf[varg0] + varg1 >= _balanceOf[varg0];\n    }\n    require(v0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 + _allowance[varg0] >= _allowance[varg0]);\n    _allowance[varg0] += varg1;\n    emit Approval(msg.sender, varg0, varg1 + _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.sender == _owner);\n    if (varg0) {\n        _owner = varg0;\n        goto 0x3d70x619;\n    }\n}\n\nfunction 0xa45() private { \n    assert(msg.sender == _owner);\n    v0 = 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02.call().value(_collectedEthers).gas(2300 * !_collectedEthers);\n    if (v0) {\n        _collectedEthers = 0;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0xed2(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    assert(varg0 <= _balanceOf[v1]);\n    v2 = address(varg1);\n    _balanceOf[v2] = _balanceOf[v1] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(address(varg1), varg0);\n    emit Transfer(address(varg1), 0, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x787e9137 > v0) {\n            if (0x2ff2e9dc > v0) {\n                if (0x200b10d == v0) {\n                    collectedEthers();\n                } else if (0x6fdde03 == v0) {\n                    name();\n                } else if (0x7da68f5 == v0) {\n                    stop();\n                } else if (0x95ea7b3 == v0) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x42966c68 > v0) {\n                if (0x2ff2e9dc == v0) {\n                    INITIAL_SUPPLY();\n                } else if (0x3ccfd60b == v0) {\n                    withdraw();\n                } else if (0x4042b66f == v0) {\n                    weiRaised();\n                }\n            } else if (0x42966c68 == v0) {\n                burn(uint256);\n            } else if (0x518ab2a8 == v0) {\n                tokensSold();\n            } else if (0x66188463 == v0) {\n                decreaseApproval(address,uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            }\n        } else if (0xa035b1fe > v0) {\n            if (0x787e9137 == v0) {\n                collectedTokens();\n            } else if (0x78e97925 == v0) {\n                startTime();\n            } else if (0x79cc6790 == v0) {\n                burnFrom(address,uint256);\n            } else if (0x7b352962 == v0) {\n                isFinished();\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            }\n        } else if (0xa9059cbb > v0) {\n            if (0xa035b1fe == v0) {\n                price();\n            } else if (0xa2b40d19 == v0) {\n                changePrice(uint256);\n            } else if (0xa3e67610 == v0) {\n                tokenOwner();\n            }\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xd73dd623 == v0) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 02:54 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _price; // STORAGE[0x4]\nuint256 _collectedTokens; // STORAGE[0x5]\nuint256 _collectedEthers; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _weiRaised; // STORAGE[0x8]\nuint256 _tokensSold; // STORAGE[0x9]\nuint8 _isFinished; // STORAGE[0xa] bytes 0 to 0\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint256 stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8; // STORAGE[0xcaeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8]\n\n// Events\nApproval(address, address, uint256);\nBurn(address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(block.timestamp >= _startTime);\n    assert(!_isFinished);\n    assert(_price);\n    assert(msg.value / _price + _tokensSold >= _tokensSold);\n    assert(msg.value / _price + _tokensSold <= _totalSupply);\n    assert(_totalSupply - (msg.value / _price + _tokensSold) >= 0);\n    assert(msg.value >= _price);\n    assert(_price);\n    MEM[0] = 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02;\n    MEM[32] = 0;\n    assert(msg.value / _price <= stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8);\n    stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8 = stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8 - msg.value / _price;\n    assert(msg.value / _price + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value / _price;\n    assert(msg.value / _price + _collectedTokens >= _collectedTokens);\n    _collectedTokens += msg.value / _price;\n    assert(msg.value + _collectedEthers >= _collectedEthers);\n    _collectedEthers += msg.value;\n    assert(msg.value + _weiRaised >= _weiRaised);\n    _weiRaised += msg.value;\n    assert(msg.value / _price + _tokensSold >= _tokensSold);\n    _tokensSold += msg.value / _price;\n    emit Transfer(0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02, msg.sender, msg.value / _price);\n}\n\nfunction collectedEthers() public nonPayable { \n    return _collectedEthers;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'COINDOGS';\n    }\n    return v0;\n}\n\nfunction stop() public nonPayable { \n    assert(msg.sender == _owner);\n    _isFinished = 1;\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1);\n    v0 = v1 = varg2 <= _balanceOf[varg0];\n    if (varg2 <= _balanceOf[varg0]) {\n        v0 = v2 = _balanceOf[varg1] + varg2 >= _balanceOf[varg1];\n    }\n    require(v0);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction INITIAL_SUPPLY() public nonPayable { \n    return 0x17d7840;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0xa45();\n    return v0;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xed2(varg0, msg.sender);\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction collectedTokens() public nonPayable { \n    return _collectedTokens;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _allowance[msg.sender]);\n    assert(varg1 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    0xed2(varg1, varg0);\n}\n\nfunction isFinished() public nonPayable { \n    return _isFinished;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x444f470000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction changePrice(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.sender == _owner);\n    _price = varg0;\n}\n\nfunction tokenOwner() public nonPayable { \n    return 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0);\n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = v2 = _balanceOf[varg0] + varg1 >= _balanceOf[varg0];\n    }\n    require(v0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 + _allowance[varg0] >= _allowance[varg0]);\n    _allowance[varg0] += varg1;\n    emit Approval(msg.sender, varg0, varg1 + _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.sender == _owner);\n    if (varg0) {\n        _owner = varg0;\n        goto 0x3d70x619;\n    }\n}\n\nfunction 0xa45() private { \n    assert(msg.sender == _owner);\n    v0 = 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02.call().value(_collectedEthers).gas(2300 * !_collectedEthers);\n    if (v0) {\n        _collectedEthers = 0;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0xed2(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    assert(varg0 <= _balanceOf[v1]);\n    v2 = address(varg1);\n    _balanceOf[v2] = _balanceOf[v1] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(address(varg1), varg0);\n    emit Transfer(address(varg1), 0, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x787e9137 > v0) {\n            if (0x2ff2e9dc > v0) {\n                if (0x200b10d == v0) {\n                    collectedEthers();\n                } else if (0x6fdde03 == v0) {\n                    name();\n                } else if (0x7da68f5 == v0) {\n                    stop();\n                } else if (0x95ea7b3 == v0) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x42966c68 > v0) {\n                if (0x2ff2e9dc == v0) {\n                    INITIAL_SUPPLY();\n                } else if (0x3ccfd60b == v0) {\n                    withdraw();\n                } else if (0x4042b66f == v0) {\n                    weiRaised();\n                }\n            } else if (0x42966c68 == v0) {\n                burn(uint256);\n            } else if (0x518ab2a8 == v0) {\n                tokensSold();\n            } else if (0x66188463 == v0) {\n                decreaseApproval(address,uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            }\n        } else if (0xa035b1fe > v0) {\n            if (0x787e9137 == v0) {\n                collectedTokens();\n            } else if (0x78e97925 == v0) {\n                startTime();\n            } else if (0x79cc6790 == v0) {\n                burnFrom(address,uint256);\n            } else if (0x7b352962 == v0) {\n                isFinished();\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            }\n        } else if (0xa9059cbb > v0) {\n            if (0xa035b1fe == v0) {\n                price();\n            } else if (0xa2b40d19 == v0) {\n                changePrice(uint256);\n            } else if (0xa3e67610 == v0) {\n                tokenOwner();\n            }\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xd73dd623 == v0) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 02:54 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nuint256 _totalSupply; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256 _price; // STORAGE[0x4]\nuint256 _collectedTokens; // STORAGE[0x5]\nuint256 _collectedEthers; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _weiRaised; // STORAGE[0x8]\nuint256 _tokensSold; // STORAGE[0x9]\nuint8 _isFinished; // STORAGE[0xa] bytes 0 to 0\naddress _owner; // STORAGE[0x3] bytes 0 to 19\nuint256 stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8; // STORAGE[0xcaeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8]\n\n// Events\nApproval(address, address, uint256);\nBurn(address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(block.timestamp >= _startTime);\n    assert(!_isFinished);\n    assert(_price);\n    assert(msg.value / _price + _tokensSold >= _tokensSold);\n    assert(msg.value / _price + _tokensSold <= _totalSupply);\n    assert(_totalSupply - (msg.value / _price + _tokensSold) >= 0);\n    assert(msg.value >= _price);\n    assert(_price);\n    MEM[0] = 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02;\n    MEM[32] = 0;\n    assert(msg.value / _price <= stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8);\n    stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8 = stor_caeca7ca587cea9299dbd600331107887518175f7851162f2f92fabb06a9efd8 - msg.value / _price;\n    assert(msg.value / _price + _balanceOf[msg.sender] >= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] += msg.value / _price;\n    assert(msg.value / _price + _collectedTokens >= _collectedTokens);\n    _collectedTokens += msg.value / _price;\n    assert(msg.value + _collectedEthers >= _collectedEthers);\n    _collectedEthers += msg.value;\n    assert(msg.value + _weiRaised >= _weiRaised);\n    _weiRaised += msg.value;\n    assert(msg.value / _price + _tokensSold >= _tokensSold);\n    _tokensSold += msg.value / _price;\n    emit Transfer(0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02, msg.sender, msg.value / _price);\n}\n\nfunction collectedEthers() public nonPayable { \n    return _collectedEthers;\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'COINDOGS';\n    }\n    return v0;\n}\n\nfunction stop() public nonPayable { \n    assert(msg.sender == _owner);\n    _isFinished = 1;\n    return 1;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg1);\n    v0 = v1 = varg2 <= _balanceOf[varg0];\n    if (varg2 <= _balanceOf[varg0]) {\n        v0 = v2 = _balanceOf[varg1] + varg2 >= _balanceOf[varg1];\n    }\n    require(v0);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 + _balanceOf[varg1] >= _balanceOf[varg1]);\n    _balanceOf[varg1] += varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction INITIAL_SUPPLY() public nonPayable { \n    return 0x17d7840;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0xa45();\n    return v0;\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xed2(varg0, msg.sender);\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction decreaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    if (varg1 <= _allowance[varg0]) {\n        assert(varg1 <= _allowance[varg0]);\n        _allowance[varg0] = _allowance[varg0] - varg1;\n    } else {\n        _allowance[varg0] = 0;\n    }\n    emit Approval(msg.sender, varg0, _allowance[varg0]);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction collectedTokens() public nonPayable { \n    return _collectedTokens;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _allowance[msg.sender]);\n    assert(varg1 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    0xed2(varg1, varg0);\n}\n\nfunction isFinished() public nonPayable { \n    return _isFinished;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x444f470000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction changePrice(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.sender == _owner);\n    _price = varg0;\n}\n\nfunction tokenOwner() public nonPayable { \n    return 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0);\n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = v2 = _balanceOf[varg0] + varg1 >= _balanceOf[varg0];\n    }\n    require(v0);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 + _balanceOf[varg0] >= _balanceOf[varg0]);\n    _balanceOf[varg0] += varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction increaseApproval(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    assert(varg1 + _allowance[varg0] >= _allowance[varg0]);\n    _allowance[varg0] += varg1;\n    emit Approval(msg.sender, varg0, varg1 + _allowance[varg0]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(msg.sender == _owner);\n    if (varg0) {\n        _owner = varg0;\n        goto 0x3d70x619;\n    }\n}\n\nfunction 0xa45() private { \n    assert(msg.sender == _owner);\n    v0 = 0xb30e79f1808fc364432fa4c73b7e0a5ba8c8fb02.call().value(_collectedEthers).gas(2300 * !_collectedEthers);\n    if (v0) {\n        _collectedEthers = 0;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction 0xed2(uint256 varg0, uint256 varg1) private { \n    v0 = address(varg1);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    assert(varg0 <= _balanceOf[v1]);\n    v2 = address(varg1);\n    _balanceOf[v2] = _balanceOf[v1] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(address(varg1), varg0);\n    emit Transfer(address(varg1), 0, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x787e9137 > v0) {\n            if (0x2ff2e9dc > v0) {\n                if (0x200b10d == v0) {\n                    collectedEthers();\n                } else if (0x6fdde03 == v0) {\n                    name();\n                } else if (0x7da68f5 == v0) {\n                    stop();\n                } else if (0x95ea7b3 == v0) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x42966c68 > v0) {\n                if (0x2ff2e9dc == v0) {\n                    INITIAL_SUPPLY();\n                } else if (0x3ccfd60b == v0) {\n                    withdraw();\n                } else if (0x4042b66f == v0) {\n                    weiRaised();\n                }\n            } else if (0x42966c68 == v0) {\n                burn(uint256);\n            } else if (0x518ab2a8 == v0) {\n                tokensSold();\n            } else if (0x66188463 == v0) {\n                decreaseApproval(address,uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            }\n        } else if (0xa035b1fe > v0) {\n            if (0x787e9137 == v0) {\n                collectedTokens();\n            } else if (0x78e97925 == v0) {\n                startTime();\n            } else if (0x79cc6790 == v0) {\n                burnFrom(address,uint256);\n            } else if (0x7b352962 == v0) {\n                isFinished();\n            } else if (0x8da5cb5b == v0) {\n                owner();\n            } else if (0x95d89b41 == v0) {\n                symbol();\n            }\n        } else if (0xa9059cbb > v0) {\n            if (0xa035b1fe == v0) {\n                price();\n            } else if (0xa2b40d19 == v0) {\n                changePrice(uint256);\n            } else if (0xa3e67610 == v0) {\n                tokenOwner();\n            }\n        } else if (0xa9059cbb == v0) {\n            transfer(address,uint256);\n        } else if (0xd73dd623 == v0) {\n            increaseApproval(address,uint256);\n        } else if (0xdd62ed3e == v0) {\n            allowance(address,address);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 35.76696515083313,
	"usage": {
		"completion_tokens": 697,
		"prompt_tokens": 3244,
		"total_tokens": 3941
	}
}