{
	"address": "0xc0829421c1d260bd3cb3e0f06cfe2d52db2ce315",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract equivalent to the decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    address public owner;\n    address public newOwner;\n    string public standard;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event OwnerUpdate(address _prevOwner, address _newOwner);\n    event Issuance(uint256 _amount);\n    event Destruction(uint256 _amount);\n\n    constructor() public {\n        owner = msg.sender;\n        // Initialize other variables as per requirement.\n    }\n\n    function transferOwnership(address _newOwner) public {\n        require(msg.sender == owner);\n        require(_newOwner != owner);\n        newOwner = _newOwner;\n    }\n\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnerUpdate(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n\n    function deposit() payable public {\n        require(balanceOf[msg.sender] + msg.value >= balanceOf[msg.sender]);\n        balanceOf[msg.sender] += msg.value;\n        require(totalSupply + msg.value >= totalSupply);\n        totalSupply += msg.value;\n        emit Issuance(msg.value);\n        emit Transfer(msg.sender, address(this), msg.value);\n    }\n\n    // The function \"withdrawTokens\" is not implemented here because it's not possible to call methods on other contracts without knowing the interface of the contract\n\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        allowance[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function withdraw(uint256 _amount) public {\n        require(balanceOf[msg.sender] >= _amount);\n        balanceOf[msg.sender] -= _amount;\n        require(totalSupply >= _amount);\n        totalSupply -= _amount;\n        msg.sender.transfer(_amount);\n        emit Transfer(msg.sender, address(0), _amount);\n        emit Destruction(_amount);\n    }\n\n    // The function \"withdrawTo\" is similar to \"withdraw\" but transfers to a different address\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= balanceOf[_from]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n```",
				"role": "assistant"
			}
		}
	],
	"created": 1700473388,
	"id": "chatcmpl-8Mv64NNHRgLQapGyHg8A8gFD8uN9i",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  newOwner is address at storage 1\n  standard is array of uint256 at storage 2\n  name is array of uint256 at storage 3\n  symbol is array of uint256 at storage 4\n  decimals is uint8 at storage 5\n  totalSupply is uint256 at storage 6\n  balanceOf is mapping of uint256 at storage 7\n  allowance is mapping of uint256 at storage 8\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef decimals(): # not payable\n  return decimals\n\ndef standard(): # not payable\n  return standard[0 len standard.length]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[account]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[owner][spender]\n\n#\n#  Regular functions\n#\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require owner != newOwner\n  newOwner = newOwner\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnerUpdate(\n        address _prevOwner=owner,\n        address _newOwner=newOwner)\n  owner = newOwner\n  newOwner = 0\n\ndef deposit() payable: \n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 _amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 value=caller)\n\ndef withdrawTokens(address _token, address _to, uint256 _amount): # not payable\n  require owner == caller\n  require _token\n  require _to\n  require _to != this.address\n  require ext_code.size(_token)\n  call _token.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args address(_to), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n\ndef approve(address spender, uint256 amount): # not payable\n  require spender\n  if amount:\n      require not allowance[caller][address(spender)]\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef _fallback(?) payable: # default function\n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 _amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 value=caller)\n\ndef withdraw(uint256 amount): # not payable\n  require this.address != caller\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require totalSupply >= amount\n  totalSupply -= amount\n  call caller with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=this.address)\n  log Destruction(uint256 _amount=amount)\n\ndef withdrawTo(address to, uint256 amount): # not payable\n  require to != this.address\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require totalSupply >= amount\n  totalSupply -= amount\n  call to with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=this.address)\n  log Destruction(uint256 _amount=amount)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require recipient != this.address\n  require recipient\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient != this.address\n  require sender\n  require recipient\n  require allowance[address(sender)][caller] >= amount\n  allowance[address(sender)][caller] -= amount\n  require balanceOf[address(sender)] >= amount\n  balanceOf[address(sender)] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  newOwner is address at storage 1\n  standard is array of uint256 at storage 2\n  name is array of uint256 at storage 3\n  symbol is array of uint256 at storage 4\n  decimals is uint8 at storage 5\n  totalSupply is uint256 at storage 6\n  balanceOf is mapping of uint256 at storage 7\n  allowance is mapping of uint256 at storage 8\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef decimals(): # not payable\n  return decimals\n\ndef standard(): # not payable\n  return standard[0 len standard.length]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[account]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[owner][spender]\n\n#\n#  Regular functions\n#\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require owner != newOwner\n  newOwner = newOwner\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnerUpdate(\n        address _prevOwner=owner,\n        address _newOwner=newOwner)\n  owner = newOwner\n  newOwner = 0\n\ndef deposit() payable: \n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 _amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 value=caller)\n\ndef withdrawTokens(address _token, address _to, uint256 _amount): # not payable\n  require owner == caller\n  require _token\n  require _to\n  require _to != this.address\n  require ext_code.size(_token)\n  call _token.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args address(_to), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n\ndef approve(address spender, uint256 amount): # not payable\n  require spender\n  if amount:\n      require not allowance[caller][address(spender)]\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef _fallback(?) payable: # default function\n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 _amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 value=caller)\n\ndef withdraw(uint256 amount): # not payable\n  require this.address != caller\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require totalSupply >= amount\n  totalSupply -= amount\n  call caller with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=this.address)\n  log Destruction(uint256 _amount=amount)\n\ndef withdrawTo(address to, uint256 amount): # not payable\n  require to != this.address\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require totalSupply >= amount\n  totalSupply -= amount\n  call to with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=this.address)\n  log Destruction(uint256 _amount=amount)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require recipient != this.address\n  require recipient\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient != this.address\n  require sender\n  require recipient\n  require allowance[address(sender)][caller] >= amount\n  allowance[address(sender)][caller] -= amount\n  require balanceOf[address(sender)] >= amount\n  balanceOf[address(sender)] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  newOwner is address at storage 1\n  standard is array of uint256 at storage 2\n  name is array of uint256 at storage 3\n  symbol is array of uint256 at storage 4\n  decimals is uint8 at storage 5\n  totalSupply is uint256 at storage 6\n  balanceOf is mapping of uint256 at storage 7\n  allowance is mapping of uint256 at storage 8\n\ndef name(): # not payable\n  return name[0 len name.length]\n\ndef totalSupply(): # not payable\n  return totalSupply\n\ndef decimals(): # not payable\n  return decimals\n\ndef standard(): # not payable\n  return standard[0 len standard.length]\n\ndef balanceOf(address account): # not payable\n  return balanceOf[account]\n\ndef owner(): # not payable\n  return owner\n\ndef symbol(): # not payable\n  return symbol[0 len symbol.length]\n\ndef newOwner(): # not payable\n  return newOwner\n\ndef allowance(address owner, address spender): # not payable\n  return allowance[owner][spender]\n\n#\n#  Regular functions\n#\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  require owner != newOwner\n  newOwner = newOwner\n\ndef acceptOwnership(): # not payable\n  require newOwner == caller\n  log OwnerUpdate(\n        address _prevOwner=owner,\n        address _newOwner=newOwner)\n  owner = newOwner\n  newOwner = 0\n\ndef deposit() payable: \n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 _amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 value=caller)\n\ndef withdrawTokens(address _token, address _to, uint256 _amount): # not payable\n  require owner == caller\n  require _token\n  require _to\n  require _to != this.address\n  require ext_code.size(_token)\n  call _token.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args address(_to), _amount\n  require ext_call.success\n  require ext_call.return_data[0]\n\ndef approve(address spender, uint256 amount): # not payable\n  require spender\n  if amount:\n      require not allowance[caller][address(spender)]\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef _fallback(?) payable: # default function\n  require call.value + balanceOf[caller] >= balanceOf[caller]\n  balanceOf[caller] += call.value\n  require call.value + totalSupply >= totalSupply\n  totalSupply += call.value\n  log Issuance(uint256 _amount=call.value)\n  log Transfer(\n        address from=call.value,\n        address to=this.address,\n        uint256 value=caller)\n\ndef withdraw(uint256 amount): # not payable\n  require this.address != caller\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require totalSupply >= amount\n  totalSupply -= amount\n  call caller with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=this.address)\n  log Destruction(uint256 _amount=amount)\n\ndef withdrawTo(address to, uint256 amount): # not payable\n  require to != this.address\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require totalSupply >= amount\n  totalSupply -= amount\n  call to with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=this.address)\n  log Destruction(uint256 _amount=amount)\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require recipient != this.address\n  require recipient\n  require balanceOf[caller] >= amount\n  balanceOf[caller] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=caller,\n        uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require recipient != this.address\n  require sender\n  require recipient\n  require allowance[address(sender)][caller] >= amount\n  allowance[address(sender)][caller] -= amount\n  require balanceOf[address(sender)] >= amount\n  balanceOf[address(sender)] -= amount\n  require amount + balanceOf[recipient] >= balanceOf[recipient]\n  balanceOf[address(recipient)] = amount + balanceOf[recipient]\n  log Transfer(\n        address from=amount,\n        address to=sender,\n        uint256 value=recipient)\n  return 1\n\n.",
	"status": "1",
	"time_cost": 54.62954354286194,
	"usage": {
		"completion_tokens": 666,
		"prompt_tokens": 1198,
		"total_tokens": 1864
	}
}