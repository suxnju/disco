{
	"address": "0xf9a5e0436c01cc15708449e480fa5f2d6a5b55ca",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code derived from the decompiled code you provided.\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MultiSigWallet {\n\n    event Deposit(address indexed sender, uint value);\n    event OwnerRemoval(address indexed owner);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event OwnerAddition(address indexed owner);\n    event RequirementChange(uint required);\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Submission(uint indexed transactionId);\n\n    mapping (uint => Transaction) public transactions;\n    mapping (uint => mapping(address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    modifier onlyWallet() {\n        require(msg.sender == address(this));\n        _;\n    }\n\n    modifier ownerDoesNotExist(address _owner) {\n        require(!isOwner[_owner]);\n        _;\n    }\n\n    modifier ownerExists(address _owner) {\n        require(isOwner[_owner]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require(transactions[transactionId].destination != address(0));\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address _owner) {\n        require(confirmations[transactionId][_owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address _owner) {\n        require(!confirmations[transactionId][_owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier validRequirement(uint _ownerCount, uint _required) {\n        if (_required > _ownerCount || _required == 0 || _ownerCount == 0)\n            revert();\n        _;\n    }\n\n    // other functions are omitted for brevity\n}\n```\n\nNote: The actual contract code might be slightly different from this one. This is due to the fact that some information might be lost during the bytecode compilation process. However, the overall structure of the contract should be similar.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040556,
	"id": "chatcmpl-8CiCqdrXPm1q9a1GHYxZ8TNeKtehi",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.13 18:49 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x128f(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xab4(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n            if (31 < (v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length = _owners.length + ~0;\n    if (!_owners.length <= _owners.length + ~0) {\n        v2 = v3 = _owners.length + ~0 + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0xf38(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    assert(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    assert(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        if (keccak256(3) + _owners.length > _owners.length + 1 + keccak256(3)) {\n            _owners[_owners.length + 1] = 0;\n            v4 = v5 = 1 + (_owners.length + 1 + keccak256(3));\n            while (keccak256(3) + _owners.length > v4) {\n                STORAGE[v4] = 0;\n                v4 += 1;\n            }\n        }\n        goto 0xa49B0x15fd;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xab4(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64] + 32;\n    if (_owners.length) {\n        do {\n            MEM[v0] = address(STORAGE[v2]);\n            v2 = v2 + 1;\n            v0 += 32;\n        } while (v1 + (_owners.length << 5) <= v0);\n    }\n    v3 = new array[](_owners.length);\n    v4 = v5 = v3.data;\n    v6 = 32 + MEM[64];\n    v7 = v8 = _owners.length << 5;\n    if (v8) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v7 <= 32) {\n                break;\n            }\n            v7 = v7 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    return v3;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new uint256[](_transactionCount);\n    }\n    v3 = new uint256[](_transactionCount);\n    v6 = v7 = 0;\n    v8 = v9 = 0;\n    while (v8 < _transactionCount) {\n        if (v1) {\n            v0 = v10 = !(0xff & _transactions[v8][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v11 = 0xff & _transactions[v8][0x3];\n            }\n        }\n        if (v0) {\n            assert(v6 < v3.length);\n            v5[v6] = v8;\n            v6 += 1;\n        }\n        v8 += 1;\n    }\n    v12 = v13 = MEM[64];\n    if (MSIZE() >= v13) {\n        v12 = v14 = new uint256[](varg1 - varg0);\n    }\n    v12 = new uint256[](varg1 - varg0);\n    while (v15 < varg1) {\n        assert(v15 < v3.length);\n        assert(v15 - varg0 < v12.length);\n        v14[v15 - varg0] = v5[v15];\n        v15 += 1;\n    }\n    v16 = new array[](v12.length);\n    v17 = v18 = v16.data;\n    v19 = v14.data;\n    v20 = v21 = v12.length << 5;\n    if (v21) {\n        while (1) {\n            MEM[v17] = MEM[v19];\n            if (v20 <= 32) {\n                break;\n            }\n            v20 = v20 + ~31;\n            v17 += 32;\n            v19 += 32;\n        }\n    }\n    return v16;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    if (MSIZE() >= v1) {\n        v0 = v2 = new uint256[](_owners.length);\n    }\n    v0 = new uint256[](_owners.length);\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _owners.length) {\n        assert(v5 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v5]), keccak256(varg0, 0x1))]) {\n            assert(v5 < _owners.length);\n            assert(v3 < v0.length);\n            v2[v3] = address(_owners[v5]);\n            v3 += 1;\n        }\n        v5 += 1;\n    }\n    v7 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v7 = v9 = new uint256[](v3);\n    }\n    v7 = new uint256[](v3);\n    v10 = v11 = 0;\n    while (v10 < v3) {\n        assert(v10 < v0.length);\n        assert(v10 < v7.length);\n        v9[v10] = address(v2[v10]);\n        v10 += 1;\n    }\n    v12 = new array[](v7.length);\n    v13 = v14 = v12.data;\n    v15 = v9.data;\n    v16 = v17 = v7.length << 5;\n    if (v17) {\n        while (1) {\n            MEM[v13] = MEM[v15];\n            if (v16 <= 32) {\n                break;\n            }\n            v16 = v16 + ~31;\n            v13 += 32;\n            v15 += 32;\n        }\n    }\n    return v12;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xf38(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xfc6(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    assert(varg0);\n    MEM[64] = MEM[64] + 128;\n    _transactions[_transactionCount] = _transactions[_transactionCount] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = v0 + 32;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    if (v4 + (31 + ((~0 + (!(_transactions[_transactionCount][0x2] & 0x1) << 8) & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v5 = v6 = 1 + v3;\n        while (v4 + (31 + ((~0 + (!(_transactions[_transactionCount][0x2] & 0x1) << 8) & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfc6(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    assert(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x128f(varg0);\n}\n\nfunction 0xab4(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb3f;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf38(uint256 varg0) private { \n    assert(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfc6(uint256 varg0) private { \n    assert(0xff & _isOwner[msg.sender]);\n    assert(address(_transactions[varg0]));\n    assert(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x128f(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 18:49 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x128f(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xab4(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n            if (31 < (v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length = _owners.length + ~0;\n    if (!_owners.length <= _owners.length + ~0) {\n        v2 = v3 = _owners.length + ~0 + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0xf38(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    assert(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    assert(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        if (keccak256(3) + _owners.length > _owners.length + 1 + keccak256(3)) {\n            _owners[_owners.length + 1] = 0;\n            v4 = v5 = 1 + (_owners.length + 1 + keccak256(3));\n            while (keccak256(3) + _owners.length > v4) {\n                STORAGE[v4] = 0;\n                v4 += 1;\n            }\n        }\n        goto 0xa49B0x15fd;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xab4(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64] + 32;\n    if (_owners.length) {\n        do {\n            MEM[v0] = address(STORAGE[v2]);\n            v2 = v2 + 1;\n            v0 += 32;\n        } while (v1 + (_owners.length << 5) <= v0);\n    }\n    v3 = new array[](_owners.length);\n    v4 = v5 = v3.data;\n    v6 = 32 + MEM[64];\n    v7 = v8 = _owners.length << 5;\n    if (v8) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v7 <= 32) {\n                break;\n            }\n            v7 = v7 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    return v3;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new uint256[](_transactionCount);\n    }\n    v3 = new uint256[](_transactionCount);\n    v6 = v7 = 0;\n    v8 = v9 = 0;\n    while (v8 < _transactionCount) {\n        if (v1) {\n            v0 = v10 = !(0xff & _transactions[v8][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v11 = 0xff & _transactions[v8][0x3];\n            }\n        }\n        if (v0) {\n            assert(v6 < v3.length);\n            v5[v6] = v8;\n            v6 += 1;\n        }\n        v8 += 1;\n    }\n    v12 = v13 = MEM[64];\n    if (MSIZE() >= v13) {\n        v12 = v14 = new uint256[](varg1 - varg0);\n    }\n    v12 = new uint256[](varg1 - varg0);\n    while (v15 < varg1) {\n        assert(v15 < v3.length);\n        assert(v15 - varg0 < v12.length);\n        v14[v15 - varg0] = v5[v15];\n        v15 += 1;\n    }\n    v16 = new array[](v12.length);\n    v17 = v18 = v16.data;\n    v19 = v14.data;\n    v20 = v21 = v12.length << 5;\n    if (v21) {\n        while (1) {\n            MEM[v17] = MEM[v19];\n            if (v20 <= 32) {\n                break;\n            }\n            v20 = v20 + ~31;\n            v17 += 32;\n            v19 += 32;\n        }\n    }\n    return v16;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    if (MSIZE() >= v1) {\n        v0 = v2 = new uint256[](_owners.length);\n    }\n    v0 = new uint256[](_owners.length);\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _owners.length) {\n        assert(v5 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v5]), keccak256(varg0, 0x1))]) {\n            assert(v5 < _owners.length);\n            assert(v3 < v0.length);\n            v2[v3] = address(_owners[v5]);\n            v3 += 1;\n        }\n        v5 += 1;\n    }\n    v7 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v7 = v9 = new uint256[](v3);\n    }\n    v7 = new uint256[](v3);\n    v10 = v11 = 0;\n    while (v10 < v3) {\n        assert(v10 < v0.length);\n        assert(v10 < v7.length);\n        v9[v10] = address(v2[v10]);\n        v10 += 1;\n    }\n    v12 = new array[](v7.length);\n    v13 = v14 = v12.data;\n    v15 = v9.data;\n    v16 = v17 = v7.length << 5;\n    if (v17) {\n        while (1) {\n            MEM[v13] = MEM[v15];\n            if (v16 <= 32) {\n                break;\n            }\n            v16 = v16 + ~31;\n            v13 += 32;\n            v15 += 32;\n        }\n    }\n    return v12;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xf38(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xfc6(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    assert(varg0);\n    MEM[64] = MEM[64] + 128;\n    _transactions[_transactionCount] = _transactions[_transactionCount] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = v0 + 32;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    if (v4 + (31 + ((~0 + (!(_transactions[_transactionCount][0x2] & 0x1) << 8) & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v5 = v6 = 1 + v3;\n        while (v4 + (31 + ((~0 + (!(_transactions[_transactionCount][0x2] & 0x1) << 8) & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfc6(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    assert(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x128f(varg0);\n}\n\nfunction 0xab4(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb3f;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf38(uint256 varg0) private { \n    assert(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfc6(uint256 varg0) private { \n    assert(0xff & _isOwner[msg.sender]);\n    assert(address(_transactions[varg0]));\n    assert(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x128f(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 18:49 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x128f(uint256 varg0) private { \n    assert(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xab4(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n            if (31 < (v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34050);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length = _owners.length + ~0;\n    if (!_owners.length <= _owners.length + ~0) {\n        v2 = v3 = _owners.length + ~0 + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0xf38(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(0xff & _isOwner[msg.sender]);\n    assert(0xff & _confirmations[msg.sender]);\n    assert(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(!(0xff & _isOwner[varg0]));\n    assert(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    assert(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        if (keccak256(3) + _owners.length > _owners.length + 1 + keccak256(3)) {\n            _owners[_owners.length + 1] = 0;\n            v4 = v5 = 1 + (_owners.length + 1 + keccak256(3));\n            while (keccak256(3) + _owners.length > v4) {\n                STORAGE[v4] = 0;\n                v4 += 1;\n            }\n        }\n        goto 0xa49B0x15fd;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xab4(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64] + 32;\n    if (_owners.length) {\n        do {\n            MEM[v0] = address(STORAGE[v2]);\n            v2 = v2 + 1;\n            v0 += 32;\n        } while (v1 + (_owners.length << 5) <= v0);\n    }\n    v3 = new array[](_owners.length);\n    v4 = v5 = v3.data;\n    v6 = 32 + MEM[64];\n    v7 = v8 = _owners.length << 5;\n    if (v8) {\n        while (1) {\n            MEM[v4] = MEM[v6];\n            if (v7 <= 32) {\n                break;\n            }\n            v7 = v7 + ~31;\n            v4 += 32;\n            v6 += 32;\n        }\n    }\n    return v3;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v3 = v4 = MEM[64];\n    if (MSIZE() >= v4) {\n        v3 = v5 = new uint256[](_transactionCount);\n    }\n    v3 = new uint256[](_transactionCount);\n    v6 = v7 = 0;\n    v8 = v9 = 0;\n    while (v8 < _transactionCount) {\n        if (v1) {\n            v0 = v10 = !(0xff & _transactions[v8][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v11 = 0xff & _transactions[v8][0x3];\n            }\n        }\n        if (v0) {\n            assert(v6 < v3.length);\n            v5[v6] = v8;\n            v6 += 1;\n        }\n        v8 += 1;\n    }\n    v12 = v13 = MEM[64];\n    if (MSIZE() >= v13) {\n        v12 = v14 = new uint256[](varg1 - varg0);\n    }\n    v12 = new uint256[](varg1 - varg0);\n    while (v15 < varg1) {\n        assert(v15 < v3.length);\n        assert(v15 - varg0 < v12.length);\n        v14[v15 - varg0] = v5[v15];\n        v15 += 1;\n    }\n    v16 = new array[](v12.length);\n    v17 = v18 = v16.data;\n    v19 = v14.data;\n    v20 = v21 = v12.length << 5;\n    if (v21) {\n        while (1) {\n            MEM[v17] = MEM[v19];\n            if (v20 <= 32) {\n                break;\n            }\n            v20 = v20 + ~31;\n            v17 += 32;\n            v19 += 32;\n        }\n    }\n    return v16;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    MEM[MEM[64]] = 0;\n    MEM[MEM[64]] = 0;\n    v0 = v1 = MEM[64];\n    if (MSIZE() >= v1) {\n        v0 = v2 = new uint256[](_owners.length);\n    }\n    v0 = new uint256[](_owners.length);\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _owners.length) {\n        assert(v5 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v5]), keccak256(varg0, 0x1))]) {\n            assert(v5 < _owners.length);\n            assert(v3 < v0.length);\n            v2[v3] = address(_owners[v5]);\n            v3 += 1;\n        }\n        v5 += 1;\n    }\n    v7 = v8 = MEM[64];\n    if (MSIZE() >= v8) {\n        v7 = v9 = new uint256[](v3);\n    }\n    v7 = new uint256[](v3);\n    v10 = v11 = 0;\n    while (v10 < v3) {\n        assert(v10 < v0.length);\n        assert(v10 < v7.length);\n        v9[v10] = address(v2[v10]);\n        v10 += 1;\n    }\n    v12 = new array[](v7.length);\n    v13 = v14 = v12.data;\n    v15 = v9.data;\n    v16 = v17 = v7.length << 5;\n    if (v17) {\n        while (1) {\n            MEM[v13] = MEM[v15];\n            if (v16 <= 32) {\n                break;\n            }\n            v16 = v16 + ~31;\n            v13 += 32;\n            v15 += 32;\n        }\n    }\n    return v12;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xf38(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xfc6(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg2 + 36, (?).length);\n    assert(varg0);\n    MEM[64] = MEM[64] + 128;\n    _transactions[_transactionCount] = _transactions[_transactionCount] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = v0 + 32;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    if (v4 + (31 + ((~0 + (!(_transactions[_transactionCount][0x2] & 0x1) << 8) & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v5 = v6 = 1 + v3;\n        while (v4 + (31 + ((~0 + (!(_transactions[_transactionCount][0x2] & 0x1) << 8) & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfc6(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    assert(msg.sender == address(this));\n    assert(0xff & _isOwner[varg0]);\n    assert(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x128f(varg0);\n}\n\nfunction 0xab4(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb3f;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf38(uint256 varg0) private { \n    assert(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    assert(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfc6(uint256 varg0) private { \n    assert(0xff & _isOwner[msg.sender]);\n    assert(address(_transactions[varg0]));\n    assert(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x128f(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
	"status": "1",
	"time_cost": 26.013559103012085,
	"usage": {
		"completion_tokens": 491,
		"prompt_tokens": 4899,
		"total_tokens": 5390
	}
}