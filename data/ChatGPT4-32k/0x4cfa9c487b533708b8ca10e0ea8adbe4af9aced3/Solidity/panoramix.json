{
	"address": "0x4cfa9c487b533708b8ca10e0ea8adbe4af9aced3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The above decompiled code seems to be a part of an ERC20 token contract with some additional functionalities. Here is a simplified version of the Solidity contract based on the decompiled code:\n\n```solidity\npragma solidity ^0.5.8;\n\ncontract MyToken {\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    address private _owner;\n    address private _governor;\n    address private _factory;\n\n    uint256 private _totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function changeOwner(address newOwner) public {\n        require(msg.sender == _owner, \"Only owner can change the owner\");\n        _owner = newOwner;\n    }\n\n    function burn(address account, uint256 amount) public {\n        require(_balances[account] >= amount, \"Not enough balance\");\n        _balances[account] -= amount;\n        _totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function mint(address account, uint256 amount) public {\n        require(msg.sender == _owner, \"Only owner can mint tokens\");\n        _balances[account] += amount;\n        _totalSupply += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function setGovernorAddress(address governor) public {\n        require(msg.sender == _owner, \"Only owner can set the governor address\");\n        _governor = governor;\n    }\n\n    function setFactoryAddress(address factory) public {\n        require(msg.sender == _owner, \"Only owner can set the factory address\");\n        _factory = factory;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(_balances[msg.sender] >= amount, \"Not enough balance\");\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n}\n```\nPlease note that this is a simplified contract and doesn't cover all the aspects of the decompiled code. The decompiled code seems to have additional logic and checks that are not included in the simplified contract. Also, the part of decompiled code is incomplete (ellipsis '...'), therefore some functions like `name()`, `symbol()`, `decimals()`, and `commission()` were not included.",
				"role": "assistant"
			}
		}
	],
	"created": 1700474536,
	"id": "chatcmpl-8MvOaJ395CbvGoqVXl9PBoJGHpH3C",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor0 is uint256 at storage 0\n  stor1 is uint256 at storage 1\n  stor3 is uint256 at storage 3\n  stor6 is uint256 at storage 6\n  stor7 is uint256 at storage 7\n  stor10 is uint256 at storage 10\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback(?) payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == changeOwner(address _newOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor3\n      stor3 = call.data[4]\n  else:\n      if mem[0 len 28], uint32(call.func_hash) == burn(address account, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[caller][2] == 1\n          require ext_code.size(caller)\n          require caller != this.address\n          static call caller.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_code.size(stor0)\n          require stor0 != this.address\n          static call stor0.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_call.return_data[0] == ext_call.return_data[0]\n          require stor[call.data[4]][8] >= call.data[36]\n          require stor[call.data[4]][8] >= call.data[36]\n          stor[call.data[4]][8] -= call.data[36]\n          require stor10 >= call.data[36]\n          stor10 -= call.data[36]\n          log Transfer(\n                address from=call.data[36],\n                address to=call.data[4],\n                uint256 value=0)\n      else:\n          if mem[0 len 28], uint32(call.func_hash) != mint(address _to, uint256 _amount):\n              if mem[0 len 28], uint32(call.func_hash) == setGovernorAddress(address _governor):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor3\n                  stor0 = call.data[4]\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == setFactoryAddress(address adr):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor3\n                  stor1 = call.data[4]\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == setMinterAddress(address minter):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor1\n                  stor[call.data[4]][2] = 1\n                  log OpenMinter(address _newMinter=call.data[4])\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == removeMinterAddress():\n                  require not call.value\n                  require stor[caller][2] == 1\n                  stor[caller][2] = 0\n                  log CloseMinter(address _oldMinter=caller)\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n                  require not call.value\n                  return stor10\n              if mem[0 len 28], uint32(call.func_hash) != balanceOf(address account):\n                  if mem[0 len 28], uint32(call.func_hash) == transfer(address recipient, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require stor[caller][8] >= call.data[36]\n                      stor[caller][8] -= call.data[36]\n                      require stor[call.data[4]][8] + call.data[36] >= stor[call.data[4]][8]\n                      stor[call.data[4]][8] += call.data[36]\n                      log Transfer(\n                            address from=call.data[36],\n                            address to=caller,\n                            uint256 value=call.data[4])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address sender, address recipient, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require _param2 < 0x10000000000000000000000000000000000000000\n                      require stor[call.data[4]][8] >= call.data[68]\n                      stor[call.data[4]][8] -= call.data[68]\n                      require stor[call.data[36]][8] + call.data[68] >= stor[call.data[36]][8]\n                      stor[call.data[36]][8] += call.data[68]\n                      require stor[caller][('map', 9, ('call.data', 4, 32))] >= call.data[68]\n                      stor[caller][('map', 9, ('call.data', 4, 32))] -= call.data[68]\n                      log Transfer(\n                            address from=call.data[68],\n                            address to=call.data[4],\n                            uint256 value=call.data[36])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      stor[call.data[4]][('map', 9, 'caller')] = call.data[36]\n                      log Approval(\n                            address owner=call.data[36],\n                            address spender=caller,\n                            uint256 value=call.data[4])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == allowance(address owner, address spender):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require _param2 < 0x10000000000000000000000000000000000000000\n                      return stor[call.data[36]][('map', 9, ('call.data', 4, 32))]\n                  if mem[0 len 28], uint32(call.func_hash) == factory_address():\n                      require not call.value\n                      return stor1\n                  if mem[0 len 28], uint32(call.func_hash) == minter_addresses(address arg0):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      return stor[call.data[4]][2]\n                  if mem[0 len 28], uint32(call.func_hash) == owner():\n                      require not call.value\n                      return stor3\n                  if mem[0 len 28], uint32(call.func_hash) == name():\n                      require not call.value\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[0 len 28], uint32(call.func_hash) == symbol():\n                      require not call.value\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[0 len 28], uint32(call.func_hash) == decimals():\n                      require not call.value\n                      return stor6\n                  if mem[0 len 28], uint32(call.func_hash) == commission():\n                      require not call.value\n                      return stor7\n                  require mem[0 len 28], uint32(call.func_hash) == balances(address )\n              require not call.value\n              require _param1 < 0x10000000000000000000000000000000000000000\n              return stor[call.data[4]][8]\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[caller][2] == 1\n          require ext_code.size(caller)\n          require caller != this.address\n          static call caller.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_code.size(stor0)\n          require stor0 != this.address\n          static call stor0.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_call.return_data[0] == ext_call.return_data[0]\n          if not call.data[36]:\n              require stor3[8] >= stor3[8]\n              require call.data[36] >= 0\n              require stor[call.data[4]][8] + call.data[36] >= stor[call.data[4]][8]\n              require call.data[36] >= 0\n              stor[call.data[4]][8] += call.data[36]\n              require stor10 + call.data[36] >= stor10\n              stor10 += call.data[36]\n              require call.data[36] >= 0\n              log Transfer(\n                    address from=call.data[36],\n                    address to=0,\n                    uint256 value=call.data[4])\n              log Transfer(\n                    address from=0,\n                    address to=0,\n                    uint256 value=stor3)\n          else:\n              require call.data[36] * stor7 / call.data[36] == stor7\n              require stor3[8] + (call.data[36] * stor7 / 10000) >= stor3[8]\n              stor3[8] += call.data[36] * stor7 / 10000\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              require stor[call.data[4]][8] + call.data[36] - (call.data[36] * stor7 / 10000) >= stor[call.data[4]][8]\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              stor[call.data[4]][8] = stor[call.data[4]][8] + call.data[36] - (call.data[36] * stor7 / 10000)\n              require stor10 + call.data[36] >= stor10\n              stor10 += call.data[36]\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              log Transfer(\n                    address from=(call.data[36] - (call.data[36] * stor7 / 10000)),\n                    address to=0,\n                    uint256 value=call.data[4])\n              log Transfer(\n                    address from=(call.data[36] * stor7 / 10000),\n                    address to=0,\n                    uint256 value=stor3)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is uint256 at storage 0\n  stor1 is uint256 at storage 1\n  stor3 is uint256 at storage 3\n  stor6 is uint256 at storage 6\n  stor7 is uint256 at storage 7\n  stor10 is uint256 at storage 10\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback(?) payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == changeOwner(address _newOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor3\n      stor3 = call.data[4]\n  else:\n      if mem[0 len 28], uint32(call.func_hash) == burn(address account, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[caller][2] == 1\n          require ext_code.size(caller)\n          require caller != this.address\n          static call caller.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_code.size(stor0)\n          require stor0 != this.address\n          static call stor0.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_call.return_data[0] == ext_call.return_data[0]\n          require stor[call.data[4]][8] >= call.data[36]\n          require stor[call.data[4]][8] >= call.data[36]\n          stor[call.data[4]][8] -= call.data[36]\n          require stor10 >= call.data[36]\n          stor10 -= call.data[36]\n          log Transfer(\n                address from=call.data[36],\n                address to=call.data[4],\n                uint256 value=0)\n      else:\n          if mem[0 len 28], uint32(call.func_hash) != mint(address _to, uint256 _amount):\n              if mem[0 len 28], uint32(call.func_hash) == setGovernorAddress(address _governor):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor3\n                  stor0 = call.data[4]\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == setFactoryAddress(address adr):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor3\n                  stor1 = call.data[4]\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == setMinterAddress(address minter):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor1\n                  stor[call.data[4]][2] = 1\n                  log OpenMinter(address _newMinter=call.data[4])\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == removeMinterAddress():\n                  require not call.value\n                  require stor[caller][2] == 1\n                  stor[caller][2] = 0\n                  log CloseMinter(address _oldMinter=caller)\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n                  require not call.value\n                  return stor10\n              if mem[0 len 28], uint32(call.func_hash) != balanceOf(address account):\n                  if mem[0 len 28], uint32(call.func_hash) == transfer(address recipient, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require stor[caller][8] >= call.data[36]\n                      stor[caller][8] -= call.data[36]\n                      require stor[call.data[4]][8] + call.data[36] >= stor[call.data[4]][8]\n                      stor[call.data[4]][8] += call.data[36]\n                      log Transfer(\n                            address from=call.data[36],\n                            address to=caller,\n                            uint256 value=call.data[4])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address sender, address recipient, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require _param2 < 0x10000000000000000000000000000000000000000\n                      require stor[call.data[4]][8] >= call.data[68]\n                      stor[call.data[4]][8] -= call.data[68]\n                      require stor[call.data[36]][8] + call.data[68] >= stor[call.data[36]][8]\n                      stor[call.data[36]][8] += call.data[68]\n                      require stor[caller][('map', 9, ('call.data', 4, 32))] >= call.data[68]\n                      stor[caller][('map', 9, ('call.data', 4, 32))] -= call.data[68]\n                      log Transfer(\n                            address from=call.data[68],\n                            address to=call.data[4],\n                            uint256 value=call.data[36])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      stor[call.data[4]][('map', 9, 'caller')] = call.data[36]\n                      log Approval(\n                            address owner=call.data[36],\n                            address spender=caller,\n                            uint256 value=call.data[4])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == allowance(address owner, address spender):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require _param2 < 0x10000000000000000000000000000000000000000\n                      return stor[call.data[36]][('map', 9, ('call.data', 4, 32))]\n                  if mem[0 len 28], uint32(call.func_hash) == factory_address():\n                      require not call.value\n                      return stor1\n                  if mem[0 len 28], uint32(call.func_hash) == minter_addresses(address arg0):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      return stor[call.data[4]][2]\n                  if mem[0 len 28], uint32(call.func_hash) == owner():\n                      require not call.value\n                      return stor3\n                  if mem[0 len 28], uint32(call.func_hash) == name():\n                      require not call.value\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[0 len 28], uint32(call.func_hash) == symbol():\n                      require not call.value\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[0 len 28], uint32(call.func_hash) == decimals():\n                      require not call.value\n                      return stor6\n                  if mem[0 len 28], uint32(call.func_hash) == commission():\n                      require not call.value\n                      return stor7\n                  require mem[0 len 28], uint32(call.func_hash) == balances(address )\n              require not call.value\n              require _param1 < 0x10000000000000000000000000000000000000000\n              return stor[call.data[4]][8]\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[caller][2] == 1\n          require ext_code.size(caller)\n          require caller != this.address\n          static call caller.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_code.size(stor0)\n          require stor0 != this.address\n          static call stor0.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_call.return_data[0] == ext_call.return_data[0]\n          if not call.data[36]:\n              require stor3[8] >= stor3[8]\n              require call.data[36] >= 0\n              require stor[call.data[4]][8] + call.data[36] >= stor[call.data[4]][8]\n              require call.data[36] >= 0\n              stor[call.data[4]][8] += call.data[36]\n              require stor10 + call.data[36] >= stor10\n              stor10 += call.data[36]\n              require call.data[36] >= 0\n              log Transfer(\n                    address from=call.data[36],\n                    address to=0,\n                    uint256 value=call.data[4])\n              log Transfer(\n                    address from=0,\n                    address to=0,\n                    uint256 value=stor3)\n          else:\n              require call.data[36] * stor7 / call.data[36] == stor7\n              require stor3[8] + (call.data[36] * stor7 / 10000) >= stor3[8]\n              stor3[8] += call.data[36] * stor7 / 10000\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              require stor[call.data[4]][8] + call.data[36] - (call.data[36] * stor7 / 10000) >= stor[call.data[4]][8]\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              stor[call.data[4]][8] = stor[call.data[4]][8] + call.data[36] - (call.data[36] * stor7 / 10000)\n              require stor10 + call.data[36] >= stor10\n              stor10 += call.data[36]\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              log Transfer(\n                    address from=(call.data[36] - (call.data[36] * stor7 / 10000)),\n                    address to=0,\n                    uint256 value=call.data[4])\n              log Transfer(\n                    address from=(call.data[36] * stor7 / 10000),\n                    address to=0,\n                    uint256 value=stor3)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor0 is uint256 at storage 0\n  stor1 is uint256 at storage 1\n  stor3 is uint256 at storage 3\n  stor6 is uint256 at storage 6\n  stor7 is uint256 at storage 7\n  stor10 is uint256 at storage 10\n  stor99 is mapping of uint256 at storage 99\n\ndef _fallback(?) payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == changeOwner(address _newOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor3\n      stor3 = call.data[4]\n  else:\n      if mem[0 len 28], uint32(call.func_hash) == burn(address account, uint256 amount):\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[caller][2] == 1\n          require ext_code.size(caller)\n          require caller != this.address\n          static call caller.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_code.size(stor0)\n          require stor0 != this.address\n          static call stor0.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_call.return_data[0] == ext_call.return_data[0]\n          require stor[call.data[4]][8] >= call.data[36]\n          require stor[call.data[4]][8] >= call.data[36]\n          stor[call.data[4]][8] -= call.data[36]\n          require stor10 >= call.data[36]\n          stor10 -= call.data[36]\n          log Transfer(\n                address from=call.data[36],\n                address to=call.data[4],\n                uint256 value=0)\n      else:\n          if mem[0 len 28], uint32(call.func_hash) != mint(address _to, uint256 _amount):\n              if mem[0 len 28], uint32(call.func_hash) == setGovernorAddress(address _governor):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor3\n                  stor0 = call.data[4]\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == setFactoryAddress(address adr):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor3\n                  stor1 = call.data[4]\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == setMinterAddress(address minter):\n                  require not call.value\n                  require _param1 < 0x10000000000000000000000000000000000000000\n                  require caller == stor1\n                  stor[call.data[4]][2] = 1\n                  log OpenMinter(address _newMinter=call.data[4])\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == removeMinterAddress():\n                  require not call.value\n                  require stor[caller][2] == 1\n                  stor[caller][2] = 0\n                  log CloseMinter(address _oldMinter=caller)\n                  stop\n              if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n                  require not call.value\n                  return stor10\n              if mem[0 len 28], uint32(call.func_hash) != balanceOf(address account):\n                  if mem[0 len 28], uint32(call.func_hash) == transfer(address recipient, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require stor[caller][8] >= call.data[36]\n                      stor[caller][8] -= call.data[36]\n                      require stor[call.data[4]][8] + call.data[36] >= stor[call.data[4]][8]\n                      stor[call.data[4]][8] += call.data[36]\n                      log Transfer(\n                            address from=call.data[36],\n                            address to=caller,\n                            uint256 value=call.data[4])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address sender, address recipient, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require _param2 < 0x10000000000000000000000000000000000000000\n                      require stor[call.data[4]][8] >= call.data[68]\n                      stor[call.data[4]][8] -= call.data[68]\n                      require stor[call.data[36]][8] + call.data[68] >= stor[call.data[36]][8]\n                      stor[call.data[36]][8] += call.data[68]\n                      require stor[caller][('map', 9, ('call.data', 4, 32))] >= call.data[68]\n                      stor[caller][('map', 9, ('call.data', 4, 32))] -= call.data[68]\n                      log Transfer(\n                            address from=call.data[68],\n                            address to=call.data[4],\n                            uint256 value=call.data[36])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 amount):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      stor[call.data[4]][('map', 9, 'caller')] = call.data[36]\n                      log Approval(\n                            address owner=call.data[36],\n                            address spender=caller,\n                            uint256 value=call.data[4])\n                      return 1\n                  if mem[0 len 28], uint32(call.func_hash) == allowance(address owner, address spender):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      require _param2 < 0x10000000000000000000000000000000000000000\n                      return stor[call.data[36]][('map', 9, ('call.data', 4, 32))]\n                  if mem[0 len 28], uint32(call.func_hash) == factory_address():\n                      require not call.value\n                      return stor1\n                  if mem[0 len 28], uint32(call.func_hash) == minter_addresses(address arg0):\n                      require not call.value\n                      require _param1 < 0x10000000000000000000000000000000000000000\n                      return stor[call.data[4]][2]\n                  if mem[0 len 28], uint32(call.func_hash) == owner():\n                      require not call.value\n                      return stor3\n                  if mem[0 len 28], uint32(call.func_hash) == name():\n                      require not call.value\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[0 len 28], uint32(call.func_hash) == symbol():\n                      require not call.value\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[0 len 28], uint32(call.func_hash) == decimals():\n                      require not call.value\n                      return stor6\n                  if mem[0 len 28], uint32(call.func_hash) == commission():\n                      require not call.value\n                      return stor7\n                  require mem[0 len 28], uint32(call.func_hash) == balances(address )\n              require not call.value\n              require _param1 < 0x10000000000000000000000000000000000000000\n              return stor[call.data[4]][8]\n          require not call.value\n          require _param1 < 0x10000000000000000000000000000000000000000\n          require stor[caller][2] == 1\n          require ext_code.size(caller)\n          require caller != this.address\n          static call caller.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_code.size(stor0)\n          require stor0 != this.address\n          static call stor0.nonce() with:\n                  gas gas_remaining wei\n          require ext_call.success\n          require ext_call.return_data[0] == ext_call.return_data[0]\n          if not call.data[36]:\n              require stor3[8] >= stor3[8]\n              require call.data[36] >= 0\n              require stor[call.data[4]][8] + call.data[36] >= stor[call.data[4]][8]\n              require call.data[36] >= 0\n              stor[call.data[4]][8] += call.data[36]\n              require stor10 + call.data[36] >= stor10\n              stor10 += call.data[36]\n              require call.data[36] >= 0\n              log Transfer(\n                    address from=call.data[36],\n                    address to=0,\n                    uint256 value=call.data[4])\n              log Transfer(\n                    address from=0,\n                    address to=0,\n                    uint256 value=stor3)\n          else:\n              require call.data[36] * stor7 / call.data[36] == stor7\n              require stor3[8] + (call.data[36] * stor7 / 10000) >= stor3[8]\n              stor3[8] += call.data[36] * stor7 / 10000\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              require stor[call.data[4]][8] + call.data[36] - (call.data[36] * stor7 / 10000) >= stor[call.data[4]][8]\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              stor[call.data[4]][8] = stor[call.data[4]][8] + call.data[36] - (call.data[36] * stor7 / 10000)\n              require stor10 + call.data[36] >= stor10\n              stor10 += call.data[36]\n              require call.data[36] >= call.data[36] * stor7 / 10000\n              log Transfer(\n                    address from=(call.data[36] - (call.data[36] * stor7 / 10000)),\n                    address to=0,\n                    uint256 value=call.data[4])\n              log Transfer(\n                    address from=(call.data[36] * stor7 / 10000),\n                    address to=0,\n                    uint256 value=stor3)\n\n.",
	"status": "1",
	"time_cost": 40.324869871139526,
	"usage": {
		"completion_tokens": 643,
		"prompt_tokens": 2444,
		"total_tokens": 3087
	}
}