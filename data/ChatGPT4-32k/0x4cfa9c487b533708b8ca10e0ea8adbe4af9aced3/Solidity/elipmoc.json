{
	"address": "0x4cfa9c487b533708b8ca10e0ea8adbe4af9aced3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given the decompiled code provided, a Solidity smart contract that represents the functionality could look like this:\n\n```solidity\npragma solidity ^0.6.1;\n\ncontract MyContract {\n    uint256 public _burn;\n    address public _factory_address;\n    address public _owner;\n    string public _name;\n    string public _symbol;\n    uint256 public _decimals;\n    uint256 public _commission;\n    uint256 public _totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function changeOwner(address newOwner) public {\n        require(msg.sender == _owner);\n        _owner = newOwner;\n    }\n\n    function burn(uint256 amount) public {\n        require(balanceOf[msg.sender] >= amount);\n        balanceOf[msg.sender] -= amount;\n        _totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    function mint(uint256 amount) public {\n        require(msg.sender == _owner);\n        balanceOf[_owner] += amount;\n        _totalSupply += amount;\n        emit Transfer(address(0), _owner, amount);\n    }\n\n    function setFactoryAddress(address newFactoryAddress) public {\n        require(msg.sender == _owner);\n        _factory_address = newFactoryAddress;\n    }\n\n    function transfer(address to, uint256 amount) public returns(bool) {\n        require(balanceOf[msg.sender] >= amount);\n        balanceOf[msg.sender] -= amount;\n        balanceOf[to] += amount;\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns(bool) {\n        require(balanceOf[msg.sender] >= amount);\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public returns(bool) {\n        require(balanceOf[from] >= amount);\n        require(allowance[from][msg.sender] >= amount);\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n        allowance[from][msg.sender] -= amount;\n        emit Transfer(from, to, amount);\n        return true;\n    }\n}\n```\n\nThis Solidity contract contains the basic functions of an ERC20 token, including `changeOwner`, `burn`, `mint`, `setFactoryAddress`, `transfer`, `approve`, and `transferFrom`. Please note that it's a simplification and certain pieces of code and functionality from the decompiled code might be missing, as they might be specific to the original contract and its particular use case.",
				"role": "assistant"
			}
		}
	],
	"created": 1701486316,
	"id": "chatcmpl-8RAbcpYJIm2WGJPXQBd6iMIJVZp7E",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.01 11:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _burn; // STORAGE[0x0]\nuint256 _factory_address; // STORAGE[0x1]\nuint256 _owner; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _decimals; // STORAGE[0x6]\nuint256 _commission; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0xa]\n\n// Events\nTransfer(address, address, uint256);\nOpenMinter(address);\nCloseMinter(address);\nApproval(address, address, uint256);\n\nfunction changeOwner(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _owner = MEM[320];\n}\n\nfunction burn(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    require(msg.sender.code.size);\n    require(this != msg.sender);\n    v0 = msg.sender.nonce().gas(msg.gas);\n    require(v0);\n    require(_burn.code.size);\n    require(this != _burn);\n    v1 = _burn.nonce().gas(msg.gas);\n    require(v1);\n    require(MEM[480] == MEM[608]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[352]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[352]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] - MEM[352];\n    require(_totalSupply >= MEM[352]);\n    _totalSupply = _totalSupply - MEM[352];\n    emit Transfer(MEM[320], 0, MEM[352]);\n}\n\nfunction mint(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    require(msg.sender.code.size);\n    require(this != msg.sender);\n    v0 = msg.sender.nonce().gas(msg.gas);\n    require(v0);\n    require(_burn.code.size);\n    require(this != _burn);\n    v1 = _burn.nonce().gas(msg.gas);\n    require(v1);\n    require(MEM[480] == MEM[608]);\n    if (MEM[352]) {\n        require(MEM[352] * _commission / MEM[352] == _commission);\n        v2 = v3 = MEM[352] * _commission;\n    } else {\n        v2 = v4 = 0;\n    }\n    require(STORAGE[keccak256(8, _owner)] + v2 / 10000 >= STORAGE[keccak256(8, _owner)]);\n    STORAGE[keccak256(8, _owner)] = STORAGE[keccak256(8, _owner)] + v2 / 10000;\n    require(MEM[352] >= v2 / 10000);\n    require(STORAGE[keccak256(8, MEM[320])] + (MEM[352] - v2 / 10000) >= STORAGE[keccak256(8, MEM[320])]);\n    require(MEM[352] >= v2 / 10000);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] + (MEM[352] - v2 / 10000);\n    require(_totalSupply + MEM[352] >= _totalSupply);\n    _totalSupply = _totalSupply + MEM[352];\n    require(MEM[352] >= v2 / 10000);\n    emit Transfer(0, MEM[320], MEM[352] - v2 / 10000);\n    emit Transfer(0, _owner, v2 / 10000);\n}\n\nfunction setGovernorAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _burn = MEM[320];\n}\n\nfunction setFactoryAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _factory_address = MEM[320];\n}\n\nfunction setMinterAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _factory_address);\n    STORAGE[keccak256(2, MEM[320])] = 1;\n    emit OpenMinter(MEM[320]);\n}\n\nfunction removeMinterAddress() public nonPayable { \n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    STORAGE[keccak256(2, msg.sender)] = 0;\n    emit CloseMinter(msg.sender);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction balanceOf(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, MEM[320])];\n}\n\nfunction transfer(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(8, msg.sender)] >= MEM[352]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - MEM[352];\n    require(STORAGE[keccak256(8, MEM[320])] + MEM[352] >= STORAGE[keccak256(8, MEM[320])]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] + MEM[352];\n    emit Transfer(msg.sender, MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 96);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[384]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] - MEM[384];\n    require(STORAGE[keccak256(8, MEM[352])] + MEM[384] >= STORAGE[keccak256(8, MEM[352])]);\n    STORAGE[keccak256(8, MEM[352])] = STORAGE[keccak256(8, MEM[352])] + MEM[384];\n    require(STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] >= MEM[384]);\n    STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] = STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] - MEM[384];\n    emit Transfer(MEM[320], MEM[352], MEM[384]);\n    return 1;\n}\n\nfunction approve(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(9, msg.sender), MEM[320])] = MEM[352];\n    emit Approval(msg.sender, MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(9, MEM[320]), MEM[352])];\n}\n\nfunction factory_address() public nonPayable { \n    return _factory_address;\n}\n\nfunction minter_addresses(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(2, MEM[320])];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(4)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (12 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(5)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (3 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction commission() public nonPayable { \n    return _commission;\n}\n\nfunction balances(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, MEM[320])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xa6f9dae1) {\n        if (function_selector != 0x9dc29fac) {\n            if (function_selector != 0x40c10f19) {\n                if (function_selector != 0x1197705e) {\n                    if (function_selector != 0x83c17c55) {\n                        if (function_selector != 0xa3106b95) {\n                            if (function_selector != 0xd05904d2) {\n                                if (function_selector != 0x18160ddd) {\n                                    if (function_selector != 0x70a08231) {\n                                        if (function_selector != 0xa9059cbb) {\n                                            if (function_selector != 0x23b872dd) {\n                                                if (function_selector != 0x95ea7b3) {\n                                                    if (function_selector != 0xdd62ed3e) {\n                                                        if (function_selector != 0xba92d382) {\n                                                            if (function_selector != 0xc51069c) {\n                                                                if (function_selector != 0x8da5cb5b) {\n                                                                    if (function_selector != 0x6fdde03) {\n                                                                        if (function_selector != 0x95d89b41) {\n                                                                            if (function_selector != 0x313ce567) {\n                                                                                if (function_selector != 0xe1489191) {\n                                                                                    require(function_selector == 0x27e235e3);\n                                                                                    balances(address);\n                                                                                } else {\n                                                                                    commission();\n                                                                                }\n                                                                            } else {\n                                                                                decimals();\n                                                                            }\n                                                                        } else {\n                                                                            symbol();\n                                                                        }\n                                                                    } else {\n                                                                        name();\n                                                                    }\n                                                                } else {\n                                                                    owner();\n                                                                }\n                                                            } else {\n                                                                minter_addresses(address);\n                                                            }\n                                                        } else {\n                                                            factory_address();\n                                                        }\n                                                    } else {\n                                                        allowance(address,address);\n                                                    }\n                                                } else {\n                                                    approve(address,uint256);\n                                                }\n                                            } else {\n                                                transferFrom(address,address,uint256);\n                                            }\n                                        } else {\n                                            transfer(address,uint256);\n                                        }\n                                    } else {\n                                        balanceOf(address);\n                                    }\n                                } else {\n                                    totalSupply();\n                                }\n                            } else {\n                                removeMinterAddress();\n                            }\n                        } else {\n                            setMinterAddress(address);\n                        }\n                    } else {\n                        setFactoryAddress(address);\n                    }\n                } else {\n                    setGovernorAddress(address);\n                }\n            } else {\n                mint(address,uint256);\n            }\n        } else {\n            burn(address,uint256);\n        }\n    } else {\n        changeOwner(address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.01 11:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _burn; // STORAGE[0x0]\nuint256 _factory_address; // STORAGE[0x1]\nuint256 _owner; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _decimals; // STORAGE[0x6]\nuint256 _commission; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0xa]\n\n// Events\nTransfer(address, address, uint256);\nOpenMinter(address);\nCloseMinter(address);\nApproval(address, address, uint256);\n\nfunction changeOwner(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _owner = MEM[320];\n}\n\nfunction burn(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    require(msg.sender.code.size);\n    require(this != msg.sender);\n    v0 = msg.sender.nonce().gas(msg.gas);\n    require(v0);\n    require(_burn.code.size);\n    require(this != _burn);\n    v1 = _burn.nonce().gas(msg.gas);\n    require(v1);\n    require(MEM[480] == MEM[608]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[352]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[352]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] - MEM[352];\n    require(_totalSupply >= MEM[352]);\n    _totalSupply = _totalSupply - MEM[352];\n    emit Transfer(MEM[320], 0, MEM[352]);\n}\n\nfunction mint(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    require(msg.sender.code.size);\n    require(this != msg.sender);\n    v0 = msg.sender.nonce().gas(msg.gas);\n    require(v0);\n    require(_burn.code.size);\n    require(this != _burn);\n    v1 = _burn.nonce().gas(msg.gas);\n    require(v1);\n    require(MEM[480] == MEM[608]);\n    if (MEM[352]) {\n        require(MEM[352] * _commission / MEM[352] == _commission);\n        v2 = v3 = MEM[352] * _commission;\n    } else {\n        v2 = v4 = 0;\n    }\n    require(STORAGE[keccak256(8, _owner)] + v2 / 10000 >= STORAGE[keccak256(8, _owner)]);\n    STORAGE[keccak256(8, _owner)] = STORAGE[keccak256(8, _owner)] + v2 / 10000;\n    require(MEM[352] >= v2 / 10000);\n    require(STORAGE[keccak256(8, MEM[320])] + (MEM[352] - v2 / 10000) >= STORAGE[keccak256(8, MEM[320])]);\n    require(MEM[352] >= v2 / 10000);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] + (MEM[352] - v2 / 10000);\n    require(_totalSupply + MEM[352] >= _totalSupply);\n    _totalSupply = _totalSupply + MEM[352];\n    require(MEM[352] >= v2 / 10000);\n    emit Transfer(0, MEM[320], MEM[352] - v2 / 10000);\n    emit Transfer(0, _owner, v2 / 10000);\n}\n\nfunction setGovernorAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _burn = MEM[320];\n}\n\nfunction setFactoryAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _factory_address = MEM[320];\n}\n\nfunction setMinterAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _factory_address);\n    STORAGE[keccak256(2, MEM[320])] = 1;\n    emit OpenMinter(MEM[320]);\n}\n\nfunction removeMinterAddress() public nonPayable { \n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    STORAGE[keccak256(2, msg.sender)] = 0;\n    emit CloseMinter(msg.sender);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction balanceOf(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, MEM[320])];\n}\n\nfunction transfer(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(8, msg.sender)] >= MEM[352]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - MEM[352];\n    require(STORAGE[keccak256(8, MEM[320])] + MEM[352] >= STORAGE[keccak256(8, MEM[320])]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] + MEM[352];\n    emit Transfer(msg.sender, MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 96);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[384]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] - MEM[384];\n    require(STORAGE[keccak256(8, MEM[352])] + MEM[384] >= STORAGE[keccak256(8, MEM[352])]);\n    STORAGE[keccak256(8, MEM[352])] = STORAGE[keccak256(8, MEM[352])] + MEM[384];\n    require(STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] >= MEM[384]);\n    STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] = STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] - MEM[384];\n    emit Transfer(MEM[320], MEM[352], MEM[384]);\n    return 1;\n}\n\nfunction approve(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(9, msg.sender), MEM[320])] = MEM[352];\n    emit Approval(msg.sender, MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(9, MEM[320]), MEM[352])];\n}\n\nfunction factory_address() public nonPayable { \n    return _factory_address;\n}\n\nfunction minter_addresses(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(2, MEM[320])];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(4)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (12 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(5)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (3 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction commission() public nonPayable { \n    return _commission;\n}\n\nfunction balances(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, MEM[320])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xa6f9dae1) {\n        if (function_selector != 0x9dc29fac) {\n            if (function_selector != 0x40c10f19) {\n                if (function_selector != 0x1197705e) {\n                    if (function_selector != 0x83c17c55) {\n                        if (function_selector != 0xa3106b95) {\n                            if (function_selector != 0xd05904d2) {\n                                if (function_selector != 0x18160ddd) {\n                                    if (function_selector != 0x70a08231) {\n                                        if (function_selector != 0xa9059cbb) {\n                                            if (function_selector != 0x23b872dd) {\n                                                if (function_selector != 0x95ea7b3) {\n                                                    if (function_selector != 0xdd62ed3e) {\n                                                        if (function_selector != 0xba92d382) {\n                                                            if (function_selector != 0xc51069c) {\n                                                                if (function_selector != 0x8da5cb5b) {\n                                                                    if (function_selector != 0x6fdde03) {\n                                                                        if (function_selector != 0x95d89b41) {\n                                                                            if (function_selector != 0x313ce567) {\n                                                                                if (function_selector != 0xe1489191) {\n                                                                                    require(function_selector == 0x27e235e3);\n                                                                                    balances(address);\n                                                                                } else {\n                                                                                    commission();\n                                                                                }\n                                                                            } else {\n                                                                                decimals();\n                                                                            }\n                                                                        } else {\n                                                                            symbol();\n                                                                        }\n                                                                    } else {\n                                                                        name();\n                                                                    }\n                                                                } else {\n                                                                    owner();\n                                                                }\n                                                            } else {\n                                                                minter_addresses(address);\n                                                            }\n                                                        } else {\n                                                            factory_address();\n                                                        }\n                                                    } else {\n                                                        allowance(address,address);\n                                                    }\n                                                } else {\n                                                    approve(address,uint256);\n                                                }\n                                            } else {\n                                                transferFrom(address,address,uint256);\n                                            }\n                                        } else {\n                                            transfer(address,uint256);\n                                        }\n                                    } else {\n                                        balanceOf(address);\n                                    }\n                                } else {\n                                    totalSupply();\n                                }\n                            } else {\n                                removeMinterAddress();\n                            }\n                        } else {\n                            setMinterAddress(address);\n                        }\n                    } else {\n                        setFactoryAddress(address);\n                    }\n                } else {\n                    setGovernorAddress(address);\n                }\n            } else {\n                mint(address,uint256);\n            }\n        } else {\n            burn(address,uint256);\n        }\n    } else {\n        changeOwner(address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.01 11:39 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _burn; // STORAGE[0x0]\nuint256 _factory_address; // STORAGE[0x1]\nuint256 _owner; // STORAGE[0x3]\nuint256[] _name; // STORAGE[0x4]\nuint256[] _symbol; // STORAGE[0x5]\nuint256 _decimals; // STORAGE[0x6]\nuint256 _commission; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0xa]\n\n// Events\nTransfer(address, address, uint256);\nOpenMinter(address);\nCloseMinter(address);\nApproval(address, address, uint256);\n\nfunction changeOwner(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _owner = MEM[320];\n}\n\nfunction burn(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    require(msg.sender.code.size);\n    require(this != msg.sender);\n    v0 = msg.sender.nonce().gas(msg.gas);\n    require(v0);\n    require(_burn.code.size);\n    require(this != _burn);\n    v1 = _burn.nonce().gas(msg.gas);\n    require(v1);\n    require(MEM[480] == MEM[608]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[352]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[352]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] - MEM[352];\n    require(_totalSupply >= MEM[352]);\n    _totalSupply = _totalSupply - MEM[352];\n    emit Transfer(MEM[320], 0, MEM[352]);\n}\n\nfunction mint(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    require(msg.sender.code.size);\n    require(this != msg.sender);\n    v0 = msg.sender.nonce().gas(msg.gas);\n    require(v0);\n    require(_burn.code.size);\n    require(this != _burn);\n    v1 = _burn.nonce().gas(msg.gas);\n    require(v1);\n    require(MEM[480] == MEM[608]);\n    if (MEM[352]) {\n        require(MEM[352] * _commission / MEM[352] == _commission);\n        v2 = v3 = MEM[352] * _commission;\n    } else {\n        v2 = v4 = 0;\n    }\n    require(STORAGE[keccak256(8, _owner)] + v2 / 10000 >= STORAGE[keccak256(8, _owner)]);\n    STORAGE[keccak256(8, _owner)] = STORAGE[keccak256(8, _owner)] + v2 / 10000;\n    require(MEM[352] >= v2 / 10000);\n    require(STORAGE[keccak256(8, MEM[320])] + (MEM[352] - v2 / 10000) >= STORAGE[keccak256(8, MEM[320])]);\n    require(MEM[352] >= v2 / 10000);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] + (MEM[352] - v2 / 10000);\n    require(_totalSupply + MEM[352] >= _totalSupply);\n    _totalSupply = _totalSupply + MEM[352];\n    require(MEM[352] >= v2 / 10000);\n    emit Transfer(0, MEM[320], MEM[352] - v2 / 10000);\n    emit Transfer(0, _owner, v2 / 10000);\n}\n\nfunction setGovernorAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _burn = MEM[320];\n}\n\nfunction setFactoryAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    _factory_address = MEM[320];\n}\n\nfunction setMinterAddress(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _factory_address);\n    STORAGE[keccak256(2, MEM[320])] = 1;\n    emit OpenMinter(MEM[320]);\n}\n\nfunction removeMinterAddress() public nonPayable { \n    require(STORAGE[keccak256(2, msg.sender)] == 1);\n    STORAGE[keccak256(2, msg.sender)] = 0;\n    emit CloseMinter(msg.sender);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction balanceOf(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, MEM[320])];\n}\n\nfunction transfer(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(STORAGE[keccak256(8, msg.sender)] >= MEM[352]);\n    STORAGE[keccak256(8, msg.sender)] = STORAGE[keccak256(8, msg.sender)] - MEM[352];\n    require(STORAGE[keccak256(8, MEM[320])] + MEM[352] >= STORAGE[keccak256(8, MEM[320])]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] + MEM[352];\n    emit Transfer(msg.sender, MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction transferFrom(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 96);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    require(STORAGE[keccak256(8, MEM[320])] >= MEM[384]);\n    STORAGE[keccak256(8, MEM[320])] = STORAGE[keccak256(8, MEM[320])] - MEM[384];\n    require(STORAGE[keccak256(8, MEM[352])] + MEM[384] >= STORAGE[keccak256(8, MEM[352])]);\n    STORAGE[keccak256(8, MEM[352])] = STORAGE[keccak256(8, MEM[352])] + MEM[384];\n    require(STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] >= MEM[384]);\n    STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] = STORAGE[keccak256(keccak256(9, MEM[320]), msg.sender)] - MEM[384];\n    emit Transfer(MEM[320], MEM[352], MEM[384]);\n    return 1;\n}\n\nfunction approve(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    STORAGE[keccak256(keccak256(9, msg.sender), MEM[320])] = MEM[352];\n    emit Approval(msg.sender, MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 < MEM[32]);\n    return STORAGE[keccak256(keccak256(9, MEM[320]), MEM[352])];\n}\n\nfunction factory_address() public nonPayable { \n    return _factory_address;\n}\n\nfunction minter_addresses(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(2, MEM[320])];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(4)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (12 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction symbol() public nonPayable { \n    while (0 > STORAGE[keccak256(5)] + 32) {\n        MEM[384] = _symbol[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (3 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction commission() public nonPayable { \n    return _commission;\n}\n\nfunction balances(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(8, MEM[320])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xa6f9dae1) {\n        if (function_selector != 0x9dc29fac) {\n            if (function_selector != 0x40c10f19) {\n                if (function_selector != 0x1197705e) {\n                    if (function_selector != 0x83c17c55) {\n                        if (function_selector != 0xa3106b95) {\n                            if (function_selector != 0xd05904d2) {\n                                if (function_selector != 0x18160ddd) {\n                                    if (function_selector != 0x70a08231) {\n                                        if (function_selector != 0xa9059cbb) {\n                                            if (function_selector != 0x23b872dd) {\n                                                if (function_selector != 0x95ea7b3) {\n                                                    if (function_selector != 0xdd62ed3e) {\n                                                        if (function_selector != 0xba92d382) {\n                                                            if (function_selector != 0xc51069c) {\n                                                                if (function_selector != 0x8da5cb5b) {\n                                                                    if (function_selector != 0x6fdde03) {\n                                                                        if (function_selector != 0x95d89b41) {\n                                                                            if (function_selector != 0x313ce567) {\n                                                                                if (function_selector != 0xe1489191) {\n                                                                                    require(function_selector == 0x27e235e3);\n                                                                                    balances(address);\n                                                                                } else {\n                                                                                    commission();\n                                                                                }\n                                                                            } else {\n                                                                                decimals();\n                                                                            }\n                                                                        } else {\n                                                                            symbol();\n                                                                        }\n                                                                    } else {\n                                                                        name();\n                                                                    }\n                                                                } else {\n                                                                    owner();\n                                                                }\n                                                            } else {\n                                                                minter_addresses(address);\n                                                            }\n                                                        } else {\n                                                            factory_address();\n                                                        }\n                                                    } else {\n                                                        allowance(address,address);\n                                                    }\n                                                } else {\n                                                    approve(address,uint256);\n                                                }\n                                            } else {\n                                                transferFrom(address,address,uint256);\n                                            }\n                                        } else {\n                                            transfer(address,uint256);\n                                        }\n                                    } else {\n                                        balanceOf(address);\n                                    }\n                                } else {\n                                    totalSupply();\n                                }\n                            } else {\n                                removeMinterAddress();\n                            }\n                        } else {\n                            setMinterAddress(address);\n                        }\n                    } else {\n                        setFactoryAddress(address);\n                    }\n                } else {\n                    setGovernorAddress(address);\n                }\n            } else {\n                mint(address,uint256);\n            }\n        } else {\n            burn(address,uint256);\n        }\n    } else {\n        changeOwner(address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 27.1316077709198,
	"usage": {
		"completion_tokens": 589,
		"prompt_tokens": 3104,
		"total_tokens": 3693
	}
}