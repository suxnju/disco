{
	"address": "0x16de59092dae5ccf4a1e6439d611fd0653f0bd01",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Here is the equivalent Solidity code based on the decompiled EVM Bytecode:\n\n```solidity\n\npragma solidity >=0.5.0 <0.6.0;\n\ncontract MyContract {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n\n    constructor() public {\n        _totalSupply = 10000;\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(_balances[msg.sender] >= amount, \"Insufficient balance\");\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_balances[sender] >= amount, \"Insufficient balance\");\n        require(_allowances[sender][msg.sender] >= amount, \"Insufficient allowance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        _allowances[sender][msg.sender] -= amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n}\n```\n\nPlease note, the original bytecode does not provide any information about function or variable names, so some assumptions have been made. The contract appears to be a simple implementation of an ERC20 token, with a fixed supply assigned to the creator of the contract.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711534262,
	"id": "chatcmpl-97KXGG2oySRJ4o261rwjNnvhApEth",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2024.03.22 01:26 UTC\n// Compiled using the solidity compiler version 0.5.12\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] array_3; // STORAGE[0x3]\nuint256[] array_4; // STORAGE[0x4]\nuint256 _deposit; // STORAGE[0x6]\nuint256 _pool; // STORAGE[0x7]\nuint256 _dToken; // STORAGE[0xe]\nuint256 _apr; // STORAGE[0xf]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint256 _token; // STORAGE[0x8] bytes 0 to 19\nuint256 _compound; // STORAGE[0x9] bytes 0 to 19\nuint256 _fulcrum; // STORAGE[0xa] bytes 0 to 19\nuint256 _aave; // STORAGE[0xb] bytes 0 to 19\nuint256 _aaveToken; // STORAGE[0xc] bytes 0 to 19\nuint256 _dydx; // STORAGE[0xd] bytes 0 to 19\n\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction 0x102f(uint256 varg0) private { \n    _deposit = _deposit + 1;\n    require(varg0 > 0, Error('withdraw must be greater than 0'));\n    require(varg0 <= _balanceOf[msg.sender], Error('insufficient balance'));\n    v0 = 0x339d();\n    _pool = v0;\n    v1 = 0x315b(varg0, _pool);\n    v2 = _SafeDiv(_totalSupply, v1);\n    v3 = _SafeSub('redeem amount exceeds balance', varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v3;\n    v4 = _SafeSub('SafeMath: subtraction overflow', varg0, _totalSupply);\n    _totalSupply = v4;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(msg.sender, address(0x0), varg0);\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[4 + MEM[64]] = address(this);\n    require(bool(_token.code.size));\n    v5, /* uint256 */ v6 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v6);\n    if (v6 < v2) {\n        v7 = _SafeSub('SafeMath: subtraction overflow', v6, v2);\n        0x345a(v7);\n    }\n    require(bool(_token.code.size));\n    v8, /* bool */ v9 = _token.transfer(msg.sender, v2).gas(msg.gas);\n    require(bool(v8), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v9 == bool(v9));\n    v10 = 0x339d();\n    _pool = v10;\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n    return ;\n}\n\nfunction 0x1506() private { \n    MEM[MEM[64]] = False;\n    MEM[32 + MEM[64]] = 0;\n    require(bool(_dydx.code.size));\n    v0 = _dydx.getAccountWei(address(this), 0, _dToken).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v1 = 0x4bbd(MEM[64], MEM[64] + RETURNDATASIZE());\n    return v1.word1;\n}\n\nfunction 0x1642() private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x16f4(uint256 varg0) private { \n    v0 = 0x2a8d();\n    require(bool((address(v0)).code.size));\n    v1 = address(v0).deposit(_token, varg0, uint16(0)).gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x17d8() private { \n    v0 = 0x211c();\n    v1 = 0x2332();\n    v2 = 0x1506();\n    v3 = 0x299c();\n    v4 = 0x2012();\n    v5 = _SafeAdd(v3, v4);\n    v6 = _SafeAdd(v2, v5);\n    v7 = _SafeAdd(v1, v6);\n    v8 = _SafeAdd(v0, v7);\n    return v8;\n}\n\nfunction 0x188d() private { \n    v0 = 0x1dd9();\n    assert(uint8(_apr >> 160) <= 4);\n    assert(v0 <= 4);\n    if (v0 != uint8(_apr >> 160)) {\n        0x3625();\n    }\n    v1 = 0x211c();\n    if (v1 > 0) {\n        assert(1 <= 4);\n        assert(v0 <= 4);\n        if (v0 != 1) {\n            assert(4 <= 4);\n            assert(v0 <= 4);\n            if (v0 != 4) {\n                assert(2 <= 4);\n                assert(v0 <= 4);\n                if (v0 != 2) {\n                    assert(3 <= 4);\n                    assert(v0 <= 4);\n                    if (v0 == 3) {\n                        v2 = 0x211c();\n                        0x16f4(v2);\n                    }\n                } else {\n                    v3 = 0x211c();\n                    0x28aa(v3);\n                }\n            } else {\n                v4 = 0x211c();\n                0x19d4(v4);\n            }\n        } else {\n            v5 = 0x211c();\n            v6 = 0x9f1(v5);\n        }\n    }\n    assert(v0 <= 4);\n    _apr = v0 << 160 | ~0xff0000000000000000000000000000000000000000 & _apr;\n    return ;\n}\n\nfunction 0x19d4(uint256 varg0) private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.mint(address(this), varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 > 0, Error('FULCRUM: supply failed'));\n    return ;\n}\n\nfunction 0x1b14() private { \n    v0 = new bytes[](((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1);\n    v1 = v2 = v0.data;\n    if (!(((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1)) {\n        return v0;\n    } else if (31 < ((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1) {\n        v3 = v4 = array_4.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + (((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_4.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x1dd9() private { \n    require(bool((address(address(_apr))).code.size));\n    v0, /* uint256 */ v1 = address(_apr).recommend(_token).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    MEM[64] = v1 + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(v1 + RETURNDATASIZE() - v1 >= 160);\n    require(MEM[v1] <= uint64.max);\n    require(v1 + MEM[v1] + 31 < v1 + RETURNDATASIZE());\n    v2 = MEM[v1 + MEM[v1]];\n    require(v2 <= uint64.max);\n    v3 = new bytes[](v2);\n    require(!((v3 + ((v2 + 31 & ~0x1f) + 32) > uint64.max) | (v3 + ((v2 + 31 & ~0x1f) + 32) < v3)));\n    require(v1 + MEM[v1] + 32 + v2 <= v1 + RETURNDATASIZE());\n    v4 = v5 = 0;\n    while (v4 < v2) {\n        v3[v4] = MEM[v1 + MEM[v1] + 32 + v4];\n        v4 = v4 + 32;\n    }\n    if (v4 > v2) {\n        v3[v2] = 0;\n    }\n    v6 = v7 = MEM[v1 + 32];\n    0x5daf(v7);\n    v6 = v8 = MEM[v1 + 64];\n    0x5daf(v8);\n    v6 = v9 = MEM[v1 + 96];\n    0x5daf(v9);\n    v6 = MEM[v1 + 128];\n    0x5daf(v6);\n    v6 = v10 = 0;\n    v11 = v12 = 0;\n    if (v6 != v7) {\n        if (v6 != v8) {\n            if (v6 != v9) {\n                if (v6 == v6) {\n                    v11 = v13 = 1;\n                }\n            } else {\n                v11 = v14 = 3;\n            }\n        } else {\n            v11 = v15 = 4;\n        }\n    } else {\n        v11 = v16 = 2;\n    }\n    return v11;\n}\n\nfunction 0x2012() private { \n    v0 = v1 = 0x1642();\n    if (v1 > 0) {\n        require(bool(_compound.code.size));\n        v2, /* uint256 */ v3 = _compound.exchangeRateStored().gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v3);\n        if (v1 != 0) {\n            v4 = v5 = v1 * v3;\n            assert(v1);\n            require(v5 / v1 == v3, Error('SafeMath: multiplication overflow'));\n        } else {\n            v4 = 0;\n        }\n        if (10 ** 18 > 0) {\n            assert(10 ** 18);\n            v0 = v4 / 10 ** 18;\n        } else {\n            MEM[MEM[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000;\n            v6 = new bytes[](v7.length);\n            MEM[4 + MEM[64]] = 32;\n            v8 = v9 = 0;\n            while (v8 < v7.length) {\n                v6[v8] = v7[v8];\n                v8 = v8 + 32;\n            }\n            if (v8 > v7.length) {\n                v6[v7.length] = 0;\n            }\n            revert(Error(v6, v10, 'SafeMath: division by zero'));\n        }\n    }\n    return v0;\n}\n\nfunction 0x211c() private { \n    require(bool(_token.code.size));\n    v0, /* uint256 */ v1 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x2332() private { \n    require(bool(_aaveToken.code.size));\n    v0, /* uint256 */ v1 = _aaveToken.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x23ea(uint256 varg0) private { \n    _deposit = _deposit + 1;\n    require(varg0 > 0, Error('withdraw must be greater than 0'));\n    require(varg0 <= _balanceOf[msg.sender], Error('insufficient balance'));\n    v0 = 0x17d8();\n    _pool = v0;\n    v1 = 0x315b(varg0, _pool);\n    v2 = _SafeDiv(_totalSupply, v1);\n    v3 = _SafeSub('redeem amount exceeds balance', varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v3;\n    v4 = _SafeSub('SafeMath: subtraction overflow', varg0, _totalSupply);\n    _totalSupply = v4;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(msg.sender, address(0x0), varg0);\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[4 + MEM[64]] = address(this);\n    require(bool(_token.code.size));\n    v5, /* uint256 */ v6 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v6);\n    v7 = v8 = uint8(_apr >> 160);\n    if (v6 < v2) {\n        v7 = v9 = 0x1dd9();\n        assert(uint8(_apr >> 160) <= 4);\n        assert(v9 <= 4);\n        if (v9 == uint8(_apr >> 160)) {\n            v10 = _SafeSub('SafeMath: subtraction overflow', v6, v2);\n            0x345a(v10);\n        } else {\n            0x3625();\n        }\n    }\n    v11 = v12 = EXTCODEHASH(_token) != 0;\n    if (EXTCODEHASH(_token) != 0) {\n        v11 = EXTCODEHASH(_token) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v11, Error('SafeERC20: call to non-contract'));\n    v13 = v14 = 0;\n    while (v13 < 68) {\n        MEM[MEM[64] + v13] = MEM[MEM[64] + 32 + v13];\n        v13 = v13 + 32;\n    }\n    if (v13 > 68) {\n        MEM[MEM[64] + 68] = 0;\n    }\n    v15, /* uint256 */ v16, /* uint256 */ v17 = _token.transfer(msg.sender, v2).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v18 = v19 = 96;\n    } else {\n        v18 = v20 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v20.data, 0, RETURNDATASIZE());\n    }\n    require(v15, Error('SafeERC20: low-level call failed'));\n    if (MEM[v18] > 0) {\n        require(v17 + MEM[v18] - v17 >= 32);\n        require(MEM[v17] == bool(MEM[v17]));\n        require(MEM[v17], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    assert(uint8(_apr >> 160) <= 4);\n    assert(v7 <= 4);\n    if (v7 != uint8(_apr >> 160)) {\n        v21 = 0x3b8d();\n        if (v21 > 0) {\n            assert(1 <= 4);\n            assert(v7 <= 4);\n            if (v7 != 1) {\n                assert(4 <= 4);\n                assert(v7 <= 4);\n                if (v7 != 4) {\n                    assert(2 <= 4);\n                    assert(v7 <= 4);\n                    if (v7 != 2) {\n                        assert(3 <= 4);\n                        assert(v7 <= 4);\n                        if (v7 == 3) {\n                            v22 = 0x3b8d();\n                            0x16f4(v22);\n                        }\n                    } else {\n                        v23 = 0x3b8d();\n                        0x28aa(v23);\n                    }\n                } else {\n                    v24 = 0x3b8d();\n                    0x19d4(v24);\n                }\n            } else {\n                v25 = 0x3b8d();\n                v26 = 0x9f1(v25);\n            }\n        }\n        assert(v7 <= 4);\n        _apr = v7 << 160 | ~0xff0000000000000000000000000000000000000000 & _apr;\n    }\n    v27 = 0x17d8();\n    _pool = v27;\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n    return ;\n}\n\nfunction function_selector() public payable { \n}\n\nfunction supplyDydx(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    v0 = 0x9f1(amount);\n    return v0;\n}\n\nfunction 0x28aa(uint256 varg0) private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.mint(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 == 0, Error('COMPOUND: supply failed'));\n    return ;\n}\n\nfunction 0x299c() private { \n    v0 = v1 = 0xd28();\n    if (v1 > 0) {\n        require(bool(_fulcrum.code.size));\n        v2, /* uint256 */ v0 = _fulcrum.assetBalanceOf(address(this)).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v0);\n    }\n    return v0;\n}\n\nfunction aaveToken() public nonPayable { \n    return _aaveToken;\n}\n\nfunction 0x2a8d() private { \n    require(bool(_aave.code.size));\n    v0, /* address */ v1 = _aave.getLendingPool().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5d81(v1);\n    return v1;\n}\n\nfunction 0x2b34() private { \n    require(bool(_aave.code.size));\n    v0, /* address */ v1 = _aave.getLendingPoolCore().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5d81(v1);\n    return v1;\n}\n\nfunction 0x2c09(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 != address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 != address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = 0xc55();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction 0x2dd4(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 != address(0x0), Error('ERC20: transfer from the zero address'));\n    require(varg1 != address(0x0), Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction provider() public nonPayable { \n    assert(uint8(_apr >> 160) < 5);\n    return uint8(_apr >> 160);\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction 0x30b9(uint256 varg0, address varg1, address varg2, address varg3) private { \n    v0 = v1 = EXTCODEHASH(varg3) != 0;\n    if (EXTCODEHASH(varg3) != 0) {\n        v0 = EXTCODEHASH(varg3) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v0, Error('SafeERC20: call to non-contract'));\n    v2 = v3 = 0;\n    while (v2 < 100) {\n        MEM[MEM[64] + v2] = MEM[MEM[64] + 32 + v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > 100) {\n        MEM[MEM[64] + 100] = 0;\n    }\n    v4, /* uint256 */ v5, /* uint256 */ v6 = varg3.transferFrom(varg2, varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v7 = v8 = 96;\n    } else {\n        v7 = v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v4, Error('SafeERC20: low-level call failed'));\n    if (MEM[v7] > 0) {\n        require(v6 + MEM[v7] - v6 >= 32);\n        require(MEM[v6] == bool(MEM[v6]));\n        require(MEM[v6], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    return ;\n}\n\nfunction 0x315b(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n    } else {\n        v0 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address spender, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(amount);\n    0x2c09(amount, spender, msg.sender);\n    return True;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 = v2 + 32;\n        }\n        if (v2 > v1.length) {\n            v0[v1.length] = 0;\n        }\n        revert(Error(v0, v4, 'SafeMath: division by zero'));\n    }\n}\n\nfunction 0x3215(uint256 varg0, address varg1) private { \n    require(varg1 != address(0x0), Error('ERC20: mint to the zero address'));\n    v0 = _SafeAdd(varg0, _totalSupply);\n    _totalSupply = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(address(0x0), varg1, varg0);\n    return ;\n}\n\nfunction 0x339d() private { \n    v0 = 0x3b8d();\n    v1 = 0x3c3f();\n    v2 = 0x3cf1();\n    v3 = 0x3de1();\n    v4 = v5 = 0x1642();\n    if (v5 > 0) {\n        require(bool(_compound.code.size));\n        v6, /* uint256 */ v7 = _compound.exchangeRateStored().gas(msg.gas);\n        require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v7);\n        if (v5 != 0) {\n            v8 = v9 = v5 * v7;\n            assert(v5);\n            require(v9 / v5 == v7, Error('SafeMath: multiplication overflow'));\n        } else {\n            v8 = v10 = 0;\n        }\n        if (10 ** 18 > 0) {\n            assert(10 ** 18);\n            v4 = v8 / 10 ** 18;\n        } else {\n            MEM[MEM[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000;\n            v11 = new bytes[](v12.length);\n            MEM[4 + MEM[64]] = 32;\n            v13 = v14 = 0;\n            while (v13 < v12.length) {\n                v11[v13] = v12[v13];\n                v13 = v13 + 32;\n            }\n            if (v13 > v12.length) {\n                v11[v12.length] = 0;\n            }\n            revert(Error(v11, v15, 'SafeMath: division by zero'));\n        }\n    }\n    v16 = _SafeAdd(v3, v4);\n    v17 = _SafeAdd(v2, v16);\n    v18 = _SafeAdd(v1, v17);\n    v19 = _SafeAdd(v0, v18);\n    return v19;\n}\n\nfunction 0x345a(uint256 varg0) private { \n    assert(2 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 2) {\n        v0 = 0x1642();\n        v1 = 0x2012();\n        require(v1 >= varg0, Error('insufficient funds'));\n        v2 = 0x315b(varg0, v0);\n        v3 = _SafeDiv(v1, v2);\n        v4 = _SafeAdd(1, v3);\n        0x4460(v4);\n    }\n    assert(3 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 3) {\n        v5 = 0x2332();\n        require(v5 >= varg0, Error('insufficient funds'));\n        0x403e(varg0);\n    }\n    assert(1 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 1) {\n        v6 = 0x1506();\n        require(v6 >= varg0, Error('insufficient funds'));\n        0x40ce(varg0);\n    }\n    assert(4 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 4) {\n        v7 = 0xd28();\n        v8 = 0x299c();\n        require(v8 >= varg0, Error('insufficient funds'));\n        v9 = 0x315b(varg0, v7);\n        v10 = _SafeDiv(v8, v9);\n        v11 = _SafeAdd(1, v10);\n        0x4604(v11);\n    }\n    return ;\n}\n\nfunction balanceFulcrum() public nonPayable { \n    v0 = 0xd28();\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction 0x3625() private { \n    v0 = 0x43ae();\n    if (v0 > 0) {\n        0x4460(v0);\n    }\n    v1 = 0x3cf1();\n    if (v1 > 0) {\n        0x40ce(v1);\n    }\n    v2 = 0x4552();\n    if (v2 > 0) {\n        0x4604(v2);\n    }\n    v3 = 0x3c3f();\n    if (v3 > 0) {\n        0x403e(v3);\n    }\n    return ;\n}\n\nfunction 0x369e(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        require(bool((address(varg2)).code.size));\n        v2, /* uint256 */ v3 = varg2.allowance(address(this), varg1).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v3);\n        v0 = v4 = v3 == 0;\n    }\n    require(v0, Error('SafeERC20: approve from non-zero to non-zero allowance'));\n    v5 = v6 = EXTCODEHASH(varg2) != 0;\n    if (EXTCODEHASH(varg2) != 0) {\n        v5 = EXTCODEHASH(varg2) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v5, Error('SafeERC20: call to non-contract'));\n    v7 = v8 = 0;\n    while (v7 < 68) {\n        MEM[MEM[64] + v7] = MEM[MEM[64] + 32 + v7];\n        v7 = v7 + 32;\n    }\n    if (v7 > 68) {\n        MEM[MEM[64] + 68] = 0;\n    }\n    v9, /* uint256 */ v10, /* uint256 */ v11 = varg2.approve(varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = v14 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v14.data, 0, RETURNDATASIZE());\n    }\n    require(v9, Error('SafeERC20: low-level call failed'));\n    if (MEM[v12] > 0) {\n        require(v11 + MEM[v12] - v11 >= 32);\n        require(MEM[v11] == bool(MEM[v11]));\n        require(MEM[v11], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    return ;\n}\n\nfunction pool() public nonPayable { \n    return _pool;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction 0x3b8d() private { \n    require(bool(_token.code.size));\n    v0, /* uint256 */ v1 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x3c3f() private { \n    require(bool(_aaveToken.code.size));\n    v0, /* uint256 */ v1 = _aaveToken.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x3cf1() private { \n    MEM[MEM[64]] = False;\n    MEM[32 + MEM[64]] = 0;\n    require(bool(_dydx.code.size));\n    v0 = _dydx.getAccountWei(address(this), 0, _dToken).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v1 = 0x4bbd(MEM[64], MEM[64] + RETURNDATASIZE());\n    return v1.word1;\n}\n\nfunction transferFrom(address sender, address recipient, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    0x5d81(sender);\n    0x5d81(recipient);\n    0x5daf(amount);\n    0x2dd4(amount, recipient, sender);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', amount, _allowance[sender][msg.sender]);\n    0x2c09(v0, msg.sender, sender);\n    return True;\n}\n\nfunction 0x3de1() private { \n    v0 = v1 = 0xd28();\n    if (v1 > 0) {\n        require(bool(_fulcrum.code.size));\n        v2, /* uint256 */ v0 = _fulcrum.assetBalanceOf(address(this)).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v0);\n    }\n    return v0;\n}\n\nfunction 0x403e(uint256 varg0) private { \n    require(bool(_aaveToken.code.size));\n    v0 = _aaveToken.redeem(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x40ce(uint256 varg0) private { \n    v0 = v1 = 1;\n    v2 = new struct(2);\n    v2.word0 = v1;\n    if (v1) {\n        v3 = v4 = v2.data;\n        do {\n            v5 = new struct(2);\n            v5.word0 = address(0x0);\n            v5.word1 = 0;\n            MEM[v3] = v5;\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v6 = new struct(2);\n    v6.word0 = address(this);\n    v6.word1 = 0;\n    assert(0 < v2.word0.length);\n    v7 = v2.data;\n    v2.word1 = v6;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[64] += 128;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = varg0;\n    v8 = 0x47b1();\n    assert(1 <= 1);\n    assert(1 <= 1);\n    v8.word0 = 1;\n    v8.word1 = 0;\n    v8.word2 = MEM[64];\n    v8.word3 = _dToken;\n    v8.word5 = address(this);\n    v9 = v10 = 1;\n    v11 = new uint256[](v10);\n    if (v10) {\n        v12 = v13 = v11.data;\n        do {\n            v14 = 0x481d();\n            MEM[v12] = v14;\n            v12 += 32;\n            v9 = v9 - 1;\n        } while (!v9);\n    }\n    assert(0 < v11.length);\n    v15 = v11.data;\n    v11[0] = v8;\n    v16 = 0x5743(4 + MEM[64], v11, v2);\n    require(bool(_dydx.code.size));\n    v17 = _dydx.operate().gas(msg.gas);\n    require(bool(v17), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction invest(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    _deposit = _deposit + 1;\n    require(amount > 0, Error('deposit must be greater than 0'));\n    v0 = 0x17d8();\n    _pool = v0;\n    0x30b9(amount, this, msg.sender, _token);\n    0x188d();\n    if (_pool != 0) {\n        v1 = 0x315b(_totalSupply, amount);\n        v2 = v3 = _SafeDiv(_pool, v1);\n    } else {\n        _pool = amount;\n    }\n    v4 = 0x17d8();\n    _pool = v4;\n    0x3215(v2, msg.sender);\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n}\n\nfunction 0x43ae() private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction withdraw(uint256 _amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(_amount);\n    0x102f(_amount);\n}\n\nfunction 0x4460(uint256 varg0) private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.redeem(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 == 0, Error('COMPOUND: withdraw failed'));\n    return ;\n}\n\nfunction 0x4552() private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x4604(uint256 varg0) private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.burn(address(this), varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 > 0, Error('FULCRUM: withdraw failed'));\n    return ;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction 0x47b1() private { \n    v0 = new struct(8);\n    assert(0 <= 1);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v1 = new struct(4);\n    v1.word0 = False;\n    assert(0 <= 0);\n    v1.word1 = 0;\n    assert(0 <= 0);\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v0.word2 = v1;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = address(0x0);\n    v0.word6 = 0;\n    v0.word7 = 96;\n    return v0;\n}\n\nfunction 0x481d() private { \n    v0 = new struct(8);\n    assert(0 <= 1);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v1 = new struct(4);\n    v1.word0 = False;\n    assert(0 <= 0);\n    v1.word1 = 0;\n    assert(0 <= 0);\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v0.word2 = v1;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = address(0x0);\n    v0.word6 = 0;\n    v0.word7 = 96;\n    return v0;\n}\n\nfunction increaseAllowance(address spender, uint256 addedValue) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(addedValue);\n    v0 = _SafeAdd(addedValue, _allowance[msg.sender][spender]);\n    0x2c09(v0, spender, msg.sender);\n    return True;\n}\n\nfunction 0x4bbd(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 >= 64);\n    require(varg1 - varg0 >= 64);\n    v0 = new struct(2);\n    require(!((v0 + 64 > uint64.max) | (v0 + 64 < v0)));\n    require(MEM[varg0] == bool(MEM[varg0]));\n    v0.word0 = MEM[varg0];\n    0x5daf(MEM[varg0 + 32]);\n    v0.word1 = MEM[varg0 + 32];\n    return v0;\n}\n\nfunction 0x4c91(uint256 varg0, uint256 varg1) private { \n    MEM[varg1] = varg0.length;\n    v0 = v1 = varg1 + 32;\n    v2 = v3 = v1 + (varg0.length << 5);\n    v4 = v5 = varg0.data;\n    v6 = v7 = 0;\n    while (v6 < varg0.length) {\n        MEM[v0] = v2 - v1;\n        assert(MEM[MEM[v4]] < 2);\n        MEM[v2] = MEM[MEM[v4]];\n        MEM[v2 + 32] = MEM[MEM[v4] + 32];\n        MEM[v2 + 64] = bool(MEM[MEM[MEM[v4] + 64]]);\n        assert(MEM[MEM[MEM[v4] + 64] + 32] < 1);\n        MEM[v2 + 64 + 32] = MEM[MEM[MEM[v4] + 64] + 32];\n        assert(MEM[MEM[MEM[v4] + 64] + 64] < 1);\n        MEM[v2 + 64 + 64] = MEM[MEM[MEM[v4] + 64] + 64];\n        MEM[v2 + 64 + 96] = MEM[MEM[MEM[v4] + 64] + 96];\n        MEM[v2 + 192] = MEM[MEM[v4] + 96];\n        MEM[v2 + 224] = MEM[MEM[v4] + 128];\n        MEM[v2 + 256] = address(MEM[MEM[v4] + 160]);\n        MEM[v2 + 288] = MEM[MEM[v4] + 192];\n        MEM[v2 + 320] = v2 + 352 - v2;\n        MEM[v2 + 352] = MEM[MEM[MEM[v4] + 224]];\n        v8 = v9 = 0;\n        while (v8 < MEM[MEM[MEM[v4] + 224]]) {\n            MEM[v2 + 352 + 32 + v8] = MEM[MEM[MEM[v4] + 224] + 32 + v8];\n            v8 = v8 + 32;\n        }\n        if (v8 > MEM[MEM[MEM[v4] + 224]]) {\n            MEM[v2 + 352 + 32 + MEM[MEM[MEM[v4] + 224]]] = 0;\n        }\n        v2 = v2 + 352 + 32 + (MEM[MEM[MEM[v4] + 224]] + 31 & ~0x1f);\n        v4 = v4 + 32;\n        v0 = v0 + 32;\n        v6 = v6 + 1;\n    }\n    return v2;\n}\n\nfunction balanceDydx() public nonPayable { \n    v0 = 0x1506();\n    return v0;\n}\n\nfunction apr() public nonPayable { \n    return address(_apr);\n}\n\nfunction fulcrum() public nonPayable { \n    return _fulcrum;\n}\n\nfunction balanceCompound() public nonPayable { \n    v0 = 0x1642();\n    return v0;\n}\n\nfunction 0x5743(uint256 varg0, uint256 varg1, struct(2) varg2) private { \n    MEM[varg0] = varg0 + 64 - varg0;\n    MEM[varg0 + 64] = varg2.word0.length;\n    v0 = v1 = varg0 + 64 + 32;\n    v2 = v3 = varg2.data;\n    v4 = v5 = 0;\n    while (v4 < varg2.word0.length) {\n        MEM[v0] = address(MEM[MEM[v2]]);\n        MEM[v0 + 32] = MEM[MEM[v2] + 32];\n        v0 = v0 + 64;\n        v2 = v2 + 32;\n        v4 = v4 + 1;\n    }\n    MEM[varg0 + 32] = v0 - varg0;\n    v6 = 0x4c91(varg1, v0);\n    return v6;\n}\n\nfunction supplyAave(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x16f4(amount);\n}\n\nfunction balanceOf(address account) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5d81(account);\n    return _balanceOf[account];\n}\n\nfunction 0x5d81(address varg0) private { \n    return ;\n}\n\nfunction 0x5daf(uint256 varg0) private { \n    return ;\n}\n\nfunction calcPoolValueInToken() public nonPayable { \n    v0 = 0x17d8();\n    return v0;\n}\n\nfunction getPricePerFullShare() public nonPayable { \n    v0 = 0x17d8();\n    v1 = 0x315b(10 ** 18, v0);\n    v2 = _SafeDiv(_totalSupply, v1);\n    return v2;\n}\n\nfunction rebalance() public nonPayable { \n    0x188d();\n}\n\nfunction supplyFulcrum(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x19d4(amount);\n}\n\nfunction aave() public nonPayable { \n    return _aave;\n}\n\nfunction dydx() public nonPayable { \n    return _dydx;\n}\n\nfunction symbol() public nonPayable { \n    v0 = 0x1b14();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction approveToken() public nonPayable { \n    0x369e(uint256.max, _compound, _token);\n    0x369e(uint256.max, _dydx, _token);\n    v0 = 0x2b34();\n    0x369e(uint256.max, v0, _token);\n    0x369e(uint256.max, _fulcrum, _token);\n}\n\nfunction recommend() public nonPayable { \n    v0 = 0x1dd9();\n    assert(v0 < 5);\n    return v0;\n}\n\nfunction decreaseAllowance(address spender, uint256 subtractedValue) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(subtractedValue);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', subtractedValue, _allowance[msg.sender][spender]);\n    0x2c09(v0, spender, msg.sender);\n    return True;\n}\n\nfunction balanceCompoundInToken() public nonPayable { \n    v0 = 0x2012();\n    return v0;\n}\n\nfunction transfer(address recipient, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(recipient);\n    0x5daf(amount);\n    0x2dd4(amount, recipient, msg.sender);\n    return True;\n}\n\nfunction balance() public nonPayable { \n    v0 = 0x211c();\n    return v0;\n}\n\nfunction deposit(uint256 _amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(_amount);\n    _deposit = _deposit + 1;\n    require(_amount > 0, Error('deposit must be greater than 0'));\n    v0 = 0x339d();\n    _pool = v0;\n    0x30b9(_amount, this, msg.sender, _token);\n    if (_pool != 0) {\n        v1 = 0x315b(_totalSupply, _amount);\n        v2 = v3 = _SafeDiv(_pool, v1);\n    } else {\n        _pool = _amount;\n    }\n    v4 = 0x339d();\n    _pool = v4;\n    0x3215(v2, msg.sender);\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n}\n\nfunction balanceAave() public nonPayable { \n    v0 = 0x2332();\n    return v0;\n}\n\nfunction dToken() public nonPayable { \n    return _dToken;\n}\n\nfunction redeem(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x23ea(amount);\n}\n\nfunction allowance(address owner, address spender) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(owner);\n    0x5d81(spender);\n    return _allowance[owner][spender];\n}\n\nfunction supplyCompound(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x28aa(amount);\n}\n\nfunction balanceFulcrumInToken() public nonPayable { \n    v0 = 0x299c();\n    return v0;\n}\n\nfunction compound() public nonPayable { \n    return _compound;\n}\n\nfunction getAave() public nonPayable { \n    v0 = 0x2a8d();\n    return address(v0);\n}\n\nfunction getAaveCore() public nonPayable { \n    v0 = 0x2b34();\n    return address(v0);\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x9f1(uint256 varg0) private { \n    v0 = v1 = 1;\n    v2 = new struct(2);\n    v2.word0 = v1;\n    if (v1) {\n        v3 = v4 = v2.data;\n        do {\n            v5 = new struct(2);\n            v5.word0 = address(0x0);\n            v5.word1 = 0;\n            MEM[v3] = v5;\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v6 = new struct(2);\n    v6.word0 = address(this);\n    v6.word1 = 0;\n    assert(0 < v2.word0.length);\n    v7 = v2.data;\n    v2.word1 = v6;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[64] += 128;\n    MEM[MEM[64]] = True;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = varg0;\n    v8 = 0x47b1();\n    assert(0 <= 1);\n    assert(0 <= 1);\n    v8.word0 = 0;\n    v8.word1 = 0;\n    v8.word2 = MEM[64];\n    v8.word3 = _dToken;\n    v8.word5 = address(this);\n    v9 = v10 = 1;\n    v11 = new uint256[](v10);\n    if (v10) {\n        v12 = v13 = v11.data;\n        do {\n            v14 = 0x481d();\n            MEM[v12] = v14;\n            v12 += 32;\n            v9 = v9 - 1;\n        } while (!v9);\n    }\n    assert(0 < v11.length);\n    v15 = v11.data;\n    v11[0] = v8;\n    v16 = 0x5743(4 + MEM[64], v11, v2);\n    require(bool(_dydx.code.size));\n    v17 = _dydx.operate().gas(msg.gas);\n    require(bool(v17), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return 0;\n}\n\nfunction 0xc55() private { \n    v0 = new bytes[](((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1);\n    v1 = v2 = v0.data;\n    if (!(((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1)) {\n        return v0;\n    } else if (31 < ((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1) {\n        v3 = v4 = array_3.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + (((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_3.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0xd28() private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction function_selector( function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x7d7c2a1c > v0) {\n            if (0x2e1a7d4d > v0) {\n                if (0xeb2a267 > v0) {\n                    if (0x6636c1c == v0) {\n                        supplyDydx(uint256);\n                    } else if (0x6a3fe59 == v0) {\n                        aaveToken();\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x85d4883 == v0) {\n                        provider();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    }\n                } else if (0xeb2a267 == v0) {\n                    balanceFulcrum();\n                } else if (0x16f0115b == v0) {\n                    pool();\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x2afcf480 == v0) {\n                    invest(uint256);\n                }\n            } else if (0x58782c21 > v0) {\n                if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else if (0x39c0a7e1 == v0) {\n                    balanceDydx();\n                } else if (0x57ded9c9 == v0) {\n                    apr();\n                }\n            } else if (0x58782c21 == v0) {\n                fulcrum();\n            } else if (0x61c1ec55 == v0) {\n                balanceCompound();\n            } else if (0x65aab749 == v0) {\n                supplyAave(uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            } else if (0x7137ef99 == v0) {\n                calcPoolValueInToken();\n            } else if (0x77c7b8fc == v0) {\n                getPricePerFullShare();\n            }\n        } else if (0xb6b55f25 > v0) {\n            if (0x99b71d5c > v0) {\n                if (0x7d7c2a1c == v0) {\n                    rebalance();\n                } else if (0x8124955c == v0) {\n                    supplyFulcrum(uint256);\n                } else if (0x819faf7b == v0) {\n                    aave();\n                } else if (0x8e4ec6ef == v0) {\n                    dydx();\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                }\n            } else if (0x99b71d5c == v0) {\n                approveToken();\n            } else if (0xa160176d == v0) {\n                recommend();\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa7287971 == v0) {\n                balanceCompoundInToken();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xb69ef8a8 == v0) {\n                balance();\n            }\n        } else if (0xe849d659 > v0) {\n            if (0xb6b55f25 == v0) {\n                deposit(uint256);\n            } else if (0xcf8ca426 == v0) {\n                balanceAave();\n            } else if (0xd9d7858a == v0) {\n                dToken();\n            } else if (0xdb006a75 == v0) {\n                redeem(uint256);\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            }\n        } else if (0xe849d659 == v0) {\n            supplyCompound(uint256);\n        } else if (0xf5a41dea == v0) {\n            balanceFulcrumInToken();\n        } else if (0xf69e2046 == v0) {\n            compound();\n        } else if (0xf7c1ec77 == v0) {\n            getAave();\n        } else if (0xf82ce27d == v0) {\n            getAaveCore();\n        } else if (0xfc0c546a == v0) {\n            token();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2024.03.22 01:26 UTC\n// Compiled using the solidity compiler version 0.5.12\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] array_3; // STORAGE[0x3]\nuint256[] array_4; // STORAGE[0x4]\nuint256 _deposit; // STORAGE[0x6]\nuint256 _pool; // STORAGE[0x7]\nuint256 _dToken; // STORAGE[0xe]\nuint256 _apr; // STORAGE[0xf]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint256 _token; // STORAGE[0x8] bytes 0 to 19\nuint256 _compound; // STORAGE[0x9] bytes 0 to 19\nuint256 _fulcrum; // STORAGE[0xa] bytes 0 to 19\nuint256 _aave; // STORAGE[0xb] bytes 0 to 19\nuint256 _aaveToken; // STORAGE[0xc] bytes 0 to 19\nuint256 _dydx; // STORAGE[0xd] bytes 0 to 19\n\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction 0x102f(uint256 varg0) private { \n    _deposit = _deposit + 1;\n    require(varg0 > 0, Error('withdraw must be greater than 0'));\n    require(varg0 <= _balanceOf[msg.sender], Error('insufficient balance'));\n    v0 = 0x339d();\n    _pool = v0;\n    v1 = 0x315b(varg0, _pool);\n    v2 = _SafeDiv(_totalSupply, v1);\n    v3 = _SafeSub('redeem amount exceeds balance', varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v3;\n    v4 = _SafeSub('SafeMath: subtraction overflow', varg0, _totalSupply);\n    _totalSupply = v4;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(msg.sender, address(0x0), varg0);\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[4 + MEM[64]] = address(this);\n    require(bool(_token.code.size));\n    v5, /* uint256 */ v6 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v6);\n    if (v6 < v2) {\n        v7 = _SafeSub('SafeMath: subtraction overflow', v6, v2);\n        0x345a(v7);\n    }\n    require(bool(_token.code.size));\n    v8, /* bool */ v9 = _token.transfer(msg.sender, v2).gas(msg.gas);\n    require(bool(v8), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v9 == bool(v9));\n    v10 = 0x339d();\n    _pool = v10;\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n    return ;\n}\n\nfunction 0x1506() private { \n    MEM[MEM[64]] = False;\n    MEM[32 + MEM[64]] = 0;\n    require(bool(_dydx.code.size));\n    v0 = _dydx.getAccountWei(address(this), 0, _dToken).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v1 = 0x4bbd(MEM[64], MEM[64] + RETURNDATASIZE());\n    return v1.word1;\n}\n\nfunction 0x1642() private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x16f4(uint256 varg0) private { \n    v0 = 0x2a8d();\n    require(bool((address(v0)).code.size));\n    v1 = address(v0).deposit(_token, varg0, uint16(0)).gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x17d8() private { \n    v0 = 0x211c();\n    v1 = 0x2332();\n    v2 = 0x1506();\n    v3 = 0x299c();\n    v4 = 0x2012();\n    v5 = _SafeAdd(v3, v4);\n    v6 = _SafeAdd(v2, v5);\n    v7 = _SafeAdd(v1, v6);\n    v8 = _SafeAdd(v0, v7);\n    return v8;\n}\n\nfunction 0x188d() private { \n    v0 = 0x1dd9();\n    assert(uint8(_apr >> 160) <= 4);\n    assert(v0 <= 4);\n    if (v0 != uint8(_apr >> 160)) {\n        0x3625();\n    }\n    v1 = 0x211c();\n    if (v1 > 0) {\n        assert(1 <= 4);\n        assert(v0 <= 4);\n        if (v0 != 1) {\n            assert(4 <= 4);\n            assert(v0 <= 4);\n            if (v0 != 4) {\n                assert(2 <= 4);\n                assert(v0 <= 4);\n                if (v0 != 2) {\n                    assert(3 <= 4);\n                    assert(v0 <= 4);\n                    if (v0 == 3) {\n                        v2 = 0x211c();\n                        0x16f4(v2);\n                    }\n                } else {\n                    v3 = 0x211c();\n                    0x28aa(v3);\n                }\n            } else {\n                v4 = 0x211c();\n                0x19d4(v4);\n            }\n        } else {\n            v5 = 0x211c();\n            v6 = 0x9f1(v5);\n        }\n    }\n    assert(v0 <= 4);\n    _apr = v0 << 160 | ~0xff0000000000000000000000000000000000000000 & _apr;\n    return ;\n}\n\nfunction 0x19d4(uint256 varg0) private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.mint(address(this), varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 > 0, Error('FULCRUM: supply failed'));\n    return ;\n}\n\nfunction 0x1b14() private { \n    v0 = new bytes[](((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1);\n    v1 = v2 = v0.data;\n    if (!(((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1)) {\n        return v0;\n    } else if (31 < ((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1) {\n        v3 = v4 = array_4.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + (((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_4.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x1dd9() private { \n    require(bool((address(address(_apr))).code.size));\n    v0, /* uint256 */ v1 = address(_apr).recommend(_token).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    MEM[64] = v1 + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(v1 + RETURNDATASIZE() - v1 >= 160);\n    require(MEM[v1] <= uint64.max);\n    require(v1 + MEM[v1] + 31 < v1 + RETURNDATASIZE());\n    v2 = MEM[v1 + MEM[v1]];\n    require(v2 <= uint64.max);\n    v3 = new bytes[](v2);\n    require(!((v3 + ((v2 + 31 & ~0x1f) + 32) > uint64.max) | (v3 + ((v2 + 31 & ~0x1f) + 32) < v3)));\n    require(v1 + MEM[v1] + 32 + v2 <= v1 + RETURNDATASIZE());\n    v4 = v5 = 0;\n    while (v4 < v2) {\n        v3[v4] = MEM[v1 + MEM[v1] + 32 + v4];\n        v4 = v4 + 32;\n    }\n    if (v4 > v2) {\n        v3[v2] = 0;\n    }\n    v6 = v7 = MEM[v1 + 32];\n    0x5daf(v7);\n    v6 = v8 = MEM[v1 + 64];\n    0x5daf(v8);\n    v6 = v9 = MEM[v1 + 96];\n    0x5daf(v9);\n    v6 = MEM[v1 + 128];\n    0x5daf(v6);\n    v6 = v10 = 0;\n    v11 = v12 = 0;\n    if (v6 != v7) {\n        if (v6 != v8) {\n            if (v6 != v9) {\n                if (v6 == v6) {\n                    v11 = v13 = 1;\n                }\n            } else {\n                v11 = v14 = 3;\n            }\n        } else {\n            v11 = v15 = 4;\n        }\n    } else {\n        v11 = v16 = 2;\n    }\n    return v11;\n}\n\nfunction 0x2012() private { \n    v0 = v1 = 0x1642();\n    if (v1 > 0) {\n        require(bool(_compound.code.size));\n        v2, /* uint256 */ v3 = _compound.exchangeRateStored().gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v3);\n        if (v1 != 0) {\n            v4 = v5 = v1 * v3;\n            assert(v1);\n            require(v5 / v1 == v3, Error('SafeMath: multiplication overflow'));\n        } else {\n            v4 = 0;\n        }\n        if (10 ** 18 > 0) {\n            assert(10 ** 18);\n            v0 = v4 / 10 ** 18;\n        } else {\n            MEM[MEM[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000;\n            v6 = new bytes[](v7.length);\n            MEM[4 + MEM[64]] = 32;\n            v8 = v9 = 0;\n            while (v8 < v7.length) {\n                v6[v8] = v7[v8];\n                v8 = v8 + 32;\n            }\n            if (v8 > v7.length) {\n                v6[v7.length] = 0;\n            }\n            revert(Error(v6, v10, 'SafeMath: division by zero'));\n        }\n    }\n    return v0;\n}\n\nfunction 0x211c() private { \n    require(bool(_token.code.size));\n    v0, /* uint256 */ v1 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x2332() private { \n    require(bool(_aaveToken.code.size));\n    v0, /* uint256 */ v1 = _aaveToken.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x23ea(uint256 varg0) private { \n    _deposit = _deposit + 1;\n    require(varg0 > 0, Error('withdraw must be greater than 0'));\n    require(varg0 <= _balanceOf[msg.sender], Error('insufficient balance'));\n    v0 = 0x17d8();\n    _pool = v0;\n    v1 = 0x315b(varg0, _pool);\n    v2 = _SafeDiv(_totalSupply, v1);\n    v3 = _SafeSub('redeem amount exceeds balance', varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v3;\n    v4 = _SafeSub('SafeMath: subtraction overflow', varg0, _totalSupply);\n    _totalSupply = v4;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(msg.sender, address(0x0), varg0);\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[4 + MEM[64]] = address(this);\n    require(bool(_token.code.size));\n    v5, /* uint256 */ v6 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v6);\n    v7 = v8 = uint8(_apr >> 160);\n    if (v6 < v2) {\n        v7 = v9 = 0x1dd9();\n        assert(uint8(_apr >> 160) <= 4);\n        assert(v9 <= 4);\n        if (v9 == uint8(_apr >> 160)) {\n            v10 = _SafeSub('SafeMath: subtraction overflow', v6, v2);\n            0x345a(v10);\n        } else {\n            0x3625();\n        }\n    }\n    v11 = v12 = EXTCODEHASH(_token) != 0;\n    if (EXTCODEHASH(_token) != 0) {\n        v11 = EXTCODEHASH(_token) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v11, Error('SafeERC20: call to non-contract'));\n    v13 = v14 = 0;\n    while (v13 < 68) {\n        MEM[MEM[64] + v13] = MEM[MEM[64] + 32 + v13];\n        v13 = v13 + 32;\n    }\n    if (v13 > 68) {\n        MEM[MEM[64] + 68] = 0;\n    }\n    v15, /* uint256 */ v16, /* uint256 */ v17 = _token.transfer(msg.sender, v2).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v18 = v19 = 96;\n    } else {\n        v18 = v20 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v20.data, 0, RETURNDATASIZE());\n    }\n    require(v15, Error('SafeERC20: low-level call failed'));\n    if (MEM[v18] > 0) {\n        require(v17 + MEM[v18] - v17 >= 32);\n        require(MEM[v17] == bool(MEM[v17]));\n        require(MEM[v17], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    assert(uint8(_apr >> 160) <= 4);\n    assert(v7 <= 4);\n    if (v7 != uint8(_apr >> 160)) {\n        v21 = 0x3b8d();\n        if (v21 > 0) {\n            assert(1 <= 4);\n            assert(v7 <= 4);\n            if (v7 != 1) {\n                assert(4 <= 4);\n                assert(v7 <= 4);\n                if (v7 != 4) {\n                    assert(2 <= 4);\n                    assert(v7 <= 4);\n                    if (v7 != 2) {\n                        assert(3 <= 4);\n                        assert(v7 <= 4);\n                        if (v7 == 3) {\n                            v22 = 0x3b8d();\n                            0x16f4(v22);\n                        }\n                    } else {\n                        v23 = 0x3b8d();\n                        0x28aa(v23);\n                    }\n                } else {\n                    v24 = 0x3b8d();\n                    0x19d4(v24);\n                }\n            } else {\n                v25 = 0x3b8d();\n                v26 = 0x9f1(v25);\n            }\n        }\n        assert(v7 <= 4);\n        _apr = v7 << 160 | ~0xff0000000000000000000000000000000000000000 & _apr;\n    }\n    v27 = 0x17d8();\n    _pool = v27;\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n    return ;\n}\n\nfunction function_selector() public payable { \n}\n\nfunction supplyDydx(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    v0 = 0x9f1(amount);\n    return v0;\n}\n\nfunction 0x28aa(uint256 varg0) private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.mint(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 == 0, Error('COMPOUND: supply failed'));\n    return ;\n}\n\nfunction 0x299c() private { \n    v0 = v1 = 0xd28();\n    if (v1 > 0) {\n        require(bool(_fulcrum.code.size));\n        v2, /* uint256 */ v0 = _fulcrum.assetBalanceOf(address(this)).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v0);\n    }\n    return v0;\n}\n\nfunction aaveToken() public nonPayable { \n    return _aaveToken;\n}\n\nfunction 0x2a8d() private { \n    require(bool(_aave.code.size));\n    v0, /* address */ v1 = _aave.getLendingPool().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5d81(v1);\n    return v1;\n}\n\nfunction 0x2b34() private { \n    require(bool(_aave.code.size));\n    v0, /* address */ v1 = _aave.getLendingPoolCore().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5d81(v1);\n    return v1;\n}\n\nfunction 0x2c09(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 != address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 != address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = 0xc55();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction 0x2dd4(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 != address(0x0), Error('ERC20: transfer from the zero address'));\n    require(varg1 != address(0x0), Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction provider() public nonPayable { \n    assert(uint8(_apr >> 160) < 5);\n    return uint8(_apr >> 160);\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction 0x30b9(uint256 varg0, address varg1, address varg2, address varg3) private { \n    v0 = v1 = EXTCODEHASH(varg3) != 0;\n    if (EXTCODEHASH(varg3) != 0) {\n        v0 = EXTCODEHASH(varg3) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v0, Error('SafeERC20: call to non-contract'));\n    v2 = v3 = 0;\n    while (v2 < 100) {\n        MEM[MEM[64] + v2] = MEM[MEM[64] + 32 + v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > 100) {\n        MEM[MEM[64] + 100] = 0;\n    }\n    v4, /* uint256 */ v5, /* uint256 */ v6 = varg3.transferFrom(varg2, varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v7 = v8 = 96;\n    } else {\n        v7 = v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v4, Error('SafeERC20: low-level call failed'));\n    if (MEM[v7] > 0) {\n        require(v6 + MEM[v7] - v6 >= 32);\n        require(MEM[v6] == bool(MEM[v6]));\n        require(MEM[v6], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    return ;\n}\n\nfunction 0x315b(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n    } else {\n        v0 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address spender, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(amount);\n    0x2c09(amount, spender, msg.sender);\n    return True;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 = v2 + 32;\n        }\n        if (v2 > v1.length) {\n            v0[v1.length] = 0;\n        }\n        revert(Error(v0, v4, 'SafeMath: division by zero'));\n    }\n}\n\nfunction 0x3215(uint256 varg0, address varg1) private { \n    require(varg1 != address(0x0), Error('ERC20: mint to the zero address'));\n    v0 = _SafeAdd(varg0, _totalSupply);\n    _totalSupply = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(address(0x0), varg1, varg0);\n    return ;\n}\n\nfunction 0x339d() private { \n    v0 = 0x3b8d();\n    v1 = 0x3c3f();\n    v2 = 0x3cf1();\n    v3 = 0x3de1();\n    v4 = v5 = 0x1642();\n    if (v5 > 0) {\n        require(bool(_compound.code.size));\n        v6, /* uint256 */ v7 = _compound.exchangeRateStored().gas(msg.gas);\n        require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v7);\n        if (v5 != 0) {\n            v8 = v9 = v5 * v7;\n            assert(v5);\n            require(v9 / v5 == v7, Error('SafeMath: multiplication overflow'));\n        } else {\n            v8 = v10 = 0;\n        }\n        if (10 ** 18 > 0) {\n            assert(10 ** 18);\n            v4 = v8 / 10 ** 18;\n        } else {\n            MEM[MEM[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000;\n            v11 = new bytes[](v12.length);\n            MEM[4 + MEM[64]] = 32;\n            v13 = v14 = 0;\n            while (v13 < v12.length) {\n                v11[v13] = v12[v13];\n                v13 = v13 + 32;\n            }\n            if (v13 > v12.length) {\n                v11[v12.length] = 0;\n            }\n            revert(Error(v11, v15, 'SafeMath: division by zero'));\n        }\n    }\n    v16 = _SafeAdd(v3, v4);\n    v17 = _SafeAdd(v2, v16);\n    v18 = _SafeAdd(v1, v17);\n    v19 = _SafeAdd(v0, v18);\n    return v19;\n}\n\nfunction 0x345a(uint256 varg0) private { \n    assert(2 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 2) {\n        v0 = 0x1642();\n        v1 = 0x2012();\n        require(v1 >= varg0, Error('insufficient funds'));\n        v2 = 0x315b(varg0, v0);\n        v3 = _SafeDiv(v1, v2);\n        v4 = _SafeAdd(1, v3);\n        0x4460(v4);\n    }\n    assert(3 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 3) {\n        v5 = 0x2332();\n        require(v5 >= varg0, Error('insufficient funds'));\n        0x403e(varg0);\n    }\n    assert(1 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 1) {\n        v6 = 0x1506();\n        require(v6 >= varg0, Error('insufficient funds'));\n        0x40ce(varg0);\n    }\n    assert(4 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 4) {\n        v7 = 0xd28();\n        v8 = 0x299c();\n        require(v8 >= varg0, Error('insufficient funds'));\n        v9 = 0x315b(varg0, v7);\n        v10 = _SafeDiv(v8, v9);\n        v11 = _SafeAdd(1, v10);\n        0x4604(v11);\n    }\n    return ;\n}\n\nfunction balanceFulcrum() public nonPayable { \n    v0 = 0xd28();\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction 0x3625() private { \n    v0 = 0x43ae();\n    if (v0 > 0) {\n        0x4460(v0);\n    }\n    v1 = 0x3cf1();\n    if (v1 > 0) {\n        0x40ce(v1);\n    }\n    v2 = 0x4552();\n    if (v2 > 0) {\n        0x4604(v2);\n    }\n    v3 = 0x3c3f();\n    if (v3 > 0) {\n        0x403e(v3);\n    }\n    return ;\n}\n\nfunction 0x369e(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        require(bool((address(varg2)).code.size));\n        v2, /* uint256 */ v3 = varg2.allowance(address(this), varg1).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v3);\n        v0 = v4 = v3 == 0;\n    }\n    require(v0, Error('SafeERC20: approve from non-zero to non-zero allowance'));\n    v5 = v6 = EXTCODEHASH(varg2) != 0;\n    if (EXTCODEHASH(varg2) != 0) {\n        v5 = EXTCODEHASH(varg2) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v5, Error('SafeERC20: call to non-contract'));\n    v7 = v8 = 0;\n    while (v7 < 68) {\n        MEM[MEM[64] + v7] = MEM[MEM[64] + 32 + v7];\n        v7 = v7 + 32;\n    }\n    if (v7 > 68) {\n        MEM[MEM[64] + 68] = 0;\n    }\n    v9, /* uint256 */ v10, /* uint256 */ v11 = varg2.approve(varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = v14 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v14.data, 0, RETURNDATASIZE());\n    }\n    require(v9, Error('SafeERC20: low-level call failed'));\n    if (MEM[v12] > 0) {\n        require(v11 + MEM[v12] - v11 >= 32);\n        require(MEM[v11] == bool(MEM[v11]));\n        require(MEM[v11], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    return ;\n}\n\nfunction pool() public nonPayable { \n    return _pool;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction 0x3b8d() private { \n    require(bool(_token.code.size));\n    v0, /* uint256 */ v1 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x3c3f() private { \n    require(bool(_aaveToken.code.size));\n    v0, /* uint256 */ v1 = _aaveToken.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x3cf1() private { \n    MEM[MEM[64]] = False;\n    MEM[32 + MEM[64]] = 0;\n    require(bool(_dydx.code.size));\n    v0 = _dydx.getAccountWei(address(this), 0, _dToken).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v1 = 0x4bbd(MEM[64], MEM[64] + RETURNDATASIZE());\n    return v1.word1;\n}\n\nfunction transferFrom(address sender, address recipient, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    0x5d81(sender);\n    0x5d81(recipient);\n    0x5daf(amount);\n    0x2dd4(amount, recipient, sender);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', amount, _allowance[sender][msg.sender]);\n    0x2c09(v0, msg.sender, sender);\n    return True;\n}\n\nfunction 0x3de1() private { \n    v0 = v1 = 0xd28();\n    if (v1 > 0) {\n        require(bool(_fulcrum.code.size));\n        v2, /* uint256 */ v0 = _fulcrum.assetBalanceOf(address(this)).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v0);\n    }\n    return v0;\n}\n\nfunction 0x403e(uint256 varg0) private { \n    require(bool(_aaveToken.code.size));\n    v0 = _aaveToken.redeem(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x40ce(uint256 varg0) private { \n    v0 = v1 = 1;\n    v2 = new struct(2);\n    v2.word0 = v1;\n    if (v1) {\n        v3 = v4 = v2.data;\n        do {\n            v5 = new struct(2);\n            v5.word0 = address(0x0);\n            v5.word1 = 0;\n            MEM[v3] = v5;\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v6 = new struct(2);\n    v6.word0 = address(this);\n    v6.word1 = 0;\n    assert(0 < v2.word0.length);\n    v7 = v2.data;\n    v2.word1 = v6;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[64] += 128;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = varg0;\n    v8 = 0x47b1();\n    assert(1 <= 1);\n    assert(1 <= 1);\n    v8.word0 = 1;\n    v8.word1 = 0;\n    v8.word2 = MEM[64];\n    v8.word3 = _dToken;\n    v8.word5 = address(this);\n    v9 = v10 = 1;\n    v11 = new uint256[](v10);\n    if (v10) {\n        v12 = v13 = v11.data;\n        do {\n            v14 = 0x481d();\n            MEM[v12] = v14;\n            v12 += 32;\n            v9 = v9 - 1;\n        } while (!v9);\n    }\n    assert(0 < v11.length);\n    v15 = v11.data;\n    v11[0] = v8;\n    v16 = 0x5743(4 + MEM[64], v11, v2);\n    require(bool(_dydx.code.size));\n    v17 = _dydx.operate().gas(msg.gas);\n    require(bool(v17), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction invest(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    _deposit = _deposit + 1;\n    require(amount > 0, Error('deposit must be greater than 0'));\n    v0 = 0x17d8();\n    _pool = v0;\n    0x30b9(amount, this, msg.sender, _token);\n    0x188d();\n    if (_pool != 0) {\n        v1 = 0x315b(_totalSupply, amount);\n        v2 = v3 = _SafeDiv(_pool, v1);\n    } else {\n        _pool = amount;\n    }\n    v4 = 0x17d8();\n    _pool = v4;\n    0x3215(v2, msg.sender);\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n}\n\nfunction 0x43ae() private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction withdraw(uint256 _amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(_amount);\n    0x102f(_amount);\n}\n\nfunction 0x4460(uint256 varg0) private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.redeem(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 == 0, Error('COMPOUND: withdraw failed'));\n    return ;\n}\n\nfunction 0x4552() private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x4604(uint256 varg0) private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.burn(address(this), varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 > 0, Error('FULCRUM: withdraw failed'));\n    return ;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction 0x47b1() private { \n    v0 = new struct(8);\n    assert(0 <= 1);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v1 = new struct(4);\n    v1.word0 = False;\n    assert(0 <= 0);\n    v1.word1 = 0;\n    assert(0 <= 0);\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v0.word2 = v1;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = address(0x0);\n    v0.word6 = 0;\n    v0.word7 = 96;\n    return v0;\n}\n\nfunction 0x481d() private { \n    v0 = new struct(8);\n    assert(0 <= 1);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v1 = new struct(4);\n    v1.word0 = False;\n    assert(0 <= 0);\n    v1.word1 = 0;\n    assert(0 <= 0);\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v0.word2 = v1;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = address(0x0);\n    v0.word6 = 0;\n    v0.word7 = 96;\n    return v0;\n}\n\nfunction increaseAllowance(address spender, uint256 addedValue) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(addedValue);\n    v0 = _SafeAdd(addedValue, _allowance[msg.sender][spender]);\n    0x2c09(v0, spender, msg.sender);\n    return True;\n}\n\nfunction 0x4bbd(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 >= 64);\n    require(varg1 - varg0 >= 64);\n    v0 = new struct(2);\n    require(!((v0 + 64 > uint64.max) | (v0 + 64 < v0)));\n    require(MEM[varg0] == bool(MEM[varg0]));\n    v0.word0 = MEM[varg0];\n    0x5daf(MEM[varg0 + 32]);\n    v0.word1 = MEM[varg0 + 32];\n    return v0;\n}\n\nfunction 0x4c91(uint256 varg0, uint256 varg1) private { \n    MEM[varg1] = varg0.length;\n    v0 = v1 = varg1 + 32;\n    v2 = v3 = v1 + (varg0.length << 5);\n    v4 = v5 = varg0.data;\n    v6 = v7 = 0;\n    while (v6 < varg0.length) {\n        MEM[v0] = v2 - v1;\n        assert(MEM[MEM[v4]] < 2);\n        MEM[v2] = MEM[MEM[v4]];\n        MEM[v2 + 32] = MEM[MEM[v4] + 32];\n        MEM[v2 + 64] = bool(MEM[MEM[MEM[v4] + 64]]);\n        assert(MEM[MEM[MEM[v4] + 64] + 32] < 1);\n        MEM[v2 + 64 + 32] = MEM[MEM[MEM[v4] + 64] + 32];\n        assert(MEM[MEM[MEM[v4] + 64] + 64] < 1);\n        MEM[v2 + 64 + 64] = MEM[MEM[MEM[v4] + 64] + 64];\n        MEM[v2 + 64 + 96] = MEM[MEM[MEM[v4] + 64] + 96];\n        MEM[v2 + 192] = MEM[MEM[v4] + 96];\n        MEM[v2 + 224] = MEM[MEM[v4] + 128];\n        MEM[v2 + 256] = address(MEM[MEM[v4] + 160]);\n        MEM[v2 + 288] = MEM[MEM[v4] + 192];\n        MEM[v2 + 320] = v2 + 352 - v2;\n        MEM[v2 + 352] = MEM[MEM[MEM[v4] + 224]];\n        v8 = v9 = 0;\n        while (v8 < MEM[MEM[MEM[v4] + 224]]) {\n            MEM[v2 + 352 + 32 + v8] = MEM[MEM[MEM[v4] + 224] + 32 + v8];\n            v8 = v8 + 32;\n        }\n        if (v8 > MEM[MEM[MEM[v4] + 224]]) {\n            MEM[v2 + 352 + 32 + MEM[MEM[MEM[v4] + 224]]] = 0;\n        }\n        v2 = v2 + 352 + 32 + (MEM[MEM[MEM[v4] + 224]] + 31 & ~0x1f);\n        v4 = v4 + 32;\n        v0 = v0 + 32;\n        v6 = v6 + 1;\n    }\n    return v2;\n}\n\nfunction balanceDydx() public nonPayable { \n    v0 = 0x1506();\n    return v0;\n}\n\nfunction apr() public nonPayable { \n    return address(_apr);\n}\n\nfunction fulcrum() public nonPayable { \n    return _fulcrum;\n}\n\nfunction balanceCompound() public nonPayable { \n    v0 = 0x1642();\n    return v0;\n}\n\nfunction 0x5743(uint256 varg0, uint256 varg1, struct(2) varg2) private { \n    MEM[varg0] = varg0 + 64 - varg0;\n    MEM[varg0 + 64] = varg2.word0.length;\n    v0 = v1 = varg0 + 64 + 32;\n    v2 = v3 = varg2.data;\n    v4 = v5 = 0;\n    while (v4 < varg2.word0.length) {\n        MEM[v0] = address(MEM[MEM[v2]]);\n        MEM[v0 + 32] = MEM[MEM[v2] + 32];\n        v0 = v0 + 64;\n        v2 = v2 + 32;\n        v4 = v4 + 1;\n    }\n    MEM[varg0 + 32] = v0 - varg0;\n    v6 = 0x4c91(varg1, v0);\n    return v6;\n}\n\nfunction supplyAave(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x16f4(amount);\n}\n\nfunction balanceOf(address account) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5d81(account);\n    return _balanceOf[account];\n}\n\nfunction 0x5d81(address varg0) private { \n    return ;\n}\n\nfunction 0x5daf(uint256 varg0) private { \n    return ;\n}\n\nfunction calcPoolValueInToken() public nonPayable { \n    v0 = 0x17d8();\n    return v0;\n}\n\nfunction getPricePerFullShare() public nonPayable { \n    v0 = 0x17d8();\n    v1 = 0x315b(10 ** 18, v0);\n    v2 = _SafeDiv(_totalSupply, v1);\n    return v2;\n}\n\nfunction rebalance() public nonPayable { \n    0x188d();\n}\n\nfunction supplyFulcrum(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x19d4(amount);\n}\n\nfunction aave() public nonPayable { \n    return _aave;\n}\n\nfunction dydx() public nonPayable { \n    return _dydx;\n}\n\nfunction symbol() public nonPayable { \n    v0 = 0x1b14();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction approveToken() public nonPayable { \n    0x369e(uint256.max, _compound, _token);\n    0x369e(uint256.max, _dydx, _token);\n    v0 = 0x2b34();\n    0x369e(uint256.max, v0, _token);\n    0x369e(uint256.max, _fulcrum, _token);\n}\n\nfunction recommend() public nonPayable { \n    v0 = 0x1dd9();\n    assert(v0 < 5);\n    return v0;\n}\n\nfunction decreaseAllowance(address spender, uint256 subtractedValue) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(subtractedValue);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', subtractedValue, _allowance[msg.sender][spender]);\n    0x2c09(v0, spender, msg.sender);\n    return True;\n}\n\nfunction balanceCompoundInToken() public nonPayable { \n    v0 = 0x2012();\n    return v0;\n}\n\nfunction transfer(address recipient, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(recipient);\n    0x5daf(amount);\n    0x2dd4(amount, recipient, msg.sender);\n    return True;\n}\n\nfunction balance() public nonPayable { \n    v0 = 0x211c();\n    return v0;\n}\n\nfunction deposit(uint256 _amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(_amount);\n    _deposit = _deposit + 1;\n    require(_amount > 0, Error('deposit must be greater than 0'));\n    v0 = 0x339d();\n    _pool = v0;\n    0x30b9(_amount, this, msg.sender, _token);\n    if (_pool != 0) {\n        v1 = 0x315b(_totalSupply, _amount);\n        v2 = v3 = _SafeDiv(_pool, v1);\n    } else {\n        _pool = _amount;\n    }\n    v4 = 0x339d();\n    _pool = v4;\n    0x3215(v2, msg.sender);\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n}\n\nfunction balanceAave() public nonPayable { \n    v0 = 0x2332();\n    return v0;\n}\n\nfunction dToken() public nonPayable { \n    return _dToken;\n}\n\nfunction redeem(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x23ea(amount);\n}\n\nfunction allowance(address owner, address spender) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(owner);\n    0x5d81(spender);\n    return _allowance[owner][spender];\n}\n\nfunction supplyCompound(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x28aa(amount);\n}\n\nfunction balanceFulcrumInToken() public nonPayable { \n    v0 = 0x299c();\n    return v0;\n}\n\nfunction compound() public nonPayable { \n    return _compound;\n}\n\nfunction getAave() public nonPayable { \n    v0 = 0x2a8d();\n    return address(v0);\n}\n\nfunction getAaveCore() public nonPayable { \n    v0 = 0x2b34();\n    return address(v0);\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x9f1(uint256 varg0) private { \n    v0 = v1 = 1;\n    v2 = new struct(2);\n    v2.word0 = v1;\n    if (v1) {\n        v3 = v4 = v2.data;\n        do {\n            v5 = new struct(2);\n            v5.word0 = address(0x0);\n            v5.word1 = 0;\n            MEM[v3] = v5;\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v6 = new struct(2);\n    v6.word0 = address(this);\n    v6.word1 = 0;\n    assert(0 < v2.word0.length);\n    v7 = v2.data;\n    v2.word1 = v6;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[64] += 128;\n    MEM[MEM[64]] = True;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = varg0;\n    v8 = 0x47b1();\n    assert(0 <= 1);\n    assert(0 <= 1);\n    v8.word0 = 0;\n    v8.word1 = 0;\n    v8.word2 = MEM[64];\n    v8.word3 = _dToken;\n    v8.word5 = address(this);\n    v9 = v10 = 1;\n    v11 = new uint256[](v10);\n    if (v10) {\n        v12 = v13 = v11.data;\n        do {\n            v14 = 0x481d();\n            MEM[v12] = v14;\n            v12 += 32;\n            v9 = v9 - 1;\n        } while (!v9);\n    }\n    assert(0 < v11.length);\n    v15 = v11.data;\n    v11[0] = v8;\n    v16 = 0x5743(4 + MEM[64], v11, v2);\n    require(bool(_dydx.code.size));\n    v17 = _dydx.operate().gas(msg.gas);\n    require(bool(v17), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return 0;\n}\n\nfunction 0xc55() private { \n    v0 = new bytes[](((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1);\n    v1 = v2 = v0.data;\n    if (!(((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1)) {\n        return v0;\n    } else if (31 < ((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1) {\n        v3 = v4 = array_3.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + (((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_3.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0xd28() private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction function_selector( function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x7d7c2a1c > v0) {\n            if (0x2e1a7d4d > v0) {\n                if (0xeb2a267 > v0) {\n                    if (0x6636c1c == v0) {\n                        supplyDydx(uint256);\n                    } else if (0x6a3fe59 == v0) {\n                        aaveToken();\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x85d4883 == v0) {\n                        provider();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    }\n                } else if (0xeb2a267 == v0) {\n                    balanceFulcrum();\n                } else if (0x16f0115b == v0) {\n                    pool();\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x2afcf480 == v0) {\n                    invest(uint256);\n                }\n            } else if (0x58782c21 > v0) {\n                if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else if (0x39c0a7e1 == v0) {\n                    balanceDydx();\n                } else if (0x57ded9c9 == v0) {\n                    apr();\n                }\n            } else if (0x58782c21 == v0) {\n                fulcrum();\n            } else if (0x61c1ec55 == v0) {\n                balanceCompound();\n            } else if (0x65aab749 == v0) {\n                supplyAave(uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            } else if (0x7137ef99 == v0) {\n                calcPoolValueInToken();\n            } else if (0x77c7b8fc == v0) {\n                getPricePerFullShare();\n            }\n        } else if (0xb6b55f25 > v0) {\n            if (0x99b71d5c > v0) {\n                if (0x7d7c2a1c == v0) {\n                    rebalance();\n                } else if (0x8124955c == v0) {\n                    supplyFulcrum(uint256);\n                } else if (0x819faf7b == v0) {\n                    aave();\n                } else if (0x8e4ec6ef == v0) {\n                    dydx();\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                }\n            } else if (0x99b71d5c == v0) {\n                approveToken();\n            } else if (0xa160176d == v0) {\n                recommend();\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa7287971 == v0) {\n                balanceCompoundInToken();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xb69ef8a8 == v0) {\n                balance();\n            }\n        } else if (0xe849d659 > v0) {\n            if (0xb6b55f25 == v0) {\n                deposit(uint256);\n            } else if (0xcf8ca426 == v0) {\n                balanceAave();\n            } else if (0xd9d7858a == v0) {\n                dToken();\n            } else if (0xdb006a75 == v0) {\n                redeem(uint256);\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            }\n        } else if (0xe849d659 == v0) {\n            supplyCompound(uint256);\n        } else if (0xf5a41dea == v0) {\n            balanceFulcrumInToken();\n        } else if (0xf69e2046 == v0) {\n            compound();\n        } else if (0xf7c1ec77 == v0) {\n            getAave();\n        } else if (0xf82ce27d == v0) {\n            getAaveCore();\n        } else if (0xfc0c546a == v0) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2024.03.22 01:26 UTC\n// Compiled using the solidity compiler version 0.5.12\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] array_3; // STORAGE[0x3]\nuint256[] array_4; // STORAGE[0x4]\nuint256 _deposit; // STORAGE[0x6]\nuint256 _pool; // STORAGE[0x7]\nuint256 _dToken; // STORAGE[0xe]\nuint256 _apr; // STORAGE[0xf]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\nuint256 _token; // STORAGE[0x8] bytes 0 to 19\nuint256 _compound; // STORAGE[0x9] bytes 0 to 19\nuint256 _fulcrum; // STORAGE[0xa] bytes 0 to 19\nuint256 _aave; // STORAGE[0xb] bytes 0 to 19\nuint256 _aaveToken; // STORAGE[0xc] bytes 0 to 19\nuint256 _dydx; // STORAGE[0xd] bytes 0 to 19\n\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction 0x102f(uint256 varg0) private { \n    _deposit = _deposit + 1;\n    require(varg0 > 0, Error('withdraw must be greater than 0'));\n    require(varg0 <= _balanceOf[msg.sender], Error('insufficient balance'));\n    v0 = 0x339d();\n    _pool = v0;\n    v1 = 0x315b(varg0, _pool);\n    v2 = _SafeDiv(_totalSupply, v1);\n    v3 = _SafeSub('redeem amount exceeds balance', varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v3;\n    v4 = _SafeSub('SafeMath: subtraction overflow', varg0, _totalSupply);\n    _totalSupply = v4;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(msg.sender, address(0x0), varg0);\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[4 + MEM[64]] = address(this);\n    require(bool(_token.code.size));\n    v5, /* uint256 */ v6 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v6);\n    if (v6 < v2) {\n        v7 = _SafeSub('SafeMath: subtraction overflow', v6, v2);\n        0x345a(v7);\n    }\n    require(bool(_token.code.size));\n    v8, /* bool */ v9 = _token.transfer(msg.sender, v2).gas(msg.gas);\n    require(bool(v8), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v9 == bool(v9));\n    v10 = 0x339d();\n    _pool = v10;\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n    return ;\n}\n\nfunction 0x1506() private { \n    MEM[MEM[64]] = False;\n    MEM[32 + MEM[64]] = 0;\n    require(bool(_dydx.code.size));\n    v0 = _dydx.getAccountWei(address(this), 0, _dToken).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v1 = 0x4bbd(MEM[64], MEM[64] + RETURNDATASIZE());\n    return v1.word1;\n}\n\nfunction 0x1642() private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x16f4(uint256 varg0) private { \n    v0 = 0x2a8d();\n    require(bool((address(v0)).code.size));\n    v1 = address(v0).deposit(_token, varg0, uint16(0)).gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x17d8() private { \n    v0 = 0x211c();\n    v1 = 0x2332();\n    v2 = 0x1506();\n    v3 = 0x299c();\n    v4 = 0x2012();\n    v5 = _SafeAdd(v3, v4);\n    v6 = _SafeAdd(v2, v5);\n    v7 = _SafeAdd(v1, v6);\n    v8 = _SafeAdd(v0, v7);\n    return v8;\n}\n\nfunction 0x188d() private { \n    v0 = 0x1dd9();\n    assert(uint8(_apr >> 160) <= 4);\n    assert(v0 <= 4);\n    if (v0 != uint8(_apr >> 160)) {\n        0x3625();\n    }\n    v1 = 0x211c();\n    if (v1 > 0) {\n        assert(1 <= 4);\n        assert(v0 <= 4);\n        if (v0 != 1) {\n            assert(4 <= 4);\n            assert(v0 <= 4);\n            if (v0 != 4) {\n                assert(2 <= 4);\n                assert(v0 <= 4);\n                if (v0 != 2) {\n                    assert(3 <= 4);\n                    assert(v0 <= 4);\n                    if (v0 == 3) {\n                        v2 = 0x211c();\n                        0x16f4(v2);\n                    }\n                } else {\n                    v3 = 0x211c();\n                    0x28aa(v3);\n                }\n            } else {\n                v4 = 0x211c();\n                0x19d4(v4);\n            }\n        } else {\n            v5 = 0x211c();\n            v6 = 0x9f1(v5);\n        }\n    }\n    assert(v0 <= 4);\n    _apr = v0 << 160 | ~0xff0000000000000000000000000000000000000000 & _apr;\n    return ;\n}\n\nfunction 0x19d4(uint256 varg0) private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.mint(address(this), varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 > 0, Error('FULCRUM: supply failed'));\n    return ;\n}\n\nfunction 0x1b14() private { \n    v0 = new bytes[](((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1);\n    v1 = v2 = v0.data;\n    if (!(((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1)) {\n        return v0;\n    } else if (31 < ((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1) {\n        v3 = v4 = array_4.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + (((!(0x1 & array_4.length) << 8) - 1 & array_4.length) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_4.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0x1dd9() private { \n    require(bool((address(address(_apr))).code.size));\n    v0, /* uint256 */ v1 = address(_apr).recommend(_token).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    RETURNDATACOPY(v1, 0, RETURNDATASIZE());\n    MEM[64] = v1 + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(v1 + RETURNDATASIZE() - v1 >= 160);\n    require(MEM[v1] <= uint64.max);\n    require(v1 + MEM[v1] + 31 < v1 + RETURNDATASIZE());\n    v2 = MEM[v1 + MEM[v1]];\n    require(v2 <= uint64.max);\n    v3 = new bytes[](v2);\n    require(!((v3 + ((v2 + 31 & ~0x1f) + 32) > uint64.max) | (v3 + ((v2 + 31 & ~0x1f) + 32) < v3)));\n    require(v1 + MEM[v1] + 32 + v2 <= v1 + RETURNDATASIZE());\n    v4 = v5 = 0;\n    while (v4 < v2) {\n        v3[v4] = MEM[v1 + MEM[v1] + 32 + v4];\n        v4 = v4 + 32;\n    }\n    if (v4 > v2) {\n        v3[v2] = 0;\n    }\n    v6 = v7 = MEM[v1 + 32];\n    0x5daf(v7);\n    v6 = v8 = MEM[v1 + 64];\n    0x5daf(v8);\n    v6 = v9 = MEM[v1 + 96];\n    0x5daf(v9);\n    v6 = MEM[v1 + 128];\n    0x5daf(v6);\n    v6 = v10 = 0;\n    v11 = v12 = 0;\n    if (v6 != v7) {\n        if (v6 != v8) {\n            if (v6 != v9) {\n                if (v6 == v6) {\n                    v11 = v13 = 1;\n                }\n            } else {\n                v11 = v14 = 3;\n            }\n        } else {\n            v11 = v15 = 4;\n        }\n    } else {\n        v11 = v16 = 2;\n    }\n    return v11;\n}\n\nfunction 0x2012() private { \n    v0 = v1 = 0x1642();\n    if (v1 > 0) {\n        require(bool(_compound.code.size));\n        v2, /* uint256 */ v3 = _compound.exchangeRateStored().gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v3);\n        if (v1 != 0) {\n            v4 = v5 = v1 * v3;\n            assert(v1);\n            require(v5 / v1 == v3, Error('SafeMath: multiplication overflow'));\n        } else {\n            v4 = 0;\n        }\n        if (10 ** 18 > 0) {\n            assert(10 ** 18);\n            v0 = v4 / 10 ** 18;\n        } else {\n            MEM[MEM[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000;\n            v6 = new bytes[](v7.length);\n            MEM[4 + MEM[64]] = 32;\n            v8 = v9 = 0;\n            while (v8 < v7.length) {\n                v6[v8] = v7[v8];\n                v8 = v8 + 32;\n            }\n            if (v8 > v7.length) {\n                v6[v7.length] = 0;\n            }\n            revert(Error(v6, v10, 'SafeMath: division by zero'));\n        }\n    }\n    return v0;\n}\n\nfunction 0x211c() private { \n    require(bool(_token.code.size));\n    v0, /* uint256 */ v1 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x2332() private { \n    require(bool(_aaveToken.code.size));\n    v0, /* uint256 */ v1 = _aaveToken.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x23ea(uint256 varg0) private { \n    _deposit = _deposit + 1;\n    require(varg0 > 0, Error('withdraw must be greater than 0'));\n    require(varg0 <= _balanceOf[msg.sender], Error('insufficient balance'));\n    v0 = 0x17d8();\n    _pool = v0;\n    v1 = 0x315b(varg0, _pool);\n    v2 = _SafeDiv(_totalSupply, v1);\n    v3 = _SafeSub('redeem amount exceeds balance', varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v3;\n    v4 = _SafeSub('SafeMath: subtraction overflow', varg0, _totalSupply);\n    _totalSupply = v4;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(msg.sender, address(0x0), varg0);\n    MEM[MEM[64]] = 0x70a0823100000000000000000000000000000000000000000000000000000000;\n    MEM[4 + MEM[64]] = address(this);\n    require(bool(_token.code.size));\n    v5, /* uint256 */ v6 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v6);\n    v7 = v8 = uint8(_apr >> 160);\n    if (v6 < v2) {\n        v7 = v9 = 0x1dd9();\n        assert(uint8(_apr >> 160) <= 4);\n        assert(v9 <= 4);\n        if (v9 == uint8(_apr >> 160)) {\n            v10 = _SafeSub('SafeMath: subtraction overflow', v6, v2);\n            0x345a(v10);\n        } else {\n            0x3625();\n        }\n    }\n    v11 = v12 = EXTCODEHASH(_token) != 0;\n    if (EXTCODEHASH(_token) != 0) {\n        v11 = EXTCODEHASH(_token) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v11, Error('SafeERC20: call to non-contract'));\n    v13 = v14 = 0;\n    while (v13 < 68) {\n        MEM[MEM[64] + v13] = MEM[MEM[64] + 32 + v13];\n        v13 = v13 + 32;\n    }\n    if (v13 > 68) {\n        MEM[MEM[64] + 68] = 0;\n    }\n    v15, /* uint256 */ v16, /* uint256 */ v17 = _token.transfer(msg.sender, v2).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v18 = v19 = 96;\n    } else {\n        v18 = v20 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v20.data, 0, RETURNDATASIZE());\n    }\n    require(v15, Error('SafeERC20: low-level call failed'));\n    if (MEM[v18] > 0) {\n        require(v17 + MEM[v18] - v17 >= 32);\n        require(MEM[v17] == bool(MEM[v17]));\n        require(MEM[v17], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    assert(uint8(_apr >> 160) <= 4);\n    assert(v7 <= 4);\n    if (v7 != uint8(_apr >> 160)) {\n        v21 = 0x3b8d();\n        if (v21 > 0) {\n            assert(1 <= 4);\n            assert(v7 <= 4);\n            if (v7 != 1) {\n                assert(4 <= 4);\n                assert(v7 <= 4);\n                if (v7 != 4) {\n                    assert(2 <= 4);\n                    assert(v7 <= 4);\n                    if (v7 != 2) {\n                        assert(3 <= 4);\n                        assert(v7 <= 4);\n                        if (v7 == 3) {\n                            v22 = 0x3b8d();\n                            0x16f4(v22);\n                        }\n                    } else {\n                        v23 = 0x3b8d();\n                        0x28aa(v23);\n                    }\n                } else {\n                    v24 = 0x3b8d();\n                    0x19d4(v24);\n                }\n            } else {\n                v25 = 0x3b8d();\n                v26 = 0x9f1(v25);\n            }\n        }\n        assert(v7 <= 4);\n        _apr = v7 << 160 | ~0xff0000000000000000000000000000000000000000 & _apr;\n    }\n    v27 = 0x17d8();\n    _pool = v27;\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n    return ;\n}\n\nfunction function_selector() public payable { \n}\n\nfunction supplyDydx(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    v0 = 0x9f1(amount);\n    return v0;\n}\n\nfunction 0x28aa(uint256 varg0) private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.mint(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 == 0, Error('COMPOUND: supply failed'));\n    return ;\n}\n\nfunction 0x299c() private { \n    v0 = v1 = 0xd28();\n    if (v1 > 0) {\n        require(bool(_fulcrum.code.size));\n        v2, /* uint256 */ v0 = _fulcrum.assetBalanceOf(address(this)).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v0);\n    }\n    return v0;\n}\n\nfunction aaveToken() public nonPayable { \n    return _aaveToken;\n}\n\nfunction 0x2a8d() private { \n    require(bool(_aave.code.size));\n    v0, /* address */ v1 = _aave.getLendingPool().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5d81(v1);\n    return v1;\n}\n\nfunction 0x2b34() private { \n    require(bool(_aave.code.size));\n    v0, /* address */ v1 = _aave.getLendingPoolCore().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5d81(v1);\n    return v1;\n}\n\nfunction 0x2c09(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 != address(0x0), Error('ERC20: approve from the zero address'));\n    require(varg1 != address(0x0), Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = 0xc55();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction 0x2dd4(uint256 varg0, address varg1, address varg2) private { \n    require(varg2 != address(0x0), Error('ERC20: transfer from the zero address'));\n    require(varg1 != address(0x0), Error('ERC20: transfer to the zero address'));\n    v0 = _SafeSub('ERC20: transfer amount exceeds balance', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(varg2, varg1, varg0);\n    return ;\n}\n\nfunction provider() public nonPayable { \n    assert(uint8(_apr >> 160) < 5);\n    return uint8(_apr >> 160);\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction 0x30b9(uint256 varg0, address varg1, address varg2, address varg3) private { \n    v0 = v1 = EXTCODEHASH(varg3) != 0;\n    if (EXTCODEHASH(varg3) != 0) {\n        v0 = EXTCODEHASH(varg3) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v0, Error('SafeERC20: call to non-contract'));\n    v2 = v3 = 0;\n    while (v2 < 100) {\n        MEM[MEM[64] + v2] = MEM[MEM[64] + 32 + v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > 100) {\n        MEM[MEM[64] + 100] = 0;\n    }\n    v4, /* uint256 */ v5, /* uint256 */ v6 = varg3.transferFrom(varg2, varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v7 = v8 = 96;\n    } else {\n        v7 = v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v4, Error('SafeERC20: low-level call failed'));\n    if (MEM[v7] > 0) {\n        require(v6 + MEM[v7] - v6 >= 32);\n        require(MEM[v6] == bool(MEM[v6]));\n        require(MEM[v6], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    return ;\n}\n\nfunction 0x315b(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, Error('SafeMath: multiplication overflow'));\n    } else {\n        v0 = 0;\n    }\n    return v0;\n}\n\nfunction approve(address spender, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(amount);\n    0x2c09(amount, spender, msg.sender);\n    return True;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new bytes[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            v0[v2] = v1[v2];\n            v2 = v2 + 32;\n        }\n        if (v2 > v1.length) {\n            v0[v1.length] = 0;\n        }\n        revert(Error(v0, v4, 'SafeMath: division by zero'));\n    }\n}\n\nfunction 0x3215(uint256 varg0, address varg1) private { \n    require(varg1 != address(0x0), Error('ERC20: mint to the zero address'));\n    v0 = _SafeAdd(varg0, _totalSupply);\n    _totalSupply = v0;\n    v1 = _SafeAdd(varg0, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    emit Transfer(address(0x0), varg1, varg0);\n    return ;\n}\n\nfunction 0x339d() private { \n    v0 = 0x3b8d();\n    v1 = 0x3c3f();\n    v2 = 0x3cf1();\n    v3 = 0x3de1();\n    v4 = v5 = 0x1642();\n    if (v5 > 0) {\n        require(bool(_compound.code.size));\n        v6, /* uint256 */ v7 = _compound.exchangeRateStored().gas(msg.gas);\n        require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v7);\n        if (v5 != 0) {\n            v8 = v9 = v5 * v7;\n            assert(v5);\n            require(v9 / v5 == v7, Error('SafeMath: multiplication overflow'));\n        } else {\n            v8 = v10 = 0;\n        }\n        if (10 ** 18 > 0) {\n            assert(10 ** 18);\n            v4 = v8 / 10 ** 18;\n        } else {\n            MEM[MEM[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000;\n            v11 = new bytes[](v12.length);\n            MEM[4 + MEM[64]] = 32;\n            v13 = v14 = 0;\n            while (v13 < v12.length) {\n                v11[v13] = v12[v13];\n                v13 = v13 + 32;\n            }\n            if (v13 > v12.length) {\n                v11[v12.length] = 0;\n            }\n            revert(Error(v11, v15, 'SafeMath: division by zero'));\n        }\n    }\n    v16 = _SafeAdd(v3, v4);\n    v17 = _SafeAdd(v2, v16);\n    v18 = _SafeAdd(v1, v17);\n    v19 = _SafeAdd(v0, v18);\n    return v19;\n}\n\nfunction 0x345a(uint256 varg0) private { \n    assert(2 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 2) {\n        v0 = 0x1642();\n        v1 = 0x2012();\n        require(v1 >= varg0, Error('insufficient funds'));\n        v2 = 0x315b(varg0, v0);\n        v3 = _SafeDiv(v1, v2);\n        v4 = _SafeAdd(1, v3);\n        0x4460(v4);\n    }\n    assert(3 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 3) {\n        v5 = 0x2332();\n        require(v5 >= varg0, Error('insufficient funds'));\n        0x403e(varg0);\n    }\n    assert(1 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 1) {\n        v6 = 0x1506();\n        require(v6 >= varg0, Error('insufficient funds'));\n        0x40ce(varg0);\n    }\n    assert(4 <= 4);\n    assert(uint8(_apr >> 160) <= 4);\n    if (uint8(_apr >> 160) == 4) {\n        v7 = 0xd28();\n        v8 = 0x299c();\n        require(v8 >= varg0, Error('insufficient funds'));\n        v9 = 0x315b(varg0, v7);\n        v10 = _SafeDiv(v8, v9);\n        v11 = _SafeAdd(1, v10);\n        0x4604(v11);\n    }\n    return ;\n}\n\nfunction balanceFulcrum() public nonPayable { \n    v0 = 0xd28();\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction 0x3625() private { \n    v0 = 0x43ae();\n    if (v0 > 0) {\n        0x4460(v0);\n    }\n    v1 = 0x3cf1();\n    if (v1 > 0) {\n        0x40ce(v1);\n    }\n    v2 = 0x4552();\n    if (v2 > 0) {\n        0x4604(v2);\n    }\n    v3 = 0x3c3f();\n    if (v3 > 0) {\n        0x403e(v3);\n    }\n    return ;\n}\n\nfunction 0x369e(uint256 varg0, address varg1, address varg2) private { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        require(bool((address(varg2)).code.size));\n        v2, /* uint256 */ v3 = varg2.allowance(address(this), varg1).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v3);\n        v0 = v4 = v3 == 0;\n    }\n    require(v0, Error('SafeERC20: approve from non-zero to non-zero allowance'));\n    v5 = v6 = EXTCODEHASH(varg2) != 0;\n    if (EXTCODEHASH(varg2) != 0) {\n        v5 = EXTCODEHASH(varg2) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n    }\n    require(v5, Error('SafeERC20: call to non-contract'));\n    v7 = v8 = 0;\n    while (v7 < 68) {\n        MEM[MEM[64] + v7] = MEM[MEM[64] + 32 + v7];\n        v7 = v7 + 32;\n    }\n    if (v7 > 68) {\n        MEM[MEM[64] + 68] = 0;\n    }\n    v9, /* uint256 */ v10, /* uint256 */ v11 = varg2.approve(varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = v14 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v14.data, 0, RETURNDATASIZE());\n    }\n    require(v9, Error('SafeERC20: low-level call failed'));\n    if (MEM[v12] > 0) {\n        require(v11 + MEM[v12] - v11 >= 32);\n        require(MEM[v11] == bool(MEM[v11]));\n        require(MEM[v11], Error('SafeERC20: ERC20 operation did not succeed'));\n    }\n    return ;\n}\n\nfunction pool() public nonPayable { \n    return _pool;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction 0x3b8d() private { \n    require(bool(_token.code.size));\n    v0, /* uint256 */ v1 = _token.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x3c3f() private { \n    require(bool(_aaveToken.code.size));\n    v0, /* uint256 */ v1 = _aaveToken.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x3cf1() private { \n    MEM[MEM[64]] = False;\n    MEM[32 + MEM[64]] = 0;\n    require(bool(_dydx.code.size));\n    v0 = _dydx.getAccountWei(address(this), 0, _dToken).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v1 = 0x4bbd(MEM[64], MEM[64] + RETURNDATASIZE());\n    return v1.word1;\n}\n\nfunction transferFrom(address sender, address recipient, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 96);\n    0x5d81(sender);\n    0x5d81(recipient);\n    0x5daf(amount);\n    0x2dd4(amount, recipient, sender);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', amount, _allowance[sender][msg.sender]);\n    0x2c09(v0, msg.sender, sender);\n    return True;\n}\n\nfunction 0x3de1() private { \n    v0 = v1 = 0xd28();\n    if (v1 > 0) {\n        require(bool(_fulcrum.code.size));\n        v2, /* uint256 */ v0 = _fulcrum.assetBalanceOf(address(this)).gas(msg.gas);\n        require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        0x5daf(v0);\n    }\n    return v0;\n}\n\nfunction 0x403e(uint256 varg0) private { \n    require(bool(_aaveToken.code.size));\n    v0 = _aaveToken.redeem(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction 0x40ce(uint256 varg0) private { \n    v0 = v1 = 1;\n    v2 = new struct(2);\n    v2.word0 = v1;\n    if (v1) {\n        v3 = v4 = v2.data;\n        do {\n            v5 = new struct(2);\n            v5.word0 = address(0x0);\n            v5.word1 = 0;\n            MEM[v3] = v5;\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v6 = new struct(2);\n    v6.word0 = address(this);\n    v6.word1 = 0;\n    assert(0 < v2.word0.length);\n    v7 = v2.data;\n    v2.word1 = v6;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[64] += 128;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = varg0;\n    v8 = 0x47b1();\n    assert(1 <= 1);\n    assert(1 <= 1);\n    v8.word0 = 1;\n    v8.word1 = 0;\n    v8.word2 = MEM[64];\n    v8.word3 = _dToken;\n    v8.word5 = address(this);\n    v9 = v10 = 1;\n    v11 = new uint256[](v10);\n    if (v10) {\n        v12 = v13 = v11.data;\n        do {\n            v14 = 0x481d();\n            MEM[v12] = v14;\n            v12 += 32;\n            v9 = v9 - 1;\n        } while (!v9);\n    }\n    assert(0 < v11.length);\n    v15 = v11.data;\n    v11[0] = v8;\n    v16 = 0x5743(4 + MEM[64], v11, v2);\n    require(bool(_dydx.code.size));\n    v17 = _dydx.operate().gas(msg.gas);\n    require(bool(v17), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return ;\n}\n\nfunction invest(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    _deposit = _deposit + 1;\n    require(amount > 0, Error('deposit must be greater than 0'));\n    v0 = 0x17d8();\n    _pool = v0;\n    0x30b9(amount, this, msg.sender, _token);\n    0x188d();\n    if (_pool != 0) {\n        v1 = 0x315b(_totalSupply, amount);\n        v2 = v3 = _SafeDiv(_pool, v1);\n    } else {\n        _pool = amount;\n    }\n    v4 = 0x17d8();\n    _pool = v4;\n    0x3215(v2, msg.sender);\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n}\n\nfunction 0x43ae() private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction withdraw(uint256 _amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(_amount);\n    0x102f(_amount);\n}\n\nfunction 0x4460(uint256 varg0) private { \n    require(bool(_compound.code.size));\n    v0, /* uint256 */ v1 = _compound.redeem(varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 == 0, Error('COMPOUND: withdraw failed'));\n    return ;\n}\n\nfunction 0x4552() private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\nfunction 0x4604(uint256 varg0) private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.burn(address(this), varg0).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    require(v1 > 0, Error('FULCRUM: withdraw failed'));\n    return ;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction 0x47b1() private { \n    v0 = new struct(8);\n    assert(0 <= 1);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v1 = new struct(4);\n    v1.word0 = False;\n    assert(0 <= 0);\n    v1.word1 = 0;\n    assert(0 <= 0);\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v0.word2 = v1;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = address(0x0);\n    v0.word6 = 0;\n    v0.word7 = 96;\n    return v0;\n}\n\nfunction 0x481d() private { \n    v0 = new struct(8);\n    assert(0 <= 1);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v1 = new struct(4);\n    v1.word0 = False;\n    assert(0 <= 0);\n    v1.word1 = 0;\n    assert(0 <= 0);\n    v1.word2 = 0;\n    v1.word3 = 0;\n    v0.word2 = v1;\n    v0.word3 = 0;\n    v0.word4 = 0;\n    v0.word5 = address(0x0);\n    v0.word6 = 0;\n    v0.word7 = 96;\n    return v0;\n}\n\nfunction increaseAllowance(address spender, uint256 addedValue) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(addedValue);\n    v0 = _SafeAdd(addedValue, _allowance[msg.sender][spender]);\n    0x2c09(v0, spender, msg.sender);\n    return True;\n}\n\nfunction 0x4bbd(uint256 varg0, uint256 varg1) private { \n    require(varg1 - varg0 >= 64);\n    require(varg1 - varg0 >= 64);\n    v0 = new struct(2);\n    require(!((v0 + 64 > uint64.max) | (v0 + 64 < v0)));\n    require(MEM[varg0] == bool(MEM[varg0]));\n    v0.word0 = MEM[varg0];\n    0x5daf(MEM[varg0 + 32]);\n    v0.word1 = MEM[varg0 + 32];\n    return v0;\n}\n\nfunction 0x4c91(uint256 varg0, uint256 varg1) private { \n    MEM[varg1] = varg0.length;\n    v0 = v1 = varg1 + 32;\n    v2 = v3 = v1 + (varg0.length << 5);\n    v4 = v5 = varg0.data;\n    v6 = v7 = 0;\n    while (v6 < varg0.length) {\n        MEM[v0] = v2 - v1;\n        assert(MEM[MEM[v4]] < 2);\n        MEM[v2] = MEM[MEM[v4]];\n        MEM[v2 + 32] = MEM[MEM[v4] + 32];\n        MEM[v2 + 64] = bool(MEM[MEM[MEM[v4] + 64]]);\n        assert(MEM[MEM[MEM[v4] + 64] + 32] < 1);\n        MEM[v2 + 64 + 32] = MEM[MEM[MEM[v4] + 64] + 32];\n        assert(MEM[MEM[MEM[v4] + 64] + 64] < 1);\n        MEM[v2 + 64 + 64] = MEM[MEM[MEM[v4] + 64] + 64];\n        MEM[v2 + 64 + 96] = MEM[MEM[MEM[v4] + 64] + 96];\n        MEM[v2 + 192] = MEM[MEM[v4] + 96];\n        MEM[v2 + 224] = MEM[MEM[v4] + 128];\n        MEM[v2 + 256] = address(MEM[MEM[v4] + 160]);\n        MEM[v2 + 288] = MEM[MEM[v4] + 192];\n        MEM[v2 + 320] = v2 + 352 - v2;\n        MEM[v2 + 352] = MEM[MEM[MEM[v4] + 224]];\n        v8 = v9 = 0;\n        while (v8 < MEM[MEM[MEM[v4] + 224]]) {\n            MEM[v2 + 352 + 32 + v8] = MEM[MEM[MEM[v4] + 224] + 32 + v8];\n            v8 = v8 + 32;\n        }\n        if (v8 > MEM[MEM[MEM[v4] + 224]]) {\n            MEM[v2 + 352 + 32 + MEM[MEM[MEM[v4] + 224]]] = 0;\n        }\n        v2 = v2 + 352 + 32 + (MEM[MEM[MEM[v4] + 224]] + 31 & ~0x1f);\n        v4 = v4 + 32;\n        v0 = v0 + 32;\n        v6 = v6 + 1;\n    }\n    return v2;\n}\n\nfunction balanceDydx() public nonPayable { \n    v0 = 0x1506();\n    return v0;\n}\n\nfunction apr() public nonPayable { \n    return address(_apr);\n}\n\nfunction fulcrum() public nonPayable { \n    return _fulcrum;\n}\n\nfunction balanceCompound() public nonPayable { \n    v0 = 0x1642();\n    return v0;\n}\n\nfunction 0x5743(uint256 varg0, uint256 varg1, struct(2) varg2) private { \n    MEM[varg0] = varg0 + 64 - varg0;\n    MEM[varg0 + 64] = varg2.word0.length;\n    v0 = v1 = varg0 + 64 + 32;\n    v2 = v3 = varg2.data;\n    v4 = v5 = 0;\n    while (v4 < varg2.word0.length) {\n        MEM[v0] = address(MEM[MEM[v2]]);\n        MEM[v0 + 32] = MEM[MEM[v2] + 32];\n        v0 = v0 + 64;\n        v2 = v2 + 32;\n        v4 = v4 + 1;\n    }\n    MEM[varg0 + 32] = v0 - varg0;\n    v6 = 0x4c91(varg1, v0);\n    return v6;\n}\n\nfunction supplyAave(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x16f4(amount);\n}\n\nfunction balanceOf(address account) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5d81(account);\n    return _balanceOf[account];\n}\n\nfunction 0x5d81(address varg0) private { \n    return ;\n}\n\nfunction 0x5daf(uint256 varg0) private { \n    return ;\n}\n\nfunction calcPoolValueInToken() public nonPayable { \n    v0 = 0x17d8();\n    return v0;\n}\n\nfunction getPricePerFullShare() public nonPayable { \n    v0 = 0x17d8();\n    v1 = 0x315b(10 ** 18, v0);\n    v2 = _SafeDiv(_totalSupply, v1);\n    return v2;\n}\n\nfunction rebalance() public nonPayable { \n    0x188d();\n}\n\nfunction supplyFulcrum(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x19d4(amount);\n}\n\nfunction aave() public nonPayable { \n    return _aave;\n}\n\nfunction dydx() public nonPayable { \n    return _dydx;\n}\n\nfunction symbol() public nonPayable { \n    v0 = 0x1b14();\n    v1 = new bytes[](v0.length);\n    v2 = v3 = 0;\n    while (v2 < v0.length) {\n        v1[v2] = v0[v2];\n        v2 = v2 + 32;\n    }\n    if (v2 > v0.length) {\n        v1[v0.length] = 0;\n    }\n    return v1;\n}\n\nfunction approveToken() public nonPayable { \n    0x369e(uint256.max, _compound, _token);\n    0x369e(uint256.max, _dydx, _token);\n    v0 = 0x2b34();\n    0x369e(uint256.max, v0, _token);\n    0x369e(uint256.max, _fulcrum, _token);\n}\n\nfunction recommend() public nonPayable { \n    v0 = 0x1dd9();\n    assert(v0 < 5);\n    return v0;\n}\n\nfunction decreaseAllowance(address spender, uint256 subtractedValue) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(spender);\n    0x5daf(subtractedValue);\n    v0 = _SafeSub('ERC20: decreased allowance below zero', subtractedValue, _allowance[msg.sender][spender]);\n    0x2c09(v0, spender, msg.sender);\n    return True;\n}\n\nfunction balanceCompoundInToken() public nonPayable { \n    v0 = 0x2012();\n    return v0;\n}\n\nfunction transfer(address recipient, uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(recipient);\n    0x5daf(amount);\n    0x2dd4(amount, recipient, msg.sender);\n    return True;\n}\n\nfunction balance() public nonPayable { \n    v0 = 0x211c();\n    return v0;\n}\n\nfunction deposit(uint256 _amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(_amount);\n    _deposit = _deposit + 1;\n    require(_amount > 0, Error('deposit must be greater than 0'));\n    v0 = 0x339d();\n    _pool = v0;\n    0x30b9(_amount, this, msg.sender, _token);\n    if (_pool != 0) {\n        v1 = 0x315b(_totalSupply, _amount);\n        v2 = v3 = _SafeDiv(_pool, v1);\n    } else {\n        _pool = _amount;\n    }\n    v4 = 0x339d();\n    _pool = v4;\n    0x3215(v2, msg.sender);\n    require(_deposit == _deposit, Error('ReentrancyGuard: reentrant call'));\n}\n\nfunction balanceAave() public nonPayable { \n    v0 = 0x2332();\n    return v0;\n}\n\nfunction dToken() public nonPayable { \n    return _dToken;\n}\n\nfunction redeem(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x23ea(amount);\n}\n\nfunction allowance(address owner, address spender) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 64);\n    0x5d81(owner);\n    0x5d81(spender);\n    return _allowance[owner][spender];\n}\n\nfunction supplyCompound(uint256 amount) public nonPayable { \n    require(4 + (msg.data.length - 4) - 4 >= 32);\n    0x5daf(amount);\n    0x28aa(amount);\n}\n\nfunction balanceFulcrumInToken() public nonPayable { \n    v0 = 0x299c();\n    return v0;\n}\n\nfunction compound() public nonPayable { \n    return _compound;\n}\n\nfunction getAave() public nonPayable { \n    v0 = 0x2a8d();\n    return address(v0);\n}\n\nfunction getAaveCore() public nonPayable { \n    v0 = 0x2b34();\n    return address(v0);\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x9f1(uint256 varg0) private { \n    v0 = v1 = 1;\n    v2 = new struct(2);\n    v2.word0 = v1;\n    if (v1) {\n        v3 = v4 = v2.data;\n        do {\n            v5 = new struct(2);\n            v5.word0 = address(0x0);\n            v5.word1 = 0;\n            MEM[v3] = v5;\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v6 = new struct(2);\n    v6.word0 = address(this);\n    v6.word1 = 0;\n    assert(0 < v2.word0.length);\n    v7 = v2.data;\n    v2.word1 = v6;\n    MEM[MEM[64]] = False;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = 0;\n    MEM[64] += 128;\n    MEM[MEM[64]] = True;\n    assert(0 <= 0);\n    MEM[32 + MEM[64]] = 0;\n    assert(0 <= 0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[96 + MEM[64]] = varg0;\n    v8 = 0x47b1();\n    assert(0 <= 1);\n    assert(0 <= 1);\n    v8.word0 = 0;\n    v8.word1 = 0;\n    v8.word2 = MEM[64];\n    v8.word3 = _dToken;\n    v8.word5 = address(this);\n    v9 = v10 = 1;\n    v11 = new uint256[](v10);\n    if (v10) {\n        v12 = v13 = v11.data;\n        do {\n            v14 = 0x481d();\n            MEM[v12] = v14;\n            v12 += 32;\n            v9 = v9 - 1;\n        } while (!v9);\n    }\n    assert(0 < v11.length);\n    v15 = v11.data;\n    v11[0] = v8;\n    v16 = 0x5743(4 + MEM[64], v11, v2);\n    require(bool(_dydx.code.size));\n    v17 = _dydx.operate().gas(msg.gas);\n    require(bool(v17), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    return 0;\n}\n\nfunction 0xc55() private { \n    v0 = new bytes[](((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1);\n    v1 = v2 = v0.data;\n    if (!(((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1)) {\n        return v0;\n    } else if (31 < ((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1) {\n        v3 = v4 = array_3.data;\n        do {\n            MEM[v1] = STORAGE[v3];\n            v3 += 1;\n            v1 += 32;\n        } while (v2 + (((!(0x1 & array_3.length) << 8) - 1 & array_3.length) >> 1) <= v1);\n        return v0;\n    } else {\n        MEM[v2] = array_3.length >> 8 << 8;\n        return v0;\n    }\n}\n\nfunction 0xd28() private { \n    require(bool(_fulcrum.code.size));\n    v0, /* uint256 */ v1 = _fulcrum.balanceOf(address(this)).gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    0x5daf(v1);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction function_selector( function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = function_selector >> 224;\n        if (0x7d7c2a1c > v0) {\n            if (0x2e1a7d4d > v0) {\n                if (0xeb2a267 > v0) {\n                    if (0x6636c1c == v0) {\n                        supplyDydx(uint256);\n                    } else if (0x6a3fe59 == v0) {\n                        aaveToken();\n                    } else if (0x6fdde03 == v0) {\n                        name();\n                    } else if (0x85d4883 == v0) {\n                        provider();\n                    } else if (0x95ea7b3 == v0) {\n                        approve(address,uint256);\n                    }\n                } else if (0xeb2a267 == v0) {\n                    balanceFulcrum();\n                } else if (0x16f0115b == v0) {\n                    pool();\n                } else if (0x18160ddd == v0) {\n                    totalSupply();\n                } else if (0x23b872dd == v0) {\n                    transferFrom(address,address,uint256);\n                } else if (0x2afcf480 == v0) {\n                    invest(uint256);\n                }\n            } else if (0x58782c21 > v0) {\n                if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x313ce567 == v0) {\n                    decimals();\n                } else if (0x39509351 == v0) {\n                    increaseAllowance(address,uint256);\n                } else if (0x39c0a7e1 == v0) {\n                    balanceDydx();\n                } else if (0x57ded9c9 == v0) {\n                    apr();\n                }\n            } else if (0x58782c21 == v0) {\n                fulcrum();\n            } else if (0x61c1ec55 == v0) {\n                balanceCompound();\n            } else if (0x65aab749 == v0) {\n                supplyAave(uint256);\n            } else if (0x70a08231 == v0) {\n                balanceOf(address);\n            } else if (0x7137ef99 == v0) {\n                calcPoolValueInToken();\n            } else if (0x77c7b8fc == v0) {\n                getPricePerFullShare();\n            }\n        } else if (0xb6b55f25 > v0) {\n            if (0x99b71d5c > v0) {\n                if (0x7d7c2a1c == v0) {\n                    rebalance();\n                } else if (0x8124955c == v0) {\n                    supplyFulcrum(uint256);\n                } else if (0x819faf7b == v0) {\n                    aave();\n                } else if (0x8e4ec6ef == v0) {\n                    dydx();\n                } else if (0x95d89b41 == v0) {\n                    symbol();\n                }\n            } else if (0x99b71d5c == v0) {\n                approveToken();\n            } else if (0xa160176d == v0) {\n                recommend();\n            } else if (0xa457c2d7 == v0) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa7287971 == v0) {\n                balanceCompoundInToken();\n            } else if (0xa9059cbb == v0) {\n                transfer(address,uint256);\n            } else if (0xb69ef8a8 == v0) {\n                balance();\n            }\n        } else if (0xe849d659 > v0) {\n            if (0xb6b55f25 == v0) {\n                deposit(uint256);\n            } else if (0xcf8ca426 == v0) {\n                balanceAave();\n            } else if (0xd9d7858a == v0) {\n                dToken();\n            } else if (0xdb006a75 == v0) {\n                redeem(uint256);\n            } else if (0xdd62ed3e == v0) {\n                allowance(address,address);\n            }\n        } else if (0xe849d659 == v0) {\n            supplyCompound(uint256);\n        } else if (0xf5a41dea == v0) {\n            balanceFulcrumInToken();\n        } else if (0xf69e2046 == v0) {\n            compound();\n        } else if (0xf7c1ec77 == v0) {\n            getAave();\n        } else if (0xf82ce27d == v0) {\n            getAaveCore();\n        } else if (0xfc0c546a == v0) {\n            token();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 57.209150552749634,
	"usage": {
		"completion_tokens": 484,
		"prompt_tokens": 15611,
		"total_tokens": 16095
	}
}