{
	"address": "0x2a37f3c4ce5ee6b1dbcdb593b21eee1c418ad403",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a rough approximation of the given decompiled EVM bytecode into Solidity:\n\n```solidity\npragma solidity >=0.7.0 <0.8.0;\n\ncontract MyContract {\n\n    address private _destruct;\n    address private _fallback;\n    \n    event LogReceiveFunds(address indexed sender, uint8 varg0, uint256 value);\n    event LogSendFunds(address indexed recipient, uint8 varg1, uint256 value);\n    \n    function receiveFunds(uint8 varg0) public payable {\n        require(_fallback != address(0));\n        require(varg0 <= 5);\n        emit LogReceiveFunds(msg.sender, varg0, msg.value);\n    }\n    \n    function destruct() public {\n        require(_destruct == msg.sender);\n        selfdestruct(payable(_destruct));\n    }\n    \n    function withdraw(uint256 varg0) public {\n        require(address(this).balance >= varg0);\n        msg.sender.transfer(varg0);\n    }\n    \n    function sendFunds(address varg0, uint8 varg1, uint256 varg2) public returns(bool success) {\n        require(address(this).balance >= varg2);\n        require(varg1 <= 5);\n        emit LogSendFunds(varg0, varg1, varg2);\n        (success, ) = varg0.call{value: varg2}(\"\");\n        return success;\n    }\n    \n    function PATCH_VERSION() public pure returns(uint8) {\n        return 2;\n    }\n    \n    function MINOR_VERSION() public pure returns(uint8) {\n        return 0;\n    }\n    \n    function controller() public view returns(address) {\n        return _destruct;\n    }\n    \n    function MAJOR_VERSION() public pure returns(uint8) {\n        return 1;\n    }\n    \n    fallback() external payable {\n    }\n    \n    receive() external payable {\n    }\n}\n```\n\nPlease note that this is a **rough translation** of the EVM Bytecode. The complete translation would require more context about the original contract's functionality. This Solidity code may not compile or work as expected without additional modifications. It's also important to note that the use of selfdestruct is potentially dangerous and should be used with caution.",
				"role": "assistant"
			}
		}
	],
	"created": 1701461922,
	"id": "chatcmpl-8R4GAt9PMwsNItbPxgx6GrQl8DEEA",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.26 09:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\naddress _destruct; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\naddress stor_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress _fallback; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nLogReceiveFunds(address, uint8, uint256);\nLogSendFunds(address, uint8, uint256);\n\nfunction receiveFunds(uint8 varg0) public payable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(101, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(varg0 & 0xff <= 5);\n    emit LogReceiveFunds(msg.sender, varg0 & 0xff & 0xff, msg.value);\n    0x244(msg.value, varg0 & 0xff, 3);\n}\n\nfunction destruct() public nonPayable { \n    require(_destruct == msg.sender);\n    selfdestruct(_destruct);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(104, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    require((address(this)).balance >= varg0);\n    0x244(varg0, 3, 1);\n    v2 = 0xff2('FD.Funder');\n    v3 = address(v2).call().value(varg0).gas(2300 * !varg0);\n    require(v3);\n}\n\nfunction sendFunds(address varg0, uint8 varg1, uint256 varg2) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(102, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    if ((address(this)).balance >= varg2) {\n        assert(varg1 & 0xff <= 5);\n        emit LogSendFunds(varg0, varg1 & 0xff & 0xff, varg2);\n        0x244(varg2, 3, varg1 & 0xff);\n        v2 = varg0.call().value(varg2).gas(2300 * !varg2);\n        if (v2) {\n            v3 = v4 = 1;\n        } else {\n            0x244(varg2, varg1 & 0xff, 3);\n            v3 = v5 = 0;\n        }\n    } else {\n        v3 = 0;\n    }\n    return v3;\n}\n\nfunction PATCH_VERSION() public nonPayable { \n    return 2;\n}\n\nfunction bookkeeping(uint8 varg0, uint8 varg1, uint256 varg2) public nonPayable { \n    0x244(varg2, varg1 & 0xff, 0xff & varg0);\n}\n\nfunction MINOR_VERSION() public nonPayable { \n    return 0;\n}\n\nfunction setContracts() public nonPayable { \n    require(_destruct == msg.sender);\n    v0 = 0xff2('FD.AccessController');\n    _fallback = v0;\n    v1 = 0xff2('FD.Database');\n    stor_3_0_19 = v1;\n    require(_fallback.code.size);\n    v2 = _fallback.setPermissionById(101, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v2);\n    require(_fallback.code.size);\n    v3 = _fallback.setPermissionById(101, 'FD.Controller').gas(msg.gas - 710);\n    require(v3);\n    require(_fallback.code.size);\n    v4 = _fallback.setPermissionById(102, 'FD.Payout').gas(msg.gas - 710);\n    require(v4);\n    require(_fallback.code.size);\n    v5 = _fallback.setPermissionById(102, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v5);\n    require(_fallback.code.size);\n    v6 = _fallback.setPermissionById(102, 'FD.Controller').gas(msg.gas - 710);\n    require(v6);\n    require(_fallback.code.size);\n    v7 = _fallback.setPermissionById(102, 'FD.Underwrite').gas(msg.gas - 710);\n    require(v7);\n    require(_fallback.code.size);\n    v8 = _fallback.setPermissionById(102, 'FD.Owner').gas(msg.gas - 710);\n    require(v8);\n    require(_fallback.code.size);\n    v9 = _fallback.setPermissionById(103, 'FD.Funder').gas(msg.gas - 710);\n    require(v9);\n    require(_fallback.code.size);\n    v10 = _fallback.setPermissionById(103, 'FD.Underwrite').gas(msg.gas - 710);\n    require(v10);\n    require(_fallback.code.size);\n    v11 = _fallback.setPermissionById(103, 'FD.Payout').gas(msg.gas - 710);\n    require(v11);\n    require(_fallback.code.size);\n    v12 = _fallback.setPermissionById(103, 'FD.Ledger').gas(msg.gas - 710);\n    require(v12);\n    require(_fallback.code.size);\n    v13 = _fallback.setPermissionById(103, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v13);\n    require(_fallback.code.size);\n    v14 = _fallback.setPermissionById(103, 'FD.Controller').gas(msg.gas - 710);\n    require(v14);\n    require(_fallback.code.size);\n    v15 = _fallback.setPermissionById(103, 'FD.Owner').gas(msg.gas - 710);\n    require(v15);\n    require(_fallback.code.size);\n    v16 = _fallback.setPermissionById(104, 'FD.Funder').gas(msg.gas - 710);\n    require(v16);\n}\n\nfunction controller() public nonPayable { \n    return _destruct;\n}\n\nfunction MAJOR_VERSION() public nonPayable { \n    return 1;\n}\n\nfunction 0x244(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(103, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(varg0 > 0);\n    assert(varg2 <= 5);\n    v2 = 0 - varg0;\n    v3 = varg2 & 0xff;\n    require(stor_3_0_19.code.size);\n    v4 = stor_3_0_19.setLedger(v3, v2).gas(msg.gas - 710);\n    require(v4);\n    assert(varg1 <= 5);\n    v5 = varg1 & 0xff;\n    require(stor_3_0_19.code.size);\n    v6 = stor_3_0_19.setLedger(v5, varg0).gas(msg.gas - 710);\n    require(v6);\n    return ;\n}\n\nfunction fallback() public payable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(104, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    0x244(msg.value, 1, 3);\n}\n\nfunction 0xff2(uint256 varg0) private { \n    MEM[32 + MEM[64]] = 0;\n    require(stor_1_0_19.code.size);\n    v0, v1 = stor_1_0_19.getContract(varg0).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x29377d61) {\n            receiveFunds(uint8);\n        } else if (0x2b68b9c6 == uint32(function_selector >> 224)) {\n            destruct();\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x50bed043 == uint32(function_selector >> 224)) {\n            sendFunds(address,uint8,uint256);\n        } else if (0x6bf2606a == uint32(function_selector >> 224)) {\n            PATCH_VERSION();\n        } else if (0xb5675ee4 == uint32(function_selector >> 224)) {\n            bookkeeping(uint8,uint8,uint256);\n        } else if (0xc8b91531 == uint32(function_selector >> 224)) {\n            MINOR_VERSION();\n        } else if (0xe0d6d530 == uint32(function_selector >> 224)) {\n            setContracts();\n        } else if (0xf77c4791 == uint32(function_selector >> 224)) {\n            controller();\n        } else if (0xf786becd == uint32(function_selector >> 224)) {\n            MAJOR_VERSION();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 09:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\naddress _destruct; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\naddress stor_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress _fallback; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nLogReceiveFunds(address, uint8, uint256);\nLogSendFunds(address, uint8, uint256);\n\nfunction receiveFunds(uint8 varg0) public payable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(101, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(varg0 & 0xff <= 5);\n    emit LogReceiveFunds(msg.sender, varg0 & 0xff & 0xff, msg.value);\n    0x244(msg.value, varg0 & 0xff, 3);\n}\n\nfunction destruct() public nonPayable { \n    require(_destruct == msg.sender);\n    selfdestruct(_destruct);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(104, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    require((address(this)).balance >= varg0);\n    0x244(varg0, 3, 1);\n    v2 = 0xff2('FD.Funder');\n    v3 = address(v2).call().value(varg0).gas(2300 * !varg0);\n    require(v3);\n}\n\nfunction sendFunds(address varg0, uint8 varg1, uint256 varg2) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(102, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    if ((address(this)).balance >= varg2) {\n        assert(varg1 & 0xff <= 5);\n        emit LogSendFunds(varg0, varg1 & 0xff & 0xff, varg2);\n        0x244(varg2, 3, varg1 & 0xff);\n        v2 = varg0.call().value(varg2).gas(2300 * !varg2);\n        if (v2) {\n            v3 = v4 = 1;\n        } else {\n            0x244(varg2, varg1 & 0xff, 3);\n            v3 = v5 = 0;\n        }\n    } else {\n        v3 = 0;\n    }\n    return v3;\n}\n\nfunction PATCH_VERSION() public nonPayable { \n    return 2;\n}\n\nfunction bookkeeping(uint8 varg0, uint8 varg1, uint256 varg2) public nonPayable { \n    0x244(varg2, varg1 & 0xff, 0xff & varg0);\n}\n\nfunction MINOR_VERSION() public nonPayable { \n    return 0;\n}\n\nfunction setContracts() public nonPayable { \n    require(_destruct == msg.sender);\n    v0 = 0xff2('FD.AccessController');\n    _fallback = v0;\n    v1 = 0xff2('FD.Database');\n    stor_3_0_19 = v1;\n    require(_fallback.code.size);\n    v2 = _fallback.setPermissionById(101, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v2);\n    require(_fallback.code.size);\n    v3 = _fallback.setPermissionById(101, 'FD.Controller').gas(msg.gas - 710);\n    require(v3);\n    require(_fallback.code.size);\n    v4 = _fallback.setPermissionById(102, 'FD.Payout').gas(msg.gas - 710);\n    require(v4);\n    require(_fallback.code.size);\n    v5 = _fallback.setPermissionById(102, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v5);\n    require(_fallback.code.size);\n    v6 = _fallback.setPermissionById(102, 'FD.Controller').gas(msg.gas - 710);\n    require(v6);\n    require(_fallback.code.size);\n    v7 = _fallback.setPermissionById(102, 'FD.Underwrite').gas(msg.gas - 710);\n    require(v7);\n    require(_fallback.code.size);\n    v8 = _fallback.setPermissionById(102, 'FD.Owner').gas(msg.gas - 710);\n    require(v8);\n    require(_fallback.code.size);\n    v9 = _fallback.setPermissionById(103, 'FD.Funder').gas(msg.gas - 710);\n    require(v9);\n    require(_fallback.code.size);\n    v10 = _fallback.setPermissionById(103, 'FD.Underwrite').gas(msg.gas - 710);\n    require(v10);\n    require(_fallback.code.size);\n    v11 = _fallback.setPermissionById(103, 'FD.Payout').gas(msg.gas - 710);\n    require(v11);\n    require(_fallback.code.size);\n    v12 = _fallback.setPermissionById(103, 'FD.Ledger').gas(msg.gas - 710);\n    require(v12);\n    require(_fallback.code.size);\n    v13 = _fallback.setPermissionById(103, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v13);\n    require(_fallback.code.size);\n    v14 = _fallback.setPermissionById(103, 'FD.Controller').gas(msg.gas - 710);\n    require(v14);\n    require(_fallback.code.size);\n    v15 = _fallback.setPermissionById(103, 'FD.Owner').gas(msg.gas - 710);\n    require(v15);\n    require(_fallback.code.size);\n    v16 = _fallback.setPermissionById(104, 'FD.Funder').gas(msg.gas - 710);\n    require(v16);\n}\n\nfunction controller() public nonPayable { \n    return _destruct;\n}\n\nfunction MAJOR_VERSION() public nonPayable { \n    return 1;\n}\n\nfunction 0x244(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(103, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(varg0 > 0);\n    assert(varg2 <= 5);\n    v2 = 0 - varg0;\n    v3 = varg2 & 0xff;\n    require(stor_3_0_19.code.size);\n    v4 = stor_3_0_19.setLedger(v3, v2).gas(msg.gas - 710);\n    require(v4);\n    assert(varg1 <= 5);\n    v5 = varg1 & 0xff;\n    require(stor_3_0_19.code.size);\n    v6 = stor_3_0_19.setLedger(v5, varg0).gas(msg.gas - 710);\n    require(v6);\n    return ;\n}\n\nfunction fallback() public payable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(104, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    0x244(msg.value, 1, 3);\n}\n\nfunction 0xff2(uint256 varg0) private { \n    MEM[32 + MEM[64]] = 0;\n    require(stor_1_0_19.code.size);\n    v0, v1 = stor_1_0_19.getContract(varg0).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x29377d61) {\n            receiveFunds(uint8);\n        } else if (0x2b68b9c6 == uint32(function_selector >> 224)) {\n            destruct();\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x50bed043 == uint32(function_selector >> 224)) {\n            sendFunds(address,uint8,uint256);\n        } else if (0x6bf2606a == uint32(function_selector >> 224)) {\n            PATCH_VERSION();\n        } else if (0xb5675ee4 == uint32(function_selector >> 224)) {\n            bookkeeping(uint8,uint8,uint256);\n        } else if (0xc8b91531 == uint32(function_selector >> 224)) {\n            MINOR_VERSION();\n        } else if (0xe0d6d530 == uint32(function_selector >> 224)) {\n            setContracts();\n        } else if (0xf77c4791 == uint32(function_selector >> 224)) {\n            controller();\n        } else if (0xf786becd == uint32(function_selector >> 224)) {\n            MAJOR_VERSION();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 09:16 UTC\n\n// Data structures and variables inferred from the use of storage instructions\naddress _destruct; // STORAGE[0x0] bytes 0 to 19\naddress stor_1_0_19; // STORAGE[0x1] bytes 0 to 19\naddress stor_3_0_19; // STORAGE[0x3] bytes 0 to 19\naddress _fallback; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nLogReceiveFunds(address, uint8, uint256);\nLogSendFunds(address, uint8, uint256);\n\nfunction receiveFunds(uint8 varg0) public payable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(101, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(varg0 & 0xff <= 5);\n    emit LogReceiveFunds(msg.sender, varg0 & 0xff & 0xff, msg.value);\n    0x244(msg.value, varg0 & 0xff, 3);\n}\n\nfunction destruct() public nonPayable { \n    require(_destruct == msg.sender);\n    selfdestruct(_destruct);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(104, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    require((address(this)).balance >= varg0);\n    0x244(varg0, 3, 1);\n    v2 = 0xff2('FD.Funder');\n    v3 = address(v2).call().value(varg0).gas(2300 * !varg0);\n    require(v3);\n}\n\nfunction sendFunds(address varg0, uint8 varg1, uint256 varg2) public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(102, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    if ((address(this)).balance >= varg2) {\n        assert(varg1 & 0xff <= 5);\n        emit LogSendFunds(varg0, varg1 & 0xff & 0xff, varg2);\n        0x244(varg2, 3, varg1 & 0xff);\n        v2 = varg0.call().value(varg2).gas(2300 * !varg2);\n        if (v2) {\n            v3 = v4 = 1;\n        } else {\n            0x244(varg2, varg1 & 0xff, 3);\n            v3 = v5 = 0;\n        }\n    } else {\n        v3 = 0;\n    }\n    return v3;\n}\n\nfunction PATCH_VERSION() public nonPayable { \n    return 2;\n}\n\nfunction bookkeeping(uint8 varg0, uint8 varg1, uint256 varg2) public nonPayable { \n    0x244(varg2, varg1 & 0xff, 0xff & varg0);\n}\n\nfunction MINOR_VERSION() public nonPayable { \n    return 0;\n}\n\nfunction setContracts() public nonPayable { \n    require(_destruct == msg.sender);\n    v0 = 0xff2('FD.AccessController');\n    _fallback = v0;\n    v1 = 0xff2('FD.Database');\n    stor_3_0_19 = v1;\n    require(_fallback.code.size);\n    v2 = _fallback.setPermissionById(101, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v2);\n    require(_fallback.code.size);\n    v3 = _fallback.setPermissionById(101, 'FD.Controller').gas(msg.gas - 710);\n    require(v3);\n    require(_fallback.code.size);\n    v4 = _fallback.setPermissionById(102, 'FD.Payout').gas(msg.gas - 710);\n    require(v4);\n    require(_fallback.code.size);\n    v5 = _fallback.setPermissionById(102, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v5);\n    require(_fallback.code.size);\n    v6 = _fallback.setPermissionById(102, 'FD.Controller').gas(msg.gas - 710);\n    require(v6);\n    require(_fallback.code.size);\n    v7 = _fallback.setPermissionById(102, 'FD.Underwrite').gas(msg.gas - 710);\n    require(v7);\n    require(_fallback.code.size);\n    v8 = _fallback.setPermissionById(102, 'FD.Owner').gas(msg.gas - 710);\n    require(v8);\n    require(_fallback.code.size);\n    v9 = _fallback.setPermissionById(103, 'FD.Funder').gas(msg.gas - 710);\n    require(v9);\n    require(_fallback.code.size);\n    v10 = _fallback.setPermissionById(103, 'FD.Underwrite').gas(msg.gas - 710);\n    require(v10);\n    require(_fallback.code.size);\n    v11 = _fallback.setPermissionById(103, 'FD.Payout').gas(msg.gas - 710);\n    require(v11);\n    require(_fallback.code.size);\n    v12 = _fallback.setPermissionById(103, 'FD.Ledger').gas(msg.gas - 710);\n    require(v12);\n    require(_fallback.code.size);\n    v13 = _fallback.setPermissionById(103, 'FD.NewPolicy').gas(msg.gas - 710);\n    require(v13);\n    require(_fallback.code.size);\n    v14 = _fallback.setPermissionById(103, 'FD.Controller').gas(msg.gas - 710);\n    require(v14);\n    require(_fallback.code.size);\n    v15 = _fallback.setPermissionById(103, 'FD.Owner').gas(msg.gas - 710);\n    require(v15);\n    require(_fallback.code.size);\n    v16 = _fallback.setPermissionById(104, 'FD.Funder').gas(msg.gas - 710);\n    require(v16);\n}\n\nfunction controller() public nonPayable { \n    return _destruct;\n}\n\nfunction MAJOR_VERSION() public nonPayable { \n    return 1;\n}\n\nfunction 0x244(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(103, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    assert(varg0 > 0);\n    assert(varg2 <= 5);\n    v2 = 0 - varg0;\n    v3 = varg2 & 0xff;\n    require(stor_3_0_19.code.size);\n    v4 = stor_3_0_19.setLedger(v3, v2).gas(msg.gas - 710);\n    require(v4);\n    assert(varg1 <= 5);\n    v5 = varg1 & 0xff;\n    require(stor_3_0_19.code.size);\n    v6 = stor_3_0_19.setLedger(v5, varg0).gas(msg.gas - 710);\n    require(v6);\n    return ;\n}\n\nfunction fallback() public payable { \n    MEM[32 + MEM[64]] = 0;\n    require(_fallback.code.size);\n    v0, v1 = _fallback.checkPermission(104, msg.sender).gas(msg.gas - 710);\n    require(v0);\n    require(v1);\n    0x244(msg.value, 1, 3);\n}\n\nfunction 0xff2(uint256 varg0) private { \n    MEM[32 + MEM[64]] = 0;\n    require(stor_1_0_19.code.size);\n    v0, v1 = stor_1_0_19.getContract(varg0).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x29377d61) {\n            receiveFunds(uint8);\n        } else if (0x2b68b9c6 == uint32(function_selector >> 224)) {\n            destruct();\n        } else if (0x2e1a7d4d == uint32(function_selector >> 224)) {\n            withdraw(uint256);\n        } else if (0x50bed043 == uint32(function_selector >> 224)) {\n            sendFunds(address,uint8,uint256);\n        } else if (0x6bf2606a == uint32(function_selector >> 224)) {\n            PATCH_VERSION();\n        } else if (0xb5675ee4 == uint32(function_selector >> 224)) {\n            bookkeeping(uint8,uint8,uint256);\n        } else if (0xc8b91531 == uint32(function_selector >> 224)) {\n            MINOR_VERSION();\n        } else if (0xe0d6d530 == uint32(function_selector >> 224)) {\n            setContracts();\n        } else if (0xf77c4791 == uint32(function_selector >> 224)) {\n            controller();\n        } else if (0xf786becd == uint32(function_selector >> 224)) {\n            MAJOR_VERSION();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 19.884412050247192,
	"usage": {
		"completion_tokens": 463,
		"prompt_tokens": 2210,
		"total_tokens": 2673
	}
}