{
	"address": "0x7ee41a4c66e92fe28abd5bde30ad644a2dc8b15f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity implementation of the decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    address public owner;\n    address public escapeCallerAddress;\n    address public escapeDestinationAddress;\n    address public securityGuardAddress;\n    uint256 public absoluteMinTimeLock;\n    uint256 public timeLock;\n    uint256 public maxSecurityGuardDelay;\n    mapping(address => bool) public allowedSpenders;\n\n    struct AuthorizedPayment {\n        bytes data;\n        address addr;\n        uint256 value;\n        bool field_768;\n        bool field_776;\n        address field_784;\n        uint256 field_1024;\n        uint256 field_1280;\n    }\n    \n    AuthorizedPayment[] public authorizedPayments;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function changeOwner(address _newOwner) public {\n        require(msg.sender == owner);\n        owner = _newOwner;\n    }\n\n    function receiveEther() payable public {\n        // logic when ether is received\n    }\n\n    function setSecurityGuard(address _newSecurityGuard) public {\n        require(msg.sender == owner);\n        securityGuardAddress = _newSecurityGuard;\n    }\n\n    function setMaxSecurityGuardDelay(uint256 _maxSecurityGuardDelay) public {\n        require(msg.sender == owner);\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\n    }\n\n    function changeEscapeCaller(address _newEscapeHatchCaller) public {\n        if (escapeCallerAddress != msg.sender) {\n            require(msg.sender == owner);\n        }\n        escapeCallerAddress = _newEscapeHatchCaller;\n    }\n\n    function setTimelock(uint256 newTimelockDurationInBlocks_) public {\n        require(msg.sender == owner);\n        require(newTimelockDurationInBlocks_ >= absoluteMinTimeLock);\n        timeLock = newTimelockDurationInBlocks_;\n    }\n\n    function escapeHatch() public {\n        if (escapeCallerAddress != msg.sender) {\n            require(msg.sender == owner);\n        }\n        // handle escape hatch logic here\n    }\n\n    function authorizeSpender(address _spender, bool _authorize) public {\n        require(msg.sender == owner);\n        allowedSpenders[_spender] = _authorize;\n    }\n\n    // Implement remaining functions\n}\n```\n\nThe contract is designed to manage authorized payments. Payments can be authorized and then collected with the use of the security guard pattern. This pattern allows delaying payments and even canceling them, which adds a layer of security. The contract also includes an escape hatch that allows for emergency extraction of funds.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472532,
	"id": "chatcmpl-8MusGBFLtSAybLDQXlr0ye8u03VhF",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  escapeCallerAddress is address at storage 1\n  escapeDestinationAddress is address at storage 2\n  authorizedPayments is array of struct at storage 3\n  securityGuardAddress is address at storage 4\n  absoluteMinTimeLock is uint256 at storage 5\n  timeLock is uint256 at storage 6\n  maxSecurityGuardDelay is uint256 at storage 7\n  stor8 is mapping of uint8 at storage 8\n\ndef maxSecurityGuardDelay(): # not payable\n  return maxSecurityGuardDelay\n\ndef numberOfAuthorizedPayments(): # not payable\n  return authorizedPayments.length\n\ndef owner(): # not payable\n  return owner\n\ndef authorizedPayments(uint256 _param1): # not payable\n  require _param1 < authorizedPayments.length\n  mem[384] = uint256(authorizedPayments[_param1].field_0)\n  idx = 384\n  s = 0\n  while authorizedPayments[_param1].length + 384 > idx + 32:\n      mem[idx + 32] = uint256(authorizedPayments[(6 * _param1) + s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  return Array(len=authorizedPayments[_param1].length, data=mem[384 len authorizedPayments[_param1].length + (floor32(authorizedPayments[_param1].length - 1) + -authorizedPayments[_param1].length + 32 % 32)]), \n         address(authorizedPayments[_param1].field_256),\n         uint256(authorizedPayments[_param1].field_512),\n         bool(uint8(authorizedPayments[_param1].field_768)),\n         bool(uint8(authorizedPayments[_param1].field_776)),\n         address(authorizedPayments[_param1].field_768),\n         uint256(authorizedPayments[_param1].field_1024),\n         uint256(authorizedPayments[_param1].field_1280)\n\ndef securityGuard(): # not payable\n  return securityGuardAddress\n\ndef escapeDestination(): # not payable\n  return escapeDestinationAddress\n\ndef timeLock(): # not payable\n  return timeLock\n\ndef allowedSpenders(address _param1): # not payable\n  return bool(stor8[_param1])\n\ndef absoluteMinTimeLock(): # not payable\n  return absoluteMinTimeLock\n\ndef escapeCaller(): # not payable\n  return escapeCallerAddress\n\n#\n#  Regular functions\n#\n\ndef changeOwner(address _newOwner): # not payable\n  require owner == caller\n  owner = _newOwner\n\ndef receiveEther() payable: \n  log EtherReceived(\n        address sender=call.value,\n        uint256 amount=caller)\n\ndef setSecurityGuard(address _newSecurityGuard): # not payable\n  require owner == caller\n  securityGuardAddress = _newSecurityGuard\n\ndef _fallback(?) payable: # default function\n  log EtherReceived(\n        address sender=call.value,\n        uint256 amount=caller)\n\ndef setMaxSecurityGuardDelay(uint256 _maxSecurityGuardDelay): # not payable\n  require owner == caller\n  maxSecurityGuardDelay = _maxSecurityGuardDelay\n\ndef changeEscapeCaller(address _newEscapeHatchCaller): # not payable\n  if escapeCallerAddress != caller:\n      require owner == caller\n  escapeCallerAddress = _newEscapeHatchCaller\n\ndef setTimelock(uint256 newTimelockDurationInBlocks_): # not payable\n  require owner == caller\n  require newTimelockDurationInBlocks_ >= absoluteMinTimeLock\n  timeLock = newTimelockDurationInBlocks_\n\ndef escapeHatch(): # not payable\n  if escapeCallerAddress != caller:\n      require owner == caller\n  call escapeDestinationAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log EscapeCalled(uint256 amount=eth.balance(this.address))\n\ndef authorizeSpender(address _spender, bool _authorize): # not payable\n  require owner == caller\n  stor8[address(_spender)] = uint8(_authorize)\n  log SpenderAuthorization(\n        address spender=_authorize,\n        bool authorized=_spender)\n\ndef cancelPayment(uint256 _idPayment): # not payable\n  require owner == caller\n  require _idPayment < authorizedPayments.length\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  uint8(authorizedPayments[_idPayment].field_768) = 1\n  log PaymentCanceled(uint256 idPayment=_idPayment)\n\ndef delayPayment(uint256 _idPayment, uint256 _delay): # not payable\n  require securityGuardAddress == caller\n  require _idPayment < authorizedPayments.length\n  require uint256(authorizedPayments[_idPayment].field_1280) + _delay <= maxSecurityGuardDelay\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  uint256(authorizedPayments[_idPayment].field_1280) += _delay\n  uint256(authorizedPayments[_idPayment].field_512) += _delay\n\ndef collectAuthorizedPayment(uint256 _idPayment): # not payable\n  require _idPayment < authorizedPayments.length\n  require address(authorizedPayments[_idPayment].field_784) == caller\n  require stor8[address(stor3[_idPayment].field_256)]\n  require block.timestamp >= uint256(authorizedPayments[_idPayment].field_512)\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  require eth.balance(this.address) >= uint256(authorizedPayments[_idPayment].field_1024)\n  uint8(authorizedPayments[_idPayment].field_776) = 1\n  call address(authorizedPayments[_idPayment].field_784) or 0 or 0 with:\n     value uint256(authorizedPayments[_idPayment].field_1024) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log PaymentExecuted(\n        uint256 idPayment=uint256(authorizedPayments[_idPayment].field_1024),\n        address recipient=_idPayment,\n        uint256 amount=address(authorizedPayments[_idPayment].field_784))\n\ndef authorizePayment(string _description, address _recipient, uint256 _amount, uint256 _paymentDelay): # not payable\n  mem[128 len _description.length] = _description[all]\n  require stor8[caller]\n  authorizedPayments.length++\n  if not authorizedPayments.length <= authorizedPayments.length + 1:\n      mem[0] = 3\n      idx = (6 * authorizedPayments.length) + 6\n      while sha3(3) + (6 * authorizedPayments.length) > idx + sha3(mem[0]):\n          uint256(stor[idx + sha3(mem[0])]) = 0\n          if 31 < stor[idx + sha3(mem[0])].length:\n              mem[0] = idx + sha3(mem[0])\n              s = sha3(idx + sha3(mem[0]))\n              while sha3(idx + sha3(mem[0])) + (stor[idx + sha3(mem[0])].length + 31 / 32) > s:\n                  uint256(stor[s]) = 0\n                  s = s + 1\n                  continue \n          address(stor[idx + sha3(mem[0]) + 1]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 2]) = 0\n          Mask(176, 0, stor[idx + sha3(mem[0]) + 3]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 4]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 5]) = 0\n          idx = idx + 6\n          continue \n  require authorizedPayments.length < authorizedPayments.length\n  address(authorizedPayments[authorizedPayments.length].field_256) = caller\n  if _paymentDelay >= timeLock:\n      uint256(authorizedPayments[authorizedPayments.length].field_512) = block.timestamp + _paymentDelay\n  else:\n      uint256(authorizedPayments[authorizedPayments.length].field_512) = block.timestamp + timeLock\n  address(authorizedPayments[authorizedPayments.length].field_784) = _recipient\n  uint256(authorizedPayments[authorizedPayments.length].field_1024) = _amount\n  uint256(authorizedPayments[authorizedPayments.length].field_0) = (2 * _description.length) + 1\n  s = 0\n  idx = 128\n  while _description.length + 128 > idx:\n      uint256(authorizedPayments[(6 * authorizedPayments.length) + s].field_0) = mem[idx]\n      s = s + 1\n      idx = idx + 32\n      continue \n  if authorizedPayments[authorizedPayments.length].length + 31 / 32 > Mask(251, 0, _description.length + 31) >> 5:\n      uint256(stor[('array', ('mul', 6, ('stor', ('length', ('name', 'authorizedPayments', 3)))), ('name', 'authorizedPayments', 3)) + (Mask(251, 0, _description.length + 31) >> 5)].field_0) = 0\n      idx = (Mask(251, 0, _description.length + 31) >> 5) + 1\n      while authorizedPayments[authorizedPayments.length].length + 31 / 32 > idx:\n          uint256(authorizedPayments[(6 * authorizedPayments.length) + idx].field_0) = 0\n          idx = idx + 1\n          continue \n  log PaymentAuthorized(\n        uint256 idPayment=uint256(authorizedPayments[authorizedPayments.length].field_1024),\n        address recipient=authorizedPayments.length,\n        uint256 amount=address(authorizedPayments[authorizedPayments.length].field_784))\n  return authorizedPayments.length\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  escapeCallerAddress is address at storage 1\n  escapeDestinationAddress is address at storage 2\n  authorizedPayments is array of struct at storage 3\n  securityGuardAddress is address at storage 4\n  absoluteMinTimeLock is uint256 at storage 5\n  timeLock is uint256 at storage 6\n  maxSecurityGuardDelay is uint256 at storage 7\n  stor8 is mapping of uint8 at storage 8\n\ndef maxSecurityGuardDelay(): # not payable\n  return maxSecurityGuardDelay\n\ndef numberOfAuthorizedPayments(): # not payable\n  return authorizedPayments.length\n\ndef owner(): # not payable\n  return owner\n\ndef authorizedPayments(uint256 _param1): # not payable\n  require _param1 < authorizedPayments.length\n  mem[384] = uint256(authorizedPayments[_param1].field_0)\n  idx = 384\n  s = 0\n  while authorizedPayments[_param1].length + 384 > idx + 32:\n      mem[idx + 32] = uint256(authorizedPayments[(6 * _param1) + s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  return Array(len=authorizedPayments[_param1].length, data=mem[384 len authorizedPayments[_param1].length + (floor32(authorizedPayments[_param1].length - 1) + -authorizedPayments[_param1].length + 32 % 32)]), \n         address(authorizedPayments[_param1].field_256),\n         uint256(authorizedPayments[_param1].field_512),\n         bool(uint8(authorizedPayments[_param1].field_768)),\n         bool(uint8(authorizedPayments[_param1].field_776)),\n         address(authorizedPayments[_param1].field_768),\n         uint256(authorizedPayments[_param1].field_1024),\n         uint256(authorizedPayments[_param1].field_1280)\n\ndef securityGuard(): # not payable\n  return securityGuardAddress\n\ndef escapeDestination(): # not payable\n  return escapeDestinationAddress\n\ndef timeLock(): # not payable\n  return timeLock\n\ndef allowedSpenders(address _param1): # not payable\n  return bool(stor8[_param1])\n\ndef absoluteMinTimeLock(): # not payable\n  return absoluteMinTimeLock\n\ndef escapeCaller(): # not payable\n  return escapeCallerAddress\n\n#\n#  Regular functions\n#\n\ndef changeOwner(address _newOwner): # not payable\n  require owner == caller\n  owner = _newOwner\n\ndef receiveEther() payable: \n  log EtherReceived(\n        address sender=call.value,\n        uint256 amount=caller)\n\ndef setSecurityGuard(address _newSecurityGuard): # not payable\n  require owner == caller\n  securityGuardAddress = _newSecurityGuard\n\ndef _fallback(?) payable: # default function\n  log EtherReceived(\n        address sender=call.value,\n        uint256 amount=caller)\n\ndef setMaxSecurityGuardDelay(uint256 _maxSecurityGuardDelay): # not payable\n  require owner == caller\n  maxSecurityGuardDelay = _maxSecurityGuardDelay\n\ndef changeEscapeCaller(address _newEscapeHatchCaller): # not payable\n  if escapeCallerAddress != caller:\n      require owner == caller\n  escapeCallerAddress = _newEscapeHatchCaller\n\ndef setTimelock(uint256 newTimelockDurationInBlocks_): # not payable\n  require owner == caller\n  require newTimelockDurationInBlocks_ >= absoluteMinTimeLock\n  timeLock = newTimelockDurationInBlocks_\n\ndef escapeHatch(): # not payable\n  if escapeCallerAddress != caller:\n      require owner == caller\n  call escapeDestinationAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log EscapeCalled(uint256 amount=eth.balance(this.address))\n\ndef authorizeSpender(address _spender, bool _authorize): # not payable\n  require owner == caller\n  stor8[address(_spender)] = uint8(_authorize)\n  log SpenderAuthorization(\n        address spender=_authorize,\n        bool authorized=_spender)\n\ndef cancelPayment(uint256 _idPayment): # not payable\n  require owner == caller\n  require _idPayment < authorizedPayments.length\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  uint8(authorizedPayments[_idPayment].field_768) = 1\n  log PaymentCanceled(uint256 idPayment=_idPayment)\n\ndef delayPayment(uint256 _idPayment, uint256 _delay): # not payable\n  require securityGuardAddress == caller\n  require _idPayment < authorizedPayments.length\n  require uint256(authorizedPayments[_idPayment].field_1280) + _delay <= maxSecurityGuardDelay\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  uint256(authorizedPayments[_idPayment].field_1280) += _delay\n  uint256(authorizedPayments[_idPayment].field_512) += _delay\n\ndef collectAuthorizedPayment(uint256 _idPayment): # not payable\n  require _idPayment < authorizedPayments.length\n  require address(authorizedPayments[_idPayment].field_784) == caller\n  require stor8[address(stor3[_idPayment].field_256)]\n  require block.timestamp >= uint256(authorizedPayments[_idPayment].field_512)\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  require eth.balance(this.address) >= uint256(authorizedPayments[_idPayment].field_1024)\n  uint8(authorizedPayments[_idPayment].field_776) = 1\n  call address(authorizedPayments[_idPayment].field_784) or 0 or 0 with:\n     value uint256(authorizedPayments[_idPayment].field_1024) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log PaymentExecuted(\n        uint256 idPayment=uint256(authorizedPayments[_idPayment].field_1024),\n        address recipient=_idPayment,\n        uint256 amount=address(authorizedPayments[_idPayment].field_784))\n\ndef authorizePayment(string _description, address _recipient, uint256 _amount, uint256 _paymentDelay): # not payable\n  mem[128 len _description.length] = _description[all]\n  require stor8[caller]\n  authorizedPayments.length++\n  if not authorizedPayments.length <= authorizedPayments.length + 1:\n      mem[0] = 3\n      idx = (6 * authorizedPayments.length) + 6\n      while sha3(3) + (6 * authorizedPayments.length) > idx + sha3(mem[0]):\n          uint256(stor[idx + sha3(mem[0])]) = 0\n          if 31 < stor[idx + sha3(mem[0])].length:\n              mem[0] = idx + sha3(mem[0])\n              s = sha3(idx + sha3(mem[0]))\n              while sha3(idx + sha3(mem[0])) + (stor[idx + sha3(mem[0])].length + 31 / 32) > s:\n                  uint256(stor[s]) = 0\n                  s = s + 1\n                  continue \n          address(stor[idx + sha3(mem[0]) + 1]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 2]) = 0\n          Mask(176, 0, stor[idx + sha3(mem[0]) + 3]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 4]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 5]) = 0\n          idx = idx + 6\n          continue \n  require authorizedPayments.length < authorizedPayments.length\n  address(authorizedPayments[authorizedPayments.length].field_256) = caller\n  if _paymentDelay >= timeLock:\n      uint256(authorizedPayments[authorizedPayments.length].field_512) = block.timestamp + _paymentDelay\n  else:\n      uint256(authorizedPayments[authorizedPayments.length].field_512) = block.timestamp + timeLock\n  address(authorizedPayments[authorizedPayments.length].field_784) = _recipient\n  uint256(authorizedPayments[authorizedPayments.length].field_1024) = _amount\n  uint256(authorizedPayments[authorizedPayments.length].field_0) = (2 * _description.length) + 1\n  s = 0\n  idx = 128\n  while _description.length + 128 > idx:\n      uint256(authorizedPayments[(6 * authorizedPayments.length) + s].field_0) = mem[idx]\n      s = s + 1\n      idx = idx + 32\n      continue \n  if authorizedPayments[authorizedPayments.length].length + 31 / 32 > Mask(251, 0, _description.length + 31) >> 5:\n      uint256(stor[('array', ('mul', 6, ('stor', ('length', ('name', 'authorizedPayments', 3)))), ('name', 'authorizedPayments', 3)) + (Mask(251, 0, _description.length + 31) >> 5)].field_0) = 0\n      idx = (Mask(251, 0, _description.length + 31) >> 5) + 1\n      while authorizedPayments[authorizedPayments.length].length + 31 / 32 > idx:\n          uint256(authorizedPayments[(6 * authorizedPayments.length) + idx].field_0) = 0\n          idx = idx + 1\n          continue \n  log PaymentAuthorized(\n        uint256 idPayment=uint256(authorizedPayments[authorizedPayments.length].field_1024),\n        address recipient=authorizedPayments.length,\n        uint256 amount=address(authorizedPayments[authorizedPayments.length].field_784))\n  return authorizedPayments.length\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  escapeCallerAddress is address at storage 1\n  escapeDestinationAddress is address at storage 2\n  authorizedPayments is array of struct at storage 3\n  securityGuardAddress is address at storage 4\n  absoluteMinTimeLock is uint256 at storage 5\n  timeLock is uint256 at storage 6\n  maxSecurityGuardDelay is uint256 at storage 7\n  stor8 is mapping of uint8 at storage 8\n\ndef maxSecurityGuardDelay(): # not payable\n  return maxSecurityGuardDelay\n\ndef numberOfAuthorizedPayments(): # not payable\n  return authorizedPayments.length\n\ndef owner(): # not payable\n  return owner\n\ndef authorizedPayments(uint256 _param1): # not payable\n  require _param1 < authorizedPayments.length\n  mem[384] = uint256(authorizedPayments[_param1].field_0)\n  idx = 384\n  s = 0\n  while authorizedPayments[_param1].length + 384 > idx + 32:\n      mem[idx + 32] = uint256(authorizedPayments[(6 * _param1) + s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  return Array(len=authorizedPayments[_param1].length, data=mem[384 len authorizedPayments[_param1].length + (floor32(authorizedPayments[_param1].length - 1) + -authorizedPayments[_param1].length + 32 % 32)]), \n         address(authorizedPayments[_param1].field_256),\n         uint256(authorizedPayments[_param1].field_512),\n         bool(uint8(authorizedPayments[_param1].field_768)),\n         bool(uint8(authorizedPayments[_param1].field_776)),\n         address(authorizedPayments[_param1].field_768),\n         uint256(authorizedPayments[_param1].field_1024),\n         uint256(authorizedPayments[_param1].field_1280)\n\ndef securityGuard(): # not payable\n  return securityGuardAddress\n\ndef escapeDestination(): # not payable\n  return escapeDestinationAddress\n\ndef timeLock(): # not payable\n  return timeLock\n\ndef allowedSpenders(address _param1): # not payable\n  return bool(stor8[_param1])\n\ndef absoluteMinTimeLock(): # not payable\n  return absoluteMinTimeLock\n\ndef escapeCaller(): # not payable\n  return escapeCallerAddress\n\n#\n#  Regular functions\n#\n\ndef changeOwner(address _newOwner): # not payable\n  require owner == caller\n  owner = _newOwner\n\ndef receiveEther() payable: \n  log EtherReceived(\n        address sender=call.value,\n        uint256 amount=caller)\n\ndef setSecurityGuard(address _newSecurityGuard): # not payable\n  require owner == caller\n  securityGuardAddress = _newSecurityGuard\n\ndef _fallback(?) payable: # default function\n  log EtherReceived(\n        address sender=call.value,\n        uint256 amount=caller)\n\ndef setMaxSecurityGuardDelay(uint256 _maxSecurityGuardDelay): # not payable\n  require owner == caller\n  maxSecurityGuardDelay = _maxSecurityGuardDelay\n\ndef changeEscapeCaller(address _newEscapeHatchCaller): # not payable\n  if escapeCallerAddress != caller:\n      require owner == caller\n  escapeCallerAddress = _newEscapeHatchCaller\n\ndef setTimelock(uint256 newTimelockDurationInBlocks_): # not payable\n  require owner == caller\n  require newTimelockDurationInBlocks_ >= absoluteMinTimeLock\n  timeLock = newTimelockDurationInBlocks_\n\ndef escapeHatch(): # not payable\n  if escapeCallerAddress != caller:\n      require owner == caller\n  call escapeDestinationAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log EscapeCalled(uint256 amount=eth.balance(this.address))\n\ndef authorizeSpender(address _spender, bool _authorize): # not payable\n  require owner == caller\n  stor8[address(_spender)] = uint8(_authorize)\n  log SpenderAuthorization(\n        address spender=_authorize,\n        bool authorized=_spender)\n\ndef cancelPayment(uint256 _idPayment): # not payable\n  require owner == caller\n  require _idPayment < authorizedPayments.length\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  uint8(authorizedPayments[_idPayment].field_768) = 1\n  log PaymentCanceled(uint256 idPayment=_idPayment)\n\ndef delayPayment(uint256 _idPayment, uint256 _delay): # not payable\n  require securityGuardAddress == caller\n  require _idPayment < authorizedPayments.length\n  require uint256(authorizedPayments[_idPayment].field_1280) + _delay <= maxSecurityGuardDelay\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  uint256(authorizedPayments[_idPayment].field_1280) += _delay\n  uint256(authorizedPayments[_idPayment].field_512) += _delay\n\ndef collectAuthorizedPayment(uint256 _idPayment): # not payable\n  require _idPayment < authorizedPayments.length\n  require address(authorizedPayments[_idPayment].field_784) == caller\n  require stor8[address(stor3[_idPayment].field_256)]\n  require block.timestamp >= uint256(authorizedPayments[_idPayment].field_512)\n  require not uint8(authorizedPayments[_idPayment].field_768)\n  require not uint8(authorizedPayments[_idPayment].field_776)\n  require eth.balance(this.address) >= uint256(authorizedPayments[_idPayment].field_1024)\n  uint8(authorizedPayments[_idPayment].field_776) = 1\n  call address(authorizedPayments[_idPayment].field_784) or 0 or 0 with:\n     value uint256(authorizedPayments[_idPayment].field_1024) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log PaymentExecuted(\n        uint256 idPayment=uint256(authorizedPayments[_idPayment].field_1024),\n        address recipient=_idPayment,\n        uint256 amount=address(authorizedPayments[_idPayment].field_784))\n\ndef authorizePayment(string _description, address _recipient, uint256 _amount, uint256 _paymentDelay): # not payable\n  mem[128 len _description.length] = _description[all]\n  require stor8[caller]\n  authorizedPayments.length++\n  if not authorizedPayments.length <= authorizedPayments.length + 1:\n      mem[0] = 3\n      idx = (6 * authorizedPayments.length) + 6\n      while sha3(3) + (6 * authorizedPayments.length) > idx + sha3(mem[0]):\n          uint256(stor[idx + sha3(mem[0])]) = 0\n          if 31 < stor[idx + sha3(mem[0])].length:\n              mem[0] = idx + sha3(mem[0])\n              s = sha3(idx + sha3(mem[0]))\n              while sha3(idx + sha3(mem[0])) + (stor[idx + sha3(mem[0])].length + 31 / 32) > s:\n                  uint256(stor[s]) = 0\n                  s = s + 1\n                  continue \n          address(stor[idx + sha3(mem[0]) + 1]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 2]) = 0\n          Mask(176, 0, stor[idx + sha3(mem[0]) + 3]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 4]) = 0\n          uint256(stor[idx + sha3(mem[0]) + 5]) = 0\n          idx = idx + 6\n          continue \n  require authorizedPayments.length < authorizedPayments.length\n  address(authorizedPayments[authorizedPayments.length].field_256) = caller\n  if _paymentDelay >= timeLock:\n      uint256(authorizedPayments[authorizedPayments.length].field_512) = block.timestamp + _paymentDelay\n  else:\n      uint256(authorizedPayments[authorizedPayments.length].field_512) = block.timestamp + timeLock\n  address(authorizedPayments[authorizedPayments.length].field_784) = _recipient\n  uint256(authorizedPayments[authorizedPayments.length].field_1024) = _amount\n  uint256(authorizedPayments[authorizedPayments.length].field_0) = (2 * _description.length) + 1\n  s = 0\n  idx = 128\n  while _description.length + 128 > idx:\n      uint256(authorizedPayments[(6 * authorizedPayments.length) + s].field_0) = mem[idx]\n      s = s + 1\n      idx = idx + 32\n      continue \n  if authorizedPayments[authorizedPayments.length].length + 31 / 32 > Mask(251, 0, _description.length + 31) >> 5:\n      uint256(stor[('array', ('mul', 6, ('stor', ('length', ('name', 'authorizedPayments', 3)))), ('name', 'authorizedPayments', 3)) + (Mask(251, 0, _description.length + 31) >> 5)].field_0) = 0\n      idx = (Mask(251, 0, _description.length + 31) >> 5) + 1\n      while authorizedPayments[authorizedPayments.length].length + 31 / 32 > idx:\n          uint256(authorizedPayments[(6 * authorizedPayments.length) + idx].field_0) = 0\n          idx = idx + 1\n          continue \n  log PaymentAuthorized(\n        uint256 idPayment=uint256(authorizedPayments[authorizedPayments.length].field_1024),\n        address recipient=authorizedPayments.length,\n        uint256 amount=address(authorizedPayments[authorizedPayments.length].field_784))\n  return authorizedPayments.length\n\n.",
	"status": "1",
	"time_cost": 35.91709518432617,
	"usage": {
		"completion_tokens": 529,
		"prompt_tokens": 2247,
		"total_tokens": 2776
	}
}