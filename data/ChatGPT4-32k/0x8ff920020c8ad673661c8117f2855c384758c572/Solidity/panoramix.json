{
	"address": "0x8ff920020c8ad673661c8117f2855c384758c572",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity version of the given decompiled code. This code is the implementation of a Multisig wallet:\n\n```Solidity\npragma solidity ^0.5.0;\n\ncontract MultiSigWallet {\n    \n    uint constant public MAX_OWNER_COUNT = 50;\n    mapping(address => bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    mapping (uint => Transaction) public transactions;\n    uint public transactionCount;\n    \n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n    \n    constructor (address[] memory _owners, uint _required) public {\n        require(_owners.length <= MAX_OWNER_COUNT, \"Owners count exceeded\");\n        require(_required <= _owners.length, \"Required approval should be less than owner counts\");\n        for (uint i=0; i<_owners.length; i++) {\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n    \n    function addOwner(address owner) public {\n        require(!isOwner[owner], \"Owner already exists\");\n        isOwner[owner] = true;\n        owners.push(owner);\n    }\n    \n    function removeOwner(address owner) public {\n        require(isOwner[owner], \"Owner does not exist\");\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++) {\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n    }\n    \n    function replaceOwner(address owner, address newOwner) public {\n        require(isOwner[owner], \"Owner does not exist\");\n        require(!isOwner[newOwner], \"New owner already exists\");\n        for (uint i=0; i<owners.length; i++) {\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n    }\n    \n    function changeRequirement(uint _required) public {\n        required = _required;\n    }\n    \n    function submitTransaction(address destination, uint value, bytes memory data) public returns (uint transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n    }\n    \n    function executeTransaction(uint transactionId) public {\n        require(!transactions[transactionId].executed, \"Transaction already executed\");\n        transactions[transactionId].executed = true;\n        (bool success,) = transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data);\n        require(success, \"Transaction failed\");\n    }\n    \n    function () external payable {\n        revert();\n    }\n}\n```\n\nNote: This is a simple version of a MultiSig wallet. In the actual implementation, we will need to handle transaction confirmations, revocations and other edge cases.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471168,
	"id": "chatcmpl-8MuWGwnTOQfB9LYlNtFEAQmZkZXo5",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 ): # not payable\n  require  < owners.length\n  return address(owners[].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 , address ): # not payable\n  return bool(uint8(stor1[][]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address ender=call.value,\n            uint256 alue=caller)\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _required <= owners.length\n  require _required\n  require owners.length\n  required = _required\n  log 0xa3f1ee91: _required\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log 0xf6a31715: caller, transactionId\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[address(owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  address(owners[owners.length].field_0) = owner\n  log 0xf39e6e1e: owner\n\ndef transactions(uint256 ): # not payable\n  mem[256] = stor0[][2].field_0\n  idx = 256\n  s = 0\n  while stor0[][2].length + 256 > idx + 32:\n      mem[idx + 32] = stor0[][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[].field_0), \n         stor0[].field_256,\n         Array(len=stor0[][2].length, data=mem[256 len stor0[][2].length + (floor32(stor0[][2].length - 1) + -stor0[][2].length + 32 % 32)]),\n         bool(uint8(stor0[].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[newOwner] = 1\n      log 0x8001553a: owner\n      log 0xf39e6e1e: newOwner\n      stop\n  stor2[address(owner)] = 0\n  stor2[newOwner] = 1\n  log 0x8001553a: owner\n  log 0xf39e6e1e: newOwner\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      if Mask(251, 0, owners.length):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + 224] = mem[160]\n          mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  else:\n      mem[160] = address(owners.field_0)\n      idx = 160\n      s = 0\n      while (32 * owners.length) + 128 > idx:\n          mem[idx + 32] = address(owners[s].field_256)\n          idx = idx + 32\n          s = s + 1\n          continue \n      loop Node((3158, 9, ('916',))) setvars: ()\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      if Mask(251, 0, owners.length):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + 224] = mem[160]\n          mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  return Array(len=owners.length, data=mem[(32 * owners.length) + 224 len 32 * owners.length])\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionId\n      else:\n          log 0x526441bb: transactionId\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log 0xa3f1ee91: owners.length\n      log 0x8001553a: owner\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log 0xa3f1ee91: owners.length\n  log 0x8001553a: owner\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log 0x4a504a94: caller, transactionId\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionId\n      else:\n          log 0x526441bb: transactionId\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log 0xc0ba8fe4: transactionCount\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log 0x4a504a94: caller, transactionCount\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionCount\n      else:\n          log 0x526441bb: transactionCount\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\ndef getConfirmations(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 224] = 32\n      mem[(32 * owners.length) + (32 * s) + 256] = s\n      if Mask(251, 0, s):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + (32 * s) + 288] = mem[(32 * owners.length) + 224]\n          mem[(32 * owners.length) + (32 * s) + 320 len floor32((32 * s) - 1)] = mem[(32 * owners.length) + 256 len floor32((32 * s) - 1)]\n      return Array(len=s, data=mem[(32 * owners.length) + (32 * s) + 288 len 32 * s])\n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  if not Mask(251, 0, s):\n      return memory\n        from (64 * s) + 256\n         len (32 * s) + 64\n  loop Node((956, 10, ())) setvars: ()\n  mem[(64 * s) + 320] = mem[(32 * s) + 256]\n  mem[(64 * s) + 352 len floor32((32 * s, None) - 1)] = mem[(32 * s) + 288 len floor32((32 * s, None) - 1)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  mem[96] = 0\n  mem[128] = 0\n  mem[160] = transactionCount\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 >= (32 * transactionCount) + 192:\n      mem[(32 * s) + 224] = to - from\n      mem[64] = (32 * s) + (32 * to - from) + 256\n      idx = from\n      while idx < to:\n          require idx < transactionCount\n          require idx - from < to - from, None\n          mem[(32 * s) + (32 * idx - from) + 256] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * s) + (32 * to - from) + 256] = 32\n      mem[(32 * s) + (32 * to - from) + 288] = to - from, None\n      if not Mask(251, 0, to - from):\n          return 32, mem[(32 * s) + (32 * to - from) + 288 len (32 * to - from) + 32]\n      loop Node((956, 10, ())) setvars: ()\n      mem[(32 * s) + (32 * to - from) + 320] = mem[(32 * s) + 256]\n      t = (32 * s) + 256\n      u = (32 * s) + (32 * to - from) + 320\n      t = 32 * to - from, None\n      while t > 32:\n          mem[u + 32] = mem[to + 32]\n          t = to + 32\n          u = u + 32\n          t = t - 32\n          continue \n      return memory\n        from (32 * s) + (32 * to - from) + 256\n         len (32 * to - from, None) + 64\n  mem[(32 * transactionCount) + 192] = to - from\n  mem[64] = (32 * transactionCount) + (32 * to - from) + 224\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * idx - from) + 224] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * to - from) + 224] = 32\n  mem[(32 * transactionCount) + (32 * to - from) + 256] = mem[(32 * transactionCount) + 192]\n  _118 = mem[(32 * transactionCount) + 192]\n  if not Mask(251, 0, mem[(32 * transactionCount) + 192]):\n      return 32, mem[(32 * transactionCount) + (32 * to - from) + 256 len (32 * mem[(32 * transactionCount) + 192]) + 32]\n  loop Node((956, 10, ())) setvars: ()\n  mem[(32 * transactionCount) + (32 * to - from) + 288] = mem[(32 * transactionCount) + 224]\n  s = (32 * transactionCount) + 224\n  t = mem[64] + 64\n  s = 32 * mem[(32 * transactionCount) + 192]\n  while s > 32:\n      mem[t + 32] = mem[to + 32]\n      s = to + 32\n      t = t + 32\n      s = s - 32\n      continue \n  return memory\n    from mem[64]\n     len (32 * _118) + (32 * transactionCount) + (32 * to - from) + -mem[64] + 288\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 ): # not payable\n  require  < owners.length\n  return address(owners[].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 , address ): # not payable\n  return bool(uint8(stor1[][]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address ender=call.value,\n            uint256 alue=caller)\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _required <= owners.length\n  require _required\n  require owners.length\n  required = _required\n  log 0xa3f1ee91: _required\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log 0xf6a31715: caller, transactionId\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[address(owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  address(owners[owners.length].field_0) = owner\n  log 0xf39e6e1e: owner\n\ndef transactions(uint256 ): # not payable\n  mem[256] = stor0[][2].field_0\n  idx = 256\n  s = 0\n  while stor0[][2].length + 256 > idx + 32:\n      mem[idx + 32] = stor0[][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[].field_0), \n         stor0[].field_256,\n         Array(len=stor0[][2].length, data=mem[256 len stor0[][2].length + (floor32(stor0[][2].length - 1) + -stor0[][2].length + 32 % 32)]),\n         bool(uint8(stor0[].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[newOwner] = 1\n      log 0x8001553a: owner\n      log 0xf39e6e1e: newOwner\n      stop\n  stor2[address(owner)] = 0\n  stor2[newOwner] = 1\n  log 0x8001553a: owner\n  log 0xf39e6e1e: newOwner\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      if Mask(251, 0, owners.length):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + 224] = mem[160]\n          mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  else:\n      mem[160] = address(owners.field_0)\n      idx = 160\n      s = 0\n      while (32 * owners.length) + 128 > idx:\n          mem[idx + 32] = address(owners[s].field_256)\n          idx = idx + 32\n          s = s + 1\n          continue \n      loop Node((3158, 9, ('916',))) setvars: ()\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      if Mask(251, 0, owners.length):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + 224] = mem[160]\n          mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  return Array(len=owners.length, data=mem[(32 * owners.length) + 224 len 32 * owners.length])\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionId\n      else:\n          log 0x526441bb: transactionId\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log 0xa3f1ee91: owners.length\n      log 0x8001553a: owner\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log 0xa3f1ee91: owners.length\n  log 0x8001553a: owner\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log 0x4a504a94: caller, transactionId\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionId\n      else:\n          log 0x526441bb: transactionId\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log 0xc0ba8fe4: transactionCount\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log 0x4a504a94: caller, transactionCount\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionCount\n      else:\n          log 0x526441bb: transactionCount\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\ndef getConfirmations(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 224] = 32\n      mem[(32 * owners.length) + (32 * s) + 256] = s\n      if Mask(251, 0, s):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + (32 * s) + 288] = mem[(32 * owners.length) + 224]\n          mem[(32 * owners.length) + (32 * s) + 320 len floor32((32 * s) - 1)] = mem[(32 * owners.length) + 256 len floor32((32 * s) - 1)]\n      return Array(len=s, data=mem[(32 * owners.length) + (32 * s) + 288 len 32 * s])\n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  if not Mask(251, 0, s):\n      return memory\n        from (64 * s) + 256\n         len (32 * s) + 64\n  loop Node((956, 10, ())) setvars: ()\n  mem[(64 * s) + 320] = mem[(32 * s) + 256]\n  mem[(64 * s) + 352 len floor32((32 * s, None) - 1)] = mem[(32 * s) + 288 len floor32((32 * s, None) - 1)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  mem[96] = 0\n  mem[128] = 0\n  mem[160] = transactionCount\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 >= (32 * transactionCount) + 192:\n      mem[(32 * s) + 224] = to - from\n      mem[64] = (32 * s) + (32 * to - from) + 256\n      idx = from\n      while idx < to:\n          require idx < transactionCount\n          require idx - from < to - from, None\n          mem[(32 * s) + (32 * idx - from) + 256] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * s) + (32 * to - from) + 256] = 32\n      mem[(32 * s) + (32 * to - from) + 288] = to - from, None\n      if not Mask(251, 0, to - from):\n          return 32, mem[(32 * s) + (32 * to - from) + 288 len (32 * to - from) + 32]\n      loop Node((956, 10, ())) setvars: ()\n      mem[(32 * s) + (32 * to - from) + 320] = mem[(32 * s) + 256]\n      t = (32 * s) + 256\n      u = (32 * s) + (32 * to - from) + 320\n      t = 32 * to - from, None\n      while t > 32:\n          mem[u + 32] = mem[to + 32]\n          t = to + 32\n          u = u + 32\n          t = t - 32\n          continue \n      return memory\n        from (32 * s) + (32 * to - from) + 256\n         len (32 * to - from, None) + 64\n  mem[(32 * transactionCount) + 192] = to - from\n  mem[64] = (32 * transactionCount) + (32 * to - from) + 224\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * idx - from) + 224] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * to - from) + 224] = 32\n  mem[(32 * transactionCount) + (32 * to - from) + 256] = mem[(32 * transactionCount) + 192]\n  _118 = mem[(32 * transactionCount) + 192]\n  if not Mask(251, 0, mem[(32 * transactionCount) + 192]):\n      return 32, mem[(32 * transactionCount) + (32 * to - from) + 256 len (32 * mem[(32 * transactionCount) + 192]) + 32]\n  loop Node((956, 10, ())) setvars: ()\n  mem[(32 * transactionCount) + (32 * to - from) + 288] = mem[(32 * transactionCount) + 224]\n  s = (32 * transactionCount) + 224\n  t = mem[64] + 64\n  s = 32 * mem[(32 * transactionCount) + 192]\n  while s > 32:\n      mem[t + 32] = mem[to + 32]\n      s = to + 32\n      t = t + 32\n      s = s - 32\n      continue \n  return memory\n    from mem[64]\n     len (32 * _118) + (32 * transactionCount) + (32 * to - from) + -mem[64] + 288\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 ): # not payable\n  require  < owners.length\n  return address(owners[].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 , address ): # not payable\n  return bool(uint8(stor1[][]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address ender=call.value,\n            uint256 alue=caller)\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _required <= owners.length\n  require _required\n  require owners.length\n  required = _required\n  log 0xa3f1ee91: _required\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log 0xf6a31715: caller, transactionId\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[address(owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  address(owners[owners.length].field_0) = owner\n  log 0xf39e6e1e: owner\n\ndef transactions(uint256 ): # not payable\n  mem[256] = stor0[][2].field_0\n  idx = 256\n  s = 0\n  while stor0[][2].length + 256 > idx + 32:\n      mem[idx + 32] = stor0[][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[].field_0), \n         stor0[].field_256,\n         Array(len=stor0[][2].length, data=mem[256 len stor0[][2].length + (floor32(stor0[][2].length - 1) + -stor0[][2].length + 32 % 32)]),\n         bool(uint8(stor0[].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[newOwner] = 1\n      log 0x8001553a: owner\n      log 0xf39e6e1e: newOwner\n      stop\n  stor2[address(owner)] = 0\n  stor2[newOwner] = 1\n  log 0x8001553a: owner\n  log 0xf39e6e1e: newOwner\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      if Mask(251, 0, owners.length):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + 224] = mem[160]\n          mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  else:\n      mem[160] = address(owners.field_0)\n      idx = 160\n      s = 0\n      while (32 * owners.length) + 128 > idx:\n          mem[idx + 32] = address(owners[s].field_256)\n          idx = idx + 32\n          s = s + 1\n          continue \n      loop Node((3158, 9, ('916',))) setvars: ()\n      mem[(32 * owners.length) + 160] = 32\n      mem[(32 * owners.length) + 192] = owners.length\n      if Mask(251, 0, owners.length):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + 224] = mem[160]\n          mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  return Array(len=owners.length, data=mem[(32 * owners.length) + 224 len 32 * owners.length])\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionId\n      else:\n          log 0x526441bb: transactionId\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log 0xa3f1ee91: owners.length\n      log 0x8001553a: owner\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log 0xa3f1ee91: owners.length\n  log 0x8001553a: owner\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log 0x4a504a94: caller, transactionId\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionId\n      else:\n          log 0x526441bb: transactionId\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log 0xc0ba8fe4: transactionCount\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log 0x4a504a94: caller, transactionCount\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log 0x33e13ecb: transactionCount\n      else:\n          log 0x526441bb: transactionCount\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\ndef getConfirmations(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 224] = 32\n      mem[(32 * owners.length) + (32 * s) + 256] = s\n      if Mask(251, 0, s):\n          loop Node((956, 10, ())) setvars: ()\n          mem[(32 * owners.length) + (32 * s) + 288] = mem[(32 * owners.length) + 224]\n          mem[(32 * owners.length) + (32 * s) + 320 len floor32((32 * s) - 1)] = mem[(32 * owners.length) + 256 len floor32((32 * s) - 1)]\n      return Array(len=s, data=mem[(32 * owners.length) + (32 * s) + 288 len 32 * s])\n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  if not Mask(251, 0, s):\n      return memory\n        from (64 * s) + 256\n         len (32 * s) + 64\n  loop Node((956, 10, ())) setvars: ()\n  mem[(64 * s) + 320] = mem[(32 * s) + 256]\n  mem[(64 * s) + 352 len floor32((32 * s, None) - 1)] = mem[(32 * s) + 288 len floor32((32 * s, None) - 1)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  mem[96] = 0\n  mem[128] = 0\n  mem[160] = transactionCount\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 >= (32 * transactionCount) + 192:\n      mem[(32 * s) + 224] = to - from\n      mem[64] = (32 * s) + (32 * to - from) + 256\n      idx = from\n      while idx < to:\n          require idx < transactionCount\n          require idx - from < to - from, None\n          mem[(32 * s) + (32 * idx - from) + 256] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * s) + (32 * to - from) + 256] = 32\n      mem[(32 * s) + (32 * to - from) + 288] = to - from, None\n      if not Mask(251, 0, to - from):\n          return 32, mem[(32 * s) + (32 * to - from) + 288 len (32 * to - from) + 32]\n      loop Node((956, 10, ())) setvars: ()\n      mem[(32 * s) + (32 * to - from) + 320] = mem[(32 * s) + 256]\n      t = (32 * s) + 256\n      u = (32 * s) + (32 * to - from) + 320\n      t = 32 * to - from, None\n      while t > 32:\n          mem[u + 32] = mem[to + 32]\n          t = to + 32\n          u = u + 32\n          t = t - 32\n          continue \n      return memory\n        from (32 * s) + (32 * to - from) + 256\n         len (32 * to - from, None) + 64\n  mem[(32 * transactionCount) + 192] = to - from\n  mem[64] = (32 * transactionCount) + (32 * to - from) + 224\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * idx - from) + 224] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * to - from) + 224] = 32\n  mem[(32 * transactionCount) + (32 * to - from) + 256] = mem[(32 * transactionCount) + 192]\n  _118 = mem[(32 * transactionCount) + 192]\n  if not Mask(251, 0, mem[(32 * transactionCount) + 192]):\n      return 32, mem[(32 * transactionCount) + (32 * to - from) + 256 len (32 * mem[(32 * transactionCount) + 192]) + 32]\n  loop Node((956, 10, ())) setvars: ()\n  mem[(32 * transactionCount) + (32 * to - from) + 288] = mem[(32 * transactionCount) + 224]\n  s = (32 * transactionCount) + 224\n  t = mem[64] + 64\n  s = 32 * mem[(32 * transactionCount) + 192]\n  while s > 32:\n      mem[t + 32] = mem[to + 32]\n      s = to + 32\n      t = t + 32\n      s = s - 32\n      continue \n  return memory\n    from mem[64]\n     len (32 * _118) + (32 * transactionCount) + (32 * to - from) + -mem[64] + 288\n\n.",
	"status": "1",
	"time_cost": 36.966915130615234,
	"usage": {
		"completion_tokens": 668,
		"prompt_tokens": 5602,
		"total_tokens": 6270
	}
}