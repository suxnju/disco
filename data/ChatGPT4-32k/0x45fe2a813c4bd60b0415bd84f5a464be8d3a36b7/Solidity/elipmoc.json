{
	"address": "0x45fe2a813c4bd60b0415bd84f5a464be8d3a36b7",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the given decompiled EVM Bytecode, the corresponding Solidity smart contract could look like this:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyToken {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n    uint256 public buyPriceEth;\n    uint256 public sellPriceEth;\n    uint256 public gasForPBTT;\n    uint256 public pBTTForGas;\n    uint256 public gasReserve;\n    uint256 public minBalanceForAccounts;\n    uint256 public totalTokenSold;\n    uint8 public halts;\n    address public owner;\n    address public proposedOwner;\n    address public opsAddress;\n    uint8 public finalized;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Finalized();\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        owner = msg.sender;\n    }\n\n    // Note: Only a subset of all functions are provided for brevity.\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    // Other functions (transferFrom, setPBTTForGas, finalize, etc.) would follow a similar pattern.\n}\n```\n\nPlease note that this is a rough reconstruction and may not cover all functionalities of the original smart contract. Also, this example assumes that values like `buyPriceEth`, `sellPriceEth`, etc. are to be set via separate setter functions (not shown), and could be changed over the lifetime of the contract. The actual implementation details would depend on the exact requirements and usage of these values.\n",
				"role": "assistant"
			}
		}
	],
	"created": 1701465413,
	"id": "chatcmpl-8R5ATph5a9XUfs9jNtCFAZ8PKYcH1",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 02:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _buyPriceEth; // STORAGE[0x9]\nuint256 _sellPriceEth; // STORAGE[0xa]\nuint256 _gasForPBTT; // STORAGE[0xb]\nuint256 _pBTTForGas; // STORAGE[0xc]\nuint256 _gasReserve; // STORAGE[0xd]\nuint256 _minBalanceForAccounts; // STORAGE[0xe]\nuint256 _totalTokenSold; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\nuint8 _halts; // STORAGE[0x10] bytes 0 to 0\naddress _owner; // STORAGE[0x6] bytes 0 to 19\naddress _proposedOwner; // STORAGE[0x7] bytes 0 to 19\naddress _opsAddress; // STORAGE[0x8] bytes 0 to 19\nuint8 _finalized; // STORAGE[0x8] bytes 20 to 20\n\n// Events\nApproval(address, address, uint256);\nFinalized();\nTransfer(address, address, uint256);\n\nfunction 0x1a4f(uint256 varg0) private { \n    if (!_opsAddress) {\n        return stor_8_0_0;\n    } else {\n        return address(varg0) == _opsAddress;\n    }\n}\n\nfunction 0x1a7c(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'Require r / a == b');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, 'Require r >= a');\n    return v0;\n}\n\nfunction 0x1bd2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    0x1f7e(varg1, msg.sender);\n    v0 = address(varg2);\n    v1 = varg0 > _balanceOf[v0];\n    v2 = v3 = varg0 <= _balanceOf[v0];\n    if (varg0 <= _balanceOf[v0]) {\n        v4 = address(varg2);\n        v2 = v5 = varg0 <= _allowance[msg.sender];\n    }\n    if (v2) {\n        v6 = address(varg1);\n        v2 = _balanceOf[v6] + varg0 > _balanceOf[v6];\n    }\n    if (!v2) {\n        v7 = v8 = 0;\n    } else {\n        v9 = address(varg2);\n        require(_balanceOf[v9] >= varg0, 'Require a >= b');\n        v10 = address(varg2);\n        _balanceOf[v10] = _balanceOf[v9] - varg0;\n        require(_balanceOf[msg.sender] >= varg0, 'Require a >= b');\n        v11 = address(varg2);\n        _allowance[msg.sender] = _balanceOf[msg.sender] - varg0;\n        v12 = address(varg1);\n        v13 = _SafeAdd(varg0, _balanceOf[v12]);\n        v14 = address(varg1);\n        _balanceOf[v14] = v13;\n        emit Transfer(address(varg2), v14, varg0);\n        v7 = v15 = 1;\n    }\n    return v7;\n}\n\nfunction fallback() public payable { \n    if (msg.sender != _owner) {\n        assert(_finalized <= 1);\n        require(_finalized == 1, 'Require smart contract is finalized');\n        assert(_halts <= 1);\n        require(_halts == 0, 'Require smart contract is not halted', 'Require smart contract is not halted');\n        require(_buyPriceEth > 0, 'buyPriceEth must be > 0');\n        require(msg.value >= _buyPriceEth, 'Transfer money must be enough for 1 token');\n        v0 = 0x1a7c(1000, msg.value);\n        assert(_buyPriceEth);\n        require(v0 / _buyPriceEth <= _balanceOf[_owner], 'Not enough token balance');\n        v1 = _SafeAdd(v0 / _buyPriceEth, _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = v1;\n        require(_balanceOf[_owner] >= v0 / _buyPriceEth, 'Require a >= b');\n        _balanceOf[_owner] = _balanceOf[_owner] - v0 / _buyPriceEth;\n        emit Transfer(_owner, msg.sender, v0 / _buyPriceEth);\n        _totalTokenSold += v0 / _buyPriceEth;\n    }\n}\n\nfunction 0x1f7e(uint256 varg0, uint256 varg1) private { \n    assert(_finalized <= 1);\n    if (_finalized != 1) {\n        if (address(varg0) != _owner) {\n            v0 = address(varg1) == _owner;\n            if (address(varg1) != _owner) {\n                v0 = v1 = 0x1a4f(varg1);\n            }\n            require(v0, 'Require is owner or ops allowed to initiate transfer');\n        }\n    }\n    return ;\n}\n\nfunction sellPriceEth() public nonPayable { \n    return _sellPriceEth;\n}\n\nfunction setPBTTForGas(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _pBTTForGas = varg0;\n}\n\nfunction setGasForPBTT(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _gasForPBTT = varg0;\n}\n\nfunction PBTTForGas() public nonPayable { \n    return _pBTTForGas;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setGasReserve(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _gasReserve = varg0;\n}\n\nfunction unhaltsTrades() public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _halts = 0;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(_halts <= 1);\n    require(_halts == 0, 'Require smart contract is not in halted state');\n    v0 = 0x1bd2(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction gasForPBTT() public nonPayable { \n    return _gasForPBTT;\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return varg0 == _owner;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawFundToOwner() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    v0 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction reclaimTokens() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    if (_balanceOf[address(this)]) {\n        require(_balanceOf[address(this)] >= _balanceOf[address(this)], 'Require a >= b');\n        _balanceOf[address(this)] = _balanceOf[address(this)] - _balanceOf[address(this)];\n        v0 = _SafeAdd(_balanceOf[address(this)], _balanceOf[_owner]);\n        _balanceOf[_owner] = v0;\n        v1 = 1;\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 > 0, 'Token amount to burn must be larger than 0');\n    require(varg0 <= _balanceOf[msg.sender], 'You cannot burn token you dont have');\n    require(_balanceOf[msg.sender] >= varg0, 'Require a >= b');\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    require(_totalSupply >= varg0, 'Require a >= b');\n    _totalSupply = _totalSupply - varg0;\n    return 1;\n}\n\nfunction minBalanceForAccounts() public nonPayable { \n    return _minBalanceForAccounts;\n}\n\nfunction setEtherPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _buyPriceEth = varg0;\n    _sellPriceEth = varg1;\n}\n\nfunction finalize() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    assert(_finalized <= 1);\n    require(_finalized == 0, 'Require !finalized');\n    _finalized = 1;\n    emit Finalized();\n    return 1;\n}\n\nfunction buyPriceEth() public nonPayable { \n    return _buyPriceEth;\n}\n\nfunction setOpsAddress(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    require(_owner != varg0, 'Require newOpsAddress != owner');\n    require(this != varg0, 'Require newOpsAddress != address(this)');\n    _opsAddress = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction opsAddress() public nonPayable { \n    return _opsAddress;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction halts() public nonPayable { \n    assert(_halts <= 1);\n    return _halts;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(_halts <= 1);\n    require(_halts == 0, 'Require smart contract is not in halted state');\n    require(varg1 >= _pBTTForGas, 'Token amount is not enough to transfer');\n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    v2 = v3 = !v0;\n    if (v3) {\n        v2 = this == varg0;\n    }\n    if (!v2) {\n        v4 = msg.sender == _owner;\n        if (msg.sender != _owner) {\n            v4 = v5 = 0x1a4f(msg.sender);\n        }\n        if (!v4) {\n            0x1f7e(varg0, msg.sender);\n            v6 = v7 = varg1 <= _balanceOf[msg.sender];\n            if (varg1 <= _balanceOf[msg.sender]) {\n                v6 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n            }\n            if (!v6) {\n                v8 = v9 = 0;\n            } else {\n                require(_balanceOf[msg.sender] >= varg1, 'Require a >= b');\n                _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n                v10 = _SafeAdd(varg1, _balanceOf[varg0]);\n                _balanceOf[varg0] = v10;\n                emit Transfer(msg.sender, varg0, varg1);\n                v8 = v11 = 1;\n            }\n            goto 0x1586B0x6a6;\n        } else {\n            v8 = v12 = 0x1bd2(varg1, varg0, _owner);\n        }\n    } else {\n        require(_sellPriceEth > 0, 'sellPriceEth must be > 0');\n        require(varg1 >= _pBTTForGas, 'Sell token amount must be larger than PBTTForGas value');\n        require(varg1 <= _balanceOf[msg.sender], 'Token balance is not enough to sold');\n        require(msg.sender.balance >= _minBalanceForAccounts, 'Seller balance must be enough to pay the transaction fee');\n        assert(1000);\n        v13 = 0x1a7c(_sellPriceEth, varg1);\n        require(this.balance >= v13, 'Require a >= b');\n        require(this.balance - v13 >= _gasReserve, 'Remaining contract balance is not enough for reserved');\n        v14 = _SafeAdd(varg1, _balanceOf[_owner]);\n        _balanceOf[_owner] = v14;\n        require(_balanceOf[msg.sender] >= varg1, 'Require a >= b');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v15 = msg.sender.call().value(v13).gas(2300 * !v13);\n        require(v15); // checks call status, propagates error data on error\n        emit Transfer(msg.sender, _owner, varg1);\n        v8 = v16 = 1;\n    }\n    return v8;\n}\n\nfunction isOwnerOrOps(address varg0) public nonPayable { \n    v0 = varg0 == _owner;\n    if (varg0 != _owner) {\n        v0 = v1 = 0x1a4f(varg0);\n    }\n    return v0;\n}\n\nfunction finalized() public nonPayable { \n    assert(_finalized <= 1);\n    return _finalized;\n}\n\nfunction totalTokenSold() public nonPayable { \n    return _totalTokenSold;\n}\n\nfunction initiateOwnershipTransfer(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    require(varg0, 'Require proposedOwner != address(0)');\n    require(this != varg0, 'Require proposedOwner != address(this)');\n    require(_owner != varg0, 'Require proposedOwner != owner');\n    _proposedOwner = varg0;\n    return 1;\n}\n\nfunction haltsTrades() public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _halts = 1;\n    return 1;\n}\n\nfunction withdrawFundToAddress(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    v0 = varg0.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _minBalanceForAccounts = varg0;\n}\n\nfunction proposedOwner() public nonPayable { \n    return _proposedOwner;\n}\n\nfunction getTokenRemaining() public nonPayable { \n    assert(1000);\n    require(0x3b9aca00 >= _totalTokenSold, 'Require a >= b');\n    return 0x3b9aca00 - _totalTokenSold;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction completeOwnershipTransfer() public nonPayable { \n    require(msg.sender == _proposedOwner, 'Require msg.sender == proposedOwner');\n    _owner = msg.sender;\n    _proposedOwner = 0;\n    return 1;\n}\n\nfunction gasReserve() public nonPayable { \n    return _gasReserve;\n}\n\nfunction isOps(address varg0) public nonPayable { \n    v0 = 0x1a4f(varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x15129a1) {\n            sellPriceEth();\n        } else if (0x2259b07 == function_selector) {\n            setPBTTForGas(uint256);\n        } else if (0x615f7c3 == function_selector) {\n            setGasForPBTT(uint256);\n        } else if (0x6a86539 == function_selector) {\n            PBTTForGas();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xd5260e7 == function_selector) {\n            setGasReserve(uint256);\n        } else if (0x1609a397 == function_selector) {\n            unhaltsTrades();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x28effe67 == function_selector) {\n            gasForPBTT();\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x39909f0b == function_selector) {\n            withdrawFundToOwner();\n        } else if (0x3c54caa5 == function_selector) {\n            reclaimTokens();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x47f1d8d7 == function_selector) {\n            minBalanceForAccounts();\n        } else if (0x4b6a3334 == function_selector) {\n            setEtherPrices(uint256,uint256);\n        } else if (0x4bb278f3 == function_selector) {\n            finalize();\n        } else if (0x5639bb3c == function_selector) {\n            buyPriceEth();\n        } else if (0x707789c5 == function_selector) {\n            setOpsAddress(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8ea64376 == function_selector) {\n            opsAddress();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa5a899ec == function_selector) {\n            halts();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xadcf59ee == function_selector) {\n            isOwnerOrOps(address);\n        } else if (0xb3f05b97 == function_selector) {\n            finalized();\n        } else if (0xb5f7f636 == function_selector) {\n            totalTokenSold();\n        } else if (0xc0b6f561 == function_selector) {\n            initiateOwnershipTransfer(address);\n        } else if (0xc2775347 == function_selector) {\n            haltsTrades();\n        } else if (0xc729a567 == function_selector) {\n            withdrawFundToAddress(address);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xd153b60c == function_selector) {\n            proposedOwner();\n        } else if (0xd1786610 == function_selector) {\n            getTokenRemaining();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe71a7811 == function_selector) {\n            completeOwnershipTransfer();\n        } else if (0xeea7570e == function_selector) {\n            gasReserve();\n        } else if (0xef326c6d == function_selector) {\n            isOps(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 02:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _buyPriceEth; // STORAGE[0x9]\nuint256 _sellPriceEth; // STORAGE[0xa]\nuint256 _gasForPBTT; // STORAGE[0xb]\nuint256 _pBTTForGas; // STORAGE[0xc]\nuint256 _gasReserve; // STORAGE[0xd]\nuint256 _minBalanceForAccounts; // STORAGE[0xe]\nuint256 _totalTokenSold; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\nuint8 _halts; // STORAGE[0x10] bytes 0 to 0\naddress _owner; // STORAGE[0x6] bytes 0 to 19\naddress _proposedOwner; // STORAGE[0x7] bytes 0 to 19\naddress _opsAddress; // STORAGE[0x8] bytes 0 to 19\nuint8 _finalized; // STORAGE[0x8] bytes 20 to 20\n\n// Events\nApproval(address, address, uint256);\nFinalized();\nTransfer(address, address, uint256);\n\nfunction 0x1a4f(uint256 varg0) private { \n    if (!_opsAddress) {\n        return stor_8_0_0;\n    } else {\n        return address(varg0) == _opsAddress;\n    }\n}\n\nfunction 0x1a7c(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'Require r / a == b');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, 'Require r >= a');\n    return v0;\n}\n\nfunction 0x1bd2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    0x1f7e(varg1, msg.sender);\n    v0 = address(varg2);\n    v1 = varg0 > _balanceOf[v0];\n    v2 = v3 = varg0 <= _balanceOf[v0];\n    if (varg0 <= _balanceOf[v0]) {\n        v4 = address(varg2);\n        v2 = v5 = varg0 <= _allowance[msg.sender];\n    }\n    if (v2) {\n        v6 = address(varg1);\n        v2 = _balanceOf[v6] + varg0 > _balanceOf[v6];\n    }\n    if (!v2) {\n        v7 = v8 = 0;\n    } else {\n        v9 = address(varg2);\n        require(_balanceOf[v9] >= varg0, 'Require a >= b');\n        v10 = address(varg2);\n        _balanceOf[v10] = _balanceOf[v9] - varg0;\n        require(_balanceOf[msg.sender] >= varg0, 'Require a >= b');\n        v11 = address(varg2);\n        _allowance[msg.sender] = _balanceOf[msg.sender] - varg0;\n        v12 = address(varg1);\n        v13 = _SafeAdd(varg0, _balanceOf[v12]);\n        v14 = address(varg1);\n        _balanceOf[v14] = v13;\n        emit Transfer(address(varg2), v14, varg0);\n        v7 = v15 = 1;\n    }\n    return v7;\n}\n\nfunction fallback() public payable { \n    if (msg.sender != _owner) {\n        assert(_finalized <= 1);\n        require(_finalized == 1, 'Require smart contract is finalized');\n        assert(_halts <= 1);\n        require(_halts == 0, 'Require smart contract is not halted', 'Require smart contract is not halted');\n        require(_buyPriceEth > 0, 'buyPriceEth must be > 0');\n        require(msg.value >= _buyPriceEth, 'Transfer money must be enough for 1 token');\n        v0 = 0x1a7c(1000, msg.value);\n        assert(_buyPriceEth);\n        require(v0 / _buyPriceEth <= _balanceOf[_owner], 'Not enough token balance');\n        v1 = _SafeAdd(v0 / _buyPriceEth, _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = v1;\n        require(_balanceOf[_owner] >= v0 / _buyPriceEth, 'Require a >= b');\n        _balanceOf[_owner] = _balanceOf[_owner] - v0 / _buyPriceEth;\n        emit Transfer(_owner, msg.sender, v0 / _buyPriceEth);\n        _totalTokenSold += v0 / _buyPriceEth;\n    }\n}\n\nfunction 0x1f7e(uint256 varg0, uint256 varg1) private { \n    assert(_finalized <= 1);\n    if (_finalized != 1) {\n        if (address(varg0) != _owner) {\n            v0 = address(varg1) == _owner;\n            if (address(varg1) != _owner) {\n                v0 = v1 = 0x1a4f(varg1);\n            }\n            require(v0, 'Require is owner or ops allowed to initiate transfer');\n        }\n    }\n    return ;\n}\n\nfunction sellPriceEth() public nonPayable { \n    return _sellPriceEth;\n}\n\nfunction setPBTTForGas(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _pBTTForGas = varg0;\n}\n\nfunction setGasForPBTT(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _gasForPBTT = varg0;\n}\n\nfunction PBTTForGas() public nonPayable { \n    return _pBTTForGas;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setGasReserve(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _gasReserve = varg0;\n}\n\nfunction unhaltsTrades() public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _halts = 0;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(_halts <= 1);\n    require(_halts == 0, 'Require smart contract is not in halted state');\n    v0 = 0x1bd2(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction gasForPBTT() public nonPayable { \n    return _gasForPBTT;\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return varg0 == _owner;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawFundToOwner() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    v0 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction reclaimTokens() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    if (_balanceOf[address(this)]) {\n        require(_balanceOf[address(this)] >= _balanceOf[address(this)], 'Require a >= b');\n        _balanceOf[address(this)] = _balanceOf[address(this)] - _balanceOf[address(this)];\n        v0 = _SafeAdd(_balanceOf[address(this)], _balanceOf[_owner]);\n        _balanceOf[_owner] = v0;\n        v1 = 1;\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 > 0, 'Token amount to burn must be larger than 0');\n    require(varg0 <= _balanceOf[msg.sender], 'You cannot burn token you dont have');\n    require(_balanceOf[msg.sender] >= varg0, 'Require a >= b');\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    require(_totalSupply >= varg0, 'Require a >= b');\n    _totalSupply = _totalSupply - varg0;\n    return 1;\n}\n\nfunction minBalanceForAccounts() public nonPayable { \n    return _minBalanceForAccounts;\n}\n\nfunction setEtherPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _buyPriceEth = varg0;\n    _sellPriceEth = varg1;\n}\n\nfunction finalize() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    assert(_finalized <= 1);\n    require(_finalized == 0, 'Require !finalized');\n    _finalized = 1;\n    emit Finalized();\n    return 1;\n}\n\nfunction buyPriceEth() public nonPayable { \n    return _buyPriceEth;\n}\n\nfunction setOpsAddress(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    require(_owner != varg0, 'Require newOpsAddress != owner');\n    require(this != varg0, 'Require newOpsAddress != address(this)');\n    _opsAddress = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction opsAddress() public nonPayable { \n    return _opsAddress;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction halts() public nonPayable { \n    assert(_halts <= 1);\n    return _halts;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(_halts <= 1);\n    require(_halts == 0, 'Require smart contract is not in halted state');\n    require(varg1 >= _pBTTForGas, 'Token amount is not enough to transfer');\n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    v2 = v3 = !v0;\n    if (v3) {\n        v2 = this == varg0;\n    }\n    if (!v2) {\n        v4 = msg.sender == _owner;\n        if (msg.sender != _owner) {\n            v4 = v5 = 0x1a4f(msg.sender);\n        }\n        if (!v4) {\n            0x1f7e(varg0, msg.sender);\n            v6 = v7 = varg1 <= _balanceOf[msg.sender];\n            if (varg1 <= _balanceOf[msg.sender]) {\n                v6 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n            }\n            if (!v6) {\n                v8 = v9 = 0;\n            } else {\n                require(_balanceOf[msg.sender] >= varg1, 'Require a >= b');\n                _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n                v10 = _SafeAdd(varg1, _balanceOf[varg0]);\n                _balanceOf[varg0] = v10;\n                emit Transfer(msg.sender, varg0, varg1);\n                v8 = v11 = 1;\n            }\n            goto 0x1586B0x6a6;\n        } else {\n            v8 = v12 = 0x1bd2(varg1, varg0, _owner);\n        }\n    } else {\n        require(_sellPriceEth > 0, 'sellPriceEth must be > 0');\n        require(varg1 >= _pBTTForGas, 'Sell token amount must be larger than PBTTForGas value');\n        require(varg1 <= _balanceOf[msg.sender], 'Token balance is not enough to sold');\n        require(msg.sender.balance >= _minBalanceForAccounts, 'Seller balance must be enough to pay the transaction fee');\n        assert(1000);\n        v13 = 0x1a7c(_sellPriceEth, varg1);\n        require(this.balance >= v13, 'Require a >= b');\n        require(this.balance - v13 >= _gasReserve, 'Remaining contract balance is not enough for reserved');\n        v14 = _SafeAdd(varg1, _balanceOf[_owner]);\n        _balanceOf[_owner] = v14;\n        require(_balanceOf[msg.sender] >= varg1, 'Require a >= b');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v15 = msg.sender.call().value(v13).gas(2300 * !v13);\n        require(v15); // checks call status, propagates error data on error\n        emit Transfer(msg.sender, _owner, varg1);\n        v8 = v16 = 1;\n    }\n    return v8;\n}\n\nfunction isOwnerOrOps(address varg0) public nonPayable { \n    v0 = varg0 == _owner;\n    if (varg0 != _owner) {\n        v0 = v1 = 0x1a4f(varg0);\n    }\n    return v0;\n}\n\nfunction finalized() public nonPayable { \n    assert(_finalized <= 1);\n    return _finalized;\n}\n\nfunction totalTokenSold() public nonPayable { \n    return _totalTokenSold;\n}\n\nfunction initiateOwnershipTransfer(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    require(varg0, 'Require proposedOwner != address(0)');\n    require(this != varg0, 'Require proposedOwner != address(this)');\n    require(_owner != varg0, 'Require proposedOwner != owner');\n    _proposedOwner = varg0;\n    return 1;\n}\n\nfunction haltsTrades() public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _halts = 1;\n    return 1;\n}\n\nfunction withdrawFundToAddress(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    v0 = varg0.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _minBalanceForAccounts = varg0;\n}\n\nfunction proposedOwner() public nonPayable { \n    return _proposedOwner;\n}\n\nfunction getTokenRemaining() public nonPayable { \n    assert(1000);\n    require(0x3b9aca00 >= _totalTokenSold, 'Require a >= b');\n    return 0x3b9aca00 - _totalTokenSold;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction completeOwnershipTransfer() public nonPayable { \n    require(msg.sender == _proposedOwner, 'Require msg.sender == proposedOwner');\n    _owner = msg.sender;\n    _proposedOwner = 0;\n    return 1;\n}\n\nfunction gasReserve() public nonPayable { \n    return _gasReserve;\n}\n\nfunction isOps(address varg0) public nonPayable { \n    v0 = 0x1a4f(varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x15129a1) {\n            sellPriceEth();\n        } else if (0x2259b07 == function_selector) {\n            setPBTTForGas(uint256);\n        } else if (0x615f7c3 == function_selector) {\n            setGasForPBTT(uint256);\n        } else if (0x6a86539 == function_selector) {\n            PBTTForGas();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xd5260e7 == function_selector) {\n            setGasReserve(uint256);\n        } else if (0x1609a397 == function_selector) {\n            unhaltsTrades();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x28effe67 == function_selector) {\n            gasForPBTT();\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x39909f0b == function_selector) {\n            withdrawFundToOwner();\n        } else if (0x3c54caa5 == function_selector) {\n            reclaimTokens();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x47f1d8d7 == function_selector) {\n            minBalanceForAccounts();\n        } else if (0x4b6a3334 == function_selector) {\n            setEtherPrices(uint256,uint256);\n        } else if (0x4bb278f3 == function_selector) {\n            finalize();\n        } else if (0x5639bb3c == function_selector) {\n            buyPriceEth();\n        } else if (0x707789c5 == function_selector) {\n            setOpsAddress(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8ea64376 == function_selector) {\n            opsAddress();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa5a899ec == function_selector) {\n            halts();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xadcf59ee == function_selector) {\n            isOwnerOrOps(address);\n        } else if (0xb3f05b97 == function_selector) {\n            finalized();\n        } else if (0xb5f7f636 == function_selector) {\n            totalTokenSold();\n        } else if (0xc0b6f561 == function_selector) {\n            initiateOwnershipTransfer(address);\n        } else if (0xc2775347 == function_selector) {\n            haltsTrades();\n        } else if (0xc729a567 == function_selector) {\n            withdrawFundToAddress(address);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xd153b60c == function_selector) {\n            proposedOwner();\n        } else if (0xd1786610 == function_selector) {\n            getTokenRemaining();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe71a7811 == function_selector) {\n            completeOwnershipTransfer();\n        } else if (0xeea7570e == function_selector) {\n            gasReserve();\n        } else if (0xef326c6d == function_selector) {\n            isOps(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 02:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x5]\nuint256 _buyPriceEth; // STORAGE[0x9]\nuint256 _sellPriceEth; // STORAGE[0xa]\nuint256 _gasForPBTT; // STORAGE[0xb]\nuint256 _pBTTForGas; // STORAGE[0xc]\nuint256 _gasReserve; // STORAGE[0xd]\nuint256 _minBalanceForAccounts; // STORAGE[0xe]\nuint256 _totalTokenSold; // STORAGE[0xf]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\nuint8 _halts; // STORAGE[0x10] bytes 0 to 0\naddress _owner; // STORAGE[0x6] bytes 0 to 19\naddress _proposedOwner; // STORAGE[0x7] bytes 0 to 19\naddress _opsAddress; // STORAGE[0x8] bytes 0 to 19\nuint8 _finalized; // STORAGE[0x8] bytes 20 to 20\n\n// Events\nApproval(address, address, uint256);\nFinalized();\nTransfer(address, address, uint256);\n\nfunction 0x1a4f(uint256 varg0) private { \n    if (!_opsAddress) {\n        return stor_8_0_0;\n    } else {\n        return address(varg0) == _opsAddress;\n    }\n}\n\nfunction 0x1a7c(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'Require r / a == b');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(v0 >= varg1, 'Require r >= a');\n    return v0;\n}\n\nfunction 0x1bd2(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    0x1f7e(varg1, msg.sender);\n    v0 = address(varg2);\n    v1 = varg0 > _balanceOf[v0];\n    v2 = v3 = varg0 <= _balanceOf[v0];\n    if (varg0 <= _balanceOf[v0]) {\n        v4 = address(varg2);\n        v2 = v5 = varg0 <= _allowance[msg.sender];\n    }\n    if (v2) {\n        v6 = address(varg1);\n        v2 = _balanceOf[v6] + varg0 > _balanceOf[v6];\n    }\n    if (!v2) {\n        v7 = v8 = 0;\n    } else {\n        v9 = address(varg2);\n        require(_balanceOf[v9] >= varg0, 'Require a >= b');\n        v10 = address(varg2);\n        _balanceOf[v10] = _balanceOf[v9] - varg0;\n        require(_balanceOf[msg.sender] >= varg0, 'Require a >= b');\n        v11 = address(varg2);\n        _allowance[msg.sender] = _balanceOf[msg.sender] - varg0;\n        v12 = address(varg1);\n        v13 = _SafeAdd(varg0, _balanceOf[v12]);\n        v14 = address(varg1);\n        _balanceOf[v14] = v13;\n        emit Transfer(address(varg2), v14, varg0);\n        v7 = v15 = 1;\n    }\n    return v7;\n}\n\nfunction fallback() public payable { \n    if (msg.sender != _owner) {\n        assert(_finalized <= 1);\n        require(_finalized == 1, 'Require smart contract is finalized');\n        assert(_halts <= 1);\n        require(_halts == 0, 'Require smart contract is not halted', 'Require smart contract is not halted');\n        require(_buyPriceEth > 0, 'buyPriceEth must be > 0');\n        require(msg.value >= _buyPriceEth, 'Transfer money must be enough for 1 token');\n        v0 = 0x1a7c(1000, msg.value);\n        assert(_buyPriceEth);\n        require(v0 / _buyPriceEth <= _balanceOf[_owner], 'Not enough token balance');\n        v1 = _SafeAdd(v0 / _buyPriceEth, _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] = v1;\n        require(_balanceOf[_owner] >= v0 / _buyPriceEth, 'Require a >= b');\n        _balanceOf[_owner] = _balanceOf[_owner] - v0 / _buyPriceEth;\n        emit Transfer(_owner, msg.sender, v0 / _buyPriceEth);\n        _totalTokenSold += v0 / _buyPriceEth;\n    }\n}\n\nfunction 0x1f7e(uint256 varg0, uint256 varg1) private { \n    assert(_finalized <= 1);\n    if (_finalized != 1) {\n        if (address(varg0) != _owner) {\n            v0 = address(varg1) == _owner;\n            if (address(varg1) != _owner) {\n                v0 = v1 = 0x1a4f(varg1);\n            }\n            require(v0, 'Require is owner or ops allowed to initiate transfer');\n        }\n    }\n    return ;\n}\n\nfunction sellPriceEth() public nonPayable { \n    return _sellPriceEth;\n}\n\nfunction setPBTTForGas(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _pBTTForGas = varg0;\n}\n\nfunction setGasForPBTT(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _gasForPBTT = varg0;\n}\n\nfunction PBTTForGas() public nonPayable { \n    return _pBTTForGas;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(_name.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction setGasReserve(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _gasReserve = varg0;\n}\n\nfunction unhaltsTrades() public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _halts = 0;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    assert(_halts <= 1);\n    require(_halts == 0, 'Require smart contract is not in halted state');\n    v0 = 0x1bd2(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction gasForPBTT() public nonPayable { \n    return _gasForPBTT;\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return varg0 == _owner;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawFundToOwner() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    v0 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction reclaimTokens() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    if (_balanceOf[address(this)]) {\n        require(_balanceOf[address(this)] >= _balanceOf[address(this)], 'Require a >= b');\n        _balanceOf[address(this)] = _balanceOf[address(this)] - _balanceOf[address(this)];\n        v0 = _SafeAdd(_balanceOf[address(this)], _balanceOf[_owner]);\n        _balanceOf[_owner] = v0;\n        v1 = 1;\n    } else {\n        v1 = v2 = 0;\n    }\n    return v1;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 > 0, 'Token amount to burn must be larger than 0');\n    require(varg0 <= _balanceOf[msg.sender], 'You cannot burn token you dont have');\n    require(_balanceOf[msg.sender] >= varg0, 'Require a >= b');\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    require(_totalSupply >= varg0, 'Require a >= b');\n    _totalSupply = _totalSupply - varg0;\n    return 1;\n}\n\nfunction minBalanceForAccounts() public nonPayable { \n    return _minBalanceForAccounts;\n}\n\nfunction setEtherPrices(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _buyPriceEth = varg0;\n    _sellPriceEth = varg1;\n}\n\nfunction finalize() public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    assert(_finalized <= 1);\n    require(_finalized == 0, 'Require !finalized');\n    _finalized = 1;\n    emit Finalized();\n    return 1;\n}\n\nfunction buyPriceEth() public nonPayable { \n    return _buyPriceEth;\n}\n\nfunction setOpsAddress(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    require(_owner != varg0, 'Require newOpsAddress != owner');\n    require(this != varg0, 'Require newOpsAddress != address(this)');\n    _opsAddress = varg0;\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction opsAddress() public nonPayable { \n    return _opsAddress;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(0x1 & _symbol.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction halts() public nonPayable { \n    assert(_halts <= 1);\n    return _halts;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    assert(_halts <= 1);\n    require(_halts == 0, 'Require smart contract is not in halted state');\n    require(varg1 >= _pBTTForGas, 'Token amount is not enough to transfer');\n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    v2 = v3 = !v0;\n    if (v3) {\n        v2 = this == varg0;\n    }\n    if (!v2) {\n        v4 = msg.sender == _owner;\n        if (msg.sender != _owner) {\n            v4 = v5 = 0x1a4f(msg.sender);\n        }\n        if (!v4) {\n            0x1f7e(varg0, msg.sender);\n            v6 = v7 = varg1 <= _balanceOf[msg.sender];\n            if (varg1 <= _balanceOf[msg.sender]) {\n                v6 = _balanceOf[varg0] + varg1 > _balanceOf[varg0];\n            }\n            if (!v6) {\n                v8 = v9 = 0;\n            } else {\n                require(_balanceOf[msg.sender] >= varg1, 'Require a >= b');\n                _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n                v10 = _SafeAdd(varg1, _balanceOf[varg0]);\n                _balanceOf[varg0] = v10;\n                emit Transfer(msg.sender, varg0, varg1);\n                v8 = v11 = 1;\n            }\n            goto 0x1586B0x6a6;\n        } else {\n            v8 = v12 = 0x1bd2(varg1, varg0, _owner);\n        }\n    } else {\n        require(_sellPriceEth > 0, 'sellPriceEth must be > 0');\n        require(varg1 >= _pBTTForGas, 'Sell token amount must be larger than PBTTForGas value');\n        require(varg1 <= _balanceOf[msg.sender], 'Token balance is not enough to sold');\n        require(msg.sender.balance >= _minBalanceForAccounts, 'Seller balance must be enough to pay the transaction fee');\n        assert(1000);\n        v13 = 0x1a7c(_sellPriceEth, varg1);\n        require(this.balance >= v13, 'Require a >= b');\n        require(this.balance - v13 >= _gasReserve, 'Remaining contract balance is not enough for reserved');\n        v14 = _SafeAdd(varg1, _balanceOf[_owner]);\n        _balanceOf[_owner] = v14;\n        require(_balanceOf[msg.sender] >= varg1, 'Require a >= b');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        v15 = msg.sender.call().value(v13).gas(2300 * !v13);\n        require(v15); // checks call status, propagates error data on error\n        emit Transfer(msg.sender, _owner, varg1);\n        v8 = v16 = 1;\n    }\n    return v8;\n}\n\nfunction isOwnerOrOps(address varg0) public nonPayable { \n    v0 = varg0 == _owner;\n    if (varg0 != _owner) {\n        v0 = v1 = 0x1a4f(varg0);\n    }\n    return v0;\n}\n\nfunction finalized() public nonPayable { \n    assert(_finalized <= 1);\n    return _finalized;\n}\n\nfunction totalTokenSold() public nonPayable { \n    return _totalTokenSold;\n}\n\nfunction initiateOwnershipTransfer(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    require(varg0, 'Require proposedOwner != address(0)');\n    require(this != varg0, 'Require proposedOwner != address(this)');\n    require(_owner != varg0, 'Require proposedOwner != owner');\n    _proposedOwner = varg0;\n    return 1;\n}\n\nfunction haltsTrades() public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _halts = 1;\n    return 1;\n}\n\nfunction withdrawFundToAddress(address varg0) public nonPayable { \n    require(1 == (msg.sender == _owner), 'Require owner to execute transaction', 'Require owner to execute transaction');\n    v0 = varg0.call().value(this.balance).gas(2300 * !this.balance);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction setMinBalance(uint256 varg0) public nonPayable { \n    v0 = msg.sender == _owner;\n    if (msg.sender != _owner) {\n        v0 = v1 = 0x1a4f(msg.sender);\n    }\n    require(v0, 'Require only owner or ops');\n    _minBalanceForAccounts = varg0;\n}\n\nfunction proposedOwner() public nonPayable { \n    return _proposedOwner;\n}\n\nfunction getTokenRemaining() public nonPayable { \n    assert(1000);\n    require(0x3b9aca00 >= _totalTokenSold, 'Require a >= b');\n    return 0x3b9aca00 - _totalTokenSold;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction completeOwnershipTransfer() public nonPayable { \n    require(msg.sender == _proposedOwner, 'Require msg.sender == proposedOwner');\n    _owner = msg.sender;\n    _proposedOwner = 0;\n    return 1;\n}\n\nfunction gasReserve() public nonPayable { \n    return _gasReserve;\n}\n\nfunction isOps(address varg0) public nonPayable { \n    v0 = 0x1a4f(varg0);\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x15129a1) {\n            sellPriceEth();\n        } else if (0x2259b07 == function_selector) {\n            setPBTTForGas(uint256);\n        } else if (0x615f7c3 == function_selector) {\n            setGasForPBTT(uint256);\n        } else if (0x6a86539 == function_selector) {\n            PBTTForGas();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xd5260e7 == function_selector) {\n            setGasReserve(uint256);\n        } else if (0x1609a397 == function_selector) {\n            unhaltsTrades();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x28effe67 == function_selector) {\n            gasForPBTT();\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x39909f0b == function_selector) {\n            withdrawFundToOwner();\n        } else if (0x3c54caa5 == function_selector) {\n            reclaimTokens();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x47f1d8d7 == function_selector) {\n            minBalanceForAccounts();\n        } else if (0x4b6a3334 == function_selector) {\n            setEtherPrices(uint256,uint256);\n        } else if (0x4bb278f3 == function_selector) {\n            finalize();\n        } else if (0x5639bb3c == function_selector) {\n            buyPriceEth();\n        } else if (0x707789c5 == function_selector) {\n            setOpsAddress(address);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8ea64376 == function_selector) {\n            opsAddress();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa5a899ec == function_selector) {\n            halts();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xadcf59ee == function_selector) {\n            isOwnerOrOps(address);\n        } else if (0xb3f05b97 == function_selector) {\n            finalized();\n        } else if (0xb5f7f636 == function_selector) {\n            totalTokenSold();\n        } else if (0xc0b6f561 == function_selector) {\n            initiateOwnershipTransfer(address);\n        } else if (0xc2775347 == function_selector) {\n            haltsTrades();\n        } else if (0xc729a567 == function_selector) {\n            withdrawFundToAddress(address);\n        } else if (0xc91d956c == function_selector) {\n            setMinBalance(uint256);\n        } else if (0xd153b60c == function_selector) {\n            proposedOwner();\n        } else if (0xd1786610 == function_selector) {\n            getTokenRemaining();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xe71a7811 == function_selector) {\n            completeOwnershipTransfer();\n        } else if (0xeea7570e == function_selector) {\n            gasReserve();\n        } else if (0xef326c6d == function_selector) {\n            isOps(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 34.16151475906372,
	"usage": {
		"completion_tokens": 542,
		"prompt_tokens": 5703,
		"total_tokens": 6245
	}
}