{
	"address": "0xa9375923ddb69cd32955f536a351007415c02696",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  owner is address at storage 0\n  orderCount is uint256 at storage 1\n  fee is uint256 at storage 2\n  lockedFees is uint256 at storage 3\n  totalFees is uint256 at storage 4\n  feeBalances is mapping of uint256 at storage 5\n  addressRegistry is array of address at storage 6\n  addressIndex is mapping of uint256 at storage 7\n  stor8 is mapping of struct at storage 8\n  stor9 is array of uint256 at storage 9\n  poolOwners is address at storage 10\n  feeTokenAddress is address at storage 11\n\ndef totalFees(): # not payable\n  return totalFees\n\ndef getOrderBookSize(): # not payable\n  return stor9.length\n\ndef orderCount(): # not payable\n  return orderCount\n\ndef lockedFees(): # not payable\n  return lockedFees\n\ndef feeToken(): # not payable\n  return feeTokenAddress\n\ndef owner(): # not payable\n  return owner\n\ndef addressIndex(address _param1): # not payable\n  return addressIndex[_param1]\n\ndef feeBalances(uint256 _param1): # not payable\n  return feeBalances[_param1]\n\ndef poolOwners(): # not payable\n  return poolOwners\n\ndef fee(): # not payable\n  return fee\n\ndef addressRegistry(uint256 _param1): # not payable\n  require _param1 < addressRegistry.length\n  return addressRegistry[_param1]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef getOrderBookKey(uint256 _i): # not payable\n  if _i >= stor9.length:\n      return 0\n  return stor9[_i]\n\ndef setFee(uint256 _fee): # not payable\n  if owner != caller:\n      revert with 0, 'Sender not authorised'\n  if _fee > 5 * 10^17:\n      revert with 0, 'Fees can't be more than 50%'\n  fee = _fee\n\ndef transferOwnership(address newOwner): # not payable\n  if owner != caller:\n      revert with 0, 'Sender not authorised'\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef costOfOrder(uint256 _price, uint256 _amount): # not payable\n  if not _price:\n      return (_amount * _price / 10^18)\n  require _price\n  require _amount * _price / _price == _amount\n  return (_amount * _price / 10^18)\n\ndef getOrder(uint256 orderId): # not payable\n  require stor8[orderId].field_510 <= 2\n  require stor8[orderId].field_478 < addressRegistry.length\n  require stor8[orderId].field_510 <= 2\n  return stor8[orderId].field_256, addressRegistry[stor8[orderId].field_478], stor8[orderId].field_256, 0\n\ndef getOrderBookKeys(uint256 _start): # not payable\n  mem[96 len 320] = code.data[10006 len 320]\n  idx = 0\n  while idx < 10:\n      if idx + _start >= stor9.length:\n          require idx < 10\n          mem[(32 * idx) + 96] = 0\n      else:\n          mem[0] = 9\n          require idx < 10\n          mem[(32 * idx) + 96] = stor[('name', 'stor9', 9) + idx + _start]\n      idx = idx + 1\n      continue \n  return memory\n    from 96\n     len 320\n\ndef withdrawDistributedToPoolOwners(): # not payable\n  require ext_code.size(feeTokenAddress)\n  call feeTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n  require totalFees <= ext_call.return_data[0]\n  if ext_call.return_data[0] - totalFees <= 0:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  'There is no distributed fee token balance in the contract'\n  require ext_code.size(feeTokenAddress)\n  call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args poolOwners, ext_call.return_data[0] - totalFees\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n\ndef feeForOrder(uint256 _price, uint256 _amount): # not payable\n  if not _price:\n      if not _amount * _price / 10^18:\n          return (fee * _amount * _price / 10^18 / 10^18)\n      if _amount * _price / 10^18:\n          if fee * _amount * _price / 10^18 / _amount * _price / 10^18 == fee:\n              return (fee * _amount * _price / 10^18 / 10^18)\n  else:\n      if _price:\n          if _amount * _price / _price == _amount:\n              if not _amount * _price / 10^18:\n                  return (fee * _amount * _price / 10^18 / 10^18)\n              if _amount * _price / 10^18:\n                  if fee * _amount * _price / 10^18 / _amount * _price / 10^18 == fee:\n                      return (fee * _amount * _price / 10^18 / 10^18)\n  revert\n\ndef onTokenTransfer(address _param1, uint256 _param2, bytes _data): # not payable\n  if feeTokenAddress != caller:\n      revert with 0, 'Sender needs to be the fee token'\n  if addressIndex[address(_param1)]:\n      require _param2 + feeBalances[stor7[address(_param1)]] >= feeBalances[stor7[address(_param1)]]\n      feeBalances[stor7[address(_param1)]] += _param2\n  else:\n      if unknown10000000() <= addressRegistry.length:\n          revert with 0, 'Registered addresses hit maximum'\n      addressIndex[address(_param1)] = addressRegistry.length\n      addressRegistry.length++\n      addressRegistry[addressRegistry.length] = _param1\n      require _param2 + feeBalances[stor6.length - 1] >= feeBalances[stor6.length - 1]\n      feeBalances[stor6.length - 1] += _param2\n  require _param2 + totalFees >= totalFees\n  totalFees += _param2\n\ndef withdrawFeeToken(uint256 _value): # not payable\n  if addressIndex[caller]:\n      if _value > feeBalances[stor7[caller]]:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You're withdrawing more than your balance'\n      require _value <= feeBalances[stor7[caller]]\n      feeBalances[stor7[caller]] -= _value\n      require _value <= totalFees\n      totalFees -= _value\n      if not feeBalances[stor7[caller]]:\n          feeBalances[stor7[caller]] = 0\n  else:\n      if unknown10000000() <= addressRegistry.length:\n          revert with 0, 'Registered addresses hit maximum'\n      addressIndex[caller] = addressRegistry.length\n      addressRegistry.length++\n      addressRegistry[addressRegistry.length] = caller\n      if _value > feeBalances[stor6.length - 1]:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You're withdrawing more than your balance'\n      require _value <= feeBalances[stor6.length - 1]\n      feeBalances[stor6.length - 1] -= _value\n      require _value <= totalFees\n      totalFees -= _value\n      if not feeBalances[stor6.length - 1]:\n          feeBalances[stor6.length - 1] = 0\n  require ext_code.size(feeTokenAddress)\n  call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args caller, _value\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >= 32\n\ndef removeSellOrder(uint256 _key): # not payable\n  require stor8[_key].field_510 <= 2\n  if stor8[_key].field_510 != 2:\n      revert with 0, 'This is not a sell order'\n  if addressIndex[caller] != stor8[_key].field_478:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You are not the sender of this order'\n  if not stor8[_key].field_0:\n      revert with 0, 'dMap remove failed'\n  if stor8[_key].field_0 < stor9.length:\n      require stor9.length - 1 < stor9.length\n      stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n      require stor8[_key].field_0 - 1 < stor9.length\n      stor9[stor8[_key].field_0] = stor9[stor9.length]\n  stor9.length--\n  if stor9.length > stor9.length - 1:\n      idx = stor9.length - 1\n      while stor9.length > idx:\n          stor9[idx] = 0\n          idx = idx + 1\n          continue \n  stor8[_key].field_0 = 0\n  stor8[_key].field_256 = 0\n  if stor8[_key].field_367:\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n  if fee * 0 / 10^18 / 10^18 > 0:\n      require (fee * 0 / 10^18 / 10^18) + feeBalances[stor7[caller]] >= feeBalances[stor7[caller]]\n      feeBalances[stor7[caller]] += fee * 0 / 10^18 / 10^18\n  require ext_code.size(poolOwners)\n  call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n       gas gas_remaining wei\n      args caller, 0\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require stor8[_key].field_510 <= 2\n  log OrderRemoved(\n        uint8 orderType=stor8[_key].field_256,\n        address sender=0,\n        uint256 price=stor8[_key].field_510,\n        uint256 amount=caller)\n\ndef removeBuyOrder(uint256 _key): # not payable\n  require stor8[_key].field_510 <= 2\n  if stor8[_key].field_510 != 1:\n      revert with 0, 'This is not a buy order'\n  if addressIndex[caller] != stor8[_key].field_478:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You are not the sender of this order'\n  if not stor8[_key].field_0:\n      revert with 0, 'dMap remove failed'\n  if stor8[_key].field_0 < stor9.length:\n      require stor9.length - 1 < stor9.length\n      stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n      require stor8[_key].field_0 - 1 < stor9.length\n      stor9[stor8[_key].field_0] = stor9[stor9.length]\n  stor9.length--\n  if stor9.length > stor9.length - 1:\n      idx = stor9.length - 1\n      while stor9.length > idx:\n          stor9[idx] = 0\n          idx = idx + 1\n          continue \n  stor8[_key].field_0 = 0\n  stor8[_key].field_256 = 0\n  if stor8[_key].field_367:\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n  if fee * 0 / 10^18 / 10^18 > 0:\n      require (fee * 0 / 10^18 / 10^18) + feeBalances[stor7[caller]] >= feeBalances[stor7[caller]]\n      feeBalances[stor7[caller]] += fee * 0 / 10^18 / 10^18\n  if stor8[_key].field_367:\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n  call caller with:\n     value 0 / 10^18 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require stor8[_key].field_510 <= 2\n  log OrderRemoved(\n        uint8 orderType=stor8[_key].field_256,\n        address sender=0,\n        uint256 price=stor8[_key].field_510,\n        uint256 amount=caller)\n\ndef getOrders(uint256 _start): # not payable\n  mem[96 len 320] = code.data[10006 len 320]\n  mem[416 len 320] = code.data[10006 len 320]\n  mem[736 len 320] = code.data[10006 len 320]\n  mem[1056 len 320] = code.data[10006 len 320]\n  mem[64] = 1696\n  mem[1376 len 320] = code.data[10006 len 320]\n  s = 0\n  t = 0\n  idx = 0\n  while idx < 10:\n      if stor9.length == _start + idx:\n          idx = 0\n          while idx < 320:\n              mem[idx + 1696] = mem[idx + 96]\n              idx = idx + 32\n              continue \n          idx = 0\n          while idx < 320:\n              mem[idx + 2016] = mem[idx + 416]\n              idx = idx + 32\n              continue \n          idx = 0\n          while idx < 320:\n              mem[idx + 2336] = mem[idx + 736]\n              idx = idx + 32\n              continue \n          idx = 0\n          while idx < 320:\n              mem[idx + 2656] = mem[idx + 1056]\n              idx = idx + 32\n              continue \n          idx = 0\n          while idx < 320:\n              mem[idx + 2976] = mem[idx + 1376]\n              idx = idx + 32\n              continue \n          return memory\n            from 1696\n             len 1600\n      require idx + _start < stor9.length\n      require idx < 10\n      mem[(32 * idx) + 96] = stor[('name', 'stor9', 9) + idx + _start]\n      mem[32] = 8\n      require stor8[stor[('name', 'stor9', 9) + idx + _start]].field_478 < addressRegistry.length\n      mem[0] = 6\n      require idx < 10\n      mem[(32 * idx) + 416] = addressRegistry[stor8[stor[('name', 'stor9', 9) + idx + _start]].field_478]\n      require stor8[stor[('name', 'stor9', 9) + idx + _start]].field_510 <= 2\n      require idx < 10\n      require stor8[stor[('name', 'stor9', 9) + idx + _start]].field_510 <= 2\n      mem[(32 * idx) + 736] = stor8[stor[('name', 'stor9', 9) + idx + _start]].field_510\n      require idx < 10\n      mem[(32 * idx) + 1056] = stor8[stor[('name', 'stor9', 9) + idx + _start]].field_367\n      mem[(32 * idx) + 1376] = 0\n      s = stor8[stor[('name', 'stor9', 9) + idx + _start]].field_256\n      t = stor[('name', 'stor9', 9) + idx + _start]\n      idx = idx + 1\n      continue \n  return mem[96 len 320], mem[416 len 320], mem[736 len 320], mem[1056 len 320], mem[1376 len 320]\n\ndef addSellOrder(uint256 _price, uint256 _amount): # not payable\n  if 0x8000000000000000000000000000 <= _price:\n      revert with 0, 'Price or amount exceeds 111 bits'\n  if 0x8000000000000000000000000000 <= _amount:\n      revert with 0, 'Price or amount exceeds 111 bits'\n  if _price <= 0:\n      revert with 0, 'Price needs to be greater than 0'\n  if _amount <= 0:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount needs to be greater than 0'\n  if _price:\n      require _price\n      require _amount * _price / _price == _amount\n  if _amount * _price / 10^18:\n      require _amount * _price / 10^18\n      require fee * _amount * _price / 10^18 / _amount * _price / 10^18 == fee\n  if addressIndex[caller]:\n      if fee * _amount * _price / 10^18 / 10^18 > 0:\n          if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n          require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n          feeBalances[stor7[caller]] -= fee * _amount * _price / 10^18 / 10^18\n  else:\n      if unknown10000000() <= addressRegistry.length:\n          revert with 0, 'Registered addresses hit maximum'\n      addressIndex[caller] = addressRegistry.length\n      addressRegistry.length++\n      addressRegistry[addressRegistry.length] = caller\n      if fee * _amount * _price / 10^18 / 10^18 > 0:\n          if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n          require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n          feeBalances[stor6.length - 1] -= fee * _amount * _price / 10^18 / 10^18\n  require ext_code.size(poolOwners)\n  call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n       gas gas_remaining wei\n      args caller, this.address, _amount\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  stor8[stor1].field_256 = Mask(145, 0, _price)\n  stor8[stor1].field_401 = 0\n  if 0 < stor8[stor1].field_0:\n      revert with 0, 'Map replacement detected'\n  stor9.length++\n  if stor9.length > stor9.length + 1:\n      idx = stor9.length + 1\n      while stor9.length > idx:\n          stor9[idx] = 0\n          idx = idx + 1\n          continue \n  stor8[stor1].field_0 = stor9.length + 1\n  require stor9.length < stor9.length\n  stor9[stor9.length] = orderCount\n  orderCount++\n  log NewOrder(\n        uint8 orderType=_price,\n        address sender=_amount,\n        uint256 price=2,\n        uint256 amount=caller)\n\ndef fillBuyOrder(uint256 _key): # not payable\n  require stor8[_key].field_510 <= 2\n  if stor8[_key].field_510 != 1:\n      revert with 0, 'This is not a buy order'\n  if addressIndex[caller]:\n      if addressIndex[caller] == stor8[_key].field_478:\n          revert with 0, 'You cannot fill your own order'\n      if not stor8[_key].field_367:\n          if fee * 0 / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          'You do not have enough deposite fees to fill this order'\n          if stor8[_key].field_367:\n              require stor8[_key].field_367\n              require not 0 / stor8[_key].field_367\n          if not stor8[_key].field_0:\n              revert with 0, 'dMap remove failed'\n          if stor8[_key].field_0 < stor9.length:\n              require stor9.length - 1 < stor9.length\n              stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n              require stor8[_key].field_0 - 1 < stor9.length\n              stor9[stor8[_key].field_0] = stor9[stor9.length]\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          call caller with:\n             value 0 / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require stor8[_key].field_478 < addressRegistry.length\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, addressRegistry[stor8[_key].field_478], 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n              feeBalances[stor7[caller]] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n      if fee * 0 / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      'You do not have enough deposite fees to fill this order'\n      if not stor8[_key].field_367:\n          if not stor8[_key].field_0:\n              revert with 0, 'dMap remove failed'\n          if stor8[_key].field_0 < stor9.length:\n              require stor9.length - 1 < stor9.length\n              stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n              require stor8[_key].field_0 - 1 < stor9.length\n              stor9[stor8[_key].field_0] = stor9[stor9.length]\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          call caller with:\n             value 0 / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require stor8[_key].field_478 < addressRegistry.length\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, addressRegistry[stor8[_key].field_478], 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n              feeBalances[stor7[caller]] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n      if not stor8[_key].field_0:\n          revert with 0, 'dMap remove failed'\n      if stor8[_key].field_0 >= stor9.length:\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          call caller with:\n             value 0 / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require stor8[_key].field_478 < addressRegistry.length\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, addressRegistry[stor8[_key].field_478], 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n              feeBalances[stor7[caller]] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor9.length - 1 < stor9.length\n      stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n      require stor8[_key].field_0 - 1 < stor9.length\n      stor9[stor8[_key].field_0] = stor9[stor9.length]\n      stor9.length--\n      if stor9.length <= stor9.length - 1:\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          call caller with:\n             value 0 / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require stor8[_key].field_478 < addressRegistry.length\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, addressRegistry[stor8[_key].field_478], 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 <= 0:\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n              stop\n          require fee * 0 / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n          feeBalances[stor7[caller]] -= fee * 0 / 10^18 / 10^18\n          if not fee * 0 / 10^18 / 10^18:\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n              stop\n          require fee * 0 / 10^18 / 10^18\n          require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n          require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n          totalFees -= 2 * fee * 0 / 10^18 / 10^18\n          require ext_code.size(feeTokenAddress)\n          call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining wei\n              args poolOwners, 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n  else:\n      if unknown10000000() <= addressRegistry.length:\n          revert with 0, 'Registered addresses hit maximum'\n      addressIndex[caller] = addressRegistry.length\n      addressRegistry.length++\n      addressRegistry[addressRegistry.length] = caller\n      if addressRegistry.length - 1 == stor8[_key].field_478:\n          revert with 0, 'You cannot fill your own order'\n      if not stor8[_key].field_367:\n          if fee * 0 / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          'You do not have enough deposite fees to fill this order'\n          if stor8[_key].field_367:\n              require stor8[_key].field_367\n              require not 0 / stor8[_key].field_367\n          if not stor8[_key].field_0:\n              revert with 0, 'dMap remove failed'\n          if stor8[_key].field_0 < stor9.length:\n              require stor9.length - 1 < stor9.length\n              stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n              require stor8[_key].field_0 - 1 < stor9.length\n              stor9[stor8[_key].field_0] = stor9[stor9.length]\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          call caller with:\n             value 0 / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require stor8[_key].field_478 < addressRegistry.length\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, addressRegistry[stor8[_key].field_478], 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n              feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n      if fee * 0 / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      'You do not have enough deposite fees to fill this order'\n      if not stor8[_key].field_367:\n          if not stor8[_key].field_0:\n              revert with 0, 'dMap remove failed'\n          if stor8[_key].field_0 < stor9.length:\n              require stor9.length - 1 < stor9.length\n              stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n              require stor8[_key].field_0 - 1 < stor9.length\n              stor9[stor8[_key].field_0] = stor9[stor9.length]\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          call caller with:\n             value 0 / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require stor8[_key].field_478 < addressRegistry.length\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, addressRegistry[stor8[_key].field_478], 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n              feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n      if not stor8[_key].field_0:\n          revert with 0, 'dMap remove failed'\n      if stor8[_key].field_0 >= stor9.length:\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          call caller with:\n             value 0 / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require stor8[_key].field_478 < addressRegistry.length\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, addressRegistry[stor8[_key].field_478], 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n              feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor9.length - 1 < stor9.length\n      stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n      require stor8[_key].field_0 - 1 < stor9.length\n      stor9[stor8[_key].field_0] = stor9[stor9.length]\n      stor9.length--\n      if stor9.length <= stor9.length - 1:\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          call caller with:\n             value 0 / 10^18 wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require stor8[_key].field_478 < addressRegistry.length\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnershipFrom(address _owner, address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, addressRegistry[stor8[_key].field_478], 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 <= 0:\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n              stop\n          require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n          feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n          if not fee * 0 / 10^18 / 10^18:\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n              stop\n          require fee * 0 / 10^18 / 10^18\n          require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n          require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n          totalFees -= 2 * fee * 0 / 10^18 / 10^18\n          require ext_code.size(feeTokenAddress)\n          call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining wei\n              args poolOwners, 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef fillSellOrder(uint256 _key) payable: \n  require stor8[_key].field_510 <= 2\n  if stor8[_key].field_510 != 2:\n      revert with 0, 'This is not a sell order'\n  if addressIndex[caller]:\n      if addressIndex[caller] == stor8[_key].field_478:\n          revert with 0, 'You cannot fill your own order'\n      if not stor8[_key].field_367:\n          if fee * 0 / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          'You do not have enough deposite fees to fill this order'\n          if stor8[_key].field_367:\n              require stor8[_key].field_367\n              require not 0 / stor8[_key].field_367\n          if 0 / 10^18 != call.value:\n              revert with 0, 'ETH sent needs to equal the cost'\n          if not stor8[_key].field_0:\n              revert with 0, 'dMap remove failed'\n          if stor8[_key].field_0 < stor9.length:\n              require stor9.length - 1 < stor9.length\n              stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n              require stor8[_key].field_0 - 1 < stor9.length\n              stor9[stor8[_key].field_0] = stor9[stor9.length]\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          require stor8[_key].field_478 < addressRegistry.length\n          call addressRegistry[stor8[_key].field_478] with:\n             value call.value wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n              feeBalances[stor7[caller]] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n      if fee * 0 / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      'You do not have enough deposite fees to fill this order'\n      if not stor8[_key].field_367:\n          if 0 / 10^18 != call.value:\n              revert with 0, 'ETH sent needs to equal the cost'\n          if not stor8[_key].field_0:\n              revert with 0, 'dMap remove failed'\n          if stor8[_key].field_0 < stor9.length:\n              require stor9.length - 1 < stor9.length\n              stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n              require stor8[_key].field_0 - 1 < stor9.length\n              stor9[stor8[_key].field_0] = stor9[stor9.length]\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          require stor8[_key].field_478 < addressRegistry.length\n          call addressRegistry[stor8[_key].field_478] with:\n             value call.value wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n              feeBalances[stor7[caller]] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor8[_key].field_367\n      require not 0 / stor8[_key].field_367\n      if 0 / 10^18 != call.value:\n          revert with 0, 'ETH sent needs to equal the cost'\n      if not stor8[_key].field_0:\n          revert with 0, 'dMap remove failed'\n      if stor8[_key].field_0 >= stor9.length:\n          stor9.length--\n          if stor9.length > stor9.length - 1:\n              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          require stor8[_key].field_478 < addressRegistry.length\n          call addressRegistry[stor8[_key].field_478] with:\n             value call.value wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 > 0:\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n              feeBalances[stor7[caller]] -= fee * 0 / 10^18 / 10^18\n              if fee * 0 / 10^18 / 10^18:\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n          require stor8[_key].field_510 <= 2\n          log OrderFilled(\n                uint8 orderType=caller,\n                address sender=stor8[_key].field_256,\n                address receiver=0,\n                uint256 price=stor8[_key].field_510,\n                uint256 amount=addressRegistry[stor8[_key].field_478])\n          stop\n      require stor9.length - 1 < stor9.length\n      stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n      require stor8[_key].field_0 - 1 < stor9.length\n      stor9[stor8[_key].field_0] = stor9[stor9.length]\n      stor9.length--\n      if stor9.length <= stor9.length - 1:\n          stor8[_key].field_0 = 0\n          stor8[_key].field_256 = 0\n          require stor8[_key].field_478 < addressRegistry.length\n          call addressRegistry[stor8[_key].field_478] with:\n             value call.value wei\n               gas 2300 * is_zero(value) wei\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require ext_code.size(poolOwners)\n          call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n               gas gas_remaining wei\n              args caller, 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          if fee * 0 / 10^18 / 10^18 <= 0:\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n              stop\n          require fee * 0 / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n          feeBalances[stor7[caller]] -= fee * 0 / 10^18 / 10^18\n          if not fee * 0 / 10^18 / 10^18:\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n              stop\n          require fee * 0 / 10^18 / 10^18\n          require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n          require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n          totalFees -= 2 * fee * 0 / 10^18 / 10^18\n          require ext_code.size(feeTokenAddress)\n          call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n               gas gas_remaining wei\n              args poolOwners, 0\n          if not ext_call.success:\n              revert with ext_call.return_data[0 len return_data.size]\n          require return_data.size >= 32\n          require stor8[_key].field_478 < addressRegistry.length\n  else:\n      if unknown10000000() <= addressRegistry.length:\n          revert with 0, 'Registered addresses hit maximum'\n      addressIndex[caller] = addressRegistry.length\n      addressRegistry.length++\n      addressRegistry[addressRegistry.length] = caller\n      if addressRegistry.length - 1 == stor8[_key].field_478:\n          revert with 0, 'You cannot fill your own order'\n      if not stor8[_key].field_367:\n          if fee * 0 / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          'You do not have enough deposite fees to fill this order'\n          if not stor8[_key].field_367:\n              if 0 / 10^18 != call.value:\n                  revert with 0, 'ETH sent needs to equal the cost'\n              if not stor8[_key].field_0:\n                  revert with 0, 'dMap remove failed'\n              if stor8[_key].field_0 < stor9.length:\n                  require stor9.length - 1 < stor9.length\n                  stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n                  require stor8[_key].field_0 - 1 < stor9.length\n                  stor9[stor8[_key].field_0] = stor9[stor9.length]\n              stor9.length--\n              if stor9.length > stor9.length - 1:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              stor8[_key].field_0 = 0\n              stor8[_key].field_256 = 0\n              require stor8[_key].field_478 < addressRegistry.length\n              call addressRegistry[stor8[_key].field_478] with:\n                 value call.value wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require ext_code.size(poolOwners)\n              call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n                   gas gas_remaining wei\n                  args caller, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if fee * 0 / 10^18 / 10^18 > 0:\n                  require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                  feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n                  if fee * 0 / 10^18 / 10^18:\n                      require fee * 0 / 10^18 / 10^18\n                      require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n                  require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                  totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                  require ext_code.size(feeTokenAddress)\n                  call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args poolOwners, 0\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n              stop\n          require stor8[_key].field_367\n          require not 0 / stor8[_key].field_367\n          if 0 / 10^18 != call.value:\n              revert with 0, 'ETH sent needs to equal the cost'\n          if not stor8[_key].field_0:\n              revert with 0, 'dMap remove failed'\n          if stor8[_key].field_0 >= stor9.length:\n              stor9.length--\n              if stor9.length > stor9.length - 1:\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n              stor8[_key].field_0 = 0\n              stor8[_key].field_256 = 0\n              require stor8[_key].field_478 < addressRegistry.length\n              call addressRegistry[stor8[_key].field_478] with:\n                 value call.value wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require ext_code.size(poolOwners)\n              call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n                   gas gas_remaining wei\n                  args caller, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if fee * 0 / 10^18 / 10^18 > 0:\n                  require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                  feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n                  if fee * 0 / 10^18 / 10^18:\n                      require fee * 0 / 10^18 / 10^18\n                      require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n                  require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                  totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                  require ext_code.size(feeTokenAddress)\n                  call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args poolOwners, 0\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n              stop\n          require stor9.length - 1 < stor9.length\n          stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n          require stor8[_key].field_0 - 1 < stor9.length\n          stor9[stor8[_key].field_0] = stor9[stor9.length]\n          stor9.length--\n          if stor9.length <= stor9.length - 1:\n              stor8[_key].field_0 = 0\n              stor8[_key].field_256 = 0\n              require stor8[_key].field_478 < addressRegistry.length\n              call addressRegistry[stor8[_key].field_478] with:\n                 value call.value wei\n                   gas 2300 * is_zero(value) wei\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require ext_code.size(poolOwners)\n              call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n                   gas gas_remaining wei\n                  args caller, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              if fee * 0 / 10^18 / 10^18 <= 0:\n                  require stor8[_key].field_478 < addressRegistry.length\n                  require stor8[_key].field_510 <= 2\n                  log OrderFilled(\n                        uint8 orderType=caller,\n                        address sender=stor8[_key].field_256,\n                        address receiver=0,\n                        uint256 price=stor8[_key].field_510,\n                        uint256 amount=addressRegistry[stor8[_key].field_478])\n                  stop\n              require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n              feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n              if not fee * 0 / 10^18 / 10^18:\n                  require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                  totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                  require ext_code.size(feeTokenAddress)\n                  call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args poolOwners, 0\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require stor8[_key].field_478 < addressRegistry.length\n                  require stor8[_key].field_510 <= 2\n                  log OrderFilled(\n                        uint8 orderType=caller,\n                        address sender=stor8[_key].field_256,\n                        address receiver=0,\n                        uint256 price=stor8[_key].field_510,\n                        uint256 amount=addressRegistry[stor8[_key].field_478])\n                  stop\n              require fee * 0 / 10^18 / 10^18\n              require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n              require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n              totalFees -= 2 * fee * 0 / 10^18 / 10^18\n              require ext_code.size(feeTokenAddress)\n              call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                   gas gas_remaining wei\n                  args poolOwners, 0\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >= 32\n              require stor8[_key].field_478 < addressRegistry.length\n              require stor8[_key].field_510 <= 2\n              log OrderFilled(\n                    uint8 orderType=caller,\n                    address sender=stor8[_key].field_256,\n                    address receiver=0,\n                    uint256 price=stor8[_key].field_510,\n                    uint256 amount=addressRegistry[stor8[_key].field_478])\n      else:\n          require stor8[_key].field_367\n          require not 0 / stor8[_key].field_367\n          if fee * 0 / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          'You do not have enough deposite fees to fill this order'\n          if not stor8[_key].field_367:\n              if 0 / 10^18 != call.value:\n                  revert with 0, 'ETH sent needs to equal the cost'\n              if not stor8[_key].field_0:\n                  revert with 0, 'dMap remove failed'\n              if stor8[_key].field_0 >= stor9.length:\n                  stor9.length--\n                  if stor9.length > stor9.length - 1:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  stor8[_key].field_0 = 0\n                  stor8[_key].field_256 = 0\n                  require stor8[_key].field_478 < addressRegistry.length\n                  call addressRegistry[stor8[_key].field_478] with:\n                     value call.value wei\n                       gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require ext_code.size(poolOwners)\n                  call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n                       gas gas_remaining wei\n                      args caller, 0\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  if fee * 0 / 10^18 / 10^18 > 0:\n                      require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                      feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n                      if fee * 0 / 10^18 / 10^18:\n                          require fee * 0 / 10^18 / 10^18\n                          require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n                      require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                      totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                      require ext_code.size(feeTokenAddress)\n                      call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args poolOwners, 0\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                  require stor8[_key].field_478 < addressRegistry.length\n                  require stor8[_key].field_510 <= 2\n                  log OrderFilled(\n                        uint8 orderType=caller,\n                        address sender=stor8[_key].field_256,\n                        address receiver=0,\n                        uint256 price=stor8[_key].field_510,\n                        uint256 amount=addressRegistry[stor8[_key].field_478])\n                  stop\n              require stor9.length - 1 < stor9.length\n              stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n              require stor8[_key].field_0 - 1 < stor9.length\n              stor9[stor8[_key].field_0] = stor9[stor9.length]\n              stor9.length--\n              if stor9.length <= stor9.length - 1:\n                  stor8[_key].field_0 = 0\n                  stor8[_key].field_256 = 0\n                  require stor8[_key].field_478 < addressRegistry.length\n                  call addressRegistry[stor8[_key].field_478] with:\n                     value call.value wei\n                       gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require ext_code.size(poolOwners)\n                  call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n                       gas gas_remaining wei\n                      args caller, 0\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  if fee * 0 / 10^18 / 10^18 <= 0:\n                      require stor8[_key].field_478 < addressRegistry.length\n                      require stor8[_key].field_510 <= 2\n                      log OrderFilled(\n                            uint8 orderType=caller,\n                            address sender=stor8[_key].field_256,\n                            address receiver=0,\n                            uint256 price=stor8[_key].field_510,\n                            uint256 amount=addressRegistry[stor8[_key].field_478])\n                      stop\n                  require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                  feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n                  if not fee * 0 / 10^18 / 10^18:\n                      require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                      totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                      require ext_code.size(feeTokenAddress)\n                      call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args poolOwners, 0\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require stor8[_key].field_478 < addressRegistry.length\n                      require stor8[_key].field_510 <= 2\n                      log OrderFilled(\n                            uint8 orderType=caller,\n                            address sender=stor8[_key].field_256,\n                            address receiver=0,\n                            uint256 price=stor8[_key].field_510,\n                            uint256 amount=addressRegistry[stor8[_key].field_478])\n                      stop\n                  require fee * 0 / 10^18 / 10^18\n                  require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n                  require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                  totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                  require ext_code.size(feeTokenAddress)\n                  call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                       gas gas_remaining wei\n                      args poolOwners, 0\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require return_data.size >= 32\n                  require stor8[_key].field_478 < addressRegistry.length\n                  require stor8[_key].field_510 <= 2\n                  log OrderFilled(\n                        uint8 orderType=caller,\n                        address sender=stor8[_key].field_256,\n                        address receiver=0,\n                        uint256 price=stor8[_key].field_510,\n                        uint256 amount=addressRegistry[stor8[_key].field_478])\n          else:\n              require stor8[_key].field_367\n              require not 0 / stor8[_key].field_367\n              if 0 / 10^18 != call.value:\n                  revert with 0, 'ETH sent needs to equal the cost'\n              if not stor8[_key].field_0:\n                  revert with 0, 'dMap remove failed'\n              if stor8[_key].field_0 >= stor9.length:\n                  stor9.length--\n                  if stor9.length > stor9.length - 1:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  stor8[_key].field_0 = 0\n                  stor8[_key].field_256 = 0\n                  require stor8[_key].field_478 < addressRegistry.length\n                  call addressRegistry[stor8[_key].field_478] with:\n                     value call.value wei\n                       gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require ext_code.size(poolOwners)\n                  call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n                       gas gas_remaining wei\n                      args caller, 0\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  if fee * 0 / 10^18 / 10^18 > 0:\n                      require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                      feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n                      if fee * 0 / 10^18 / 10^18:\n                          require fee * 0 / 10^18 / 10^18\n                          require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n                      require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                      totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                      require ext_code.size(feeTokenAddress)\n                      call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args poolOwners, 0\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                  require stor8[_key].field_478 < addressRegistry.length\n                  require stor8[_key].field_510 <= 2\n                  log OrderFilled(\n                        uint8 orderType=caller,\n                        address sender=stor8[_key].field_256,\n                        address receiver=0,\n                        uint256 price=stor8[_key].field_510,\n                        uint256 amount=addressRegistry[stor8[_key].field_478])\n                  stop\n              require stor9.length - 1 < stor9.length\n              stor8[stor9[stor9.length]].field_0 = stor8[_key].field_0\n              require stor8[_key].field_0 - 1 < stor9.length\n              stor9[stor8[_key].field_0] = stor9[stor9.length]\n              stor9.length--\n              if stor9.length <= stor9.length - 1:\n                  stor8[_key].field_0 = 0\n                  stor8[_key].field_256 = 0\n                  require stor8[_key].field_478 < addressRegistry.length\n                  call addressRegistry[stor8[_key].field_478] with:\n                     value call.value wei\n                       gas 2300 * is_zero(value) wei\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  require ext_code.size(poolOwners)\n                  call poolOwners.sendOwnership(address _receiver, uint256 _amount) with:\n                       gas gas_remaining wei\n                      args caller, 0\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  if fee * 0 / 10^18 / 10^18 <= 0:\n                      require stor8[_key].field_478 < addressRegistry.length\n                      require stor8[_key].field_510 <= 2\n                      log OrderFilled(\n                            uint8 orderType=caller,\n                            address sender=stor8[_key].field_256,\n                            address receiver=0,\n                            uint256 price=stor8[_key].field_510,\n                            uint256 amount=addressRegistry[stor8[_key].field_478])\n                      stop\n                  require fee * 0 / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                  feeBalances[stor6.length - 1] -= fee * 0 / 10^18 / 10^18\n                  if not fee * 0 / 10^18 / 10^18:\n                      require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                      totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                      require ext_code.size(feeTokenAddress)\n                      call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args poolOwners, 0\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n                      require stor8[_key].field_478 < addressRegistry.length\n                      require stor8[_key].field_510 <= 2\n                      log OrderFilled(\n                            uint8 orderType=caller,\n                            address sender=stor8[_key].field_256,\n                            address receiver=0,\n                            uint256 price=stor8[_key].field_510,\n                            uint256 amount=addressRegistry[stor8[_key].field_478])\n                  else:\n                      require fee * 0 / 10^18 / 10^18\n                      require 2 * fee * 0 / 10^18 / 10^18 / fee * 0 / 10^18 / 10^18 == 2\n                      require 2 * fee * 0 / 10^18 / 10^18 <= totalFees\n                      totalFees -= 2 * fee * 0 / 10^18 / 10^18\n                      require ext_code.size(feeTokenAddress)\n                      call feeTokenAddress.transfer(address recipient, uint256 amount) with:\n                           gas gas_remaining wei\n                          args poolOwners, 0\n                      if not ext_call.success:\n                          revert with ext_call.return_data[0 len return_data.size]\n                      require return_data.size >= 32\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef addBuyOrder(uint256 _price, uint256 _amount) payable: \n  if 0x8000000000000000000000000000 <= _price:\n      revert with 0, 'Price or amount exceeds 111 bits'\n  if 0x8000000000000000000000000000 <= _amount:\n      revert with 0, 'Price or amount exceeds 111 bits'\n  if _price <= 0:\n      revert with 0, 'Price needs to be greater than 0'\n  if _amount <= 0:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount needs to be greater than 0'\n  if not _price:\n      if not _amount * _price / 10^18:\n          if addressIndex[caller]:\n              if fee * _amount * _price / 10^18 / 10^18 <= 0:\n                  if _price:\n                      require _price\n                      require _amount * _price / _price == _amount\n                  if _amount * _price / 10^18:\n                      require _amount * _price / 10^18\n                      require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                  if _price:\n                      require _price\n                      require _amount * _price / _price == _amount\n                  if _amount * _price != 10^18 * _amount * _price / 10^18:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                  if _amount * _price / 10^18 != call.value:\n                      revert with 0, 'ETH sent needs to equal the cost'\n                  stor8[stor1].field_256 = Mask(145, 0, _price)\n                  stor8[stor1].field_401 = 0\n                  if 0 < stor8[stor1].field_0:\n                      revert with 0, 'Map replacement detected'\n                  stor9.length++\n                  if stor9.length > stor9.length + 1:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  stor8[stor1].field_0 = stor9.length + 1\n                  require stor9.length < stor9.length\n                  stor9[stor9.length] = orderCount\n                  orderCount++\n                  log NewOrder(\n                        uint8 orderType=_price,\n                        address sender=_amount,\n                        uint256 price=1,\n                        uint256 amount=caller)\n                  stop\n              if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n              require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n              feeBalances[stor7[caller]] -= fee * _amount * _price / 10^18 / 10^18\n              if not _price:\n                  if not _amount * _price / 10^18:\n                      if not _price:\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length > stor9.length + 1:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                          stop\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length <= stor9.length + 1:\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                  else:\n                      require _amount * _price / 10^18\n                      require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                      if not _price:\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                      else:\n                          require _price\n                          require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n              else:\n                  require _price\n                  require _amount * _price / _price == _amount\n                  if not _amount * _price / 10^18:\n                      if not _price:\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                      else:\n                          require _price\n                          require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                  else:\n                      require _amount * _price / 10^18\n                      require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                      if not _price:\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                      else:\n                          require _price\n                          require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n          else:\n              if unknown10000000() <= addressRegistry.length:\n                  revert with 0, 'Registered addresses hit maximum'\n              addressIndex[caller] = addressRegistry.length\n              addressRegistry.length++\n              addressRegistry[addressRegistry.length] = caller\n              if fee * _amount * _price / 10^18 / 10^18 > 0:\n                  if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n                  require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                  feeBalances[stor6.length - 1] -= fee * _amount * _price / 10^18 / 10^18\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length > stor9.length + 1:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                              stop\n                          require _price\n                          require _amount * _price / _price == _amount\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length <= stor9.length + 1:\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n              else:\n                  if not _price:\n                      if _amount * _price / 10^18:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                      if _price:\n                          require _price\n                          require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _price\n                  require _amount * _price / _price == _amount\n                  if not _amount * _price / 10^18:\n                      if _price:\n                          require _price\n                          require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _amount * _price / 10^18\n                  require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                  if not _price:\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _price\n                  require _amount * _price / _price == _amount\n                  if _amount * _price != 10^18 * _amount * _price / 10^18:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                  if _amount * _price / 10^18 != call.value:\n                      revert with 0, 'ETH sent needs to equal the cost'\n                  stor8[stor1].field_256 = Mask(145, 0, _price)\n                  stor8[stor1].field_401 = 0\n                  if 0 < stor8[stor1].field_0:\n                      revert with 0, 'Map replacement detected'\n                  stor9.length++\n                  if stor9.length <= stor9.length + 1:\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n      else:\n          require _amount * _price / 10^18\n          require fee * _amount * _price / 10^18 / _amount * _price / 10^18 == fee\n          if addressIndex[caller]:\n              if fee * _amount * _price / 10^18 / 10^18 <= 0:\n                  if not _price:\n                      if _amount * _price / 10^18:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                      if _price:\n                          require _price\n                          require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _price\n                  require _amount * _price / _price == _amount\n                  if not _amount * _price / 10^18:\n                      if _price:\n                          require _price\n                          require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _amount * _price / 10^18\n                  require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                  if not _price:\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _price\n                  require _amount * _price / _price == _amount\n                  if _amount * _price != 10^18 * _amount * _price / 10^18:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                  if _amount * _price / 10^18 != call.value:\n                      revert with 0, 'ETH sent needs to equal the cost'\n                  stor8[stor1].field_256 = Mask(145, 0, _price)\n                  stor8[stor1].field_401 = 0\n                  if 0 < stor8[stor1].field_0:\n                      revert with 0, 'Map replacement detected'\n                  stor9.length++\n                  if stor9.length <= stor9.length + 1:\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n              else:\n                  if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n                  require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n                  feeBalances[stor7[caller]] -= fee * _amount * _price / 10^18 / 10^18\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                                  orderCount++\n                                  log NewOrder(\n                                        uint8 orderType=_price,\n                                        address sender=_amount,\n                                        uint256 price=1,\n                                        uint256 amount=caller)\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n          else:\n              if unknown10000000() <= addressRegistry.length:\n                  revert with 0, 'Registered addresses hit maximum'\n              addressIndex[caller] = addressRegistry.length\n              addressRegistry.length++\n              addressRegistry[addressRegistry.length] = caller\n              if fee * _amount * _price / 10^18 / 10^18 > 0:\n                  if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n                  require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                  feeBalances[stor6.length - 1] -= fee * _amount * _price / 10^18 / 10^18\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if _amount * _price / 10^18:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                      else:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n              else:\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length > stor9.length + 1:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                          stop\n                      require _amount * _price / 10^18\n                      require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                      if not _price:\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length > stor9.length + 1:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                          stop\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length <= stor9.length + 1:\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length > stor9.length + 1:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                              stop\n                          require _price\n                          require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                                  orderCount++\n                                  log NewOrder(\n                                        uint8 orderType=_price,\n                                        address sender=_amount,\n                                        uint256 price=1,\n                                        uint256 amount=caller)\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n  else:\n      require _price\n      require _amount * _price / _price == _amount\n      if not _amount * _price / 10^18:\n          if addressIndex[caller]:\n              if fee * _amount * _price / 10^18 / 10^18 <= 0:\n                  if not _price:\n                      if _amount * _price / 10^18:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                      if _price:\n                          require _price\n                          require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _price\n                  require _amount * _price / _price == _amount\n                  if not _amount * _price / 10^18:\n                      if _price:\n                          require _price\n                          require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _amount * _price / 10^18\n                  require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                  if not _price:\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length > stor9.length + 1:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n                      orderCount++\n                      log NewOrder(\n                            uint8 orderType=_price,\n                            address sender=_amount,\n                            uint256 price=1,\n                            uint256 amount=caller)\n                      stop\n                  require _price\n                  require _amount * _price / _price == _amount\n                  if _amount * _price != 10^18 * _amount * _price / 10^18:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                  if _amount * _price / 10^18 != call.value:\n                      revert with 0, 'ETH sent needs to equal the cost'\n                  stor8[stor1].field_256 = Mask(145, 0, _price)\n                  stor8[stor1].field_401 = 0\n                  if 0 < stor8[stor1].field_0:\n                      revert with 0, 'Map replacement detected'\n                  stor9.length++\n                  if stor9.length <= stor9.length + 1:\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n              else:\n                  if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n                  require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n                  feeBalances[stor7[caller]] -= fee * _amount * _price / 10^18 / 10^18\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                                  orderCount++\n                                  log NewOrder(\n                                        uint8 orderType=_price,\n                                        address sender=_amount,\n                                        uint256 price=1,\n                                        uint256 amount=caller)\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n          else:\n              if unknown10000000() <= addressRegistry.length:\n                  revert with 0, 'Registered addresses hit maximum'\n              addressIndex[caller] = addressRegistry.length\n              addressRegistry.length++\n              addressRegistry[addressRegistry.length] = caller\n              if fee * _amount * _price / 10^18 / 10^18 > 0:\n                  if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n                  require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                  feeBalances[stor6.length - 1] -= fee * _amount * _price / 10^18 / 10^18\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if _amount * _price / 10^18:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                      else:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n              else:\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length > stor9.length + 1:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                          stop\n                      require _amount * _price / 10^18\n                      require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                      if not _price:\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length > stor9.length + 1:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                          stop\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if _amount * _price != 10^18 * _amount * _price / 10^18:\n                          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                      if _amount * _price / 10^18 != call.value:\n                          revert with 0, 'ETH sent needs to equal the cost'\n                      stor8[stor1].field_256 = Mask(145, 0, _price)\n                      stor8[stor1].field_401 = 0\n                      if 0 < stor8[stor1].field_0:\n                          revert with 0, 'Map replacement detected'\n                      stor9.length++\n                      if stor9.length <= stor9.length + 1:\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length > stor9.length + 1:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                              stop\n                          require _price\n                          require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                                  orderCount++\n                                  log NewOrder(\n                                        uint8 orderType=_price,\n                                        address sender=_amount,\n                                        uint256 price=1,\n                                        uint256 amount=caller)\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n      else:\n          require _amount * _price / 10^18\n          require fee * _amount * _price / 10^18 / _amount * _price / 10^18 == fee\n          if addressIndex[caller]:\n              if fee * _amount * _price / 10^18 / 10^18 > 0:\n                  if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor7[caller]]:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n                  require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor7[caller]]\n                  feeBalances[stor7[caller]] -= fee * _amount * _price / 10^18 / 10^18\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n              else:\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length > stor9.length + 1:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                          stop\n                      require _amount * _price / 10^18\n                      require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                      if not _price:\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length > stor9.length + 1:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          stor8[stor1].field_0 = stor9.length + 1\n                          require stor9.length < stor9.length\n                          stor9[stor9.length] = orderCount\n                          orderCount++\n                          log NewOrder(\n                                uint8 orderType=_price,\n                                address sender=_amount,\n                                uint256 price=1,\n                                uint256 amount=caller)\n                          stop\n                      require _price\n                      require _amount * _price / _price == _amount\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length > stor9.length + 1:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                              stop\n                          require _price\n                          require _amount * _price / _price == _amount\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                  if _amount * _price != 10^18 * _amount * _price / 10^18:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                  if _amount * _price / 10^18 != call.value:\n                      revert with 0, 'ETH sent needs to equal the cost'\n                  stor8[stor1].field_256 = Mask(145, 0, _price)\n                  stor8[stor1].field_401 = 0\n                  if 0 < stor8[stor1].field_0:\n                      revert with 0, 'Map replacement detected'\n                  stor9.length++\n                  if stor9.length <= stor9.length + 1:\n                      stor8[stor1].field_0 = stor9.length + 1\n                      require stor9.length < stor9.length\n                      stor9[stor9.length] = orderCount\n          else:\n              if unknown10000000() <= addressRegistry.length:\n                  revert with 0, 'Registered addresses hit maximum'\n              addressIndex[caller] = addressRegistry.length\n              addressRegistry.length++\n              addressRegistry[addressRegistry.length] = caller\n              if fee * _amount * _price / 10^18 / 10^18 > 0:\n                  if fee * _amount * _price / 10^18 / 10^18 > feeBalances[stor6.length - 1]:\n                      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You do not have enough deposite for fees'\n                  require fee * _amount * _price / 10^18 / 10^18 <= feeBalances[stor6.length - 1]\n                  feeBalances[stor6.length - 1] -= fee * _amount * _price / 10^18 / 10^18\n                  if _price:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                          else:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                  else:\n                      if _amount * _price / 10^18:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                      else:\n                          if _price:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 >= stor8[stor1].field_0:\n                                  stor9.length++\n                          else:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n              else:\n                  if not _price:\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length > stor9.length + 1:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                              stop\n                          require _price\n                          require _amount * _price / _price == _amount\n                          if _amount * _price != 10^18 * _amount * _price / 10^18:\n                              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                          if _amount * _price / 10^18 != call.value:\n                              revert with 0, 'ETH sent needs to equal the cost'\n                          stor8[stor1].field_256 = Mask(145, 0, _price)\n                          stor8[stor1].field_401 = 0\n                          if 0 < stor8[stor1].field_0:\n                              revert with 0, 'Map replacement detected'\n                          stor9.length++\n                          if stor9.length <= stor9.length + 1:\n                              stor8[stor1].field_0 = stor9.length + 1\n                              require stor9.length < stor9.length\n                              stor9[stor9.length] = orderCount\n                              orderCount++\n                              log NewOrder(\n                                    uint8 orderType=_price,\n                                    address sender=_amount,\n                                    uint256 price=1,\n                                    uint256 amount=caller)\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                                  orderCount++\n                                  log NewOrder(\n                                        uint8 orderType=_price,\n                                        address sender=_amount,\n                                        uint256 price=1,\n                                        uint256 amount=caller)\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                  else:\n                      require _price\n                      require _amount * _price / _price == _amount\n                      if not _amount * _price / 10^18:\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                                  orderCount++\n                                  log NewOrder(\n                                        uint8 orderType=_price,\n                                        address sender=_amount,\n                                        uint256 price=1,\n                                        uint256 amount=caller)\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                      else:\n                          require _amount * _price / 10^18\n                          require 10^18 * _amount * _price / 10^18 / _amount * _price / 10^18 == 10^18\n                          if not _price:\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n                                  require stor9.length < stor9.length\n                                  stor9[stor9.length] = orderCount\n                          else:\n                              require _price\n                              require _amount * _price / _price == _amount\n                              if _amount * _price != 10^18 * _amount * _price / 10^18:\n                                  revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'The price and amount of this order is too small'\n                              if _amount * _price / 10^18 != call.value:\n                                  revert with 0, 'ETH sent needs to equal the cost'\n                              stor8[stor1].field_256 = Mask(145, 0, _price)\n                              stor8[stor1].field_401 = 0\n                              if 0 < stor8[stor1].field_0:\n                                  revert with 0, 'Map replacement detected'\n                              stor9.length++\n                              if stor9.length <= stor9.length + 1:\n                                  stor8[stor1].field_0 = stor9.length + 1\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 46777 tokens. Please reduce the length of the messages."
}