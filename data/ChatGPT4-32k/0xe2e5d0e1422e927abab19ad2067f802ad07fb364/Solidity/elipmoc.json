{
	"address": "0xe2e5d0e1422e927abab19ad2067f802ad07fb364",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Apologies, but the decompiled code provided is not a perfect representation of the original Solidity code. Decompiling EVM Bytecode will not always give you the original code as the original code is often optimized and obfuscated during the compilation process. \n\nHowever, here is the best attempt to create a Solidity contract based on the given details:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract MyContract {\n    mapping (address => uint256) public _balanceOf;\n    mapping (address => mapping (address => uint256)) public _allowance;\n    uint256 public _supply;\n    string public _name;\n    string public _symbol;\n    uint256 public _decimals;\n    uint256 public _cliff;\n    uint256 public _tokensSold;\n    uint256 public _eARLYADOPTERS;\n    uint256 public _iCO_ONE;\n    uint256 public _iCO_TWO;\n    address public _closeEarlyAdopters;\n    address public _vc1Wallet4Pct;\n    address public _vc2Wallet4Pct;\n    address public _vc3Wallet4Pct;\n    address public _cf1Wallet2Pct;\n    address public _cf2Wallet2Pct;\n    address public _dev1Wallet2Pct;\n    address public _dev2Wallet2Pct;\n    address public _dev3Wallet2Pct;\n    address public _dev4Wallet2Pct;\n    address public _preicobrandingWallet1Pct;\n    address public _lotusWallet75Pct;\n    address public _airdropWallet5Pct;\n\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n\n    constructor() public {\n        // Initialize your state variables here\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balanceOf[msg.sender] >= _value);\n        _balanceOf[msg.sender] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= _balanceOf[_from]);\n        require(_value <= _allowance[_from][msg.sender]);\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        _allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    // Define more functions here based on the decompiled code\n\n}\n```\n\nPlease note that this is a very simplified version of your contract and may not include all the necessary features or security measures. You may need to further adjust the contract to fit your needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039638,
	"id": "chatcmpl-8Chy2Z8D71HfwQsjV8tc3Eku6pOa7",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 11:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _supply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5]\nuint256 _cliff; // STORAGE[0x7]\nuint256 _tokensSold; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _withdrawAllocation; // STORAGE[0x16]\nmapping (uint256 => [uint256]) owner_17; // STORAGE[0x17]\nmapping (uint256 => [uint256]) owner_18; // STORAGE[0x18]\nuint256 _eARLYADOPTERS; // STORAGE[0x19]\nuint256 stor_1a; // STORAGE[0x1a]\nuint256 stor_1b; // STORAGE[0x1b]\nuint256 stor_1c; // STORAGE[0x1c]\nuint256 stor_1d; // STORAGE[0x1d]\nuint256 stor_1e; // STORAGE[0x1e]\nuint256 _iCO_ONE; // STORAGE[0x1f]\nuint256 stor_20; // STORAGE[0x20]\nuint256 stor_21; // STORAGE[0x21]\nuint256 stor_22; // STORAGE[0x22]\nuint256 stor_23; // STORAGE[0x23]\nuint256 stor_24; // STORAGE[0x24]\nuint256 _iCO_TWO; // STORAGE[0x25]\nuint256 stor_26; // STORAGE[0x26]\nuint256 stor_27; // STORAGE[0x27]\nuint256 stor_28; // STORAGE[0x28]\nuint256 stor_29; // STORAGE[0x29]\nuint256 stor_2a; // STORAGE[0x2a]\nmapping (uint256 => [uint256]) owner_2b; // STORAGE[0x2b]\nmapping (uint256 => [uint256]) owner_2c; // STORAGE[0x2c]\nmapping (uint256 => [uint256]) owner_2d; // STORAGE[0x2d]\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\nuint8 _withdrawVestedTokens; // STORAGE[0x2e] bytes 0 to 0\naddress _closeEarlyAdopters; // STORAGE[0x6] bytes 0 to 19\nuint160 _vc1Wallet4Pct; // STORAGE[0x9] bytes 0 to 19\nuint160 _vc2Wallet4Pct; // STORAGE[0xa] bytes 0 to 19\nuint160 _vc3Wallet4Pct; // STORAGE[0xb] bytes 0 to 19\nuint160 _cf1Wallet2Pct; // STORAGE[0xc] bytes 0 to 19\nuint160 _cf2Wallet2Pct; // STORAGE[0xd] bytes 0 to 19\nuint160 _dev1Wallet2Pct; // STORAGE[0xe] bytes 0 to 19\nuint160 _dev2Wallet2Pct; // STORAGE[0xf] bytes 0 to 19\nuint160 _dev3Wallet2Pct; // STORAGE[0x10] bytes 0 to 19\nuint160 _dev4Wallet2Pct; // STORAGE[0x11] bytes 0 to 19\nuint160 _preicobrandingWallet1Pct; // STORAGE[0x12] bytes 0 to 19\naddress _lotusWallet75Pct; // STORAGE[0x13] bytes 0 to 19\nuint160 _airdropWallet5Pct; // STORAGE[0x14] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1c8b(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg2);\n    v0 = 25 * (varg0 / varg1) / varg2;\n    v1 = v0 + varg3;\n    v2 = v1 < varg3;\n    v3 = v1 >= varg3;\n    if (v1 >= varg3) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\nfunction 0x1d13(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg2);\n    v0 = 75 * (varg0 / varg1) / varg2;\n    v1 = v0 + varg3;\n    v2 = v1 < varg3;\n    v3 = v1 >= varg3;\n    if (v1 >= varg3) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\nfunction fallback() public payable { \n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v2 = _withdrawVestedTokens == 3;\n    }\n    if (!v0) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v3 = _withdrawVestedTokens == 5;\n    }\n    require(v0);\n    require(msg.value > 0);\n    v4 = 0x7fd();\n    v5 = v6 = msg.value >= v4;\n    if (v6) {\n        v7 = 0x8b9();\n        v5 = v8 = msg.value <= v7;\n    }\n    require(v5);\n    v9 = 0x976();\n    v10 = 0xa33();\n    v11 = 0xaf0();\n    v12 = 0xbad();\n    v13 = 0xc6a();\n    assert(v9);\n    v14 = msg.value / v9 * 10 ** _decimals;\n    require(v14 + v11 <= v10);\n    require(v13 + v14 <= v12);\n    v15 = _SafeAdd(v14, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v15;\n    v16 = _SafeAdd(v14, _tokensSold);\n    _tokensSold = v16;\n    assert(_withdrawVestedTokens <= 6);\n    v17 = v18 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v17 = v19 = _withdrawVestedTokens == 3;\n    }\n    if (!v17) {\n        assert(_withdrawVestedTokens <= 6);\n        v17 = _withdrawVestedTokens == 5;\n    }\n    require(v17);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v20 = _SafeAdd(v14, stor_27);\n                stor_27 = v20;\n                v21 = _SafeAdd(v14, owner_2d[msg.sender]);\n                owner_2d[msg.sender] = v21;\n            }\n        } else {\n            v22 = _SafeAdd(v14, stor_21);\n            stor_21 = v22;\n            v23 = _SafeAdd(v14, owner_2c[msg.sender]);\n            owner_2c[msg.sender] = v23;\n        }\n    } else {\n        v24 = _SafeAdd(v14, stor_1b);\n        stor_1b = v24;\n        v25 = _SafeAdd(v14, owner_2b[msg.sender]);\n        owner_2b[msg.sender] = v25;\n    }\n    v26 = (msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= _withdrawAllocation[_vc1Wallet4Pct];\n    if ((msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= _withdrawAllocation[_vc1Wallet4Pct]) {\n        v26 = v27 = (msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= (msg.value << 2) / 100;\n    }\n    assert(v26);\n    _withdrawAllocation[_vc1Wallet4Pct] += (msg.value << 2) / 100;\n    v28 = 0xf45(msg.value << 2, 100, _withdrawAllocation[_vc2Wallet4Pct]);\n    _withdrawAllocation[_vc2Wallet4Pct] = v28;\n    v29 = 0xf45(msg.value << 2, 100, _withdrawAllocation[_vc3Wallet4Pct]);\n    _withdrawAllocation[_vc3Wallet4Pct] = v29;\n    v30 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_cf1Wallet2Pct]);\n    _withdrawAllocation[_cf1Wallet2Pct] = v30;\n    v31 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_cf2Wallet2Pct]);\n    _withdrawAllocation[_cf2Wallet2Pct] = v31;\n    v32 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev1Wallet2Pct]);\n    _withdrawAllocation[_dev1Wallet2Pct] = v32;\n    v33 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev3Wallet2Pct]);\n    _withdrawAllocation[_dev3Wallet2Pct] = v33;\n    v34 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev2Wallet2Pct]);\n    _withdrawAllocation[_dev2Wallet2Pct] = v34;\n    v35 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev4Wallet2Pct]);\n    _withdrawAllocation[_dev4Wallet2Pct] = v35;\n    v36 = 0xf45(msg.value, 100, _withdrawAllocation[_preicobrandingWallet1Pct]);\n    _withdrawAllocation[_preicobrandingWallet1Pct] = v36;\n    v37 = 0xf45(msg.value * 75, 100, _withdrawAllocation[_lotusWallet75Pct]);\n    _withdrawAllocation[_lotusWallet75Pct] = v37;\n    emit Transfer(address(this), msg.sender, v14);\n}\n\nfunction currentMinPurchase() public nonPayable { \n    v0 = 0x7fd();\n    return v0;\n}\n\nfunction supply() public nonPayable { \n    return _supply;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = !varg1;\n    if (varg1) {\n        v0 = v2 = !_allowance[varg0];\n    }\n    require(v0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction closeEarlyAdopters() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 1);\n    _withdrawVestedTokens = 2;\n}\n\nfunction dev1Wallet2Pct() public nonPayable { \n    return _dev1Wallet2Pct;\n}\n\nfunction cliff() public nonPayable { \n    return _cliff;\n}\n\nfunction airdropWallet5Pct() public nonPayable { \n    return _airdropWallet5Pct;\n}\n\nfunction totalSupply() public nonPayable { \n    return _supply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_balanceOf[varg0] >= varg2);\n    require(_allowance[msg.sender] >= varg2);\n    require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);\n    v0 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v0;\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction currentSaleLimit() public nonPayable { \n    v0 = 0xa33();\n    return v0;\n}\n\nfunction currentSaleLimitPerAddress() public nonPayable { \n    v0 = 0xbad();\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction preicobrandingWallet1Pct() public nonPayable { \n    return _preicobrandingWallet1Pct;\n}\n\nfunction withdrawVestedTokens() public nonPayable { \n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 6);\n    require(_cliff > 0);\n    require(block.timestamp >= _cliff);\n    require(owner_18[msg.sender] < owner_17[msg.sender]);\n    assert(stor_8_0_0);\n    v0 = owner_17[msg.sender] / 15 * (1 + (block.timestamp - _cliff) / STORAGE[8]) - owner_18[msg.sender];\n    v1 = _SafeAdd(v0, owner_18[msg.sender]);\n    owner_18[msg.sender] = v1;\n    v2 = _SafeAdd(v0, owner_18[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    emit Transfer(address(this), msg.sender, v0);\n}\n\nfunction dev2Wallet2Pct() public nonPayable { \n    return _dev2Wallet2Pct;\n}\n\nfunction startIcoTwo() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 3;\n    if (_withdrawVestedTokens != 3) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 4;\n    }\n    require(v0);\n    _withdrawVestedTokens = 5;\n}\n\nfunction cf1Wallet2Pct() public nonPayable { \n    return _cf1Wallet2Pct;\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction vc1Wallet4Pct() public nonPayable { \n    return _vc1Wallet4Pct;\n}\n\nfunction ICO_ONE() public nonPayable { \n    return _iCO_ONE, stor_20, stor_21, stor_22, stor_23, stor_24;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction dev4Wallet2Pct() public nonPayable { \n    return _dev4Wallet2Pct;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction startIcoOne() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 2;\n    }\n    require(v0);\n    _withdrawVestedTokens = 3;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 > _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    v0 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction lotusWallet75Pct() public nonPayable { \n    return _lotusWallet75Pct;\n}\n\nfunction currentMaxPurchase() public nonPayable { \n    v0 = 0x8b9();\n    return v0;\n}\n\nfunction dev3Wallet2Pct() public nonPayable { \n    return _dev3Wallet2Pct;\n}\n\nfunction ICO_TWO() public nonPayable { \n    return _iCO_TWO, stor_26, stor_27, stor_28, stor_29, stor_2a;\n}\n\nfunction closeIcoOne() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 3);\n    _withdrawVestedTokens = 4;\n}\n\nfunction startEarlyAdopters() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 0);\n    _withdrawVestedTokens = 1;\n}\n\nfunction cf2Wallet2Pct() public nonPayable { \n    return _cf2Wallet2Pct;\n}\n\nfunction currentStageTokensBoughtByAddress() public nonPayable { \n    v0 = 0xc6a();\n    return v0;\n}\n\nfunction currentSaleSold() public nonPayable { \n    v0 = 0xaf0();\n    return v0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction vc3Wallet4Pct() public nonPayable { \n    return _vc3Wallet4Pct;\n}\n\nfunction EARLYADOPTERS() public nonPayable { \n    return _eARLYADOPTERS, stor_1a, stor_1b, stor_1c, stor_1d, stor_1e;\n}\n\nfunction currentSalePriceInWei() public nonPayable { \n    v0 = 0x976();\n    return v0;\n}\n\nfunction withdrawAllocation() public nonPayable { \n    require(_withdrawAllocation[msg.sender] > 0);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 2;\n    if (_withdrawVestedTokens != 2) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v2 = _withdrawVestedTokens == 4;\n    }\n    if (!v0) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 6;\n    }\n    require(v0);\n    v3 = v4 = _lotusWallet75Pct != msg.sender;\n    if (_lotusWallet75Pct == msg.sender) {\n        assert(_withdrawVestedTokens <= 6);\n        v3 = _withdrawVestedTokens == 6;\n    }\n    require(v3);\n    _withdrawAllocation[msg.sender] = 0;\n    v5 = msg.sender.call().value(_withdrawAllocation[msg.sender]).gas(2300 * !_withdrawAllocation[msg.sender]);\n    require(v5);\n}\n\nfunction closeSale() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 5);\n    _withdrawVestedTokens = 6;\n    require(_closeEarlyAdopters == msg.sender);\n    v0 = 40 * _supply / 100 - _tokensSold;\n    v1 = 0xf45(v0 * 75, 100, _balanceOf[_lotusWallet75Pct]);\n    _balanceOf[_lotusWallet75Pct] = v1;\n    emit Transfer(address(this), _lotusWallet75Pct, v0 * 75 / 100);\n    v2 = v3 = _balanceOf[_vc1Wallet4Pct];\n    v4 = v5 = 7320;\n    v6 = v7 = 100;\n    v8 = 25 * ((v0 << 2) / v7);\n    assert(v7);\n    while (1) {\n        v9 = v8 / v6 + v2 >= v2;\n        if (v8 / v6 + v2 >= v2) {\n            v9 = v10 = v8 / v6 + v2 >= v8 / v6;\n        }\n        if (v9) {\n            break;\n        }\n        assert(v9);\n        owner_17[_vc1Wallet4Pct] = v8 / v6 + v2;\n        v11 = 0x1c8b(v0 << 2, 100, 100, owner_17[_vc2Wallet4Pct]);\n        _balanceOf[_vc2Wallet4Pct] = v11;\n        emit Transfer(address(this), _vc2Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v12 = 0x1d13(v0 << 2, 100, 100, owner_17[_vc2Wallet4Pct]);\n        owner_17[_vc2Wallet4Pct] = v12;\n        v13 = 0x1c8b(v0 << 2, 100, 100, owner_17[_vc3Wallet4Pct]);\n        _balanceOf[_vc3Wallet4Pct] = v13;\n        emit Transfer(address(this), _vc3Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v14 = 0x1d13(v0 << 2, 100, 100, owner_17[_vc3Wallet4Pct]);\n        owner_17[_vc3Wallet4Pct] = v14;\n        v15 = 0x1c8b(v0 << 1, 100, 100, owner_17[_cf1Wallet2Pct]);\n        _balanceOf[_cf1Wallet2Pct] = v15;\n        emit Transfer(address(this), _cf1Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v16 = 0x1d13(v0 << 1, 100, 100, owner_17[_cf1Wallet2Pct]);\n        owner_17[_cf1Wallet2Pct] = v16;\n        v17 = 0x1c8b(v0 << 1, 100, 100, owner_17[_cf2Wallet2Pct]);\n        _balanceOf[_cf2Wallet2Pct] = v17;\n        emit Transfer(address(this), _cf2Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v18 = 0x1d13(v0 << 1, 100, 100, owner_17[_cf2Wallet2Pct]);\n        owner_17[_cf2Wallet2Pct] = v18;\n        v19 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev1Wallet2Pct]);\n        _balanceOf[_dev1Wallet2Pct] = v19;\n        emit Transfer(address(this), _dev1Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v20 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev1Wallet2Pct]);\n        owner_17[_dev1Wallet2Pct] = v20;\n        v21 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev2Wallet2Pct]);\n        _balanceOf[_dev2Wallet2Pct] = v21;\n        emit Transfer(address(this), _dev2Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v22 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev2Wallet2Pct]);\n        owner_17[_dev2Wallet2Pct] = v22;\n        v23 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev3Wallet2Pct]);\n        _balanceOf[_dev3Wallet2Pct] = v23;\n        emit Transfer(address(this), _dev3Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v24 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev3Wallet2Pct]);\n        owner_17[_dev3Wallet2Pct] = v24;\n        v25 = 0x1c8b(v0, 100, 100, owner_17[_preicobrandingWallet1Pct]);\n        _balanceOf[_preicobrandingWallet1Pct] = v25;\n        emit Transfer(address(this), _preicobrandingWallet1Pct, v0 / 100 * 25 / 100);\n        v26 = 0x1d13(v0, 100, 100, owner_17[_preicobrandingWallet1Pct]);\n        owner_17[_preicobrandingWallet1Pct] = v26;\n        v27 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev4Wallet2Pct]);\n        _balanceOf[_dev4Wallet2Pct] = v27;\n        emit Transfer(address(this), _dev4Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v28 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev4Wallet2Pct]);\n        owner_17[_dev4Wallet2Pct] = v28;\n        v29 = _SafeAdd(55 * _supply / 100, owner_17[_lotusWallet75Pct]);\n        _balanceOf[_lotusWallet75Pct] = v29;\n        emit Transfer(address(this), _lotusWallet75Pct, 55 * _supply / 100);\n        v30 = _SafeAdd(5 * _supply / 100, _balanceOf[_airdropWallet5Pct]);\n        _balanceOf[_airdropWallet5Pct] = v30;\n        emit Transfer(address(this), _airdropWallet5Pct, 5 * _supply / 100);\n        _cliff = block.timestamp + 0xed4e00;\n        exit;\n        goto {'0x1d20', '0x1c98'};\n        _balanceOf[_vc1Wallet4Pct] = v8 / v6 + v2;\n        emit Transfer(address(this), _vc1Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v2 = v31 = owner_17[_vc1Wallet4Pct];\n        v4 = v32 = 7456;\n        v6 = v33 = 100;\n        v8 = v34 = 75 * ((v0 << 2) / v33);\n        assert(v33);\n    }\n}\n\nfunction vc2Wallet4Pct() public nonPayable { \n    return _vc2Wallet4Pct;\n}\n\nfunction 0x7fd() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_28;\n            }\n        } else {\n            v0 = v7 = stor_22;\n        }\n    } else {\n        v0 = v8 = stor_1c;\n    }\n    return v0;\n}\n\nfunction 0x8b9() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_29;\n            }\n        } else {\n            v0 = v7 = stor_23;\n        }\n    } else {\n        v0 = v8 = stor_1d;\n    }\n    return v0;\n}\n\nfunction 0x976() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_26;\n            }\n        } else {\n            v0 = v7 = stor_20;\n        }\n    } else {\n        v0 = v8 = stor_1a;\n    }\n    return v0;\n}\n\nfunction 0xa33() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = _iCO_TWO;\n            }\n        } else {\n            v0 = v7 = _iCO_ONE;\n        }\n    } else {\n        v0 = v8 = _eARLYADOPTERS;\n    }\n    return v0;\n}\n\nfunction 0xaf0() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_27;\n            }\n        } else {\n            v0 = v7 = stor_21;\n        }\n    } else {\n        v0 = v8 = stor_1b;\n    }\n    return v0;\n}\n\nfunction 0xbad() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_2a;\n            }\n        } else {\n            v0 = v7 = stor_24;\n        }\n    } else {\n        v0 = v8 = stor_1e;\n    }\n    return v0;\n}\n\nfunction 0xc6a() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = owner_2d[msg.sender];\n            }\n        } else {\n            v0 = v7 = owner_2c[msg.sender];\n        }\n    } else {\n        v0 = v8 = owner_2b[msg.sender];\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\nfunction 0xf45(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    v1 = v0 + varg2;\n    v2 = v1 < varg2;\n    v3 = v1 >= varg2;\n    if (v1 >= varg2) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xfdc73f) {\n            currentMinPurchase();\n        } else if (0x47fc9aa == function_selector) {\n            supply();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc26ac30 == function_selector) {\n            closeEarlyAdopters();\n        } else if (0xfac20e1 == function_selector) {\n            dev1Wallet2Pct();\n        } else if (0x13d033c0 == function_selector) {\n            cliff();\n        } else if (0x1615d035 == function_selector) {\n            airdropWallet5Pct();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2a18ca16 == function_selector) {\n            currentSaleLimit();\n        } else if (0x2ca1aa16 == function_selector) {\n            currentSaleLimitPerAddress();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x341cc817 == function_selector) {\n            preicobrandingWallet1Pct();\n        } else if (0x39f05521 == function_selector) {\n            withdrawVestedTokens();\n        } else if (0x3be1c410 == function_selector) {\n            dev2Wallet2Pct();\n        } else if (0x3dbae9f9 == function_selector) {\n            startIcoTwo();\n        } else if (0x4266806b == function_selector) {\n            cf1Wallet2Pct();\n        } else if (0x518ab2a8 == function_selector) {\n            tokensSold();\n        } else if (0x66005ede == function_selector) {\n            vc1Wallet4Pct();\n        } else if (0x6f3ad341 == function_selector) {\n            ICO_ONE();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x90427b6c == function_selector) {\n            dev4Wallet2Pct();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa0695fc2 == function_selector) {\n            startIcoOne();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xac7b986f == function_selector) {\n            lotusWallet75Pct();\n        } else if (0xaf0638f6 == function_selector) {\n            currentMaxPurchase();\n        } else if (0xb154f47c == function_selector) {\n            dev3Wallet2Pct();\n        } else if (0xbb814746 == function_selector) {\n            ICO_TWO();\n        } else if (0xc2d25167 == function_selector) {\n            closeIcoOne();\n        } else if (0xc467706d == function_selector) {\n            startEarlyAdopters();\n        } else if (0xcb6b1f05 == function_selector) {\n            cf2Wallet2Pct();\n        } else if (0xd042ce2c == function_selector) {\n            currentStageTokensBoughtByAddress();\n        } else if (0xdcd6561d == function_selector) {\n            currentSaleSold();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xdef1a2da == function_selector) {\n            vc3Wallet4Pct();\n        } else if (0xe50e2f65 == function_selector) {\n            EARLYADOPTERS();\n        } else if (0xeb570b05 == function_selector) {\n            currentSalePriceInWei();\n        } else if (0xee224707 == function_selector) {\n            withdrawAllocation();\n        } else if (0xee55efee == function_selector) {\n            closeSale();\n        } else if (0xf3635a02 == function_selector) {\n            vc2Wallet4Pct();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 11:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _supply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5]\nuint256 _cliff; // STORAGE[0x7]\nuint256 _tokensSold; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _withdrawAllocation; // STORAGE[0x16]\nmapping (uint256 => [uint256]) owner_17; // STORAGE[0x17]\nmapping (uint256 => [uint256]) owner_18; // STORAGE[0x18]\nuint256 _eARLYADOPTERS; // STORAGE[0x19]\nuint256 stor_1a; // STORAGE[0x1a]\nuint256 stor_1b; // STORAGE[0x1b]\nuint256 stor_1c; // STORAGE[0x1c]\nuint256 stor_1d; // STORAGE[0x1d]\nuint256 stor_1e; // STORAGE[0x1e]\nuint256 _iCO_ONE; // STORAGE[0x1f]\nuint256 stor_20; // STORAGE[0x20]\nuint256 stor_21; // STORAGE[0x21]\nuint256 stor_22; // STORAGE[0x22]\nuint256 stor_23; // STORAGE[0x23]\nuint256 stor_24; // STORAGE[0x24]\nuint256 _iCO_TWO; // STORAGE[0x25]\nuint256 stor_26; // STORAGE[0x26]\nuint256 stor_27; // STORAGE[0x27]\nuint256 stor_28; // STORAGE[0x28]\nuint256 stor_29; // STORAGE[0x29]\nuint256 stor_2a; // STORAGE[0x2a]\nmapping (uint256 => [uint256]) owner_2b; // STORAGE[0x2b]\nmapping (uint256 => [uint256]) owner_2c; // STORAGE[0x2c]\nmapping (uint256 => [uint256]) owner_2d; // STORAGE[0x2d]\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\nuint8 _withdrawVestedTokens; // STORAGE[0x2e] bytes 0 to 0\naddress _closeEarlyAdopters; // STORAGE[0x6] bytes 0 to 19\nuint160 _vc1Wallet4Pct; // STORAGE[0x9] bytes 0 to 19\nuint160 _vc2Wallet4Pct; // STORAGE[0xa] bytes 0 to 19\nuint160 _vc3Wallet4Pct; // STORAGE[0xb] bytes 0 to 19\nuint160 _cf1Wallet2Pct; // STORAGE[0xc] bytes 0 to 19\nuint160 _cf2Wallet2Pct; // STORAGE[0xd] bytes 0 to 19\nuint160 _dev1Wallet2Pct; // STORAGE[0xe] bytes 0 to 19\nuint160 _dev2Wallet2Pct; // STORAGE[0xf] bytes 0 to 19\nuint160 _dev3Wallet2Pct; // STORAGE[0x10] bytes 0 to 19\nuint160 _dev4Wallet2Pct; // STORAGE[0x11] bytes 0 to 19\nuint160 _preicobrandingWallet1Pct; // STORAGE[0x12] bytes 0 to 19\naddress _lotusWallet75Pct; // STORAGE[0x13] bytes 0 to 19\nuint160 _airdropWallet5Pct; // STORAGE[0x14] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1c8b(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg2);\n    v0 = 25 * (varg0 / varg1) / varg2;\n    v1 = v0 + varg3;\n    v2 = v1 < varg3;\n    v3 = v1 >= varg3;\n    if (v1 >= varg3) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\nfunction 0x1d13(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg2);\n    v0 = 75 * (varg0 / varg1) / varg2;\n    v1 = v0 + varg3;\n    v2 = v1 < varg3;\n    v3 = v1 >= varg3;\n    if (v1 >= varg3) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\nfunction fallback() public payable { \n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v2 = _withdrawVestedTokens == 3;\n    }\n    if (!v0) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v3 = _withdrawVestedTokens == 5;\n    }\n    require(v0);\n    require(msg.value > 0);\n    v4 = 0x7fd();\n    v5 = v6 = msg.value >= v4;\n    if (v6) {\n        v7 = 0x8b9();\n        v5 = v8 = msg.value <= v7;\n    }\n    require(v5);\n    v9 = 0x976();\n    v10 = 0xa33();\n    v11 = 0xaf0();\n    v12 = 0xbad();\n    v13 = 0xc6a();\n    assert(v9);\n    v14 = msg.value / v9 * 10 ** _decimals;\n    require(v14 + v11 <= v10);\n    require(v13 + v14 <= v12);\n    v15 = _SafeAdd(v14, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v15;\n    v16 = _SafeAdd(v14, _tokensSold);\n    _tokensSold = v16;\n    assert(_withdrawVestedTokens <= 6);\n    v17 = v18 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v17 = v19 = _withdrawVestedTokens == 3;\n    }\n    if (!v17) {\n        assert(_withdrawVestedTokens <= 6);\n        v17 = _withdrawVestedTokens == 5;\n    }\n    require(v17);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v20 = _SafeAdd(v14, stor_27);\n                stor_27 = v20;\n                v21 = _SafeAdd(v14, owner_2d[msg.sender]);\n                owner_2d[msg.sender] = v21;\n            }\n        } else {\n            v22 = _SafeAdd(v14, stor_21);\n            stor_21 = v22;\n            v23 = _SafeAdd(v14, owner_2c[msg.sender]);\n            owner_2c[msg.sender] = v23;\n        }\n    } else {\n        v24 = _SafeAdd(v14, stor_1b);\n        stor_1b = v24;\n        v25 = _SafeAdd(v14, owner_2b[msg.sender]);\n        owner_2b[msg.sender] = v25;\n    }\n    v26 = (msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= _withdrawAllocation[_vc1Wallet4Pct];\n    if ((msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= _withdrawAllocation[_vc1Wallet4Pct]) {\n        v26 = v27 = (msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= (msg.value << 2) / 100;\n    }\n    assert(v26);\n    _withdrawAllocation[_vc1Wallet4Pct] += (msg.value << 2) / 100;\n    v28 = 0xf45(msg.value << 2, 100, _withdrawAllocation[_vc2Wallet4Pct]);\n    _withdrawAllocation[_vc2Wallet4Pct] = v28;\n    v29 = 0xf45(msg.value << 2, 100, _withdrawAllocation[_vc3Wallet4Pct]);\n    _withdrawAllocation[_vc3Wallet4Pct] = v29;\n    v30 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_cf1Wallet2Pct]);\n    _withdrawAllocation[_cf1Wallet2Pct] = v30;\n    v31 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_cf2Wallet2Pct]);\n    _withdrawAllocation[_cf2Wallet2Pct] = v31;\n    v32 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev1Wallet2Pct]);\n    _withdrawAllocation[_dev1Wallet2Pct] = v32;\n    v33 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev3Wallet2Pct]);\n    _withdrawAllocation[_dev3Wallet2Pct] = v33;\n    v34 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev2Wallet2Pct]);\n    _withdrawAllocation[_dev2Wallet2Pct] = v34;\n    v35 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev4Wallet2Pct]);\n    _withdrawAllocation[_dev4Wallet2Pct] = v35;\n    v36 = 0xf45(msg.value, 100, _withdrawAllocation[_preicobrandingWallet1Pct]);\n    _withdrawAllocation[_preicobrandingWallet1Pct] = v36;\n    v37 = 0xf45(msg.value * 75, 100, _withdrawAllocation[_lotusWallet75Pct]);\n    _withdrawAllocation[_lotusWallet75Pct] = v37;\n    emit Transfer(address(this), msg.sender, v14);\n}\n\nfunction currentMinPurchase() public nonPayable { \n    v0 = 0x7fd();\n    return v0;\n}\n\nfunction supply() public nonPayable { \n    return _supply;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = !varg1;\n    if (varg1) {\n        v0 = v2 = !_allowance[varg0];\n    }\n    require(v0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction closeEarlyAdopters() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 1);\n    _withdrawVestedTokens = 2;\n}\n\nfunction dev1Wallet2Pct() public nonPayable { \n    return _dev1Wallet2Pct;\n}\n\nfunction cliff() public nonPayable { \n    return _cliff;\n}\n\nfunction airdropWallet5Pct() public nonPayable { \n    return _airdropWallet5Pct;\n}\n\nfunction totalSupply() public nonPayable { \n    return _supply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_balanceOf[varg0] >= varg2);\n    require(_allowance[msg.sender] >= varg2);\n    require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);\n    v0 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v0;\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction currentSaleLimit() public nonPayable { \n    v0 = 0xa33();\n    return v0;\n}\n\nfunction currentSaleLimitPerAddress() public nonPayable { \n    v0 = 0xbad();\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction preicobrandingWallet1Pct() public nonPayable { \n    return _preicobrandingWallet1Pct;\n}\n\nfunction withdrawVestedTokens() public nonPayable { \n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 6);\n    require(_cliff > 0);\n    require(block.timestamp >= _cliff);\n    require(owner_18[msg.sender] < owner_17[msg.sender]);\n    assert(stor_8_0_0);\n    v0 = owner_17[msg.sender] / 15 * (1 + (block.timestamp - _cliff) / STORAGE[8]) - owner_18[msg.sender];\n    v1 = _SafeAdd(v0, owner_18[msg.sender]);\n    owner_18[msg.sender] = v1;\n    v2 = _SafeAdd(v0, owner_18[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    emit Transfer(address(this), msg.sender, v0);\n}\n\nfunction dev2Wallet2Pct() public nonPayable { \n    return _dev2Wallet2Pct;\n}\n\nfunction startIcoTwo() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 3;\n    if (_withdrawVestedTokens != 3) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 4;\n    }\n    require(v0);\n    _withdrawVestedTokens = 5;\n}\n\nfunction cf1Wallet2Pct() public nonPayable { \n    return _cf1Wallet2Pct;\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction vc1Wallet4Pct() public nonPayable { \n    return _vc1Wallet4Pct;\n}\n\nfunction ICO_ONE() public nonPayable { \n    return _iCO_ONE, stor_20, stor_21, stor_22, stor_23, stor_24;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction dev4Wallet2Pct() public nonPayable { \n    return _dev4Wallet2Pct;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction startIcoOne() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 2;\n    }\n    require(v0);\n    _withdrawVestedTokens = 3;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 > _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    v0 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction lotusWallet75Pct() public nonPayable { \n    return _lotusWallet75Pct;\n}\n\nfunction currentMaxPurchase() public nonPayable { \n    v0 = 0x8b9();\n    return v0;\n}\n\nfunction dev3Wallet2Pct() public nonPayable { \n    return _dev3Wallet2Pct;\n}\n\nfunction ICO_TWO() public nonPayable { \n    return _iCO_TWO, stor_26, stor_27, stor_28, stor_29, stor_2a;\n}\n\nfunction closeIcoOne() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 3);\n    _withdrawVestedTokens = 4;\n}\n\nfunction startEarlyAdopters() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 0);\n    _withdrawVestedTokens = 1;\n}\n\nfunction cf2Wallet2Pct() public nonPayable { \n    return _cf2Wallet2Pct;\n}\n\nfunction currentStageTokensBoughtByAddress() public nonPayable { \n    v0 = 0xc6a();\n    return v0;\n}\n\nfunction currentSaleSold() public nonPayable { \n    v0 = 0xaf0();\n    return v0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction vc3Wallet4Pct() public nonPayable { \n    return _vc3Wallet4Pct;\n}\n\nfunction EARLYADOPTERS() public nonPayable { \n    return _eARLYADOPTERS, stor_1a, stor_1b, stor_1c, stor_1d, stor_1e;\n}\n\nfunction currentSalePriceInWei() public nonPayable { \n    v0 = 0x976();\n    return v0;\n}\n\nfunction withdrawAllocation() public nonPayable { \n    require(_withdrawAllocation[msg.sender] > 0);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 2;\n    if (_withdrawVestedTokens != 2) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v2 = _withdrawVestedTokens == 4;\n    }\n    if (!v0) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 6;\n    }\n    require(v0);\n    v3 = v4 = _lotusWallet75Pct != msg.sender;\n    if (_lotusWallet75Pct == msg.sender) {\n        assert(_withdrawVestedTokens <= 6);\n        v3 = _withdrawVestedTokens == 6;\n    }\n    require(v3);\n    _withdrawAllocation[msg.sender] = 0;\n    v5 = msg.sender.call().value(_withdrawAllocation[msg.sender]).gas(2300 * !_withdrawAllocation[msg.sender]);\n    require(v5);\n}\n\nfunction closeSale() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 5);\n    _withdrawVestedTokens = 6;\n    require(_closeEarlyAdopters == msg.sender);\n    v0 = 40 * _supply / 100 - _tokensSold;\n    v1 = 0xf45(v0 * 75, 100, _balanceOf[_lotusWallet75Pct]);\n    _balanceOf[_lotusWallet75Pct] = v1;\n    emit Transfer(address(this), _lotusWallet75Pct, v0 * 75 / 100);\n    v2 = v3 = _balanceOf[_vc1Wallet4Pct];\n    v4 = v5 = 7320;\n    v6 = v7 = 100;\n    v8 = 25 * ((v0 << 2) / v7);\n    assert(v7);\n    while (1) {\n        v9 = v8 / v6 + v2 >= v2;\n        if (v8 / v6 + v2 >= v2) {\n            v9 = v10 = v8 / v6 + v2 >= v8 / v6;\n        }\n        if (v9) {\n            break;\n        }\n        assert(v9);\n        owner_17[_vc1Wallet4Pct] = v8 / v6 + v2;\n        v11 = 0x1c8b(v0 << 2, 100, 100, owner_17[_vc2Wallet4Pct]);\n        _balanceOf[_vc2Wallet4Pct] = v11;\n        emit Transfer(address(this), _vc2Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v12 = 0x1d13(v0 << 2, 100, 100, owner_17[_vc2Wallet4Pct]);\n        owner_17[_vc2Wallet4Pct] = v12;\n        v13 = 0x1c8b(v0 << 2, 100, 100, owner_17[_vc3Wallet4Pct]);\n        _balanceOf[_vc3Wallet4Pct] = v13;\n        emit Transfer(address(this), _vc3Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v14 = 0x1d13(v0 << 2, 100, 100, owner_17[_vc3Wallet4Pct]);\n        owner_17[_vc3Wallet4Pct] = v14;\n        v15 = 0x1c8b(v0 << 1, 100, 100, owner_17[_cf1Wallet2Pct]);\n        _balanceOf[_cf1Wallet2Pct] = v15;\n        emit Transfer(address(this), _cf1Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v16 = 0x1d13(v0 << 1, 100, 100, owner_17[_cf1Wallet2Pct]);\n        owner_17[_cf1Wallet2Pct] = v16;\n        v17 = 0x1c8b(v0 << 1, 100, 100, owner_17[_cf2Wallet2Pct]);\n        _balanceOf[_cf2Wallet2Pct] = v17;\n        emit Transfer(address(this), _cf2Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v18 = 0x1d13(v0 << 1, 100, 100, owner_17[_cf2Wallet2Pct]);\n        owner_17[_cf2Wallet2Pct] = v18;\n        v19 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev1Wallet2Pct]);\n        _balanceOf[_dev1Wallet2Pct] = v19;\n        emit Transfer(address(this), _dev1Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v20 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev1Wallet2Pct]);\n        owner_17[_dev1Wallet2Pct] = v20;\n        v21 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev2Wallet2Pct]);\n        _balanceOf[_dev2Wallet2Pct] = v21;\n        emit Transfer(address(this), _dev2Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v22 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev2Wallet2Pct]);\n        owner_17[_dev2Wallet2Pct] = v22;\n        v23 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev3Wallet2Pct]);\n        _balanceOf[_dev3Wallet2Pct] = v23;\n        emit Transfer(address(this), _dev3Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v24 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev3Wallet2Pct]);\n        owner_17[_dev3Wallet2Pct] = v24;\n        v25 = 0x1c8b(v0, 100, 100, owner_17[_preicobrandingWallet1Pct]);\n        _balanceOf[_preicobrandingWallet1Pct] = v25;\n        emit Transfer(address(this), _preicobrandingWallet1Pct, v0 / 100 * 25 / 100);\n        v26 = 0x1d13(v0, 100, 100, owner_17[_preicobrandingWallet1Pct]);\n        owner_17[_preicobrandingWallet1Pct] = v26;\n        v27 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev4Wallet2Pct]);\n        _balanceOf[_dev4Wallet2Pct] = v27;\n        emit Transfer(address(this), _dev4Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v28 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev4Wallet2Pct]);\n        owner_17[_dev4Wallet2Pct] = v28;\n        v29 = _SafeAdd(55 * _supply / 100, owner_17[_lotusWallet75Pct]);\n        _balanceOf[_lotusWallet75Pct] = v29;\n        emit Transfer(address(this), _lotusWallet75Pct, 55 * _supply / 100);\n        v30 = _SafeAdd(5 * _supply / 100, _balanceOf[_airdropWallet5Pct]);\n        _balanceOf[_airdropWallet5Pct] = v30;\n        emit Transfer(address(this), _airdropWallet5Pct, 5 * _supply / 100);\n        _cliff = block.timestamp + 0xed4e00;\n        exit;\n        goto {'0x1d20', '0x1c98'};\n        _balanceOf[_vc1Wallet4Pct] = v8 / v6 + v2;\n        emit Transfer(address(this), _vc1Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v2 = v31 = owner_17[_vc1Wallet4Pct];\n        v4 = v32 = 7456;\n        v6 = v33 = 100;\n        v8 = v34 = 75 * ((v0 << 2) / v33);\n        assert(v33);\n    }\n}\n\nfunction vc2Wallet4Pct() public nonPayable { \n    return _vc2Wallet4Pct;\n}\n\nfunction 0x7fd() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_28;\n            }\n        } else {\n            v0 = v7 = stor_22;\n        }\n    } else {\n        v0 = v8 = stor_1c;\n    }\n    return v0;\n}\n\nfunction 0x8b9() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_29;\n            }\n        } else {\n            v0 = v7 = stor_23;\n        }\n    } else {\n        v0 = v8 = stor_1d;\n    }\n    return v0;\n}\n\nfunction 0x976() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_26;\n            }\n        } else {\n            v0 = v7 = stor_20;\n        }\n    } else {\n        v0 = v8 = stor_1a;\n    }\n    return v0;\n}\n\nfunction 0xa33() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = _iCO_TWO;\n            }\n        } else {\n            v0 = v7 = _iCO_ONE;\n        }\n    } else {\n        v0 = v8 = _eARLYADOPTERS;\n    }\n    return v0;\n}\n\nfunction 0xaf0() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_27;\n            }\n        } else {\n            v0 = v7 = stor_21;\n        }\n    } else {\n        v0 = v8 = stor_1b;\n    }\n    return v0;\n}\n\nfunction 0xbad() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_2a;\n            }\n        } else {\n            v0 = v7 = stor_24;\n        }\n    } else {\n        v0 = v8 = stor_1e;\n    }\n    return v0;\n}\n\nfunction 0xc6a() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = owner_2d[msg.sender];\n            }\n        } else {\n            v0 = v7 = owner_2c[msg.sender];\n        }\n    } else {\n        v0 = v8 = owner_2b[msg.sender];\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\nfunction 0xf45(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    v1 = v0 + varg2;\n    v2 = v1 < varg2;\n    v3 = v1 >= varg2;\n    if (v1 >= varg2) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xfdc73f) {\n            currentMinPurchase();\n        } else if (0x47fc9aa == function_selector) {\n            supply();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc26ac30 == function_selector) {\n            closeEarlyAdopters();\n        } else if (0xfac20e1 == function_selector) {\n            dev1Wallet2Pct();\n        } else if (0x13d033c0 == function_selector) {\n            cliff();\n        } else if (0x1615d035 == function_selector) {\n            airdropWallet5Pct();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2a18ca16 == function_selector) {\n            currentSaleLimit();\n        } else if (0x2ca1aa16 == function_selector) {\n            currentSaleLimitPerAddress();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x341cc817 == function_selector) {\n            preicobrandingWallet1Pct();\n        } else if (0x39f05521 == function_selector) {\n            withdrawVestedTokens();\n        } else if (0x3be1c410 == function_selector) {\n            dev2Wallet2Pct();\n        } else if (0x3dbae9f9 == function_selector) {\n            startIcoTwo();\n        } else if (0x4266806b == function_selector) {\n            cf1Wallet2Pct();\n        } else if (0x518ab2a8 == function_selector) {\n            tokensSold();\n        } else if (0x66005ede == function_selector) {\n            vc1Wallet4Pct();\n        } else if (0x6f3ad341 == function_selector) {\n            ICO_ONE();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x90427b6c == function_selector) {\n            dev4Wallet2Pct();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa0695fc2 == function_selector) {\n            startIcoOne();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xac7b986f == function_selector) {\n            lotusWallet75Pct();\n        } else if (0xaf0638f6 == function_selector) {\n            currentMaxPurchase();\n        } else if (0xb154f47c == function_selector) {\n            dev3Wallet2Pct();\n        } else if (0xbb814746 == function_selector) {\n            ICO_TWO();\n        } else if (0xc2d25167 == function_selector) {\n            closeIcoOne();\n        } else if (0xc467706d == function_selector) {\n            startEarlyAdopters();\n        } else if (0xcb6b1f05 == function_selector) {\n            cf2Wallet2Pct();\n        } else if (0xd042ce2c == function_selector) {\n            currentStageTokensBoughtByAddress();\n        } else if (0xdcd6561d == function_selector) {\n            currentSaleSold();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xdef1a2da == function_selector) {\n            vc3Wallet4Pct();\n        } else if (0xe50e2f65 == function_selector) {\n            EARLYADOPTERS();\n        } else if (0xeb570b05 == function_selector) {\n            currentSalePriceInWei();\n        } else if (0xee224707 == function_selector) {\n            withdrawAllocation();\n        } else if (0xee55efee == function_selector) {\n            closeSale();\n        } else if (0xf3635a02 == function_selector) {\n            vc2Wallet4Pct();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 11:15 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _supply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5]\nuint256 _cliff; // STORAGE[0x7]\nuint256 _tokensSold; // STORAGE[0x15]\nmapping (uint256 => [uint256]) _withdrawAllocation; // STORAGE[0x16]\nmapping (uint256 => [uint256]) owner_17; // STORAGE[0x17]\nmapping (uint256 => [uint256]) owner_18; // STORAGE[0x18]\nuint256 _eARLYADOPTERS; // STORAGE[0x19]\nuint256 stor_1a; // STORAGE[0x1a]\nuint256 stor_1b; // STORAGE[0x1b]\nuint256 stor_1c; // STORAGE[0x1c]\nuint256 stor_1d; // STORAGE[0x1d]\nuint256 stor_1e; // STORAGE[0x1e]\nuint256 _iCO_ONE; // STORAGE[0x1f]\nuint256 stor_20; // STORAGE[0x20]\nuint256 stor_21; // STORAGE[0x21]\nuint256 stor_22; // STORAGE[0x22]\nuint256 stor_23; // STORAGE[0x23]\nuint256 stor_24; // STORAGE[0x24]\nuint256 _iCO_TWO; // STORAGE[0x25]\nuint256 stor_26; // STORAGE[0x26]\nuint256 stor_27; // STORAGE[0x27]\nuint256 stor_28; // STORAGE[0x28]\nuint256 stor_29; // STORAGE[0x29]\nuint256 stor_2a; // STORAGE[0x2a]\nmapping (uint256 => [uint256]) owner_2b; // STORAGE[0x2b]\nmapping (uint256 => [uint256]) owner_2c; // STORAGE[0x2c]\nmapping (uint256 => [uint256]) owner_2d; // STORAGE[0x2d]\nuint8 stor_8_0_0; // STORAGE[0x8] bytes 0 to 0\nuint8 _withdrawVestedTokens; // STORAGE[0x2e] bytes 0 to 0\naddress _closeEarlyAdopters; // STORAGE[0x6] bytes 0 to 19\nuint160 _vc1Wallet4Pct; // STORAGE[0x9] bytes 0 to 19\nuint160 _vc2Wallet4Pct; // STORAGE[0xa] bytes 0 to 19\nuint160 _vc3Wallet4Pct; // STORAGE[0xb] bytes 0 to 19\nuint160 _cf1Wallet2Pct; // STORAGE[0xc] bytes 0 to 19\nuint160 _cf2Wallet2Pct; // STORAGE[0xd] bytes 0 to 19\nuint160 _dev1Wallet2Pct; // STORAGE[0xe] bytes 0 to 19\nuint160 _dev2Wallet2Pct; // STORAGE[0xf] bytes 0 to 19\nuint160 _dev3Wallet2Pct; // STORAGE[0x10] bytes 0 to 19\nuint160 _dev4Wallet2Pct; // STORAGE[0x11] bytes 0 to 19\nuint160 _preicobrandingWallet1Pct; // STORAGE[0x12] bytes 0 to 19\naddress _lotusWallet75Pct; // STORAGE[0x13] bytes 0 to 19\nuint160 _airdropWallet5Pct; // STORAGE[0x14] bytes 0 to 19\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x1c8b(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg2);\n    v0 = 25 * (varg0 / varg1) / varg2;\n    v1 = v0 + varg3;\n    v2 = v1 < varg3;\n    v3 = v1 >= varg3;\n    if (v1 >= varg3) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\nfunction 0x1d13(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    assert(varg2);\n    v0 = 75 * (varg0 / varg1) / varg2;\n    v1 = v0 + varg3;\n    v2 = v1 < varg3;\n    v3 = v1 >= varg3;\n    if (v1 >= varg3) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\nfunction fallback() public payable { \n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v2 = _withdrawVestedTokens == 3;\n    }\n    if (!v0) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v3 = _withdrawVestedTokens == 5;\n    }\n    require(v0);\n    require(msg.value > 0);\n    v4 = 0x7fd();\n    v5 = v6 = msg.value >= v4;\n    if (v6) {\n        v7 = 0x8b9();\n        v5 = v8 = msg.value <= v7;\n    }\n    require(v5);\n    v9 = 0x976();\n    v10 = 0xa33();\n    v11 = 0xaf0();\n    v12 = 0xbad();\n    v13 = 0xc6a();\n    assert(v9);\n    v14 = msg.value / v9 * 10 ** _decimals;\n    require(v14 + v11 <= v10);\n    require(v13 + v14 <= v12);\n    v15 = _SafeAdd(v14, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v15;\n    v16 = _SafeAdd(v14, _tokensSold);\n    _tokensSold = v16;\n    assert(_withdrawVestedTokens <= 6);\n    v17 = v18 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v17 = v19 = _withdrawVestedTokens == 3;\n    }\n    if (!v17) {\n        assert(_withdrawVestedTokens <= 6);\n        v17 = _withdrawVestedTokens == 5;\n    }\n    require(v17);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v20 = _SafeAdd(v14, stor_27);\n                stor_27 = v20;\n                v21 = _SafeAdd(v14, owner_2d[msg.sender]);\n                owner_2d[msg.sender] = v21;\n            }\n        } else {\n            v22 = _SafeAdd(v14, stor_21);\n            stor_21 = v22;\n            v23 = _SafeAdd(v14, owner_2c[msg.sender]);\n            owner_2c[msg.sender] = v23;\n        }\n    } else {\n        v24 = _SafeAdd(v14, stor_1b);\n        stor_1b = v24;\n        v25 = _SafeAdd(v14, owner_2b[msg.sender]);\n        owner_2b[msg.sender] = v25;\n    }\n    v26 = (msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= _withdrawAllocation[_vc1Wallet4Pct];\n    if ((msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= _withdrawAllocation[_vc1Wallet4Pct]) {\n        v26 = v27 = (msg.value << 2) / 100 + _withdrawAllocation[_vc1Wallet4Pct] >= (msg.value << 2) / 100;\n    }\n    assert(v26);\n    _withdrawAllocation[_vc1Wallet4Pct] += (msg.value << 2) / 100;\n    v28 = 0xf45(msg.value << 2, 100, _withdrawAllocation[_vc2Wallet4Pct]);\n    _withdrawAllocation[_vc2Wallet4Pct] = v28;\n    v29 = 0xf45(msg.value << 2, 100, _withdrawAllocation[_vc3Wallet4Pct]);\n    _withdrawAllocation[_vc3Wallet4Pct] = v29;\n    v30 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_cf1Wallet2Pct]);\n    _withdrawAllocation[_cf1Wallet2Pct] = v30;\n    v31 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_cf2Wallet2Pct]);\n    _withdrawAllocation[_cf2Wallet2Pct] = v31;\n    v32 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev1Wallet2Pct]);\n    _withdrawAllocation[_dev1Wallet2Pct] = v32;\n    v33 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev3Wallet2Pct]);\n    _withdrawAllocation[_dev3Wallet2Pct] = v33;\n    v34 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev2Wallet2Pct]);\n    _withdrawAllocation[_dev2Wallet2Pct] = v34;\n    v35 = 0xf45(msg.value << 1, 100, _withdrawAllocation[_dev4Wallet2Pct]);\n    _withdrawAllocation[_dev4Wallet2Pct] = v35;\n    v36 = 0xf45(msg.value, 100, _withdrawAllocation[_preicobrandingWallet1Pct]);\n    _withdrawAllocation[_preicobrandingWallet1Pct] = v36;\n    v37 = 0xf45(msg.value * 75, 100, _withdrawAllocation[_lotusWallet75Pct]);\n    _withdrawAllocation[_lotusWallet75Pct] = v37;\n    emit Transfer(address(this), msg.sender, v14);\n}\n\nfunction currentMinPurchase() public nonPayable { \n    v0 = 0x7fd();\n    return v0;\n}\n\nfunction supply() public nonPayable { \n    return _supply;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = !varg1;\n    if (varg1) {\n        v0 = v2 = !_allowance[varg0];\n    }\n    require(v0);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction closeEarlyAdopters() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 1);\n    _withdrawVestedTokens = 2;\n}\n\nfunction dev1Wallet2Pct() public nonPayable { \n    return _dev1Wallet2Pct;\n}\n\nfunction cliff() public nonPayable { \n    return _cliff;\n}\n\nfunction airdropWallet5Pct() public nonPayable { \n    return _airdropWallet5Pct;\n}\n\nfunction totalSupply() public nonPayable { \n    return _supply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(_balanceOf[varg0] >= varg2);\n    require(_allowance[msg.sender] >= varg2);\n    require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);\n    v0 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v0;\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction currentSaleLimit() public nonPayable { \n    v0 = 0xa33();\n    return v0;\n}\n\nfunction currentSaleLimitPerAddress() public nonPayable { \n    v0 = 0xbad();\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction preicobrandingWallet1Pct() public nonPayable { \n    return _preicobrandingWallet1Pct;\n}\n\nfunction withdrawVestedTokens() public nonPayable { \n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 6);\n    require(_cliff > 0);\n    require(block.timestamp >= _cliff);\n    require(owner_18[msg.sender] < owner_17[msg.sender]);\n    assert(stor_8_0_0);\n    v0 = owner_17[msg.sender] / 15 * (1 + (block.timestamp - _cliff) / STORAGE[8]) - owner_18[msg.sender];\n    v1 = _SafeAdd(v0, owner_18[msg.sender]);\n    owner_18[msg.sender] = v1;\n    v2 = _SafeAdd(v0, owner_18[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    emit Transfer(address(this), msg.sender, v0);\n}\n\nfunction dev2Wallet2Pct() public nonPayable { \n    return _dev2Wallet2Pct;\n}\n\nfunction startIcoTwo() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 3;\n    if (_withdrawVestedTokens != 3) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 4;\n    }\n    require(v0);\n    _withdrawVestedTokens = 5;\n}\n\nfunction cf1Wallet2Pct() public nonPayable { \n    return _cf1Wallet2Pct;\n}\n\nfunction tokensSold() public nonPayable { \n    return _tokensSold;\n}\n\nfunction vc1Wallet4Pct() public nonPayable { \n    return _vc1Wallet4Pct;\n}\n\nfunction ICO_ONE() public nonPayable { \n    return _iCO_ONE, stor_20, stor_21, stor_22, stor_23, stor_24;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction dev4Wallet2Pct() public nonPayable { \n    return _dev4Wallet2Pct;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction startIcoOne() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 2;\n    }\n    require(v0);\n    _withdrawVestedTokens = 3;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 > _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    v0 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction lotusWallet75Pct() public nonPayable { \n    return _lotusWallet75Pct;\n}\n\nfunction currentMaxPurchase() public nonPayable { \n    v0 = 0x8b9();\n    return v0;\n}\n\nfunction dev3Wallet2Pct() public nonPayable { \n    return _dev3Wallet2Pct;\n}\n\nfunction ICO_TWO() public nonPayable { \n    return _iCO_TWO, stor_26, stor_27, stor_28, stor_29, stor_2a;\n}\n\nfunction closeIcoOne() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 3);\n    _withdrawVestedTokens = 4;\n}\n\nfunction startEarlyAdopters() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 0);\n    _withdrawVestedTokens = 1;\n}\n\nfunction cf2Wallet2Pct() public nonPayable { \n    return _cf2Wallet2Pct;\n}\n\nfunction currentStageTokensBoughtByAddress() public nonPayable { \n    v0 = 0xc6a();\n    return v0;\n}\n\nfunction currentSaleSold() public nonPayable { \n    v0 = 0xaf0();\n    return v0;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction vc3Wallet4Pct() public nonPayable { \n    return _vc3Wallet4Pct;\n}\n\nfunction EARLYADOPTERS() public nonPayable { \n    return _eARLYADOPTERS, stor_1a, stor_1b, stor_1c, stor_1d, stor_1e;\n}\n\nfunction currentSalePriceInWei() public nonPayable { \n    v0 = 0x976();\n    return v0;\n}\n\nfunction withdrawAllocation() public nonPayable { \n    require(_withdrawAllocation[msg.sender] > 0);\n    assert(_withdrawVestedTokens <= 6);\n    v0 = v1 = _withdrawVestedTokens == 2;\n    if (_withdrawVestedTokens != 2) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = v2 = _withdrawVestedTokens == 4;\n    }\n    if (!v0) {\n        assert(_withdrawVestedTokens <= 6);\n        v0 = _withdrawVestedTokens == 6;\n    }\n    require(v0);\n    v3 = v4 = _lotusWallet75Pct != msg.sender;\n    if (_lotusWallet75Pct == msg.sender) {\n        assert(_withdrawVestedTokens <= 6);\n        v3 = _withdrawVestedTokens == 6;\n    }\n    require(v3);\n    _withdrawAllocation[msg.sender] = 0;\n    v5 = msg.sender.call().value(_withdrawAllocation[msg.sender]).gas(2300 * !_withdrawAllocation[msg.sender]);\n    require(v5);\n}\n\nfunction closeSale() public nonPayable { \n    require(_closeEarlyAdopters == msg.sender);\n    assert(_withdrawVestedTokens <= 6);\n    require(_withdrawVestedTokens == 5);\n    _withdrawVestedTokens = 6;\n    require(_closeEarlyAdopters == msg.sender);\n    v0 = 40 * _supply / 100 - _tokensSold;\n    v1 = 0xf45(v0 * 75, 100, _balanceOf[_lotusWallet75Pct]);\n    _balanceOf[_lotusWallet75Pct] = v1;\n    emit Transfer(address(this), _lotusWallet75Pct, v0 * 75 / 100);\n    v2 = v3 = _balanceOf[_vc1Wallet4Pct];\n    v4 = v5 = 7320;\n    v6 = v7 = 100;\n    v8 = 25 * ((v0 << 2) / v7);\n    assert(v7);\n    while (1) {\n        v9 = v8 / v6 + v2 >= v2;\n        if (v8 / v6 + v2 >= v2) {\n            v9 = v10 = v8 / v6 + v2 >= v8 / v6;\n        }\n        if (v9) {\n            break;\n        }\n        assert(v9);\n        owner_17[_vc1Wallet4Pct] = v8 / v6 + v2;\n        v11 = 0x1c8b(v0 << 2, 100, 100, owner_17[_vc2Wallet4Pct]);\n        _balanceOf[_vc2Wallet4Pct] = v11;\n        emit Transfer(address(this), _vc2Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v12 = 0x1d13(v0 << 2, 100, 100, owner_17[_vc2Wallet4Pct]);\n        owner_17[_vc2Wallet4Pct] = v12;\n        v13 = 0x1c8b(v0 << 2, 100, 100, owner_17[_vc3Wallet4Pct]);\n        _balanceOf[_vc3Wallet4Pct] = v13;\n        emit Transfer(address(this), _vc3Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v14 = 0x1d13(v0 << 2, 100, 100, owner_17[_vc3Wallet4Pct]);\n        owner_17[_vc3Wallet4Pct] = v14;\n        v15 = 0x1c8b(v0 << 1, 100, 100, owner_17[_cf1Wallet2Pct]);\n        _balanceOf[_cf1Wallet2Pct] = v15;\n        emit Transfer(address(this), _cf1Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v16 = 0x1d13(v0 << 1, 100, 100, owner_17[_cf1Wallet2Pct]);\n        owner_17[_cf1Wallet2Pct] = v16;\n        v17 = 0x1c8b(v0 << 1, 100, 100, owner_17[_cf2Wallet2Pct]);\n        _balanceOf[_cf2Wallet2Pct] = v17;\n        emit Transfer(address(this), _cf2Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v18 = 0x1d13(v0 << 1, 100, 100, owner_17[_cf2Wallet2Pct]);\n        owner_17[_cf2Wallet2Pct] = v18;\n        v19 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev1Wallet2Pct]);\n        _balanceOf[_dev1Wallet2Pct] = v19;\n        emit Transfer(address(this), _dev1Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v20 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev1Wallet2Pct]);\n        owner_17[_dev1Wallet2Pct] = v20;\n        v21 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev2Wallet2Pct]);\n        _balanceOf[_dev2Wallet2Pct] = v21;\n        emit Transfer(address(this), _dev2Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v22 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev2Wallet2Pct]);\n        owner_17[_dev2Wallet2Pct] = v22;\n        v23 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev3Wallet2Pct]);\n        _balanceOf[_dev3Wallet2Pct] = v23;\n        emit Transfer(address(this), _dev3Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v24 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev3Wallet2Pct]);\n        owner_17[_dev3Wallet2Pct] = v24;\n        v25 = 0x1c8b(v0, 100, 100, owner_17[_preicobrandingWallet1Pct]);\n        _balanceOf[_preicobrandingWallet1Pct] = v25;\n        emit Transfer(address(this), _preicobrandingWallet1Pct, v0 / 100 * 25 / 100);\n        v26 = 0x1d13(v0, 100, 100, owner_17[_preicobrandingWallet1Pct]);\n        owner_17[_preicobrandingWallet1Pct] = v26;\n        v27 = 0x1c8b(v0 << 1, 100, 100, owner_17[_dev4Wallet2Pct]);\n        _balanceOf[_dev4Wallet2Pct] = v27;\n        emit Transfer(address(this), _dev4Wallet2Pct, (v0 << 1) / 100 * 25 / 100);\n        v28 = 0x1d13(v0 << 1, 100, 100, owner_17[_dev4Wallet2Pct]);\n        owner_17[_dev4Wallet2Pct] = v28;\n        v29 = _SafeAdd(55 * _supply / 100, owner_17[_lotusWallet75Pct]);\n        _balanceOf[_lotusWallet75Pct] = v29;\n        emit Transfer(address(this), _lotusWallet75Pct, 55 * _supply / 100);\n        v30 = _SafeAdd(5 * _supply / 100, _balanceOf[_airdropWallet5Pct]);\n        _balanceOf[_airdropWallet5Pct] = v30;\n        emit Transfer(address(this), _airdropWallet5Pct, 5 * _supply / 100);\n        _cliff = block.timestamp + 0xed4e00;\n        exit;\n        goto {'0x1d20', '0x1c98'};\n        _balanceOf[_vc1Wallet4Pct] = v8 / v6 + v2;\n        emit Transfer(address(this), _vc1Wallet4Pct, (v0 << 2) / 100 * 25 / 100);\n        v2 = v31 = owner_17[_vc1Wallet4Pct];\n        v4 = v32 = 7456;\n        v6 = v33 = 100;\n        v8 = v34 = 75 * ((v0 << 2) / v33);\n        assert(v33);\n    }\n}\n\nfunction vc2Wallet4Pct() public nonPayable { \n    return _vc2Wallet4Pct;\n}\n\nfunction 0x7fd() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_28;\n            }\n        } else {\n            v0 = v7 = stor_22;\n        }\n    } else {\n        v0 = v8 = stor_1c;\n    }\n    return v0;\n}\n\nfunction 0x8b9() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_29;\n            }\n        } else {\n            v0 = v7 = stor_23;\n        }\n    } else {\n        v0 = v8 = stor_1d;\n    }\n    return v0;\n}\n\nfunction 0x976() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_26;\n            }\n        } else {\n            v0 = v7 = stor_20;\n        }\n    } else {\n        v0 = v8 = stor_1a;\n    }\n    return v0;\n}\n\nfunction 0xa33() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = _iCO_TWO;\n            }\n        } else {\n            v0 = v7 = _iCO_ONE;\n        }\n    } else {\n        v0 = v8 = _eARLYADOPTERS;\n    }\n    return v0;\n}\n\nfunction 0xaf0() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_27;\n            }\n        } else {\n            v0 = v7 = stor_21;\n        }\n    } else {\n        v0 = v8 = stor_1b;\n    }\n    return v0;\n}\n\nfunction 0xbad() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = stor_2a;\n            }\n        } else {\n            v0 = v7 = stor_24;\n        }\n    } else {\n        v0 = v8 = stor_1e;\n    }\n    return v0;\n}\n\nfunction 0xc6a() private { \n    v0 = v1 = 0;\n    assert(_withdrawVestedTokens <= 6);\n    v2 = v3 = _withdrawVestedTokens == 1;\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v4 = _withdrawVestedTokens == 3;\n    }\n    if (!v2) {\n        assert(_withdrawVestedTokens <= 6);\n        v2 = v5 = _withdrawVestedTokens == 5;\n    }\n    require(v2);\n    assert(_withdrawVestedTokens <= 6);\n    if (_withdrawVestedTokens != 1) {\n        assert(_withdrawVestedTokens <= 6);\n        if (_withdrawVestedTokens != 3) {\n            assert(_withdrawVestedTokens <= 6);\n            if (_withdrawVestedTokens == 5) {\n                v0 = v6 = owner_2d[msg.sender];\n            }\n        } else {\n            v0 = v7 = owner_2c[msg.sender];\n        }\n    } else {\n        v0 = v8 = owner_2b[msg.sender];\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\nfunction 0xf45(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg0 / varg1;\n    v1 = v0 + varg2;\n    v2 = v1 < varg2;\n    v3 = v1 >= varg2;\n    if (v1 >= varg2) {\n        v3 = v4 = v1 >= v0;\n    }\n    assert(v3);\n    return v1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xfdc73f) {\n            currentMinPurchase();\n        } else if (0x47fc9aa == function_selector) {\n            supply();\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0xc26ac30 == function_selector) {\n            closeEarlyAdopters();\n        } else if (0xfac20e1 == function_selector) {\n            dev1Wallet2Pct();\n        } else if (0x13d033c0 == function_selector) {\n            cliff();\n        } else if (0x1615d035 == function_selector) {\n            airdropWallet5Pct();\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2a18ca16 == function_selector) {\n            currentSaleLimit();\n        } else if (0x2ca1aa16 == function_selector) {\n            currentSaleLimitPerAddress();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x341cc817 == function_selector) {\n            preicobrandingWallet1Pct();\n        } else if (0x39f05521 == function_selector) {\n            withdrawVestedTokens();\n        } else if (0x3be1c410 == function_selector) {\n            dev2Wallet2Pct();\n        } else if (0x3dbae9f9 == function_selector) {\n            startIcoTwo();\n        } else if (0x4266806b == function_selector) {\n            cf1Wallet2Pct();\n        } else if (0x518ab2a8 == function_selector) {\n            tokensSold();\n        } else if (0x66005ede == function_selector) {\n            vc1Wallet4Pct();\n        } else if (0x6f3ad341 == function_selector) {\n            ICO_ONE();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x90427b6c == function_selector) {\n            dev4Wallet2Pct();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa0695fc2 == function_selector) {\n            startIcoOne();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xac7b986f == function_selector) {\n            lotusWallet75Pct();\n        } else if (0xaf0638f6 == function_selector) {\n            currentMaxPurchase();\n        } else if (0xb154f47c == function_selector) {\n            dev3Wallet2Pct();\n        } else if (0xbb814746 == function_selector) {\n            ICO_TWO();\n        } else if (0xc2d25167 == function_selector) {\n            closeIcoOne();\n        } else if (0xc467706d == function_selector) {\n            startEarlyAdopters();\n        } else if (0xcb6b1f05 == function_selector) {\n            cf2Wallet2Pct();\n        } else if (0xd042ce2c == function_selector) {\n            currentStageTokensBoughtByAddress();\n        } else if (0xdcd6561d == function_selector) {\n            currentSaleSold();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xdef1a2da == function_selector) {\n            vc3Wallet4Pct();\n        } else if (0xe50e2f65 == function_selector) {\n            EARLYADOPTERS();\n        } else if (0xeb570b05 == function_selector) {\n            currentSalePriceInWei();\n        } else if (0xee224707 == function_selector) {\n            withdrawAllocation();\n        } else if (0xee55efee == function_selector) {\n            closeSale();\n        } else if (0xf3635a02 == function_selector) {\n            vc2Wallet4Pct();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 50.73517680168152,
	"usage": {
		"completion_tokens": 661,
		"prompt_tokens": 9729,
		"total_tokens": 10390
	}
}