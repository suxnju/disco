{
	"address": "0x41634a7cb08ee639a751973e63577ddcfe9e7101",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The provided decompiled code seems to be from a token smart contract with some custom functionality such as `sellOne`, `buyOne`, `getPrice` and safe math functions. However, the code seems to be incomplete or incorrectly decompiled as there are several syntax errors and unexplained variables. \n\nPlease note that it's not possible to write a perfect contract code with exact behaviors according to this decompiled code. However, here is a basic interpretation in Solidity:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Token {\n    mapping (address => uint256) private _balances;\n    uint256 private _totalSupply;\n    uint8 private _decimals;\n    string private _symbol;\n    string private _name;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function sellOne() public {\n        require(_balances[msg.sender] >= 1);\n        _balances[msg.sender] -= 1;\n        _balances[address(this)] += 1;\n        emit Transfer(msg.sender, address(this), 1);\n        // Some complex computation and external calls are omitted for simplicity\n    }\n\n    function name() public view returns(string memory) {\n        return _name;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        _allowances[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowances[from][msg.sender]);\n        \n        _balances[from] -= value;\n        _balances[to] += value;\n        _allowances[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function buyOne() public payable {\n        require(msg.value == _totalSupply - _balances[address(this)], 'Wrong amount');\n        require(_balances[address(this)] >= 1);\n\n        _balances[address(this)] -= 1;\n        _balances[msg.sender] += 1;\n        emit Transfer(address(this), msg.sender, 1);\n        // Complex computation and external calls are again omitted for simplicity\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return _totalSupply - _balances[address(this)];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n}\n```\nThis is a simplified version and may not represent the full functionality of the original contract. Also, the code above is provided as an example and not recommended for production use without further testing and security measures.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457048,
	"id": "chatcmpl-8R2zYvc50zpD9QLsqPT4BPX1ovDpV",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.17 08:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256 __totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction sellOne() public nonPayable { \n    require(1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - 1;\n    require(_totalSupply[address(this)] + 1 >= _totalSupply[address(this)]);\n    _totalSupply[address(this)] = _totalSupply[address(this)] + 1;\n    emit Transfer(msg.sender, address(this), 1);\n    v0 = msg.sender.call().value((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000 - ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10).gas(!((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000 - ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = stor_4_0_19.call().value(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10).gas(!(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply - _totalSupply[0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _totalSupply[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction buyOne() public payable { \n    require(msg.value == (__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 + ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10, 'Wrong amount');\n    require(1 <= _totalSupply[address(this)]);\n    _totalSupply[address(this)] = _totalSupply[address(this)] - 1;\n    require(_totalSupply[msg.sender] + 1 >= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] + 1;\n    emit Transfer(address(this), msg.sender, 1);\n    v0 = stor_4_0_19.call().value(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10).gas(!(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _totalSupply[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getPrice() public nonPayable { \n    return (__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= varg0);\n    return varg0 - varg1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg1;\n    require(_totalSupply[varg0] + varg1 >= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction safeDiv(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 > 0);\n    assert(varg1);\n    return varg0 / varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        assert(varg0);\n        v0 = v2 = varg0 * varg1 / varg0 == varg1;\n    }\n    require(v0);\n    return varg0 * varg1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 + varg1 >= varg0);\n    return varg0 + varg1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x5091752 == function_selector >> 224) {\n                    sellOne();\n                } else if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x3eaaf86b == function_selector >> 224) {\n                _totalSupply();\n            } else if (0x6b5e2896 == function_selector >> 224) {\n                buyOne();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0x98d5fdca == function_selector >> 224) {\n                getPrice();\n            } else if (0xa293d1e8 == function_selector >> 224) {\n                safeSub(uint256,uint256);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xb5931f7c == function_selector >> 224) {\n            safeDiv(uint256,uint256);\n        } else if (0xd05c78da == function_selector >> 224) {\n            safeMul(uint256,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe6cb9013 == function_selector >> 224) {\n            safeAdd(uint256,uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.17 08:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256 __totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction sellOne() public nonPayable { \n    require(1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - 1;\n    require(_totalSupply[address(this)] + 1 >= _totalSupply[address(this)]);\n    _totalSupply[address(this)] = _totalSupply[address(this)] + 1;\n    emit Transfer(msg.sender, address(this), 1);\n    v0 = msg.sender.call().value((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000 - ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10).gas(!((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000 - ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = stor_4_0_19.call().value(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10).gas(!(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply - _totalSupply[0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _totalSupply[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction buyOne() public payable { \n    require(msg.value == (__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 + ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10, 'Wrong amount');\n    require(1 <= _totalSupply[address(this)]);\n    _totalSupply[address(this)] = _totalSupply[address(this)] - 1;\n    require(_totalSupply[msg.sender] + 1 >= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] + 1;\n    emit Transfer(address(this), msg.sender, 1);\n    v0 = stor_4_0_19.call().value(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10).gas(!(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _totalSupply[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getPrice() public nonPayable { \n    return (__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= varg0);\n    return varg0 - varg1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg1;\n    require(_totalSupply[varg0] + varg1 >= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction safeDiv(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 > 0);\n    assert(varg1);\n    return varg0 / varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        assert(varg0);\n        v0 = v2 = varg0 * varg1 / varg0 == varg1;\n    }\n    require(v0);\n    return varg0 * varg1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 + varg1 >= varg0);\n    return varg0 + varg1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x5091752 == function_selector >> 224) {\n                    sellOne();\n                } else if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x3eaaf86b == function_selector >> 224) {\n                _totalSupply();\n            } else if (0x6b5e2896 == function_selector >> 224) {\n                buyOne();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0x98d5fdca == function_selector >> 224) {\n                getPrice();\n            } else if (0xa293d1e8 == function_selector >> 224) {\n                safeSub(uint256,uint256);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xb5931f7c == function_selector >> 224) {\n            safeDiv(uint256,uint256);\n        } else if (0xd05c78da == function_selector >> 224) {\n            safeMul(uint256,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe6cb9013 == function_selector >> 224) {\n            safeAdd(uint256,uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.17 08:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _symbol; // STORAGE[0x0]\nuint256[] _name; // STORAGE[0x1]\nuint256 __totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _totalSupply; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction sellOne() public nonPayable { \n    require(1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - 1;\n    require(_totalSupply[address(this)] + 1 >= _totalSupply[address(this)]);\n    _totalSupply[address(this)] = _totalSupply[address(this)] + 1;\n    emit Transfer(msg.sender, address(this), 1);\n    v0 = msg.sender.call().value((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000 - ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10).gas(!((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000 - ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    v1 = stor_4_0_19.call().value(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10).gas(!(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 - 0x5af3107a4000) / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return __totalSupply - _totalSupply[0];\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg2 <= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] - varg2;\n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    require(_allowance[varg1] + varg2 >= _allowance[varg1]);\n    _totalSupply[varg1] = _allowance[varg1] + varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction _totalSupply() public nonPayable { \n    return __totalSupply;\n}\n\nfunction buyOne() public payable { \n    require(msg.value == (__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000 + ((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10, 'Wrong amount');\n    require(1 <= _totalSupply[address(this)]);\n    _totalSupply[address(this)] = _totalSupply[address(this)] - 1;\n    require(_totalSupply[msg.sender] + 1 >= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] + 1;\n    emit Transfer(address(this), msg.sender, 1);\n    v0 = stor_4_0_19.call().value(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10).gas(!(((__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000) / 10) * 2300);\n    require(v0); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _totalSupply[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction getPrice() public nonPayable { \n    return (__totalSupply - _totalSupply[address(this)]) * 0x5af3107a4000 + 0x16345785d8a0000;\n}\n\nfunction safeSub(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= varg0);\n    return varg0 - varg1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 <= _totalSupply[msg.sender]);\n    _totalSupply[msg.sender] = _totalSupply[msg.sender] - varg1;\n    require(_totalSupply[varg0] + varg1 >= _totalSupply[varg0]);\n    _totalSupply[varg0] = _totalSupply[varg0] + varg1;\n    emit Transfer(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction safeDiv(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 > 0);\n    assert(varg1);\n    return varg0 / varg1;\n}\n\nfunction safeMul(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        assert(varg0);\n        v0 = v2 = varg0 * varg1 / varg0 == varg1;\n    }\n    require(v0);\n    return varg0 * varg1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction safeAdd(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 + varg1 >= varg0);\n    return varg0 + varg1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x70a08231 > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x5091752 == function_selector >> 224) {\n                    sellOne();\n                } else if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x3eaaf86b == function_selector >> 224) {\n                _totalSupply();\n            } else if (0x6b5e2896 == function_selector >> 224) {\n                buyOne();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0x98d5fdca == function_selector >> 224) {\n                getPrice();\n            } else if (0xa293d1e8 == function_selector >> 224) {\n                safeSub(uint256,uint256);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xb5931f7c == function_selector >> 224) {\n            safeDiv(uint256,uint256);\n        } else if (0xd05c78da == function_selector >> 224) {\n            safeMul(uint256,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe6cb9013 == function_selector >> 224) {\n            safeAdd(uint256,uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 37.37113952636719,
	"usage": {
		"completion_tokens": 743,
		"prompt_tokens": 2874,
		"total_tokens": 3617
	}
}