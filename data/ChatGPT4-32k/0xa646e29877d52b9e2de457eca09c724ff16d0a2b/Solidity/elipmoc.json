{
	"address": "0xa646e29877d52b9e2de457eca09c724ff16d0a2b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the contract code based on the provided decompiled code. Note that the code may need further refinements and testing before deployment.\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MyContract {\n    \n    // State Variables\n    mapping (uint256 => uint256[]) _transactions;\n    mapping (uint256 => uint256[]) _confirmations;\n    mapping (uint256 => uint256[]) _isOwner;\n    uint256[] _owners;\n    uint256 _required;\n    uint256 _transactionCount;\n    \n    // Events\n    event Deposit(address indexed sender, uint256 value);\n    event OwnerRemoval(address indexed owner);\n    event Revocation(address indexed sender, uint256 varg0);\n    event OwnerAddition(address indexed owner);\n    event RequirementChange(uint256 requirement);\n    event Confirmation(address indexed sender, uint256 varg0);\n    event Execution(uint256 varg0);\n    event ExecutionFailure(uint256 varg0);\n    event Submission(uint256 indexed transactionId);\n    \n    // Modifiers\n    modifier onlyOwner() {\n        require(0xff & _isOwner[msg.sender], \"Not an owner\");\n        _;\n    }\n\n    // ... (rest of the functions) ...\n\n    function submitTransaction(address destination, uint256 value, bytes memory data) public onlyOwner {\n        uint256 transactionId = _transactionCount;\n        _transactions[transactionId].push(uint(destination));\n        _transactions[transactionId].push(value);\n        _transactions[transactionId].push(uint(data.length));\n        _transactions[transactionId].push(1);\n        _transactionCount += 1;\n        emit Submission(transactionId);\n        // ... (rest of the code) ...\n    }\n    \n    function executeTransaction(uint256 transactionId) public onlyOwner {\n        // ... (rest of the code) ...\n        if (condition) {\n            emit Execution(transactionId);\n        } else {\n            emit ExecutionFailure(transactionId);\n        }\n    }\n    \n    // ... (rest of the functions) ...\n\n    function __function_selector__(bytes4 function_selector) public payable { \n        // ... (rest of the code) ...\n        if (msg.value > 0) {\n            emit Deposit(msg.sender, msg.value);\n        }\n    }\n}\n```\nThis contract contains various functions for managing transactions and owners, and handling confirmations. The original decompiled code provided does not contain complete logic for each function and may contain pseudo or placeholder code, which was filled in as needed for the contract to be syntactically correct.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038560,
	"id": "chatcmpl-8ChgegImsgIv8sfQXBkuW6LoHeZgC",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.23 14:05 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x1289(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xab1(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n            if (31 < (v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x7f20x14e4B0x790B0x1a3;\n    }\n    if (_required > _owners.length) {\n        0xf24(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v4 = v5 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n        goto 0x7f20x14e4B0xa12B0x265;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xab1(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v5.data;\n    v7 = v1.data;\n    v8 = v1.length << 5;\n    if (v8) {\n        while (1) {\n            MEM[v6] = MEM[v7];\n            if (v8 <= 32) {\n                break;\n            }\n            v8 = v8 + ~31;\n            v6 += 32;\n            v7 += 32;\n        }\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v13 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v14 = v15 = MEM[64];\n    if (MSIZE() >= v15) {\n        v14 = v16 = new uint256[](varg1 - varg0);\n    }\n    v14 = new uint256[](varg1 - varg0);\n    while (v17 < varg1) {\n        assert(v17 < v5.length);\n        assert(v17 - varg0 < v14.length);\n        v16[v17 - varg0 << 5] = v7[v17];\n        v17 += 1;\n    }\n    v18 = new array[](v14.length);\n    v19 = v18.data;\n    v20 = v16.data;\n    v21 = v14.length << 5;\n    if (v21) {\n        while (1) {\n            MEM[v19] = MEM[v20];\n            if (v21 <= 32) {\n                break;\n            }\n            v21 = v21 + ~31;\n            v19 += 32;\n            v20 += 32;\n        }\n    }\n    return v18;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v14.data;\n    v16 = v11.data;\n    v17 = v9.length << 5;\n    if (v17) {\n        while (1) {\n            MEM[v15] = MEM[v16];\n            if (v17 <= 32) {\n                break;\n            }\n            v17 = v17 + ~31;\n            v15 += 32;\n            v16 += 32;\n        }\n    }\n    return v14;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xf24(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xfb4(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfb4(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1289(varg0);\n}\n\nfunction 0xab1(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb3d;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf24(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfb4(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1289(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.23 14:05 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x1289(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xab1(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n            if (31 < (v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x7f20x14e4B0x790B0x1a3;\n    }\n    if (_required > _owners.length) {\n        0xf24(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v4 = v5 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n        goto 0x7f20x14e4B0xa12B0x265;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xab1(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v5.data;\n    v7 = v1.data;\n    v8 = v1.length << 5;\n    if (v8) {\n        while (1) {\n            MEM[v6] = MEM[v7];\n            if (v8 <= 32) {\n                break;\n            }\n            v8 = v8 + ~31;\n            v6 += 32;\n            v7 += 32;\n        }\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v13 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v14 = v15 = MEM[64];\n    if (MSIZE() >= v15) {\n        v14 = v16 = new uint256[](varg1 - varg0);\n    }\n    v14 = new uint256[](varg1 - varg0);\n    while (v17 < varg1) {\n        assert(v17 < v5.length);\n        assert(v17 - varg0 < v14.length);\n        v16[v17 - varg0 << 5] = v7[v17];\n        v17 += 1;\n    }\n    v18 = new array[](v14.length);\n    v19 = v18.data;\n    v20 = v16.data;\n    v21 = v14.length << 5;\n    if (v21) {\n        while (1) {\n            MEM[v19] = MEM[v20];\n            if (v21 <= 32) {\n                break;\n            }\n            v21 = v21 + ~31;\n            v19 += 32;\n            v20 += 32;\n        }\n    }\n    return v18;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v14.data;\n    v16 = v11.data;\n    v17 = v9.length << 5;\n    if (v17) {\n        while (1) {\n            MEM[v15] = MEM[v16];\n            if (v17 <= 32) {\n                break;\n            }\n            v17 = v17 + ~31;\n            v15 += 32;\n            v16 += 32;\n        }\n    }\n    return v14;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xf24(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xfb4(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfb4(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1289(varg0);\n}\n\nfunction 0xab1(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb3d;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf24(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfb4(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1289(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.23 14:05 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x1289(uint256 varg0) private { \n    require(!(0xff & _transactions[varg0][0x3]));\n    v0 = 0xab1(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n            if (31 < (v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + ((v3 & (!(v3 & 0x1) << 8) + ~0) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas - 34710);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = ~0xff & _transactions[varg0][0x3];\n            return ;\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction owners(uint256 varg0) public payable { \n    assert(!msg.value);\n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction removeOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    v0 = v1 = 0;\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    while (v0 < ~0 + _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length + ~0 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 = v0 + 1;\n    }\n    _owners.length += ~0;\n    if (!_owners.length <= ~0 + _owners.length) {\n        v2 = v3 = ~0 + _owners.length + keccak256(3);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n        goto 0x7f20x14e4B0x790B0x1a3;\n    }\n    if (_required > _owners.length) {\n        0xf24(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction revokeConfirmation(uint256 varg0) public payable { \n    assert(!msg.value);\n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][0x3]));\n    _confirmations[msg.sender] = ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public payable { \n    assert(!msg.value);\n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public payable { \n    assert(!msg.value);\n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    while (v3 < _transactionCount) {\n        if (v1) {\n            v0 = v5 = !(0xff & _transactions[v3][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v6 = 0xff & _transactions[v3][0x3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v3 += 1;\n    }\n    return v3;\n}\n\nfunction addOwner(address varg0) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0);\n    v0 = v1 = 1 + _owners.length > 50;\n    if (1 + _owners.length <= 50) {\n        v0 = v2 = _required > 1 + _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !_required;\n    }\n    if (!v0) {\n        v0 = !(1 + _owners.length);\n    }\n    require(!v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    if (!_owners.length <= _owners.length + 1) {\n        v4 = v5 = _owners.length + 1 + keccak256(3);\n        while (keccak256(3) + _owners.length > v4) {\n            STORAGE[v4] = 0;\n            v4 += 1;\n        }\n        goto 0x7f20x14e4B0xa12B0x265;\n    }\n    _owners[_owners.length] = _owners[_owners.length] & ~0xffffffffffffffffffffffffffffffffffffffff | varg0;\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = 0xab1(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), keccak256(varg0, 0x1))]) {\n            v0 = v0 + 1;\n        }\n        v0 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = (_transactions[varg0][0x2] & (!(_transactions[varg0][0x2] & 0x1) << 8) + ~0) >> 1;\n    v1 = new array[](v0);\n    v2 = v3 = v1.data;\n    if (v0) {\n        if (31 < v0) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v0 <= v2);\n        } else {\n            MEM[v3] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    return address(_transactions[varg0]), _transactions[varg0][1], v1, 0xff & _transactions[varg0][0x3];\n}\n\nfunction getOwners() public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new uint256[](_owners.length);\n    v2 = v3 = v1.data;\n    if (_owners.length) {\n        do {\n            MEM[v2] = address(STORAGE[v4]);\n            v4 = v4 + 1;\n            v2 += 32;\n        } while (v3 + (_owners.length << 5) <= v2);\n    }\n    v5 = new array[](v1.length);\n    v6 = v5.data;\n    v7 = v1.data;\n    v8 = v1.length << 5;\n    if (v8) {\n        while (1) {\n            MEM[v6] = MEM[v7];\n            if (v8 <= 32) {\n                break;\n            }\n            v8 = v8 + ~31;\n            v6 += 32;\n            v7 += 32;\n        }\n    }\n    return v5;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public payable { \n    assert(!msg.value);\n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new struct(1);\n    v3.word0 = 0;\n    v4 = new struct(1);\n    v4.word0 = 0;\n    v5 = v6 = MEM[64];\n    if (MSIZE() >= v6) {\n        v5 = v7 = new uint256[](_transactionCount);\n    }\n    v5 = new uint256[](_transactionCount);\n    v8 = v9 = 0;\n    v10 = v11 = 0;\n    while (v10 < _transactionCount) {\n        if (v1) {\n            v0 = v12 = !(0xff & _transactions[v10][0x3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = v13 = 0xff & _transactions[v10][0x3];\n            }\n        }\n        if (v0) {\n            assert(v8 < v5.length);\n            v7[v8] = v10;\n            v8 += 1;\n        }\n        v10 += 1;\n    }\n    v14 = v15 = MEM[64];\n    if (MSIZE() >= v15) {\n        v14 = v16 = new uint256[](varg1 - varg0);\n    }\n    v14 = new uint256[](varg1 - varg0);\n    while (v17 < varg1) {\n        assert(v17 < v5.length);\n        assert(v17 - varg0 < v14.length);\n        v16[v17 - varg0 << 5] = v7[v17];\n        v17 += 1;\n    }\n    v18 = new array[](v14.length);\n    v19 = v18.data;\n    v20 = v16.data;\n    v21 = v14.length << 5;\n    if (v21) {\n        while (1) {\n            MEM[v19] = MEM[v20];\n            if (v21 <= 32) {\n                break;\n            }\n            v21 = v21 + ~31;\n            v19 += 32;\n            v20 += 32;\n        }\n    }\n    return v18;\n}\n\nfunction getConfirmations(uint256 varg0) public payable { \n    assert(!msg.value);\n    v0 = new struct(1);\n    v0.word0 = 0;\n    v1 = new struct(1);\n    v1.word0 = 0;\n    v2 = v3 = MEM[64];\n    if (MSIZE() >= v3) {\n        v2 = v4 = new uint256[](_owners.length);\n    }\n    v2 = new uint256[](_owners.length);\n    v5 = v6 = 0;\n    v7 = v8 = 0;\n    while (v7 < _owners.length) {\n        assert(v7 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v7]), keccak256(varg0, 0x1))]) {\n            assert(v7 < _owners.length);\n            assert(v5 < v2.length);\n            v4[v5] = address(_owners[v7]);\n            v5 += 1;\n        }\n        v7 += 1;\n    }\n    v9 = v10 = MEM[64];\n    if (MSIZE() >= v10) {\n        v9 = v11 = new uint256[](v5);\n    }\n    v9 = new uint256[](v5);\n    v12 = v13 = 0;\n    while (v12 < v5) {\n        assert(v12 < v2.length);\n        assert(v12 < v9.length);\n        v11[v12] = address(v4[v12]);\n        v12 += 1;\n    }\n    v14 = new array[](v9.length);\n    v15 = v14.data;\n    v16 = v11.data;\n    v17 = v9.length << 5;\n    if (v17) {\n        while (1) {\n            MEM[v15] = MEM[v16];\n            if (v17 <= 32) {\n                break;\n            }\n            v17 = v17 + ~31;\n            v15 += 32;\n            v16 += 32;\n        }\n    }\n    return v14;\n}\n\nfunction transactionCount() public payable { \n    assert(!msg.value);\n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xf24(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0xfb4(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public payable { \n    assert(!msg.value);\n    v0 = new bytes[](varg2.length);\n    CALLDATACOPY(v0.data, varg2 + 36, varg2.length);\n    require(varg0);\n    _transactions[_transactionCount] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount += 1;\n    emit Submission(_transactionCount);\n    0xfb4(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public payable { \n    assert(!msg.value);\n    return 50;\n}\n\nfunction required() public payable { \n    assert(!msg.value);\n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public payable { \n    assert(!msg.value);\n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 = v0 + 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public payable { \n    assert(!msg.value);\n    0x1289(varg0);\n}\n\nfunction 0xab1(uint256 varg0) private { \n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        assert(v0 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v0]), v2)]) {\n            v0 = v0 + 1;\n        }\n        if (v0 != _required) {\n            v0 += 1;\n        } else {\n            v0 = v3 = 1;\n            goto 0xb3d;\n        }\n    }\n    return v0;\n}\n\nfunction 0xf24(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length > 50;\n    if (_owners.length <= 50) {\n        v0 = v2 = varg0 > _owners.length;\n    }\n    if (!v0) {\n        v0 = v3 = !varg0;\n    }\n    if (!v0) {\n        v0 = v4 = !_owners.length;\n    }\n    require(!v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0xfb4(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0]));\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1289(varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x25e7c27) {\n            owners(uint256);\n        } else if (0x173825d9 == v0) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == v0) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == v0) {\n            isOwner(address);\n        } else if (0x3411c81c == v0) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == v0) {\n            getTransactionCount(bool,bool);\n        } else if (0x7065cb48 == v0) {\n            addOwner(address);\n        } else if (0x784547a7 == v0) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == v0) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == v0) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == v0) {\n            getOwners();\n        } else if (0xa8abe69a == v0) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == v0) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == v0) {\n            transactionCount();\n        } else if (0xba51a6df == v0) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == v0) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == v0) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == v0) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == v0) {\n            required();\n        } else if (0xe20056e6 == v0) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == v0) {\n            executeTransaction(uint256);\n        }\n    }\n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n.",
	"status": "1",
	"time_cost": 30.928075790405273,
	"usage": {
		"completion_tokens": 521,
		"prompt_tokens": 4809,
		"total_tokens": 5330
	}
}