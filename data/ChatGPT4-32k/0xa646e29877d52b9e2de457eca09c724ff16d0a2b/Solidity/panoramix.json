{
	"address": "0xa646e29877d52b9e2de457eca09c724ff16d0a2b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code, here's how the smart contract may look like in Solidity:\n\nPlease note that I'm assuming the behavior of the smart contract based on the decompiled code.\n\n```solidity\npragma solidity >=0.5.0 <0.8.0;\n\ncontract Wallet {\n    uint constant MAX_OWNER_COUNT = 50;\n    mapping(address => bool) isOwner;\n    mapping(bytes32 => bool) transactions;\n    mapping(uint => mapping(address => bool)) confirmations;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n\n    event RequirementChange(uint required);\n    event Revocation(address sender, uint transactionId);\n    event OwnerAddition(address owner);\n    event OwnerRemoval(address owner);\n    event Execution(uint transactionId);\n    event ExecutionFailure(uint transactionId);\n    event Submission(uint transactionId);\n    event Confirmation(address sender, uint transactionId);\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"Not an owner\");\n        _;\n    }\n\n    function addOwner(address _owner) external onlyOwner {\n        require(_owner != address(0), \"Invalid address\");\n        require(!isOwner[_owner], \"Address is already an owner\");\n        require(owners.length + 1 <= MAX_OWNER_COUNT, \"Exceeded max owners\");\n\n        isOwner[_owner] = true;\n        owners.push(_owner);\n        emit OwnerAddition(_owner);\n    }\n\n    function removeOwner(address _owner) external onlyOwner {\n        require(isOwner[_owner], \"Not an owner\");\n        isOwner[_owner] = false;\n        for (uint i = 0; i < owners.length - 1; i++) {\n            if (owners[i] == _owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        }\n        owners.pop();\n        emit OwnerRemoval(_owner);\n    }\n\n    function replaceOwner(address _owner, address _newOwner) external onlyOwner {\n        require(isOwner[_owner], \"Not an owner\");\n        require(_newOwner != address(0), \"Invalid address\");\n        require(!isOwner[_newOwner], \"Address is already an owner\");\n\n        for (uint i = 0; i < owners.length; i++) {\n            if (owners[i] == _owner) {\n                owners[i] = _newOwner;\n                break;\n            }\n        }\n        isOwner[_owner] = false;\n        isOwner[_newOwner] = true;\n        emit OwnerRemoval(_owner);\n        emit OwnerAddition(_newOwner);\n    }\n\n    function changeRequirement(uint _newRequired) external onlyOwner {\n        require(_newRequired > 0 && _newRequired <= owners.length, \"Invalid requirement\");\n        required = _newRequired;\n        emit RequirementChange(_newRequired);\n    }\n\n    function submitTransaction(address _destination, uint _value, bytes calldata _data) external onlyOwner returns (uint transactionId) {\n        transactionId = transactionCount;\n        transactions[keccak256(abi.encodePacked(_destination, _value, _data))] = true;\n        transactionCount++;\n        confirmations[transactionId][msg.sender] = true;\n        emit Submission(transactionId);\n        executeTransaction(transactionId);\n    }\n\n    function confirmTransaction(uint transactionId) external onlyOwner {\n        require(transactions[keccak256(abi.encodePacked(transactionId))], \"Invalid transaction\");\n        confirmations[transactionId][msg.sender] = true;\n        executeTransaction(transactionId);\n    }\n\n    function executeTransaction(uint transactionId) public onlyOwner {\n        require(transactions[keccak256(abi.encodePacked(transactionId))], \"Invalid transaction\");\n        if (isConfirmed(transactionId)) {\n            (address destination, uint value, bytes memory data) = getTransaction(transactionId);\n            (bool success,) = destination.call.value(value)(data);\n            if (success) {\n                emit Execution(transactionId);\n            } else {\n                emit ExecutionFailure(transactionId);\n            }\n        }\n    }\n\n    function isConfirmed(uint transactionId) public view returns (bool) {\n        uint count = 0;\n        for (uint i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]]) {\n                count += 1;\n            }\n            if (count == required) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getTransaction(uint transactionId) public view returns (address destination, uint value, bytes memory data) {\n        // Returns the transaction details\n    }\n\n    function getConfirmationCount(uint transactionId) public view returns (uint count) {\n        for (uint i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]]) {\n                count += 1;\n            }\n        }\n    }\n\n    function getTransactionCount(bool pending, bool executed) public view returns (uint count) {\n        // Returns the transaction count based on the status\n    }\n}\n``` \n\nNOTE: This code has not been tested and may need adjustments based on the specific contract requirements. Please ensure to test thoroughly before deploying it.",
				"role": "assistant"
			}
		}
	],
	"created": 1700470631,
	"id": "chatcmpl-8MuNb4d29ArkSPPcqtHjE1ZnM4w7R",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return addr(owners[_param1].field_0)\n\ndef isOwner(address _owner): # not payable\n  return bool(stor2[_owner])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeRequirement(uint256 _newRequired): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _newRequired <= owners.length\n  require _newRequired\n  require owners.length\n  required = _newRequired\n  log RequirementChange(uint256 required=_newRequired)\n\ndef revokeConfirmation(uint256 _transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[_transactionId][caller])\n  require not uint8(stor0[_transactionId].field_768)\n  uint8(stor1[_transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=_transactionId)\n\ndef getConfirmationCount(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address _owner): # not payable\n  require caller == this.address\n  require not stor2[addr(_owner)]\n  require _owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[addr(_owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  addr(owners[owners.length].field_0) = _owner\n  log OwnerAddition(address owner=_owner)\n\ndef replaceOwner(address _owner, address _newOwner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  require not stor2[addr(_newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if addr(owners[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      addr(owners[idx].field_0) = _newOwner\n      stor2[addr(_owner)] = 0\n      stor2[_newOwner] = 1\n      log OwnerRemoval(address owner=_owner)\n      log OwnerAddition(address owner=_newOwner)\n      stop\n  stor2[addr(_owner)] = 0\n  stor2[_newOwner] = 1\n  log OwnerRemoval(address owner=_owner)\n  log OwnerAddition(address owner=_newOwner)\n\ndef transactions(uint256 _param1): # not payable\n  mem[256] = stor0[_param1][2].field_0\n  idx = 256\n  s = 0\n  while stor0[_param1][2].length + 256 > idx + 32:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return addr(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[256 len stor0[_param1][2].length + (floor32(stor0[_param1][2].length - 1) + -stor0[_param1][2].length + 32 % 32)]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef getOwners(): # not payable\n  if owners.length:\n      mem[160] = addr(owners.field_0)\n      idx = 160\n      s = 0\n      while (32 * owners.length) + 128 > idx:\n          mem[idx + 32] = addr(owners[s].field_256)\n          idx = idx + 32\n          s = s + 1\n          continue \n  mem[(32 * owners.length) + 160] = 32\n  mem[(32 * owners.length) + 192] = owners.length\n  if Mask(251, 0, owners.length):\n      mem[(32 * owners.length) + 224] = mem[160]\n      mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  return Array(len=owners.length, data=mem[(32 * owners.length) + 224 len 32 * owners.length])\n\ndef getTransactionCount(bool _pending, bool _executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not _pending:\n          if not _executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not _executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef executeTransaction(uint256 _transactionId): # not payable\n  require not uint8(stor0[_transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[_transactionId].field_768) = 1\n      mem[96] = stor0[_transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(_transactionId, 0) + 2)\n      while stor0[_transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionId].field_0).mem[96 len 4] with:\n         value stor0[_transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[_transactionId][2].length + (floor32(stor0[_transactionId][2].length - 1) + -stor0[_transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=_transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=_transactionId)\n          uint8(stor0[_transactionId].field_768) = 0\n      stop\n\ndef removeOwner(address _owner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  stor2[addr(_owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if addr(owners[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      addr(owners[idx].field_0) = addr(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=_owner)\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=_owner)\n\ndef confirmTransaction(uint256 _transactionId): # not payable\n  require stor2[caller]\n  require addr(stor0[_transactionId].field_0)\n  require not uint8(stor1[_transactionId][caller])\n  uint8(stor1[_transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=_transactionId)\n  require not uint8(stor0[_transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[_transactionId].field_768) = 1\n      mem[96] = stor0[_transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(_transactionId, 0) + 2)\n      while stor0[_transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionId].field_0).mem[96 len 4] with:\n         value stor0[_transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[_transactionId][2].length + (floor32(stor0[_transactionId][2].length - 1) + -stor0[_transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=_transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=_transactionId)\n          uint8(stor0[_transactionId].field_768) = 0\n      stop\n\ndef getConfirmations(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = addr(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 224] = 32\n      mem[(32 * owners.length) + (32 * s) + 256] = s\n      if Mask(251, 0, s):\n          mem[(32 * owners.length) + (32 * s) + 288] = mem[(32 * owners.length) + 224]\n          mem[(32 * owners.length) + (32 * s) + 320 len floor32((32 * s) - 1)] = mem[(32 * owners.length) + 256 len floor32((32 * s) - 1)]\n      return Array(len=s, data=mem[(32 * owners.length) + (32 * s) + 288 len 32 * s])\n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  if not Mask(251, 0, s):\n      return memory\n        from (64 * s) + 256\n         len (32 * s) + 64\n  mem[(64 * s) + 320] = mem[(32 * s) + 256]\n  mem[(64 * s) + 352 len floor32((32 * s, None) - 1)] = mem[(32 * s) + 288 len floor32((32 * s, None) - 1)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef submitTransaction(address _destination, uint256 _value, bytes _data): # not payable\n  require _destination\n  addr(stor0[stor5].field_0) = _destination\n  stor0[stor5].field_256 = _value\n  stor0[stor5][2][].field_0 = Array(len=_data.length, data=_data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require addr(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(_data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(_data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(_data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[stor5].field_0).mem[ceil32(_data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[ceil32(_data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\ndef getTransactionIds(uint256 _from, uint256 _to, bool _pending, bool _executed): # not payable\n  mem[96] = 0\n  mem[128] = 0\n  mem[160] = transactionCount\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not _pending:\n          if not _executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not _executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 >= (32 * transactionCount) + 192:\n      mem[(32 * s) + 224] = _to - _from\n      mem[64] = (32 * s) + (32 * _to - _from) + 256\n      idx = _from\n      while idx < _to:\n          require idx < transactionCount\n          require idx - _from < _to - _from, None\n          mem[(32 * s) + (32 * idx - _from) + 256] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * s) + (32 * _to - _from) + 256] = 32\n      mem[(32 * s) + (32 * _to - _from) + 288] = _to - _from, None\n      if not Mask(251, 0, _to - _from):\n          return 32, mem[(32 * s) + (32 * _to - _from) + 288 len (32 * _to - _from) + 32]\n      mem[(32 * s) + (32 * _to - _from) + 320] = mem[(32 * s) + 256]\n      t = (32 * s) + 256\n      u = (32 * s) + (32 * _to - _from) + 320\n      t = 32 * _to - _from, None\n      while t > 32:\n          mem[u + 32] = mem[_to + 32]\n          t = _to + 32\n          u = u + 32\n          t = t - 32\n          continue \n      return memory\n        from (32 * s) + (32 * _to - _from) + 256\n         len (32 * _to - _from, None) + 64\n  mem[(32 * transactionCount) + 192] = _to - _from\n  mem[64] = (32 * transactionCount) + (32 * _to - _from) + 224\n  idx = _from\n  while idx < _to:\n      require idx < transactionCount\n      require idx - _from < mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * idx - _from) + 224] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * _to - _from) + 224] = 32\n  mem[(32 * transactionCount) + (32 * _to - _from) + 256] = mem[(32 * transactionCount) + 192]\n  _118 = mem[(32 * transactionCount) + 192]\n  if not Mask(251, 0, mem[(32 * transactionCount) + 192]):\n      return 32, mem[(32 * transactionCount) + (32 * _to - _from) + 256 len (32 * mem[(32 * transactionCount) + 192]) + 32]\n  mem[(32 * transactionCount) + (32 * _to - _from) + 288] = mem[(32 * transactionCount) + 224]\n  s = (32 * transactionCount) + 224\n  t = mem[64] + 64\n  s = 32 * mem[(32 * transactionCount) + 192]\n  while s > 32:\n      mem[t + 32] = mem[_to + 32]\n      s = _to + 32\n      t = t + 32\n      s = s - 32\n      continue \n  return memory\n    from mem[64]\n     len (32 * _118) + (32 * transactionCount) + (32 * _to - _from) + -mem[64] + 288\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return addr(owners[_param1].field_0)\n\ndef isOwner(address _owner): # not payable\n  return bool(stor2[_owner])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeRequirement(uint256 _newRequired): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _newRequired <= owners.length\n  require _newRequired\n  require owners.length\n  required = _newRequired\n  log RequirementChange(uint256 required=_newRequired)\n\ndef revokeConfirmation(uint256 _transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[_transactionId][caller])\n  require not uint8(stor0[_transactionId].field_768)\n  uint8(stor1[_transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=_transactionId)\n\ndef getConfirmationCount(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address _owner): # not payable\n  require caller == this.address\n  require not stor2[addr(_owner)]\n  require _owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[addr(_owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  addr(owners[owners.length].field_0) = _owner\n  log OwnerAddition(address owner=_owner)\n\ndef replaceOwner(address _owner, address _newOwner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  require not stor2[addr(_newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if addr(owners[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      addr(owners[idx].field_0) = _newOwner\n      stor2[addr(_owner)] = 0\n      stor2[_newOwner] = 1\n      log OwnerRemoval(address owner=_owner)\n      log OwnerAddition(address owner=_newOwner)\n      stop\n  stor2[addr(_owner)] = 0\n  stor2[_newOwner] = 1\n  log OwnerRemoval(address owner=_owner)\n  log OwnerAddition(address owner=_newOwner)\n\ndef transactions(uint256 _param1): # not payable\n  mem[256] = stor0[_param1][2].field_0\n  idx = 256\n  s = 0\n  while stor0[_param1][2].length + 256 > idx + 32:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return addr(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[256 len stor0[_param1][2].length + (floor32(stor0[_param1][2].length - 1) + -stor0[_param1][2].length + 32 % 32)]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef getOwners(): # not payable\n  if owners.length:\n      mem[160] = addr(owners.field_0)\n      idx = 160\n      s = 0\n      while (32 * owners.length) + 128 > idx:\n          mem[idx + 32] = addr(owners[s].field_256)\n          idx = idx + 32\n          s = s + 1\n          continue \n  mem[(32 * owners.length) + 160] = 32\n  mem[(32 * owners.length) + 192] = owners.length\n  if Mask(251, 0, owners.length):\n      mem[(32 * owners.length) + 224] = mem[160]\n      mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  return Array(len=owners.length, data=mem[(32 * owners.length) + 224 len 32 * owners.length])\n\ndef getTransactionCount(bool _pending, bool _executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not _pending:\n          if not _executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not _executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef executeTransaction(uint256 _transactionId): # not payable\n  require not uint8(stor0[_transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[_transactionId].field_768) = 1\n      mem[96] = stor0[_transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(_transactionId, 0) + 2)\n      while stor0[_transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionId].field_0).mem[96 len 4] with:\n         value stor0[_transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[_transactionId][2].length + (floor32(stor0[_transactionId][2].length - 1) + -stor0[_transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=_transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=_transactionId)\n          uint8(stor0[_transactionId].field_768) = 0\n      stop\n\ndef removeOwner(address _owner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  stor2[addr(_owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if addr(owners[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      addr(owners[idx].field_0) = addr(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=_owner)\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=_owner)\n\ndef confirmTransaction(uint256 _transactionId): # not payable\n  require stor2[caller]\n  require addr(stor0[_transactionId].field_0)\n  require not uint8(stor1[_transactionId][caller])\n  uint8(stor1[_transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=_transactionId)\n  require not uint8(stor0[_transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[_transactionId].field_768) = 1\n      mem[96] = stor0[_transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(_transactionId, 0) + 2)\n      while stor0[_transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionId].field_0).mem[96 len 4] with:\n         value stor0[_transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[_transactionId][2].length + (floor32(stor0[_transactionId][2].length - 1) + -stor0[_transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=_transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=_transactionId)\n          uint8(stor0[_transactionId].field_768) = 0\n      stop\n\ndef getConfirmations(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = addr(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 224] = 32\n      mem[(32 * owners.length) + (32 * s) + 256] = s\n      if Mask(251, 0, s):\n          mem[(32 * owners.length) + (32 * s) + 288] = mem[(32 * owners.length) + 224]\n          mem[(32 * owners.length) + (32 * s) + 320 len floor32((32 * s) - 1)] = mem[(32 * owners.length) + 256 len floor32((32 * s) - 1)]\n      return Array(len=s, data=mem[(32 * owners.length) + (32 * s) + 288 len 32 * s])\n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  if not Mask(251, 0, s):\n      return memory\n        from (64 * s) + 256\n         len (32 * s) + 64\n  mem[(64 * s) + 320] = mem[(32 * s) + 256]\n  mem[(64 * s) + 352 len floor32((32 * s, None) - 1)] = mem[(32 * s) + 288 len floor32((32 * s, None) - 1)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef submitTransaction(address _destination, uint256 _value, bytes _data): # not payable\n  require _destination\n  addr(stor0[stor5].field_0) = _destination\n  stor0[stor5].field_256 = _value\n  stor0[stor5][2][].field_0 = Array(len=_data.length, data=_data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require addr(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(_data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(_data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(_data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[stor5].field_0).mem[ceil32(_data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[ceil32(_data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\ndef getTransactionIds(uint256 _from, uint256 _to, bool _pending, bool _executed): # not payable\n  mem[96] = 0\n  mem[128] = 0\n  mem[160] = transactionCount\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not _pending:\n          if not _executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not _executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 >= (32 * transactionCount) + 192:\n      mem[(32 * s) + 224] = _to - _from\n      mem[64] = (32 * s) + (32 * _to - _from) + 256\n      idx = _from\n      while idx < _to:\n          require idx < transactionCount\n          require idx - _from < _to - _from, None\n          mem[(32 * s) + (32 * idx - _from) + 256] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * s) + (32 * _to - _from) + 256] = 32\n      mem[(32 * s) + (32 * _to - _from) + 288] = _to - _from, None\n      if not Mask(251, 0, _to - _from):\n          return 32, mem[(32 * s) + (32 * _to - _from) + 288 len (32 * _to - _from) + 32]\n      mem[(32 * s) + (32 * _to - _from) + 320] = mem[(32 * s) + 256]\n      t = (32 * s) + 256\n      u = (32 * s) + (32 * _to - _from) + 320\n      t = 32 * _to - _from, None\n      while t > 32:\n          mem[u + 32] = mem[_to + 32]\n          t = _to + 32\n          u = u + 32\n          t = t - 32\n          continue \n      return memory\n        from (32 * s) + (32 * _to - _from) + 256\n         len (32 * _to - _from, None) + 64\n  mem[(32 * transactionCount) + 192] = _to - _from\n  mem[64] = (32 * transactionCount) + (32 * _to - _from) + 224\n  idx = _from\n  while idx < _to:\n      require idx < transactionCount\n      require idx - _from < mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * idx - _from) + 224] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * _to - _from) + 224] = 32\n  mem[(32 * transactionCount) + (32 * _to - _from) + 256] = mem[(32 * transactionCount) + 192]\n  _118 = mem[(32 * transactionCount) + 192]\n  if not Mask(251, 0, mem[(32 * transactionCount) + 192]):\n      return 32, mem[(32 * transactionCount) + (32 * _to - _from) + 256 len (32 * mem[(32 * transactionCount) + 192]) + 32]\n  mem[(32 * transactionCount) + (32 * _to - _from) + 288] = mem[(32 * transactionCount) + 224]\n  s = (32 * transactionCount) + 224\n  t = mem[64] + 64\n  s = 32 * mem[(32 * transactionCount) + 192]\n  while s > 32:\n      mem[t + 32] = mem[_to + 32]\n      s = _to + 32\n      t = t + 32\n      s = s - 32\n      continue \n  return memory\n    from mem[64]\n     len (32 * _118) + (32 * transactionCount) + (32 * _to - _from) + -mem[64] + 288\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return addr(owners[_param1].field_0)\n\ndef isOwner(address _owner): # not payable\n  return bool(stor2[_owner])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef _fallback() payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeRequirement(uint256 _newRequired): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require _newRequired <= owners.length\n  require _newRequired\n  require owners.length\n  required = _newRequired\n  log RequirementChange(uint256 required=_newRequired)\n\ndef revokeConfirmation(uint256 _transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[_transactionId][caller])\n  require not uint8(stor0[_transactionId].field_768)\n  uint8(stor1[_transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=_transactionId)\n\ndef getConfirmationCount(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef addOwner(address _owner): # not payable\n  require caller == this.address\n  require not stor2[addr(_owner)]\n  require _owner\n  require owners.length + 1 <= 50\n  require required <= owners.length + 1\n  require required\n  require owners.length + 1\n  stor2[addr(_owner)] = 1\n  owners.length++\n  if not owners.length <= owners.length + 1:\n      idx = owners.length + 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  addr(owners[owners.length].field_0) = _owner\n  log OwnerAddition(address owner=_owner)\n\ndef replaceOwner(address _owner, address _newOwner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  require not stor2[addr(_newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if addr(owners[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      addr(owners[idx].field_0) = _newOwner\n      stor2[addr(_owner)] = 0\n      stor2[_newOwner] = 1\n      log OwnerRemoval(address owner=_owner)\n      log OwnerAddition(address owner=_newOwner)\n      stop\n  stor2[addr(_owner)] = 0\n  stor2[_newOwner] = 1\n  log OwnerRemoval(address owner=_owner)\n  log OwnerAddition(address owner=_newOwner)\n\ndef transactions(uint256 _param1): # not payable\n  mem[256] = stor0[_param1][2].field_0\n  idx = 256\n  s = 0\n  while stor0[_param1][2].length + 256 > idx + 32:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return addr(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[256 len stor0[_param1][2].length + (floor32(stor0[_param1][2].length - 1) + -stor0[_param1][2].length + 32 % 32)]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef getOwners(): # not payable\n  if owners.length:\n      mem[160] = addr(owners.field_0)\n      idx = 160\n      s = 0\n      while (32 * owners.length) + 128 > idx:\n          mem[idx + 32] = addr(owners[s].field_256)\n          idx = idx + 32\n          s = s + 1\n          continue \n  mem[(32 * owners.length) + 160] = 32\n  mem[(32 * owners.length) + 192] = owners.length\n  if Mask(251, 0, owners.length):\n      mem[(32 * owners.length) + 224] = mem[160]\n      mem[(32 * owners.length) + 256 len floor32((32 * owners.length) - 1)] = mem[192 len floor32((32 * owners.length) - 1)]\n  return Array(len=owners.length, data=mem[(32 * owners.length) + 224 len 32 * owners.length])\n\ndef getTransactionCount(bool _pending, bool _executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not _pending:\n          if not _executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not _executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef executeTransaction(uint256 _transactionId): # not payable\n  require not uint8(stor0[_transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[_transactionId].field_768) = 1\n      mem[96] = stor0[_transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(_transactionId, 0) + 2)\n      while stor0[_transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionId].field_0).mem[96 len 4] with:\n         value stor0[_transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[_transactionId][2].length + (floor32(stor0[_transactionId][2].length - 1) + -stor0[_transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=_transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=_transactionId)\n          uint8(stor0[_transactionId].field_768) = 0\n      stop\n\ndef removeOwner(address _owner): # not payable\n  require caller == this.address\n  require stor2[addr(_owner)]\n  stor2[addr(_owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      require idx < owners.length\n      mem[0] = 3\n      if addr(owners[idx].field_0) != _owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      addr(owners[idx].field_0) = addr(owners[owners.length].field_0)\n      owners.length--\n      if not owners.length <= owners.length - 1:\n          idx = owners.length + sha3(3) - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length <= owners.length\n          require owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=_owner)\n      stop\n  owners.length--\n  if not owners.length <= owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length <= owners.length\n      require owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=_owner)\n\ndef confirmTransaction(uint256 _transactionId): # not payable\n  require stor2[caller]\n  require addr(stor0[_transactionId].field_0)\n  require not uint8(stor1[_transactionId][caller])\n  uint8(stor1[_transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=_transactionId)\n  require not uint8(stor0[_transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[_transactionId].field_768) = 1\n      mem[96] = stor0[_transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(_transactionId, 0) + 2)\n      while stor0[_transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[_transactionId].field_0).mem[96 len 4] with:\n         value stor0[_transactionId].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[100 len stor0[_transactionId][2].length + (floor32(stor0[_transactionId][2].length - 1) + -stor0[_transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=_transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=_transactionId)\n          uint8(stor0[_transactionId].field_768) = 0\n      stop\n\ndef getConfirmations(uint256 _transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(_transactionId, 1)\n      if not uint8(stor1[_transactionId][addr(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 192] = addr(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 < (32 * owners.length) + 192:\n      mem[(32 * owners.length) + 192] = s\n      t = 0\n      while t < s:\n          require t < owners.length\n          require t < s\n          mem[(32 * owners.length) + (32 * t) + 224] = mem[(32 * t) + 204 len 20]\n          t = t + 1\n          continue \n      mem[(32 * owners.length) + (32 * s) + 224] = 32\n      mem[(32 * owners.length) + (32 * s) + 256] = s\n      if Mask(251, 0, s):\n          mem[(32 * owners.length) + (32 * s) + 288] = mem[(32 * owners.length) + 224]\n          mem[(32 * owners.length) + (32 * s) + 320 len floor32((32 * s) - 1)] = mem[(32 * owners.length) + 256 len floor32((32 * s) - 1)]\n      return Array(len=s, data=mem[(32 * owners.length) + (32 * s) + 288 len 32 * s])\n  mem[(32 * s) + 224] = s\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s, None\n      mem[(32 * s) + (32 * t) + 256] = mem[(32 * t) + 204 len 20]\n      t = t + 1\n      continue \n  mem[(64 * s) + 256] = 32\n  mem[(64 * s) + 288] = s, None\n  if not Mask(251, 0, s):\n      return memory\n        from (64 * s) + 256\n         len (32 * s) + 64\n  mem[(64 * s) + 320] = mem[(32 * s) + 256]\n  mem[(64 * s) + 352 len floor32((32 * s, None) - 1)] = mem[(32 * s) + 288 len floor32((32 * s, None) - 1)]\n  return memory\n    from (64 * s) + 256\n     len (32 * s, None) + 64\n\ndef submitTransaction(address _destination, uint256 _value, bytes _data): # not payable\n  require _destination\n  addr(stor0[stor5].field_0) = _destination\n  stor0[stor5].field_256 = _value\n  stor0[stor5][2][].field_0 = Array(len=_data.length, data=_data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require addr(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = addr(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][addr(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(_data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(_data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(_data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call addr(stor0[stor5].field_0).mem[ceil32(_data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining - 34710 wei\n          args mem[ceil32(_data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\ndef getTransactionIds(uint256 _from, uint256 _to, bool _pending, bool _executed): # not payable\n  mem[96] = 0\n  mem[128] = 0\n  mem[160] = transactionCount\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not _pending:\n          if not _executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not _executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 192] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  if (32 * s) + 224 >= (32 * transactionCount) + 192:\n      mem[(32 * s) + 224] = _to - _from\n      mem[64] = (32 * s) + (32 * _to - _from) + 256\n      idx = _from\n      while idx < _to:\n          require idx < transactionCount\n          require idx - _from < _to - _from, None\n          mem[(32 * s) + (32 * idx - _from) + 256] = mem[(32 * idx) + 192]\n          idx = idx + 1\n          continue \n      mem[(32 * s) + (32 * _to - _from) + 256] = 32\n      mem[(32 * s) + (32 * _to - _from) + 288] = _to - _from, None\n      if not Mask(251, 0, _to - _from):\n          return 32, mem[(32 * s) + (32 * _to - _from) + 288 len (32 * _to - _from) + 32]\n      mem[(32 * s) + (32 * _to - _from) + 320] = mem[(32 * s) + 256]\n      t = (32 * s) + 256\n      u = (32 * s) + (32 * _to - _from) + 320\n      t = 32 * _to - _from, None\n      while t > 32:\n          mem[u + 32] = mem[_to + 32]\n          t = _to + 32\n          u = u + 32\n          t = t - 32\n          continue \n      return memory\n        from (32 * s) + (32 * _to - _from) + 256\n         len (32 * _to - _from, None) + 64\n  mem[(32 * transactionCount) + 192] = _to - _from\n  mem[64] = (32 * transactionCount) + (32 * _to - _from) + 224\n  idx = _from\n  while idx < _to:\n      require idx < transactionCount\n      require idx - _from < mem[(32 * transactionCount) + 192]\n      mem[(32 * transactionCount) + (32 * idx - _from) + 224] = mem[(32 * idx) + 192]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * _to - _from) + 224] = 32\n  mem[(32 * transactionCount) + (32 * _to - _from) + 256] = mem[(32 * transactionCount) + 192]\n  _118 = mem[(32 * transactionCount) + 192]\n  if not Mask(251, 0, mem[(32 * transactionCount) + 192]):\n      return 32, mem[(32 * transactionCount) + (32 * _to - _from) + 256 len (32 * mem[(32 * transactionCount) + 192]) + 32]\n  mem[(32 * transactionCount) + (32 * _to - _from) + 288] = mem[(32 * transactionCount) + 224]\n  s = (32 * transactionCount) + 224\n  t = mem[64] + 64\n  s = 32 * mem[(32 * transactionCount) + 192]\n  while s > 32:\n      mem[t + 32] = mem[_to + 32]\n      s = _to + 32\n      t = t + 32\n      s = s - 32\n      continue \n  return memory\n    from mem[64]\n     len (32 * _118) + (32 * transactionCount) + (32 * _to - _from) + -mem[64] + 288\n\n.",
	"status": "1",
	"time_cost": 68.24763321876526,
	"usage": {
		"completion_tokens": 1061,
		"prompt_tokens": 5530,
		"total_tokens": 6591
	}
}