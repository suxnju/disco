{
	"address": "0x1ba2b2aa8d8c62e395e9e859b948929442c7fd77",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here's a simplified version of the decompiled code. Please note that the decompiled code is very complex and contains many low-level operations, so some high-level Solidity features may not be represented exactly:\n\n```solidity\npragma solidity ^0.8.20;\n\ncontract TokenContract {\n    mapping (address => uint256) public _balanceOf;\n    mapping (address => mapping (address => uint256)) public _allowance;\n    uint256 public _totalSupply;\n    address public _owner;\n    uint256 public __maxTxAmount;\n    uint256 public __maxWalletSize;\n    uint256 public __taxSwapThreshold;\n    uint256 public __maxTaxSwap;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return _balanceOf[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balanceOf[msg.sender] >= _value);\n        _balanceOf[msg.sender] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= _allowance[_from][msg.sender]);\n        _allowance[_from][msg.sender] -= _value;\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return _allowance[_owner][_spender];\n    }\n}\n```\n\nPlease note that this code is a simplified version and does not include all the functionality of the original contract. For example, it does not include the `SafeMath` operations, the specific error messages in the `require` statements, the detailed tokenomics, or the logic for fees and swapping tokens. Please adapt and extend the code to suit your specific needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495549,
	"id": "chatcmpl-8VP9Z2bdzQqyhnEA3sxiV6fGV49fV",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.16 14:36 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _manualSend; // STORAGE[0x6] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction 0x11f2(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction 0x1206(uint256 varg0, uint256 varg1) private { \n    v0 = _SafeAdd(varg1, varg0);\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    require((varg1 == varg1 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    return varg1 * varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1 + varg0, Panic(17)); // arithmetic overflow or underflow\n    return varg1 + varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x939(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    return v1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    0xa5c(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    0x939(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSend);\n    if (_balanceOf[this]) {\n        0xf85(_balanceOf[this]);\n    }\n    if (this.balance) {\n        v0 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        // Unknown jump to Block 0x1afb. Refer to 3-address code (TAC);\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    __maxTxAmount = v1;\n    v2 = _SafeExp(10, uint8(9));\n    v3 = _SafeMul(0x3b9aca00, v2);\n    __maxWalletSize = v3;\n    v4 = _SafeExp(10, uint8(9));\n    v5 = _SafeMul(0x3b9aca00, v4);\n    emit MaxTxAmountUpdated(v5);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0xa5c(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    0x939(v1, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v2, /* address */ v3 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    v6, /* address */ v7 = address(v3).createPair(address(this), address(v5)).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v7 == address(v7));\n    owner_14 = bytes12(owner_14) | address(v7);\n    v8, /* uint256 */ v9, /* uint256 */ v10, /* uint256 */ v11 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v8), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v12, /* bool */ v13 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v12), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v13 == bool(v13));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction manualSend() public nonPayable { \n    v0 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction 0x939(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0xa5c(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != varg1;\n    }\n    if (v2) {\n        v5 = v6 = 3039;\n        v7 = v8 = 100;\n        v9 = v10 = 7640;\n        if (stor_e > stor_b) {\n            v11 = v12 = stor_9;\n        } else {\n            v11 = v13 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x113b. Refer to 3-address code (TAC);\n                }\n                v14 = v15 = 0;\n                // Unknown jump to Block {'0x1dd8', '0x1dfd'}. Refer to 3-address code (TAC);\n                if (v7) {\n                    require(v7, Panic(18)); // division by zero\n                    v0 = v14 / v7;\n                    // Unknown jump to Block {'0xd67', '0xbdf'}. Refer to 3-address code (TAC);\n                    v16 = v17 = address(owner_14) == varg2;\n                    if (v17) {\n                        v16 = v18 = stor_13_0_19 != varg1;\n                    }\n                    if (v16) {\n                        v16 = v19 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v16) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        v20 = _SafeAdd(_balanceOf[varg1], varg0);\n                        require(v20 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v21 = v22 = address(owner_14) == varg1;\n                    if (v22) {\n                        v21 = v23 = this != varg2;\n                    }\n                    if (v21) {\n                        v5 = v24 = 3431;\n                        v7 = v25 = 100;\n                        v9 = v26 = 7677;\n                        if (stor_e > stor_c) {\n                            v11 = v27 = stor_a;\n                        } else {\n                            v11 = v28 = stor_8;\n                            continue;\n                        }\n                    }\n                    v29 = v30 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v29 = v31 = address(owner_14) == varg1;\n                    }\n                    if (v29) {\n                        v29 = v32 = uint8(owner_14 >> 176);\n                    }\n                    if (v29) {\n                        v29 = v33 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v29) {\n                        v29 = v34 = stor_e > stor_d;\n                    }\n                    if (v29) {\n                        v35 = 0x11f2(__maxTaxSwap, _balanceOf[this]);\n                        v36 = 0x11f2(v35, varg0);\n                        0xf85(v36);\n                        if (this.balance > 0xb1a2bc2ec50000) {\n                            v37 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v37), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v38 = new bytes[](v39.length);\n                    v40 = v41 = 0;\n                    while (v40 < v39.length) {\n                        v38[v40] = v39[v40];\n                        v40 += 32;\n                    }\n                    v38[v39.length] = 0;\n                    revert(Error(v38));\n                }\n                // Unknown jump to Block 0x11b1. Refer to 3-address code (TAC);\n                v14 = v42 = _SafeMul(varg0, v11);\n                require(varg0, Panic(18)); // division by zero\n                require(v42 / varg0 == v11, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x1dd8', '0x1dfd'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v43 = 0x1206(v0, _balanceOf[this]);\n        _balanceOf[this] = v43;\n        emit Transfer(varg2, this, v0);\n    }\n    v44 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v44;\n    v45 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v46 = 0x1206(v45, _balanceOf[varg1]);\n    _balanceOf[varg1] = v46;\n    v47 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v47;\n    emit Transfer(varg2, varg1, v47);\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction 0xf85(uint256 varg0) private { \n    owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    0x939(varg0, stor_13_0_19, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(stor_13_0_19.code.size));\n    v11 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        if (0x751039fc > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 != function_selector >> 224) {\n                    if (0x95ea7b3 == function_selector >> 224) {\n                        approve(address,uint256);\n                    } else if (0xfaee56f == function_selector >> 224) {\n                        _maxTaxSwap();\n                    } else {\n                        require(0x18160ddd == function_selector >> 224);\n                        totalSupply();\n                    }\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x51bc3c85 == function_selector >> 224) {\n                manualSwap();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else {\n                require(0x715018a6 == function_selector >> 224);\n                renounceOwnership();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x751039fc == function_selector >> 224) {\n                removeLimits();\n            } else if (0x7d1db4a5 == function_selector >> 224) {\n                _maxTxAmount();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x8f9a55c0 == function_selector >> 224) {\n                _maxWalletSize();\n            } else {\n                require(0x95d89b41 == function_selector >> 224);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xbf474bed == function_selector >> 224) {\n            _taxSwapThreshold();\n        } else if (0xc9567bf9 == function_selector >> 224) {\n            openTrading();\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else {\n            require(0xf4293890 == function_selector >> 224);\n            manualSend();\n        }\n        symbol();\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.16 14:36 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _manualSend; // STORAGE[0x6] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction 0x11f2(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction 0x1206(uint256 varg0, uint256 varg1) private { \n    v0 = _SafeAdd(varg1, varg0);\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    require((varg1 == varg1 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    return varg1 * varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1 + varg0, Panic(17)); // arithmetic overflow or underflow\n    return varg1 + varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x939(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    return v1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    0xa5c(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    0x939(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSend);\n    if (_balanceOf[this]) {\n        0xf85(_balanceOf[this]);\n    }\n    if (this.balance) {\n        v0 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        // Unknown jump to Block 0x1afb. Refer to 3-address code (TAC);\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    __maxTxAmount = v1;\n    v2 = _SafeExp(10, uint8(9));\n    v3 = _SafeMul(0x3b9aca00, v2);\n    __maxWalletSize = v3;\n    v4 = _SafeExp(10, uint8(9));\n    v5 = _SafeMul(0x3b9aca00, v4);\n    emit MaxTxAmountUpdated(v5);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0xa5c(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    0x939(v1, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v2, /* address */ v3 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    v6, /* address */ v7 = address(v3).createPair(address(this), address(v5)).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v7 == address(v7));\n    owner_14 = bytes12(owner_14) | address(v7);\n    v8, /* uint256 */ v9, /* uint256 */ v10, /* uint256 */ v11 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v8), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v12, /* bool */ v13 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v12), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v13 == bool(v13));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction manualSend() public nonPayable { \n    v0 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction 0x939(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0xa5c(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != varg1;\n    }\n    if (v2) {\n        v5 = v6 = 3039;\n        v7 = v8 = 100;\n        v9 = v10 = 7640;\n        if (stor_e > stor_b) {\n            v11 = v12 = stor_9;\n        } else {\n            v11 = v13 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x113b. Refer to 3-address code (TAC);\n                }\n                v14 = v15 = 0;\n                // Unknown jump to Block {'0x1dd8', '0x1dfd'}. Refer to 3-address code (TAC);\n                if (v7) {\n                    require(v7, Panic(18)); // division by zero\n                    v0 = v14 / v7;\n                    // Unknown jump to Block {'0xd67', '0xbdf'}. Refer to 3-address code (TAC);\n                    v16 = v17 = address(owner_14) == varg2;\n                    if (v17) {\n                        v16 = v18 = stor_13_0_19 != varg1;\n                    }\n                    if (v16) {\n                        v16 = v19 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v16) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        v20 = _SafeAdd(_balanceOf[varg1], varg0);\n                        require(v20 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v21 = v22 = address(owner_14) == varg1;\n                    if (v22) {\n                        v21 = v23 = this != varg2;\n                    }\n                    if (v21) {\n                        v5 = v24 = 3431;\n                        v7 = v25 = 100;\n                        v9 = v26 = 7677;\n                        if (stor_e > stor_c) {\n                            v11 = v27 = stor_a;\n                        } else {\n                            v11 = v28 = stor_8;\n                            continue;\n                        }\n                    }\n                    v29 = v30 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v29 = v31 = address(owner_14) == varg1;\n                    }\n                    if (v29) {\n                        v29 = v32 = uint8(owner_14 >> 176);\n                    }\n                    if (v29) {\n                        v29 = v33 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v29) {\n                        v29 = v34 = stor_e > stor_d;\n                    }\n                    if (v29) {\n                        v35 = 0x11f2(__maxTaxSwap, _balanceOf[this]);\n                        v36 = 0x11f2(v35, varg0);\n                        0xf85(v36);\n                        if (this.balance > 0xb1a2bc2ec50000) {\n                            v37 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v37), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v38 = new bytes[](v39.length);\n                    v40 = v41 = 0;\n                    while (v40 < v39.length) {\n                        v38[v40] = v39[v40];\n                        v40 += 32;\n                    }\n                    v38[v39.length] = 0;\n                    revert(Error(v38));\n                }\n                // Unknown jump to Block 0x11b1. Refer to 3-address code (TAC);\n                v14 = v42 = _SafeMul(varg0, v11);\n                require(varg0, Panic(18)); // division by zero\n                require(v42 / varg0 == v11, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x1dd8', '0x1dfd'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v43 = 0x1206(v0, _balanceOf[this]);\n        _balanceOf[this] = v43;\n        emit Transfer(varg2, this, v0);\n    }\n    v44 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v44;\n    v45 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v46 = 0x1206(v45, _balanceOf[varg1]);\n    _balanceOf[varg1] = v46;\n    v47 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v47;\n    emit Transfer(varg2, varg1, v47);\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction 0xf85(uint256 varg0) private { \n    owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    0x939(varg0, stor_13_0_19, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(stor_13_0_19.code.size));\n    v11 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        if (0x751039fc > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 != function_selector >> 224) {\n                    if (0x95ea7b3 == function_selector >> 224) {\n                        approve(address,uint256);\n                    } else if (0xfaee56f == function_selector >> 224) {\n                        _maxTaxSwap();\n                    } else {\n                        require(0x18160ddd == function_selector >> 224);\n                        totalSupply();\n                    }\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x51bc3c85 == function_selector >> 224) {\n                manualSwap();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else {\n                require(0x715018a6 == function_selector >> 224);\n                renounceOwnership();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x751039fc == function_selector >> 224) {\n                removeLimits();\n            } else if (0x7d1db4a5 == function_selector >> 224) {\n                _maxTxAmount();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x8f9a55c0 == function_selector >> 224) {\n                _maxWalletSize();\n            } else {\n                require(0x95d89b41 == function_selector >> 224);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xbf474bed == function_selector >> 224) {\n            _taxSwapThreshold();\n        } else if (0xc9567bf9 == function_selector >> 224) {\n            openTrading();\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else {\n            require(0xf4293890 == function_selector >> 224);\n            manualSend();\n        }\n        symbol();\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.16 14:36 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _manualSend; // STORAGE[0x6] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction 0x11f2(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction 0x1206(uint256 varg0, uint256 varg1) private { \n    v0 = _SafeAdd(varg1, varg0);\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    require((varg1 == varg1 * varg0 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n    return varg1 * varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg0 <= varg1 + varg0, Panic(17)); // arithmetic overflow or underflow\n    return varg1 + varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0x939(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    return v1;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    0xa5c(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    0x939(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 9;\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSend);\n    if (_balanceOf[this]) {\n        0xf85(_balanceOf[this]);\n    }\n    if (this.balance) {\n        v0 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        // Unknown jump to Block 0x1afb. Refer to 3-address code (TAC);\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    __maxTxAmount = v1;\n    v2 = _SafeExp(10, uint8(9));\n    v3 = _SafeMul(0x3b9aca00, v2);\n    __maxWalletSize = v3;\n    v4 = _SafeExp(10, uint8(9));\n    v5 = _SafeMul(0x3b9aca00, v4);\n    emit MaxTxAmountUpdated(v5);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    0xa5c(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(9));\n    v1 = _SafeMul(0x3b9aca00, v0);\n    0x939(v1, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v2, /* address */ v3 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    v4, /* address */ v5 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v5 == address(v5));\n    v6, /* address */ v7 = address(v3).createPair(address(this), address(v5)).gas(msg.gas);\n    require(bool(v6), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v7 == address(v7));\n    owner_14 = bytes12(owner_14) | address(v7);\n    v8, /* uint256 */ v9, /* uint256 */ v10, /* uint256 */ v11 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v8), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v12, /* bool */ v13 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v12), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v13 == bool(v13));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction manualSend() public nonPayable { \n    v0 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n}\n\nfunction 0x939(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction 0xa5c(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(varg1, Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != varg1;\n    }\n    if (v2) {\n        v5 = v6 = 3039;\n        v7 = v8 = 100;\n        v9 = v10 = 7640;\n        if (stor_e > stor_b) {\n            v11 = v12 = stor_9;\n        } else {\n            v11 = v13 = stor_7;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x113b. Refer to 3-address code (TAC);\n                }\n                v14 = v15 = 0;\n                // Unknown jump to Block {'0x1dd8', '0x1dfd'}. Refer to 3-address code (TAC);\n                if (v7) {\n                    require(v7, Panic(18)); // division by zero\n                    v0 = v14 / v7;\n                    // Unknown jump to Block {'0xd67', '0xbdf'}. Refer to 3-address code (TAC);\n                    v16 = v17 = address(owner_14) == varg2;\n                    if (v17) {\n                        v16 = v18 = stor_13_0_19 != varg1;\n                    }\n                    if (v16) {\n                        v16 = v19 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v16) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        v20 = _SafeAdd(_balanceOf[varg1], varg0);\n                        require(v20 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(stor_e + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v21 = v22 = address(owner_14) == varg1;\n                    if (v22) {\n                        v21 = v23 = this != varg2;\n                    }\n                    if (v21) {\n                        v5 = v24 = 3431;\n                        v7 = v25 = 100;\n                        v9 = v26 = 7677;\n                        if (stor_e > stor_c) {\n                            v11 = v27 = stor_a;\n                        } else {\n                            v11 = v28 = stor_8;\n                            continue;\n                        }\n                    }\n                    v29 = v30 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v29 = v31 = address(owner_14) == varg1;\n                    }\n                    if (v29) {\n                        v29 = v32 = uint8(owner_14 >> 176);\n                    }\n                    if (v29) {\n                        v29 = v33 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v29) {\n                        v29 = v34 = stor_e > stor_d;\n                    }\n                    if (v29) {\n                        v35 = 0x11f2(__maxTaxSwap, _balanceOf[this]);\n                        v36 = 0x11f2(v35, varg0);\n                        0xf85(v36);\n                        if (this.balance > 0xb1a2bc2ec50000) {\n                            v37 = _manualSend.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v37), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v38 = new bytes[](v39.length);\n                    v40 = v41 = 0;\n                    while (v40 < v39.length) {\n                        v38[v40] = v39[v40];\n                        v40 += 32;\n                    }\n                    v38[v39.length] = 0;\n                    revert(Error(v38));\n                }\n                // Unknown jump to Block 0x11b1. Refer to 3-address code (TAC);\n                v14 = v42 = _SafeMul(varg0, v11);\n                require(varg0, Panic(18)); // division by zero\n                require(v42 / varg0 == v11, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x1dd8', '0x1dfd'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v43 = 0x1206(v0, _balanceOf[this]);\n        _balanceOf[this] = v43;\n        emit Transfer(varg2, this, v0);\n    }\n    v44 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v44;\n    v45 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v46 = 0x1206(v45, _balanceOf[varg1]);\n    _balanceOf[varg1] = v46;\n    v47 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v47;\n    emit Transfer(varg2, varg1, v47);\n    return ;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction 0xf85(uint256 varg0) private { \n    owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n    v0 = new address[](2);\n    CALLDATACOPY(v0.data, msg.data.length, 64);\n    require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v1 = v0.data;\n    v0[0] = address(this);\n    v2, /* address */ v3 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v3 == address(v3));\n    require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n    v0[1] = address(v3);\n    0x939(varg0, stor_13_0_19, this);\n    v4 = new address[](v0.length);\n    v5 = v6 = v4.data;\n    v7 = v8 = v0.data;\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v5] = address(MEM[v7]);\n        v7 += 32;\n        v5 += 32;\n        v9 += 1;\n    }\n    require(bool(stor_13_0_19.code.size));\n    v11 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else {\n        if (0x751039fc > function_selector >> 224) {\n            if (0x23b872dd > function_selector >> 224) {\n                if (0x6fdde03 != function_selector >> 224) {\n                    if (0x95ea7b3 == function_selector >> 224) {\n                        approve(address,uint256);\n                    } else if (0xfaee56f == function_selector >> 224) {\n                        _maxTaxSwap();\n                    } else {\n                        require(0x18160ddd == function_selector >> 224);\n                        totalSupply();\n                    }\n                }\n            } else if (0x23b872dd == function_selector >> 224) {\n                transferFrom(address,address,uint256);\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x51bc3c85 == function_selector >> 224) {\n                manualSwap();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            } else {\n                require(0x715018a6 == function_selector >> 224);\n                renounceOwnership();\n            }\n        } else if (0xa9059cbb > function_selector >> 224) {\n            if (0x751039fc == function_selector >> 224) {\n                removeLimits();\n            } else if (0x7d1db4a5 == function_selector >> 224) {\n                _maxTxAmount();\n            } else if (0x8da5cb5b == function_selector >> 224) {\n                owner();\n            } else if (0x8f9a55c0 == function_selector >> 224) {\n                _maxWalletSize();\n            } else {\n                require(0x95d89b41 == function_selector >> 224);\n            }\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xbf474bed == function_selector >> 224) {\n            _taxSwapThreshold();\n        } else if (0xc9567bf9 == function_selector >> 224) {\n            openTrading();\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else {\n            require(0xf4293890 == function_selector >> 224);\n            manualSend();\n        }\n        symbol();\n    }\n}\n.",
	"status": "1",
	"time_cost": 42.24886345863342,
	"usage": {
		"completion_tokens": 566,
		"prompt_tokens": 5259,
		"total_tokens": 5825
	}
}