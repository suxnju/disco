{
	"address": "0x087239350b3b9bcdad0e7e318ef9c4eaff5eaed3",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled code provided is quite complex and extensive. It appears to represent a smart contract that involves token transfers, approvals, and changing of ownerships. Below is a simplified example of a Solidity smart contract that includes some of the functionality from the decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    \n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowances;\n    address public owner;\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function transfer(address to, uint256 tokens) public returns (bool success) {\n        require(balances[msg.sender] >= tokens);\n        balances[msg.sender] -= tokens;\n        balances[to] += tokens;\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\n        require(balances[from] >= tokens);\n        require(allowances[from][msg.sender] >= tokens);\n        balances[from] -= tokens;\n        balances[to] += tokens;\n        allowances[from][msg.sender] -= tokens;\n        return true;\n    }\n\n    function approve(address spender, uint256 tokens) public returns (bool success) {\n        allowances[msg.sender][spender] = tokens;\n        return true;\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint256 balance) {\n        return balances[tokenOwner];\n    }\n\n    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining) {\n        return allowances[tokenOwner][spender];\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == owner);\n        owner = newOwner;\n    }\n}\n```\n\nPlease note that this is a simple illustration of the contract and does not cover all the functionalities in the decompiled code. The original contract is much more complex and involves additional functionalities not covered in this example.",
				"role": "assistant"
			}
		}
	],
	"created": 1700474407,
	"id": "chatcmpl-8MvMVinHiHnNo8kVxN4Q0SBuWmlJY",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor11 is uint256 at storage 11\n  stor99 is mapping of uint256 at storage 99\n  storFFFF is uint256 at storage 0xffffff\n\ndef _fallback() payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == 1433889655:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][7]\n      require _param3 > block.timestamp and _param2 > 0\n      require stor[sha3('liquidityAddingAllowed')][9]\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 1608)\n  if mem[0 len 28], uint32(call.func_hash) == 2479501194:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][8]\n      require _param2 > 0 and _param4 > block.timestamp\n      require stor[caller][5] >= _param2\n      require stor4 > 0\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2404)\n  if mem[0 len 28], uint32(call.func_hash) == 2444389088:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 3989)\n  if mem[0 len 28], uint32(call.func_hash) == 308675509:\n      require not call.value\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require _param3 < 0x10000000000000000000000000000000000000000\n      call this.address.0x91b26ae0 with:\n           gas gas_remaining wei\n          args _param2, _param3\n      require ext_call.success\n      if not _param1:\n          return 0\n      require _param1 * ext_call.return_data[0] / _param1 == ext_call.return_data[0]\n      return (_param1 * ext_call.return_data[0] / 10000 * 10^18)\n  if mem[0 len 28], uint32(call.func_hash) == 1138301937:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][7] and stor[_param2][8]\n      require _param3 > 0 and _param4 > 0\n      require _param5 > block.timestamp\n      require stor[sha3('tradingAllowed')][9]\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 5517)\n  if mem[0 len 28], uint32(call.func_hash) == 601346472:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require caller == stor2\n      require stor[_param1][7] != _param2\n      require ext_code.size(_param1)\n      require this.address xor _param1\n      static call _param1.decimals() with:\n              gas gas_remaining wei\n      require ext_call.success\n      require ext_call.return_data[0] >= 2\n      stor[_param1][7] = _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 1155257140:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require caller == stor2\n      require stor[_param1][8] != _param2\n      require ext_code.size(_param1)\n      require this.address xor _param1\n      static call _param1.decimals() with:\n              gas gas_remaining wei\n      require ext_call.success\n      require ext_call.return_data[0] >= 2\n      stor[_param1][8] = _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2419724289:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require _param2 < 2\n      require caller == stor2\n      stor[sha3(mem[352 len call.data[_param1 + 4]])][9] = _param2\n      require call.data[_param1 + 4] <=\u2032 32\n      require call.data[_param1 + 4] >=\u2032 0\n      log 0x22b59c94: call.data[_param1 + 36] / 256^0, _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2157994635:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require 10^10 * stor[_param1][5] <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * stor4 <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * stor4\n      require 100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      return (100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4)\n  if mem[0 len 28], uint32(call.func_hash) == transferOwnership(address newOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param1 xor 0\n      require caller == stor2\n      stor2 = _param1\n      log OwnershipTransferred(\n            address previousOwner=stor2,\n            address newOwner=_param1)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2571061792:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require caller == stor2\n      require 10^15 * _param2 /\u2032 _param2 == 10^15 or not _param2\n      require 10^15 * _param2 /\u2032 10^10 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^15 * _param2 /\u2032 10^10 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      mem[416] = 10^15\n      require 10^15 * _param2 /\u2032 _param2 == 10^15 or not _param2\n      require 10^15 * _param2 /\u2032 10^10 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^15 * _param2 /\u2032 10^10 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      if 10^15 * _param2 /\u2032 10^10 >=\u2032 0:\n          require 10^15 * _param2 /\u2032 10^10 /\u2032 10^10 >=\u2032 0\n          stor[sha3(mem[352 len call.data[_param1 + 4]])][10] = 10^15 * _param2 /\u2032 10^10 /\u2032 10^10\n      else:\n          require (10^15 * _param2 /\u2032 10^10) - 9999999999 /\u2032 10^10 >=\u2032 0\n          stor[sha3(mem[352 len call.data[_param1 + 4]])][10] = (10^15 * _param2 /\u2032 10^10) - 9999999999 /\u2032 10^10\n      require call.data[_param1 + 4] <=\u2032 32\n      require call.data[_param1 + 4] >=\u2032 0\n      log 0xd8dd23b6: call.data[_param1 + 36] / 256^0, _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 3758476223:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require 10^10 * stor[sha3(mem[352 len call.data[_param1 + 4]])][10] <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      mem[416] = 10^10 * stor[sha3(mem[352 len call.data[_param1 + 4]])][10]\n      require 10^10 * mem[416] /\u2032 10^15 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * mem[416] /\u2032 10^15 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      return (10^10 * mem[416] /\u2032 10^15)\n  if mem[0 len 28], uint32(call.func_hash) == 2261901355:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor2\n      stor11 = _param1\n      log 0x12ad2958: _param1\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == transfer(address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[caller][5] >= _param2\n      stor[caller][5] -= _param2\n      require stor[_param1][5] + _param2 >= stor[_param1][5]\n      stor[_param1][5] += _param2\n      log Transfer(\n            address from=_param2,\n            address to=caller,\n            uint256 tokens=_param1)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address from, address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][5] >= _param3\n      stor[_param1][5] -= _param3\n      require stor[_param2][5] + _param3 >= stor[_param2][5]\n      stor[_param2][5] += _param3\n      require stor[caller][('map', 6, ('param', '_param1'))] >= _param3\n      stor[caller][('map', 6, ('param', '_param1'))] -= _param3\n      log Transfer(\n            address from=_param3,\n            address to=_param1,\n            uint256 tokens=_param2)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      stor[_param1][('map', 6, 'caller')] = _param2\n      log Approval(\n            address tokenOwner=_param2,\n            address spender=caller,\n            uint256 tokens=caller)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == name():\n      require not call.value\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == symbol():\n      require not call.value\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == owner():\n      require not call.value\n      return stor2\n  if mem[0 len 28], uint32(call.func_hash) == decimals():\n      require not call.value\n      return stor3\n  if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n      require not call.value\n      return stor4\n  if mem[0 len 28], uint32(call.func_hash) == balanceOf(address tokenOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][5]\n  if mem[0 len 28], uint32(call.func_hash) == allowance(address tokenOwner, address spender):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      return stor[_param2][('map', 6, ('param', '_param1'))]\n  if mem[0 len 28], uint32(call.func_hash) == 1234824079:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][7]\n  if mem[0 len 28], uint32(call.func_hash) == 1374475002:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][8]\n  if mem[0 len 28], uint32(call.func_hash) != 1965492475:\n      require mem[0 len 28], uint32(call.func_hash) == 734338157\n      require not call.value\n      return stor11\n  require not call.value\n  mem[320 len 64] = call.data[_param1 + 4 len 64]\n  require _param1.length <= 32\n  return stor[sha3(mem[352 len call.data[_param1 + 4]])][9]\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor11 is uint256 at storage 11\n  stor99 is mapping of uint256 at storage 99\n  storFFFF is uint256 at storage 0xffffff\n\ndef _fallback() payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == 1433889655:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][7]\n      require _param3 > block.timestamp and _param2 > 0\n      require stor[sha3('liquidityAddingAllowed')][9]\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 1608)\n  if mem[0 len 28], uint32(call.func_hash) == 2479501194:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][8]\n      require _param2 > 0 and _param4 > block.timestamp\n      require stor[caller][5] >= _param2\n      require stor4 > 0\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2404)\n  if mem[0 len 28], uint32(call.func_hash) == 2444389088:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 3989)\n  if mem[0 len 28], uint32(call.func_hash) == 308675509:\n      require not call.value\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require _param3 < 0x10000000000000000000000000000000000000000\n      call this.address.0x91b26ae0 with:\n           gas gas_remaining wei\n          args _param2, _param3\n      require ext_call.success\n      if not _param1:\n          return 0\n      require _param1 * ext_call.return_data[0] / _param1 == ext_call.return_data[0]\n      return (_param1 * ext_call.return_data[0] / 10000 * 10^18)\n  if mem[0 len 28], uint32(call.func_hash) == 1138301937:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][7] and stor[_param2][8]\n      require _param3 > 0 and _param4 > 0\n      require _param5 > block.timestamp\n      require stor[sha3('tradingAllowed')][9]\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 5517)\n  if mem[0 len 28], uint32(call.func_hash) == 601346472:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require caller == stor2\n      require stor[_param1][7] != _param2\n      require ext_code.size(_param1)\n      require this.address xor _param1\n      static call _param1.decimals() with:\n              gas gas_remaining wei\n      require ext_call.success\n      require ext_call.return_data[0] >= 2\n      stor[_param1][7] = _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 1155257140:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require caller == stor2\n      require stor[_param1][8] != _param2\n      require ext_code.size(_param1)\n      require this.address xor _param1\n      static call _param1.decimals() with:\n              gas gas_remaining wei\n      require ext_call.success\n      require ext_call.return_data[0] >= 2\n      stor[_param1][8] = _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2419724289:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require _param2 < 2\n      require caller == stor2\n      stor[sha3(mem[352 len call.data[_param1 + 4]])][9] = _param2\n      require call.data[_param1 + 4] <=\u2032 32\n      require call.data[_param1 + 4] >=\u2032 0\n      log 0x22b59c94: call.data[_param1 + 36] / 256^0, _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2157994635:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require 10^10 * stor[_param1][5] <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * stor4 <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * stor4\n      require 100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      return (100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4)\n  if mem[0 len 28], uint32(call.func_hash) == transferOwnership(address newOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param1 xor 0\n      require caller == stor2\n      stor2 = _param1\n      log OwnershipTransferred(\n            address previousOwner=stor2,\n            address newOwner=_param1)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2571061792:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require caller == stor2\n      require 10^15 * _param2 /\u2032 _param2 == 10^15 or not _param2\n      require 10^15 * _param2 /\u2032 10^10 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^15 * _param2 /\u2032 10^10 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      mem[416] = 10^15\n      require 10^15 * _param2 /\u2032 _param2 == 10^15 or not _param2\n      require 10^15 * _param2 /\u2032 10^10 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^15 * _param2 /\u2032 10^10 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      if 10^15 * _param2 /\u2032 10^10 >=\u2032 0:\n          require 10^15 * _param2 /\u2032 10^10 /\u2032 10^10 >=\u2032 0\n          stor[sha3(mem[352 len call.data[_param1 + 4]])][10] = 10^15 * _param2 /\u2032 10^10 /\u2032 10^10\n      else:\n          require (10^15 * _param2 /\u2032 10^10) - 9999999999 /\u2032 10^10 >=\u2032 0\n          stor[sha3(mem[352 len call.data[_param1 + 4]])][10] = (10^15 * _param2 /\u2032 10^10) - 9999999999 /\u2032 10^10\n      require call.data[_param1 + 4] <=\u2032 32\n      require call.data[_param1 + 4] >=\u2032 0\n      log 0xd8dd23b6: call.data[_param1 + 36] / 256^0, _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 3758476223:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require 10^10 * stor[sha3(mem[352 len call.data[_param1 + 4]])][10] <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      mem[416] = 10^10 * stor[sha3(mem[352 len call.data[_param1 + 4]])][10]\n      require 10^10 * mem[416] /\u2032 10^15 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * mem[416] /\u2032 10^15 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      return (10^10 * mem[416] /\u2032 10^15)\n  if mem[0 len 28], uint32(call.func_hash) == 2261901355:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor2\n      stor11 = _param1\n      log 0x12ad2958: _param1\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == transfer(address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[caller][5] >= _param2\n      stor[caller][5] -= _param2\n      require stor[_param1][5] + _param2 >= stor[_param1][5]\n      stor[_param1][5] += _param2\n      log Transfer(\n            address from=_param2,\n            address to=caller,\n            uint256 tokens=_param1)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address from, address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][5] >= _param3\n      stor[_param1][5] -= _param3\n      require stor[_param2][5] + _param3 >= stor[_param2][5]\n      stor[_param2][5] += _param3\n      require stor[caller][('map', 6, ('param', '_param1'))] >= _param3\n      stor[caller][('map', 6, ('param', '_param1'))] -= _param3\n      log Transfer(\n            address from=_param3,\n            address to=_param1,\n            uint256 tokens=_param2)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      stor[_param1][('map', 6, 'caller')] = _param2\n      log Approval(\n            address tokenOwner=_param2,\n            address spender=caller,\n            uint256 tokens=caller)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == name():\n      require not call.value\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == symbol():\n      require not call.value\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == owner():\n      require not call.value\n      return stor2\n  if mem[0 len 28], uint32(call.func_hash) == decimals():\n      require not call.value\n      return stor3\n  if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n      require not call.value\n      return stor4\n  if mem[0 len 28], uint32(call.func_hash) == balanceOf(address tokenOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][5]\n  if mem[0 len 28], uint32(call.func_hash) == allowance(address tokenOwner, address spender):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      return stor[_param2][('map', 6, ('param', '_param1'))]\n  if mem[0 len 28], uint32(call.func_hash) == 1234824079:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][7]\n  if mem[0 len 28], uint32(call.func_hash) == 1374475002:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][8]\n  if mem[0 len 28], uint32(call.func_hash) != 1965492475:\n      require mem[0 len 28], uint32(call.func_hash) == 734338157\n      require not call.value\n      return stor11\n  require not call.value\n  mem[320 len 64] = call.data[_param1 + 4 len 64]\n  require _param1.length <= 32\n  return stor[sha3(mem[352 len call.data[_param1 + 4]])][9]\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint256 at storage 4\n  stor11 is uint256 at storage 11\n  stor99 is mapping of uint256 at storage 99\n  storFFFF is uint256 at storage 0xffffff\n\ndef _fallback() payable: # default function\n  if mem[0 len 28], uint32(call.func_hash) == 1433889655:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][7]\n      require _param3 > block.timestamp and _param2 > 0\n      require stor[sha3('liquidityAddingAllowed')][9]\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 1608)\n  if mem[0 len 28], uint32(call.func_hash) == 2479501194:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][8]\n      require _param2 > 0 and _param4 > block.timestamp\n      require stor[caller][5] >= _param2\n      require stor4 > 0\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 2404)\n  if mem[0 len 28], uint32(call.func_hash) == 2444389088:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 3989)\n  if mem[0 len 28], uint32(call.func_hash) == 308675509:\n      require not call.value\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require _param3 < 0x10000000000000000000000000000000000000000\n      call this.address.0x91b26ae0 with:\n           gas gas_remaining wei\n          args _param2, _param3\n      require ext_call.success\n      if not _param1:\n          return 0\n      require _param1 * ext_call.return_data[0] / _param1 == ext_call.return_data[0]\n      return (_param1 * ext_call.return_data[0] / 10000 * 10^18)\n  if mem[0 len 28], uint32(call.func_hash) == 1138301937:\n      require not storFFFF\n      storFFFF = 1\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][7] and stor[_param2][8]\n      require _param3 > 0 and _param4 > 0\n      require _param5 > block.timestamp\n      require stor[sha3('tradingAllowed')][9]\n      require ext_code.size(stor11)\n      require this.address xor stor11\n      static call stor11.0xf1bb1086 with:\n              gas gas_remaining wei\n             args _param1\n      require ext_call.success\n      require ext_call.return_data[0] > 0\n      ...  # Decompilation aborted, sorry: ('jump to a parameter computed at runtime', 5517)\n  if mem[0 len 28], uint32(call.func_hash) == 601346472:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require caller == stor2\n      require stor[_param1][7] != _param2\n      require ext_code.size(_param1)\n      require this.address xor _param1\n      static call _param1.decimals() with:\n              gas gas_remaining wei\n      require ext_call.success\n      require ext_call.return_data[0] >= 2\n      stor[_param1][7] = _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 1155257140:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 2\n      require caller == stor2\n      require stor[_param1][8] != _param2\n      require ext_code.size(_param1)\n      require this.address xor _param1\n      static call _param1.decimals() with:\n              gas gas_remaining wei\n      require ext_call.success\n      require ext_call.return_data[0] >= 2\n      stor[_param1][8] = _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2419724289:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require _param2 < 2\n      require caller == stor2\n      stor[sha3(mem[352 len call.data[_param1 + 4]])][9] = _param2\n      require call.data[_param1 + 4] <=\u2032 32\n      require call.data[_param1 + 4] >=\u2032 0\n      log 0x22b59c94: call.data[_param1 + 36] / 256^0, _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2157994635:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require 10^10 * stor[_param1][5] <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * stor4 <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * stor4\n      require 100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      return (100 * 10^18 * stor[_param1][5] /\u2032 10^10 * stor4)\n  if mem[0 len 28], uint32(call.func_hash) == transferOwnership(address newOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param1 xor 0\n      require caller == stor2\n      stor2 = _param1\n      log OwnershipTransferred(\n            address previousOwner=stor2,\n            address newOwner=_param1)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 2571061792:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require caller == stor2\n      require 10^15 * _param2 /\u2032 _param2 == 10^15 or not _param2\n      require 10^15 * _param2 /\u2032 10^10 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^15 * _param2 /\u2032 10^10 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      mem[416] = 10^15\n      require 10^15 * _param2 /\u2032 _param2 == 10^15 or not _param2\n      require 10^15 * _param2 /\u2032 10^10 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^15 * _param2 /\u2032 10^10 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      if 10^15 * _param2 /\u2032 10^10 >=\u2032 0:\n          require 10^15 * _param2 /\u2032 10^10 /\u2032 10^10 >=\u2032 0\n          stor[sha3(mem[352 len call.data[_param1 + 4]])][10] = 10^15 * _param2 /\u2032 10^10 /\u2032 10^10\n      else:\n          require (10^15 * _param2 /\u2032 10^10) - 9999999999 /\u2032 10^10 >=\u2032 0\n          stor[sha3(mem[352 len call.data[_param1 + 4]])][10] = (10^15 * _param2 /\u2032 10^10) - 9999999999 /\u2032 10^10\n      require call.data[_param1 + 4] <=\u2032 32\n      require call.data[_param1 + 4] >=\u2032 0\n      log 0xd8dd23b6: call.data[_param1 + 36] / 256^0, _param2\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == 3758476223:\n      require not call.value\n      mem[320 len 64] = call.data[_param1 + 4 len 64]\n      require _param1.length <= 32\n      require 10^10 * stor[sha3(mem[352 len call.data[_param1 + 4]])][10] <= 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      mem[416] = 10^10 * stor[sha3(mem[352 len call.data[_param1 + 4]])][10]\n      require 10^10 * mem[416] /\u2032 10^15 <=\u2032 0x12a05f1fffffffffffffffffffffffffdabf41c00\n      require 10^10 * mem[416] /\u2032 10^15 >=\u2032 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000\n      return (10^10 * mem[416] /\u2032 10^15)\n  if mem[0 len 28], uint32(call.func_hash) == 2261901355:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require caller == stor2\n      stor11 = _param1\n      log 0x12ad2958: _param1\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == transfer(address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require stor[caller][5] >= _param2\n      stor[caller][5] -= _param2\n      require stor[_param1][5] + _param2 >= stor[_param1][5]\n      stor[_param1][5] += _param2\n      log Transfer(\n            address from=_param2,\n            address to=caller,\n            uint256 tokens=_param1)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == transferFrom(address from, address to, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      require stor[_param1][5] >= _param3\n      stor[_param1][5] -= _param3\n      require stor[_param2][5] + _param3 >= stor[_param2][5]\n      stor[_param2][5] += _param3\n      require stor[caller][('map', 6, ('param', '_param1'))] >= _param3\n      stor[caller][('map', 6, ('param', '_param1'))] -= _param3\n      log Transfer(\n            address from=_param3,\n            address to=_param1,\n            uint256 tokens=_param2)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == approve(address spender, uint256 tokens):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      stor[_param1][('map', 6, 'caller')] = _param2\n      log Approval(\n            address tokenOwner=_param2,\n            address spender=caller,\n            uint256 tokens=caller)\n      return 1\n  if mem[0 len 28], uint32(call.func_hash) == name():\n      require not call.value\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == symbol():\n      require not call.value\n      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n  if mem[0 len 28], uint32(call.func_hash) == owner():\n      require not call.value\n      return stor2\n  if mem[0 len 28], uint32(call.func_hash) == decimals():\n      require not call.value\n      return stor3\n  if mem[0 len 28], uint32(call.func_hash) == totalSupply():\n      require not call.value\n      return stor4\n  if mem[0 len 28], uint32(call.func_hash) == balanceOf(address tokenOwner):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][5]\n  if mem[0 len 28], uint32(call.func_hash) == allowance(address tokenOwner, address spender):\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      require _param2 < 0x10000000000000000000000000000000000000000\n      return stor[_param2][('map', 6, ('param', '_param1'))]\n  if mem[0 len 28], uint32(call.func_hash) == 1234824079:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][7]\n  if mem[0 len 28], uint32(call.func_hash) == 1374475002:\n      require not call.value\n      require _param1 < 0x10000000000000000000000000000000000000000\n      return stor[_param1][8]\n  if mem[0 len 28], uint32(call.func_hash) != 1965492475:\n      require mem[0 len 28], uint32(call.func_hash) == 734338157\n      require not call.value\n      return stor11\n  require not call.value\n  mem[320 len 64] = call.data[_param1 + 4 len 64]\n  require _param1.length <= 32\n  return stor[sha3(mem[352 len call.data[_param1 + 4]])][9]\n\n.",
	"status": "1",
	"time_cost": 20.635526180267334,
	"usage": {
		"completion_tokens": 393,
		"prompt_tokens": 3804,
		"total_tokens": 4197
	}
}