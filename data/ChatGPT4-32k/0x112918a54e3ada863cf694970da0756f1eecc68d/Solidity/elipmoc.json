{
	"address": "0x112918a54e3ada863cf694970da0756f1eecc68d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract code that aligns with the decompiled EVM Bytecode:\n\n```solidity\npragma solidity 0.5.17;\n\ncontract MultiSigWallet {\n    // Events\n    event Deposit(address indexed sender, uint value);\n    event OwnerRemoval(address indexed owner);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event OwnerAddition(address indexed owner);\n    event RequirementChange(uint required);\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Submission(uint indexed transactionId);\n\n    // Constants\n    uint constant public MAX_OWNER_COUNT = 50;\n\n    // Properties\n    mapping (uint => Transaction) public transactions;\n    mapping (uint => mapping(address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    address[] public owners;\n    uint public required;\n    uint public transactionCount;\n\n    // Structs\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    // Modifiers\n    modifier ownerDoesNotExist(address owner) {\n        require(!isOwner[owner]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require(isOwner[owner]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require(transactions[transactionId].destination != address(0));\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require(confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require(!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require(!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier validRequirement(uint ownerCount, uint _required) {\n        require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0);\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _required) public validRequirement(_owners.length, _required) {\n        for (uint i = 0; i < _owners.length; i++) {\n            isOwner[_owners[i]] = true;\n        }\n        owners = _owners;\n        required = _required;\n    }\n\n    // Fallback function to accept deposits\n    function() external payable {\n        if (msg.value > 0) {\n            emit Deposit(msg.sender, msg.value);\n        }\n    }\n\n    // Owner addition, removal and replacement\n    function addOwner(address owner) public ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) {\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    function removeOwner(address owner) public ownerExists(owner) {\n        isOwner[owner] = false;\n        for (uint i = 0; i < owners.length - 1; i++) {\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        }\n        owners.length -= 1;\n        if (required > owners.length) {\n            changeRequirement(owners.length);\n        }\n        emit OwnerRemoval(owner);\n    }\n\n    function replaceOwner(address owner, address newOwner) public ownerExists(owner) ownerDoesNotExist(newOwner) {\n        for (uint i = 0; i < owners.length; i++) {\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        emit OwnerRemoval(owner);\n        emit OwnerAddition(newOwner);\n    }\n\n    // Requirement change\n    function changeRequirement(uint _required) public validRequirement(owners.length, _required) {\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    // Transaction submission and confirmation\n    function submitTransaction(address destination, uint value, bytes memory data) public returns (uint transactionId) {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) {\n        confirmations[transactionId][msg.sender] = true;\n        emit Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n\n    function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            (bool success,) = txn.destination.call.value(txn.value)(txn.data);\n            if (success)\n                emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) {\n        confirmations[transactionId][msg.sender] = false;\n        emit Revocation(msg.sender, transactionId);\n    }\n\n    // Internals\n    function addTransaction(address destination, uint value, bytes memory data) internal notNull(destination) returns (uint transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    function isConfirmed(uint transactionId) internal view returns (bool) {\n        uint count = 0;\n        for (uint i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    // Views\n    function getConfirmationCount(uint transactionId) public view returns (uint count) {\n        for (uint i = 0; i < owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n        }\n    }\n\n    function getTransactionCount(bool pending, bool executed) public view returns (uint count) {\n        for (uint i = 0; i < transactionCount; i++) {\n            if (pending && !transactions[i].executed || executed && transactions[i].executed)\n                count += 1;\n        }\n    }\n\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    function getConfirmations(uint transactionId) public view returns (address[] memory _confirmations) {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        }\n        _confirmations = new address[](count);\n        for (i=0; i<count; i++) {\n            _confirmations[i] = confirmationsTemp[i];\n        }\n    }\n\n    function getTransactionIds(uint from, uint to, bool pending, bool executed) public view returns (uint[] memory _transactionIds) {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i=0; i<transactionCount; i++) {\n            if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        }\n        _transactionIds = new uint[](to - from);\n        for (i=from; i<to; i++) {\n            _transactionIds[i - from] = transactionIdsTemp[i];\n        }\n    }\n\n}\n```\n\nThis contract represents a multi-signature wallet, where multiple owners must confirm a transaction before it is executed. It includes functions for adding, removing, and replacing owners, changing the number of required confirmations, submitting, confirming, executing, and revoking transactions, and retrieving information about owners and transactions.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039108,
	"id": "chatcmpl-8ChpUfSwaUelNC2k4PBdum1Q9G9Qw",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 09:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x106b(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1752(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length <= 50;\n    v0 = v2 = _owners.length != 0;\n    v0 = v3 = varg0 <= _owners.length;\n    v0 = v4 = varg0 != 0;\n    require(v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x1822(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0][0]) != 0);\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1d3e(varg0);\n    return ;\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (_owners.length > _owners.length - 1) {\n        v2 = v3 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x1752(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction 0x1d3e(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[varg0]);\n    require(!(0xff & _transactions[varg0][3]));\n    v0 = 0x106b(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0 != 0);\n    v0 = v1 = _owners.length + 1 <= 50;\n    v0 = v2 = _owners.length + 1 != 0;\n    v0 = v3 = _required <= _owners.length + 1;\n    v0 = v4 = _required != 0;\n    require(v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    _owners[_owners.length + 1 - 1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length + 1 - 1];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0x106b(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v4, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new uint256[](_owners.length);\n    v1 = v2 = v0.data;\n    if (_owners.length) {\n        do {\n            MEM[v1] = address(STORAGE[v3]);\n            v1 += 32;\n            v3 += 1;\n        } while (v2 + (_owners.length << 5) <= v1);\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length << 5) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    return v4;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new uint256[](_transactionCount);\n    if (_transactionCount) {\n        MEM[(v3.data) len (_transactionCount << 5)] = this.code[this.code.size len (_transactionCount << 5)];\n    }\n    v4 = v5 = 0;\n    v6 = v7 = 0;\n    while (v6 < _transactionCount) {\n        if (v1) {\n            v0 = v8 = !(0xff & _transactions[v6][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v6][3];\n            }\n        }\n        if (v0) {\n            assert(v4 < v3.length);\n            v3[v4] = v6;\n            v4 = v4 + 1;\n        }\n        v6 += 1;\n    }\n    v9 = new uint256[](varg1 - varg0);\n    if (varg1 - varg0) {\n        MEM[(v9.data) len (varg1 - varg0 << 5)] = this.code[this.code.size len (varg1 - varg0 << 5)];\n    }\n    while (v10 < varg1) {\n        assert(v10 < v3.length);\n        assert(v10 - varg0 < v9.length);\n        v9[v10 - varg0] = v3[v10];\n        v10 += 1;\n    }\n    v11 = new array[](v9.length);\n    v12 = v13 = 0;\n    while (v12 < v9.length << 5) {\n        MEM[v11.data + v12] = MEM[v9.data + v12];\n        v12 = v12 + 32;\n    }\n    return v11;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new uint256[](_owners.length);\n    if (_owners.length) {\n        MEM[(v0.data) len (_owners.length << 5)] = this.code[this.code.size len (_owners.length << 5)];\n    }\n    v1 = v2 = 0;\n    v3 = v4 = 0;\n    while (v3 < _owners.length) {\n        assert(v3 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v3]), keccak256(varg0, 1))]) {\n            assert(v3 < _owners.length);\n            assert(v1 < v0.length);\n            v0[v1] = address(_owners[v3]);\n            v1 = v1 + 1;\n        }\n        v3 += 1;\n    }\n    v5 = new uint256[](v1);\n    if (v1) {\n        MEM[(v5.data) len (v1 << 5)] = this.code[this.code.size len (v1 << 5)];\n    }\n    v6 = v7 = 0;\n    while (v6 < v1) {\n        assert(v6 < v0.length);\n        assert(v6 < v5.length);\n        v5[v6] = address(v0[v6]);\n        v6 += 1;\n    }\n    v8 = new array[](v5.length);\n    v9 = v10 = 0;\n    while (v9 < v5.length << 5) {\n        MEM[v8.data + v9] = MEM[v5.data + v9];\n        v9 = v9 + 32;\n    }\n    return v8;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0x1752(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0x1822(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(varg0 != 0);\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x1822(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 50;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x1d3e(varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x25e7c27 == function_selector) {\n            owners(uint256);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == function_selector) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3411c81c == function_selector) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == function_selector) {\n            getTransactionCount(bool,bool);\n        } else if (0x552079dc == function_selector) {\n            fallback();\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x784547a7 == function_selector) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == function_selector) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == function_selector) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == function_selector) {\n            getOwners();\n        } else if (0xa8abe69a == function_selector) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == function_selector) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == function_selector) {\n            transactionCount();\n        } else if (0xba51a6df == function_selector) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == function_selector) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == function_selector) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == function_selector) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == function_selector) {\n            required();\n        } else if (0xe20056e6 == function_selector) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == function_selector) {\n            executeTransaction(uint256);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 09:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x106b(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1752(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length <= 50;\n    v0 = v2 = _owners.length != 0;\n    v0 = v3 = varg0 <= _owners.length;\n    v0 = v4 = varg0 != 0;\n    require(v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x1822(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0][0]) != 0);\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1d3e(varg0);\n    return ;\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (_owners.length > _owners.length - 1) {\n        v2 = v3 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x1752(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction 0x1d3e(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[varg0]);\n    require(!(0xff & _transactions[varg0][3]));\n    v0 = 0x106b(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0 != 0);\n    v0 = v1 = _owners.length + 1 <= 50;\n    v0 = v2 = _owners.length + 1 != 0;\n    v0 = v3 = _required <= _owners.length + 1;\n    v0 = v4 = _required != 0;\n    require(v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    _owners[_owners.length + 1 - 1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length + 1 - 1];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0x106b(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v4, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new uint256[](_owners.length);\n    v1 = v2 = v0.data;\n    if (_owners.length) {\n        do {\n            MEM[v1] = address(STORAGE[v3]);\n            v1 += 32;\n            v3 += 1;\n        } while (v2 + (_owners.length << 5) <= v1);\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length << 5) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    return v4;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new uint256[](_transactionCount);\n    if (_transactionCount) {\n        MEM[(v3.data) len (_transactionCount << 5)] = this.code[this.code.size len (_transactionCount << 5)];\n    }\n    v4 = v5 = 0;\n    v6 = v7 = 0;\n    while (v6 < _transactionCount) {\n        if (v1) {\n            v0 = v8 = !(0xff & _transactions[v6][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v6][3];\n            }\n        }\n        if (v0) {\n            assert(v4 < v3.length);\n            v3[v4] = v6;\n            v4 = v4 + 1;\n        }\n        v6 += 1;\n    }\n    v9 = new uint256[](varg1 - varg0);\n    if (varg1 - varg0) {\n        MEM[(v9.data) len (varg1 - varg0 << 5)] = this.code[this.code.size len (varg1 - varg0 << 5)];\n    }\n    while (v10 < varg1) {\n        assert(v10 < v3.length);\n        assert(v10 - varg0 < v9.length);\n        v9[v10 - varg0] = v3[v10];\n        v10 += 1;\n    }\n    v11 = new array[](v9.length);\n    v12 = v13 = 0;\n    while (v12 < v9.length << 5) {\n        MEM[v11.data + v12] = MEM[v9.data + v12];\n        v12 = v12 + 32;\n    }\n    return v11;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new uint256[](_owners.length);\n    if (_owners.length) {\n        MEM[(v0.data) len (_owners.length << 5)] = this.code[this.code.size len (_owners.length << 5)];\n    }\n    v1 = v2 = 0;\n    v3 = v4 = 0;\n    while (v3 < _owners.length) {\n        assert(v3 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v3]), keccak256(varg0, 1))]) {\n            assert(v3 < _owners.length);\n            assert(v1 < v0.length);\n            v0[v1] = address(_owners[v3]);\n            v1 = v1 + 1;\n        }\n        v3 += 1;\n    }\n    v5 = new uint256[](v1);\n    if (v1) {\n        MEM[(v5.data) len (v1 << 5)] = this.code[this.code.size len (v1 << 5)];\n    }\n    v6 = v7 = 0;\n    while (v6 < v1) {\n        assert(v6 < v0.length);\n        assert(v6 < v5.length);\n        v5[v6] = address(v0[v6]);\n        v6 += 1;\n    }\n    v8 = new array[](v5.length);\n    v9 = v10 = 0;\n    while (v9 < v5.length << 5) {\n        MEM[v8.data + v9] = MEM[v5.data + v9];\n        v9 = v9 + 32;\n    }\n    return v8;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0x1752(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0x1822(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(varg0 != 0);\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x1822(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 50;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x1d3e(varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x25e7c27 == function_selector) {\n            owners(uint256);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == function_selector) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3411c81c == function_selector) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == function_selector) {\n            getTransactionCount(bool,bool);\n        } else if (0x552079dc == function_selector) {\n            fallback();\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x784547a7 == function_selector) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == function_selector) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == function_selector) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == function_selector) {\n            getOwners();\n        } else if (0xa8abe69a == function_selector) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == function_selector) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == function_selector) {\n            transactionCount();\n        } else if (0xba51a6df == function_selector) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == function_selector) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == function_selector) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == function_selector) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == function_selector) {\n            required();\n        } else if (0xe20056e6 == function_selector) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == function_selector) {\n            executeTransaction(uint256);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 09:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _transactions; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _confirmations; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isOwner; // STORAGE[0x2]\nuint256[] _owners; // STORAGE[0x3]\nuint256 _required; // STORAGE[0x4]\nuint256 _transactionCount; // STORAGE[0x5]\n\n// Events\nDeposit(address, uint256);\nOwnerRemoval(address);\nRevocation(address, uint256);\nOwnerAddition(address);\nRequirementChange(uint256);\nConfirmation(address, uint256);\nExecution(uint256);\nExecutionFailure(uint256);\nSubmission(uint256);\n\nfunction 0x106b(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = 0;\n    while (v4 < _owners.length) {\n        assert(v4 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v4]), v6)]) {\n            v2 = v2 + 1;\n        }\n        if (v2 != _required) {\n            v4 += 1;\n        } else {\n            v0 = v7 = 1;\n            break;\n        }\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction owners(uint256 varg0) public nonPayable { \n    assert(varg0 < _owners.length);\n    return address(_owners[varg0]);\n}\n\nfunction 0x1752(uint256 varg0) private { \n    require(msg.sender == address(this));\n    v0 = v1 = _owners.length <= 50;\n    v0 = v2 = _owners.length != 0;\n    v0 = v3 = varg0 <= _owners.length;\n    v0 = v4 = varg0 != 0;\n    require(v0);\n    _required = varg0;\n    emit RequirementChange(varg0);\n    return ;\n}\n\nfunction 0x1822(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(address(_transactions[varg0][0]) != 0);\n    require(!(0xff & _confirmations[varg0]));\n    _confirmations[varg0] = 0x1 | ~0xff & _confirmations[varg0];\n    emit Confirmation(msg.sender, varg0);\n    0x1d3e(varg0);\n    return ;\n}\n\nfunction removeOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    v0 = v1 = 0;\n    while (v0 < _owners.length - 1) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            break;\n        }\n        if (address(_owners[v0]) == varg0) {\n            assert(_owners.length - 1 < _owners.length);\n            assert(v0 < _owners.length);\n            _owners[v0] = address(_owners[_owners.length - 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n        }\n        v0 += 1;\n    }\n    _owners.length = _owners.length - 1;\n    if (_owners.length > _owners.length - 1) {\n        v2 = v3 = keccak256(3) + (_owners.length - 1);\n        while (keccak256(3) + _owners.length > v2) {\n            STORAGE[v2] = 0;\n            v2 += 1;\n        }\n    }\n    if (_required > _owners.length) {\n        0x1752(_owners.length);\n    }\n    emit OwnerRemoval(varg0);\n}\n\nfunction 0x1d3e(uint256 varg0) private { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[varg0]);\n    require(!(0xff & _transactions[varg0][3]));\n    v0 = 0x106b(varg0);\n    if (v0) {\n        _transactions[varg0][3] = 0x1 | ~0xff & _transactions[varg0][0x3];\n        v1 = v2 = MEM[64];\n        v3 = _transactions[varg0][2];\n        if (((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n            if (31 < ((!(0x1 & v3) << 8) - 1 & v3) >> 1) {\n                do {\n                    MEM[v1] = STORAGE[v4];\n                    v4 += 1;\n                    v1 += 32;\n                } while (v2 + (((!(0x1 & v3) << 8) - 1 & v3) >> 1) <= v1);\n            } else {\n                v5 = _transactions[varg0][2] >> 8 << 8;\n            }\n        }\n        v6 = address(_transactions[varg0][0]).call(v5).value(_transactions[varg0][1]).gas(msg.gas);\n        if (!v6) {\n            emit ExecutionFailure(varg0);\n            _transactions[varg0][3] = 0x0 | ~0xff & _transactions[varg0][0x3];\n        } else {\n            emit Execution(varg0);\n        }\n    }\n    return ;\n}\n\nfunction revokeConfirmation(uint256 varg0) public nonPayable { \n    require(0xff & _isOwner[msg.sender]);\n    require(0xff & _confirmations[msg.sender]);\n    require(!(0xff & _transactions[varg0][3]));\n    _confirmations[msg.sender] = 0x0 | ~0xff & _confirmations[msg.sender];\n    emit Revocation(msg.sender, varg0);\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return 0xff & _isOwner[varg0];\n}\n\nfunction confirmations(uint256 varg0, address varg1) public nonPayable { \n    return 0xff & _confirmations[varg1];\n}\n\nfunction getTransactionCount(bool varg0, bool varg1) public nonPayable { \n    v0 = v1 = varg0;\n    v0 = v2 = varg1;\n    v3 = v4 = 0;\n    v5 = v6 = 0;\n    while (v5 < _transactionCount) {\n        if (v1) {\n            v0 = v7 = !(0xff & _transactions[v5][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v5][3];\n            }\n        }\n        if (v0) {\n            v3 = v3 + 1;\n        }\n        v5 += 1;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    if (msg.value > 0) {\n        emit Deposit(msg.sender, msg.value);\n    }\n}\n\nfunction addOwner(address varg0) public nonPayable { \n    require(msg.sender == address(this));\n    require(!(0xff & _isOwner[varg0]));\n    require(varg0 != 0);\n    v0 = v1 = _owners.length + 1 <= 50;\n    v0 = v2 = _owners.length + 1 != 0;\n    v0 = v3 = _required <= _owners.length + 1;\n    v0 = v4 = _required != 0;\n    require(v0);\n    _isOwner[varg0] = 0x1 | ~0xff & _isOwner[varg0];\n    _owners.length = _owners.length + 1;\n    _owners[_owners.length + 1 - 1] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[_owners.length + 1 - 1];\n    emit OwnerAddition(varg0);\n}\n\nfunction isConfirmed(uint256 varg0) public nonPayable { \n    v0 = 0x106b(varg0);\n    return v0;\n}\n\nfunction getConfirmationCount(uint256 varg0) public nonPayable { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    while (v2 < _owners.length) {\n        assert(v2 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v2]), keccak256(varg0, 1))]) {\n            v0 = v0 + 1;\n        }\n        v2 += 1;\n    }\n    return v0;\n}\n\nfunction transactions(uint256 varg0) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _transactions[varg0][0x2]) << 8) - 1 & _transactions[varg0][0x2]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _transactions[varg0][2] >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return address(_transactions[varg0][0]), _transactions[varg0][1], v4, 0xff & _transactions[varg0][3];\n}\n\nfunction getOwners() public nonPayable { \n    v0 = new uint256[](_owners.length);\n    v1 = v2 = v0.data;\n    if (_owners.length) {\n        do {\n            MEM[v1] = address(STORAGE[v3]);\n            v1 += 32;\n            v3 += 1;\n        } while (v2 + (_owners.length << 5) <= v1);\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length << 5) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    return v4;\n}\n\nfunction getTransactionIds(uint256 varg0, uint256 varg1, bool varg2, bool varg3) public nonPayable { \n    v0 = v1 = varg2;\n    v0 = v2 = varg3;\n    v3 = new uint256[](_transactionCount);\n    if (_transactionCount) {\n        MEM[(v3.data) len (_transactionCount << 5)] = this.code[this.code.size len (_transactionCount << 5)];\n    }\n    v4 = v5 = 0;\n    v6 = v7 = 0;\n    while (v6 < _transactionCount) {\n        if (v1) {\n            v0 = v8 = !(0xff & _transactions[v6][3]);\n        }\n        if (!v0) {\n            if (v2) {\n                v0 = 0xff & _transactions[v6][3];\n            }\n        }\n        if (v0) {\n            assert(v4 < v3.length);\n            v3[v4] = v6;\n            v4 = v4 + 1;\n        }\n        v6 += 1;\n    }\n    v9 = new uint256[](varg1 - varg0);\n    if (varg1 - varg0) {\n        MEM[(v9.data) len (varg1 - varg0 << 5)] = this.code[this.code.size len (varg1 - varg0 << 5)];\n    }\n    while (v10 < varg1) {\n        assert(v10 < v3.length);\n        assert(v10 - varg0 < v9.length);\n        v9[v10 - varg0] = v3[v10];\n        v10 += 1;\n    }\n    v11 = new array[](v9.length);\n    v12 = v13 = 0;\n    while (v12 < v9.length << 5) {\n        MEM[v11.data + v12] = MEM[v9.data + v12];\n        v12 = v12 + 32;\n    }\n    return v11;\n}\n\nfunction getConfirmations(uint256 varg0) public nonPayable { \n    v0 = new uint256[](_owners.length);\n    if (_owners.length) {\n        MEM[(v0.data) len (_owners.length << 5)] = this.code[this.code.size len (_owners.length << 5)];\n    }\n    v1 = v2 = 0;\n    v3 = v4 = 0;\n    while (v3 < _owners.length) {\n        assert(v3 < _owners.length);\n        if (0xff & STORAGE[keccak256(address(_owners[v3]), keccak256(varg0, 1))]) {\n            assert(v3 < _owners.length);\n            assert(v1 < v0.length);\n            v0[v1] = address(_owners[v3]);\n            v1 = v1 + 1;\n        }\n        v3 += 1;\n    }\n    v5 = new uint256[](v1);\n    if (v1) {\n        MEM[(v5.data) len (v1 << 5)] = this.code[this.code.size len (v1 << 5)];\n    }\n    v6 = v7 = 0;\n    while (v6 < v1) {\n        assert(v6 < v0.length);\n        assert(v6 < v5.length);\n        v5[v6] = address(v0[v6]);\n        v6 += 1;\n    }\n    v8 = new array[](v5.length);\n    v9 = v10 = 0;\n    while (v9 < v5.length << 5) {\n        MEM[v8.data + v9] = MEM[v5.data + v9];\n        v9 = v9 + 32;\n    }\n    return v8;\n}\n\nfunction transactionCount() public nonPayable { \n    return _transactionCount;\n}\n\nfunction changeRequirement(uint256 varg0) public nonPayable { \n    0x1752(varg0);\n}\n\nfunction confirmTransaction(uint256 varg0) public nonPayable { \n    0x1822(varg0);\n}\n\nfunction submitTransaction(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(varg0 != 0);\n    _transactions[_transactionCount][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _transactions[_transactionCount][0x0];\n    _transactions[_transactionCount][1] = varg1;\n    v1 = v2 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _transactions[_transactionCount][2] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v2 + MEM[v0] > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _transactions[_transactionCount][2] = MEM[v0] + MEM[v0] | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + (((!(0x1 & _transactions[_transactionCount][0x2]) << 8) - 1 & _transactions[_transactionCount][0x2]) >> 1) >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n    _transactions[_transactionCount][3] = 0x0 | ~0xff & _transactions[_transactionCount][0x3];\n    _transactionCount = _transactionCount + 1;\n    emit Submission(_transactionCount);\n    0x1822(_transactionCount);\n    return _transactionCount;\n}\n\nfunction MAX_OWNER_COUNT() public nonPayable { \n    return 50;\n}\n\nfunction required() public nonPayable { \n    return _required;\n}\n\nfunction replaceOwner(address varg0, address varg1) public nonPayable { \n    require(msg.sender == address(this));\n    require(0xff & _isOwner[varg0]);\n    require(!(0xff & _isOwner[varg1]));\n    v0 = v1 = 0;\n    while (v0 < _owners.length) {\n        if (v0 < _owners.length) {\n            break;\n        }\n        assert(v0 < _owners.length);\n        if (address(_owners[v0]) != varg0) {\n            v0 += 1;\n            continue;\n        } else {\n            assert(v0 < _owners.length);\n            _owners[v0] = varg1 | ~0xffffffffffffffffffffffffffffffffffffffff & _owners[v0];\n            break;\n        }\n    }\n    _isOwner[varg0] = 0x0 | ~0xff & _isOwner[varg0];\n    _isOwner[varg1] = 0x1 | ~0xff & _isOwner[varg1];\n    emit OwnerRemoval(varg0);\n    emit OwnerAddition(varg1);\n}\n\nfunction executeTransaction(uint256 varg0) public nonPayable { \n    0x1d3e(varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x25e7c27 == function_selector) {\n            owners(uint256);\n        } else if (0x173825d9 == function_selector) {\n            removeOwner(address);\n        } else if (0x20ea8d86 == function_selector) {\n            revokeConfirmation(uint256);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3411c81c == function_selector) {\n            confirmations(uint256,address);\n        } else if (0x54741525 == function_selector) {\n            getTransactionCount(bool,bool);\n        } else if (0x552079dc == function_selector) {\n            fallback();\n        } else if (0x7065cb48 == function_selector) {\n            addOwner(address);\n        } else if (0x784547a7 == function_selector) {\n            isConfirmed(uint256);\n        } else if (0x8b51d13f == function_selector) {\n            getConfirmationCount(uint256);\n        } else if (0x9ace38c2 == function_selector) {\n            transactions(uint256);\n        } else if (0xa0e67e2b == function_selector) {\n            getOwners();\n        } else if (0xa8abe69a == function_selector) {\n            getTransactionIds(uint256,uint256,bool,bool);\n        } else if (0xb5dc40c3 == function_selector) {\n            getConfirmations(uint256);\n        } else if (0xb77bf600 == function_selector) {\n            transactionCount();\n        } else if (0xba51a6df == function_selector) {\n            changeRequirement(uint256);\n        } else if (0xc01a8c84 == function_selector) {\n            confirmTransaction(uint256);\n        } else if (0xc6427474 == function_selector) {\n            submitTransaction(address,uint256,bytes);\n        } else if (0xd74f8edd == function_selector) {\n            MAX_OWNER_COUNT();\n        } else if (0xdc8452cd == function_selector) {\n            required();\n        } else if (0xe20056e6 == function_selector) {\n            replaceOwner(address,address);\n        } else if (0xee22610b == function_selector) {\n            executeTransaction(uint256);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 81.87886476516724,
	"usage": {
		"completion_tokens": 1774,
		"prompt_tokens": 4740,
		"total_tokens": 6514
	}
}