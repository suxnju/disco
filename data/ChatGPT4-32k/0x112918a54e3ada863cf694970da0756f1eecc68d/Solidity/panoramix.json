{
	"address": "0x112918a54e3ada863cf694970da0756f1eecc68d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The following is a Solidity contract that is similar to the decompiled EVM bytecode:\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract CompiledContract {\n    uint constant MAX_OWNER_COUNT = 50;\n    uint required;\n    uint transactionCount;\n    mapping (address => bool) isOwner;\n    mapping (uint => Transaction) transactions;\n    mapping (uint => mapping (address => bool)) confirmations;\n    address[] owners;\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n        bool executed;\n    }\n\n    event Deposit(address indexed sender, uint value);\n    event Submission(uint indexed transactionId);\n    event Confirmation(address indexed sender, uint indexed transactionId);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event RequirementChange(uint required);\n\n    modifier onlyOwner {\n        require(isOwner[msg.sender]);\n        _;\n    }\n\n    function addOwner(address owner) public onlyOwner {\n        require(owner != 0);\n        require(!isOwner[owner]);\n        require(owners.length + 1 <= MAX_OWNER_COUNT);\n        isOwner[owner] = true;\n        owners.push(owner);\n        emit OwnerAddition(owner);\n    }\n\n    function removeOwner(address owner) public onlyOwner {\n        require(isOwner[owner]);\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        emit OwnerRemoval(owner);\n    }\n\n    function changeRequirement(uint _required) public onlyOwner {\n        require(_required <= owners.length);\n        required = _required;\n        emit RequirementChange(_required);\n    }\n\n    function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) {\n        transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n    }\n\n    function addTransaction(address destination, uint value, bytes data) internal returns (uint transactionId) {\n        transactionId = transactionCount;\n        transactions[transactionId] = Transaction({\n            destination: destination,\n            value: value,\n            data: data,\n            executed: false\n        });\n        transactionCount += 1;\n        emit Submission(transactionId);\n    }\n\n    function confirmTransaction(uint transactionId) public onlyOwner {\n        require(transactions[transactionId].destination != 0);\n        require(confirmations[transactionId][msg.sender] == false);\n        confirmations[transactionId][msg.sender] = true;\n        executeTransaction(transactionId);\n    }\n\n    function executeTransaction(uint transactionId) public onlyOwner {\n        require(transactions[transactionId].executed == false);\n        if (isConfirmed(transactionId)) {\n            Transaction storage txn = transactions[transactionId];\n            txn.executed = true;\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n                emit Execution(transactionId);\n            else {\n                emit ExecutionFailure(transactionId);\n                txn.executed = false;\n            }\n        }\n    }\n\n    function isConfirmed(uint transactionId) internal view returns (bool) {\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    function external_call(address destination, uint value, uint dataLength, bytes data) internal returns (bool) {\n        bool result;\n        assembly {\n            let x := mload(0x40)\n            mstore(x, value)\n            mstore(add(x, 0x20), dataLength)\n            mstore(add(x, 0x40), data)\n            result := call(\n                sub(gas, 34710),\n                destination,\n                value,\n                x,\n                0x60,\n                x,\n                0x20\n            )\n        }\n        return result;\n    }\n}\n```\nThis Solidity contract includes functions to manage owners, change requirements for execution, submit transactions, execute confirmed transactions, and check if a transaction is confirmed. The contract also includes an internal function to make an external call. Please note that the external_call function is a simplified version of the original function and may not cover all edge cases.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471513,
	"id": "chatcmpl-8MubpVQdAFNtiAxPrW0h7aFxT45wQ",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return address(owners[_param1].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef fallback() payable: \n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require owners.length\n  require _required <= owners.length\n  require _required\n  required = _required\n  log RequirementChange(uint256 required=_required)\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require owners.length + 1\n  require required <= owners.length + 1\n  require required\n  stor2[address(owner)] = 1\n  owners.length++\n  address(owners[owners.length].field_0) = owner\n  log OwnerAddition(address owner=owner)\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef transactions(uint256 _param1): # not payable\n  mem[128] = stor0[_param1][2].field_0\n  idx = 128\n  s = 0\n  while stor0[_param1][2].length + 96 > idx:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[128 len stor0[_param1][2].length]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[address(newOwner)] = 1\n      log OwnerRemoval(address owner=owner)\n      log OwnerAddition(address owner=newOwner)\n      stop\n  stor2[address(owner)] = 0\n  stor2[address(newOwner)] = 1\n  log OwnerRemoval(address owner=owner)\n  log OwnerAddition(address owner=newOwner)\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 128] = 32\n      mem[(32 * owners.length) + 160] = owners.length\n      mem[(32 * owners.length) + 192 len floor32(owners.length)] = mem[128 len floor32(owners.length)]\n      return memory\n        from (32 * owners.length) + 128\n         len (96 * owners.length) + 64\n  mem[128] = address(owners.field_0)\n  idx = 128\n  s = 0\n  while (32 * owners.length) + 96 > idx:\n      mem[idx + 32] = address(owners[s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 192 len floor32(owners.length)] = mem[128 len floor32(owners.length)]\n  return Array(len=owners.length, data=mem[128 len floor32(owners.length)], mem[(32 * owners.length) + floor32(owners.length) + 192 len (32 * owners.length) - floor32(owners.length)]), \n\ndef getConfirmations(uint256 transactionId): # not payable\n  if owners.length:\n      mem[128 len 32 * owners.length] = code.data[8738 len 32 * owners.length]\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 128] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 128] = s\n  if s:\n      mem[(32 * owners.length) + 160 len 32 * s] = code.data[8738 len 32 * s]\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s\n      mem[(32 * t) + (32 * owners.length) + 160] = mem[(32 * t) + 140 len 20]\n      t = t + 1\n      continue \n  mem[(32 * owners.length) + (32 * s) + 224 len floor32(s)] = mem[(32 * owners.length) + 160 len floor32(s)]\n  return Array(len=s, data=mem[(32 * owners.length) + 160 len floor32(s)], mem[(32 * owners.length) + (32 * s) + floor32(s) + 224 len (32 * s) - floor32(s)]), \n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if owners.length > owners.length - 1:\n          idx = sha3(3) + owners.length - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length\n          require owners.length <= owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=owner)\n      stop\n  owners.length--\n  if owners.length > owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length\n      require owners.length <= owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=owner)\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  if transactionCount:\n      mem[128 len 32 * transactionCount] = code.data[8738 len 32 * transactionCount]\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 128] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  mem[(32 * transactionCount) + 128] = to - from\n  if to - from:\n      mem[(32 * transactionCount) + 160 len 32 * to - from] = code.data[8738 len 32 * to - from]\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < mem[(32 * transactionCount) + 128]\n      mem[(32 * idx - from) + (32 * transactionCount) + 160] = mem[(32 * idx) + 128]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * to - from) + 160] = 32\n  mem[(32 * transactionCount) + (32 * to - from) + 192] = mem[(32 * transactionCount) + 128]\n  mem[(32 * transactionCount) + (32 * to - from) + 224 len floor32(mem[(32 * transactionCount) + 128])] = mem[(32 * transactionCount) + 160 len floor32(mem[(32 * transactionCount) + 128])]\n  return Array(len=mem[(32 * transactionCount) + 128], data=mem[(32 * transactionCount) + (32 * to - from) + 224 len 32 * mem[(32 * transactionCount) + 128]]), \n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require uint8(stor1[stor5][caller])\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return address(owners[_param1].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef fallback() payable: \n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require owners.length\n  require _required <= owners.length\n  require _required\n  required = _required\n  log RequirementChange(uint256 required=_required)\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require owners.length + 1\n  require required <= owners.length + 1\n  require required\n  stor2[address(owner)] = 1\n  owners.length++\n  address(owners[owners.length].field_0) = owner\n  log OwnerAddition(address owner=owner)\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef transactions(uint256 _param1): # not payable\n  mem[128] = stor0[_param1][2].field_0\n  idx = 128\n  s = 0\n  while stor0[_param1][2].length + 96 > idx:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[128 len stor0[_param1][2].length]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[address(newOwner)] = 1\n      log OwnerRemoval(address owner=owner)\n      log OwnerAddition(address owner=newOwner)\n      stop\n  stor2[address(owner)] = 0\n  stor2[address(newOwner)] = 1\n  log OwnerRemoval(address owner=owner)\n  log OwnerAddition(address owner=newOwner)\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 128] = 32\n      mem[(32 * owners.length) + 160] = owners.length\n      mem[(32 * owners.length) + 192 len floor32(owners.length)] = mem[128 len floor32(owners.length)]\n      return memory\n        from (32 * owners.length) + 128\n         len (96 * owners.length) + 64\n  mem[128] = address(owners.field_0)\n  idx = 128\n  s = 0\n  while (32 * owners.length) + 96 > idx:\n      mem[idx + 32] = address(owners[s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 192 len floor32(owners.length)] = mem[128 len floor32(owners.length)]\n  return Array(len=owners.length, data=mem[128 len floor32(owners.length)], mem[(32 * owners.length) + floor32(owners.length) + 192 len (32 * owners.length) - floor32(owners.length)]), \n\ndef getConfirmations(uint256 transactionId): # not payable\n  if owners.length:\n      mem[128 len 32 * owners.length] = code.data[8738 len 32 * owners.length]\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 128] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 128] = s\n  if s:\n      mem[(32 * owners.length) + 160 len 32 * s] = code.data[8738 len 32 * s]\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s\n      mem[(32 * t) + (32 * owners.length) + 160] = mem[(32 * t) + 140 len 20]\n      t = t + 1\n      continue \n  mem[(32 * owners.length) + (32 * s) + 224 len floor32(s)] = mem[(32 * owners.length) + 160 len floor32(s)]\n  return Array(len=s, data=mem[(32 * owners.length) + 160 len floor32(s)], mem[(32 * owners.length) + (32 * s) + floor32(s) + 224 len (32 * s) - floor32(s)]), \n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if owners.length > owners.length - 1:\n          idx = sha3(3) + owners.length - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length\n          require owners.length <= owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=owner)\n      stop\n  owners.length--\n  if owners.length > owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length\n      require owners.length <= owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=owner)\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  if transactionCount:\n      mem[128 len 32 * transactionCount] = code.data[8738 len 32 * transactionCount]\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 128] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  mem[(32 * transactionCount) + 128] = to - from\n  if to - from:\n      mem[(32 * transactionCount) + 160 len 32 * to - from] = code.data[8738 len 32 * to - from]\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < mem[(32 * transactionCount) + 128]\n      mem[(32 * idx - from) + (32 * transactionCount) + 160] = mem[(32 * idx) + 128]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * to - from) + 160] = 32\n  mem[(32 * transactionCount) + (32 * to - from) + 192] = mem[(32 * transactionCount) + 128]\n  mem[(32 * transactionCount) + (32 * to - from) + 224 len floor32(mem[(32 * transactionCount) + 128])] = mem[(32 * transactionCount) + 160 len floor32(mem[(32 * transactionCount) + 128])]\n  return Array(len=mem[(32 * transactionCount) + 128], data=mem[(32 * transactionCount) + (32 * to - from) + 224 len 32 * mem[(32 * transactionCount) + 128]]), \n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require uint8(stor1[stor5][caller])\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst MAX_OWNER_COUNT = 50\n\ndef storage:\n  stor0 is mapping of struct at storage 0\n  stor1 is mapping of uint8 at storage 1\n  stor2 is mapping of uint8 at storage 2\n  owners is array of struct at storage 3\n  required is uint256 at storage 4\n  transactionCount is uint256 at storage 5\n\ndef owners(uint256 _param1): # not payable\n  require _param1 < owners.length\n  return address(owners[_param1].field_0)\n\ndef isOwner(address account): # not payable\n  return bool(stor2[account])\n\ndef confirmations(uint256 _param1, address _param2): # not payable\n  return bool(uint8(stor1[_param1][_param2]))\n\ndef transactionCount(): # not payable\n  return transactionCount\n\ndef required(): # not payable\n  return required\n\n#\n#  Regular functions\n#\n\ndef fallback() payable: \n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef _fallback(?) payable: # default function\n  if call.value > 0:\n      log Deposit(\n            address sender=call.value,\n            uint256 value=caller)\n\ndef changeRequirement(uint256 _required): # not payable\n  require caller == this.address\n  require owners.length <= 50\n  require owners.length\n  require _required <= owners.length\n  require _required\n  required = _required\n  log RequirementChange(uint256 required=_required)\n\ndef revokeConfirmation(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  uint8(stor1[transactionId][caller]) = 0\n  log Revocation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n\ndef addOwner(address owner): # not payable\n  require caller == this.address\n  require not stor2[address(owner)]\n  require owner\n  require owners.length + 1 <= 50\n  require owners.length + 1\n  require required <= owners.length + 1\n  require required\n  stor2[address(owner)] = 1\n  owners.length++\n  address(owners[owners.length].field_0) = owner\n  log OwnerAddition(address owner=owner)\n\ndef getConfirmationCount(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef isConfirmed(uint256 transactionId): # not payable\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      return 1\n  return 0\n\ndef transactions(uint256 _param1): # not payable\n  mem[128] = stor0[_param1][2].field_0\n  idx = 128\n  s = 0\n  while stor0[_param1][2].length + 96 > idx:\n      mem[idx + 32] = stor0[_param1][s + 2].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  return address(stor0[_param1].field_0), \n         stor0[_param1].field_256,\n         Array(len=stor0[_param1][2].length, data=mem[128 len stor0[_param1][2].length]),\n         bool(uint8(stor0[_param1].field_768))\n\ndef replaceOwner(address owner, address newOwner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  require not stor2[address(newOwner)]\n  idx = 0\n  while idx < owners.length:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require idx < owners.length\n      address(owners[idx].field_0) = newOwner\n      stor2[address(owner)] = 0\n      stor2[address(newOwner)] = 1\n      log OwnerRemoval(address owner=owner)\n      log OwnerAddition(address owner=newOwner)\n      stop\n  stor2[address(owner)] = 0\n  stor2[address(newOwner)] = 1\n  log OwnerRemoval(address owner=owner)\n  log OwnerAddition(address owner=newOwner)\n\ndef getTransactionCount(bool pending, bool executed): # not payable\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      idx = idx + 1\n      s = s + 1\n      continue \n  return s\n\ndef getOwners(): # not payable\n  if not owners.length:\n      mem[(32 * owners.length) + 128] = 32\n      mem[(32 * owners.length) + 160] = owners.length\n      mem[(32 * owners.length) + 192 len floor32(owners.length)] = mem[128 len floor32(owners.length)]\n      return memory\n        from (32 * owners.length) + 128\n         len (96 * owners.length) + 64\n  mem[128] = address(owners.field_0)\n  idx = 128\n  s = 0\n  while (32 * owners.length) + 96 > idx:\n      mem[idx + 32] = address(owners[s].field_256)\n      idx = idx + 32\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 192 len floor32(owners.length)] = mem[128 len floor32(owners.length)]\n  return Array(len=owners.length, data=mem[128 len floor32(owners.length)], mem[(32 * owners.length) + floor32(owners.length) + 192 len (32 * owners.length) - floor32(owners.length)]), \n\ndef getConfirmations(uint256 transactionId): # not payable\n  if owners.length:\n      mem[128 len 32 * owners.length] = code.data[8738 len 32 * owners.length]\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          idx = idx + 1\n          s = s\n          continue \n      require idx < owners.length\n      mem[0] = 3\n      require s < owners.length\n      mem[(32 * s) + 128] = address(owners[idx].field_0)\n      idx = idx + 1\n      s = s + 1\n      continue \n  mem[(32 * owners.length) + 128] = s\n  if s:\n      mem[(32 * owners.length) + 160 len 32 * s] = code.data[8738 len 32 * s]\n  t = 0\n  while t < s:\n      require t < owners.length\n      require t < s\n      mem[(32 * t) + (32 * owners.length) + 160] = mem[(32 * t) + 140 len 20]\n      t = t + 1\n      continue \n  mem[(32 * owners.length) + (32 * s) + 224 len floor32(s)] = mem[(32 * owners.length) + 160 len floor32(s)]\n  return Array(len=s, data=mem[(32 * owners.length) + 160 len floor32(s)], mem[(32 * owners.length) + (32 * s) + floor32(s) + 224 len (32 * s) - floor32(s)]), \n\ndef removeOwner(address owner): # not payable\n  require caller == this.address\n  require stor2[address(owner)]\n  stor2[address(owner)] = 0\n  idx = 0\n  while idx < owners.length - 1:\n      mem[0] = 3\n      if address(owners[idx].field_0) != owner:\n          idx = idx + 1\n          continue \n      require owners.length - 1 < owners.length\n      require idx < owners.length\n      address(owners[idx].field_0) = address(owners[owners.length].field_0)\n      owners.length--\n      if owners.length > owners.length - 1:\n          idx = sha3(3) + owners.length - 1\n          while sha3(3) + owners.length > idx:\n              stor[idx] = 0\n              idx = idx + 1\n              continue \n      if required > owners.length:\n          require caller == this.address\n          require owners.length <= 50\n          require owners.length\n          require owners.length <= owners.length\n          require owners.length\n          required = owners.length\n          log RequirementChange(uint256 required=owners.length)\n      log OwnerRemoval(address owner=owner)\n      stop\n  owners.length--\n  if owners.length > owners.length - 1:\n      idx = owners.length - 1\n      while owners.length > idx:\n          owners[idx].field_0 = 0\n          idx = idx + 1\n          continue \n  if required > owners.length:\n      require caller == this.address\n      require owners.length <= 50\n      require owners.length\n      require owners.length <= owners.length\n      require owners.length\n      required = owners.length\n      log RequirementChange(uint256 required=owners.length)\n  log OwnerRemoval(address owner=owner)\n\ndef executeTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef confirmTransaction(uint256 transactionId): # not payable\n  require stor2[caller]\n  require address(stor0[transactionId].field_0)\n  require not uint8(stor1[transactionId][caller])\n  uint8(stor1[transactionId][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionId)\n  require stor2[caller]\n  require uint8(stor1[transactionId][caller])\n  require not uint8(stor0[transactionId].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionId, 1)\n      if not uint8(stor1[transactionId][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[transactionId].field_768) = 1\n      mem[96] = stor0[transactionId][2].field_0\n      idx = 96\n      s = sha3(sha3(transactionId, 0) + 2)\n      while stor0[transactionId][2].length + 96 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[transactionId].field_0).mem[96 len 4] with:\n         value stor0[transactionId].field_256 wei\n           gas gas_remaining wei\n          args mem[100 len stor0[transactionId][2].length + (floor32(stor0[transactionId][2].length - 1) + -stor0[transactionId][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionId)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionId)\n          uint8(stor0[transactionId].field_768) = 0\n      stop\n\ndef getTransactionIds(uint256 from, uint256 to, bool pending, bool executed): # not payable\n  if transactionCount:\n      mem[128 len 32 * transactionCount] = code.data[8738 len 32 * transactionCount]\n  idx = 0\n  s = 0\n  while idx < transactionCount:\n      if not pending:\n          if not executed:\n              idx = idx + 1\n              s = s\n              continue \n          mem[0] = idx\n          mem[32] = 0\n          if not uint8(stor0[idx].field_768):\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          mem[0] = idx\n          mem[32] = 0\n          if uint8(stor0[idx].field_768):\n              if not executed:\n                  idx = idx + 1\n                  s = s\n                  continue \n              mem[0] = idx\n              mem[32] = 0\n              if not uint8(stor0[idx].field_768):\n                  idx = idx + 1\n                  s = s\n                  continue \n      require s < transactionCount\n      mem[(32 * s) + 128] = idx\n      idx = idx + 1\n      s = s + 1\n      continue \n  mem[(32 * transactionCount) + 128] = to - from\n  if to - from:\n      mem[(32 * transactionCount) + 160 len 32 * to - from] = code.data[8738 len 32 * to - from]\n  idx = from\n  while idx < to:\n      require idx < transactionCount\n      require idx - from < mem[(32 * transactionCount) + 128]\n      mem[(32 * idx - from) + (32 * transactionCount) + 160] = mem[(32 * idx) + 128]\n      idx = idx + 1\n      continue \n  mem[(32 * transactionCount) + (32 * to - from) + 160] = 32\n  mem[(32 * transactionCount) + (32 * to - from) + 192] = mem[(32 * transactionCount) + 128]\n  mem[(32 * transactionCount) + (32 * to - from) + 224 len floor32(mem[(32 * transactionCount) + 128])] = mem[(32 * transactionCount) + 160 len floor32(mem[(32 * transactionCount) + 128])]\n  return Array(len=mem[(32 * transactionCount) + 128], data=mem[(32 * transactionCount) + (32 * to - from) + 224 len 32 * mem[(32 * transactionCount) + 128]]), \n\ndef submitTransaction(address destination, uint256 value, bytes data): # not payable\n  require destination\n  address(stor0[stor5].field_0) = destination\n  stor0[stor5].field_256 = value\n  stor0[stor5][2][].field_0 = Array(len=data.length, data=data[all])\n  uint8(stor0[stor5].field_768) = 0\n  transactionCount++\n  log Submission(uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require address(stor0[stor5].field_0)\n  require not uint8(stor1[stor5][caller])\n  uint8(stor1[stor5][caller]) = 1\n  log Confirmation(\n        address sender=caller,\n        uint256 transactionId=transactionCount)\n  require stor2[caller]\n  require uint8(stor1[stor5][caller])\n  require not uint8(stor0[stor5].field_768)\n  idx = 0\n  s = 0\n  while idx < owners.length:\n      mem[0] = address(owners[idx].field_0)\n      mem[32] = sha3(transactionCount, 1)\n      if not uint8(stor1[stor5][address(stor3[idx].field_0)]):\n          if s != required:\n              idx = idx + 1\n              s = s\n              continue \n      else:\n          if s + 1 != required:\n              idx = idx + 1\n              s = s + 1\n              continue \n      uint8(stor0[stor5].field_768) = 1\n      mem[ceil32(data.length) + 256] = stor0[stor5][2].field_0\n      idx = ceil32(data.length) + 256\n      s = sha3(sha3(transactionCount, 0) + 2)\n      while ceil32(data.length) + stor0[stor5][2].length + 256 > idx + 32:\n          mem[idx + 32] = uint256(stor1[s])\n          idx = idx + 32\n          s = s + 1\n          continue \n      call address(stor0[stor5].field_0).mem[ceil32(data.length) + 256 len 4] with:\n         value stor0[stor5].field_256 wei\n           gas gas_remaining wei\n          args mem[ceil32(data.length) + 260 len stor0[stor5][2].length + (floor32(stor0[stor5][2].length - 1) + -stor0[stor5][2].length + 32 % 32) - 4]\n      if ext_call.success:\n          log Execution(uint256 transactionId=transactionCount)\n      else:\n          log ExecutionFailure(uint256 transactionId=transactionCount)\n          uint8(stor0[stor5].field_768) = 0\n      return transactionCount\n  return transactionCount\n\n.",
	"status": "1",
	"time_cost": 61.18665599822998,
	"usage": {
		"completion_tokens": 941,
		"prompt_tokens": 4653,
		"total_tokens": 5594
	}
}