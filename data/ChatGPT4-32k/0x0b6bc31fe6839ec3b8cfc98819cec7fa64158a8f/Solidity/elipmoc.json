{
	"address": "0x0b6bc31fe6839ec3b8cfc98819cec7fa64158a8f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity code equivalent to the given decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Wallet {\n    uint256 private _reclaimPeriod;\n    uint256 private _timeout;\n    address private _owner;\n    address private _backup;\n\n    event Received(address, uint256, bytes);\n    event OwnerChanged(address, address);\n    event ReclaimBegun();\n    event Sent(address, uint256, bytes);\n    event ReclaimPeriodChanged(uint256, uint256);\n    event BackupChanged(address, address);\n    event Reset();\n    event Reclaimed();\n\n    function timeLeft() public view returns (uint256){\n        require(_timeout != 0, \"Timeout should not be zero\");\n        if (block.timestamp > _timeout) {\n            return 0;\n        } else {\n            return _timeout - block.timestamp;\n        }\n    }\n\n    function setOwner(address newOwner) public { \n        require(msg.sender == _owner, \"Only owner can set a new owner\");\n        emit OwnerChanged(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function reclaimPeriod() public view returns (uint256) { \n        return _reclaimPeriod;\n    }\n\n    function backup() public view returns (address) { \n        return _backup;\n    }\n\n    function beginReclaim() public { \n        require(msg.sender == _backup, \"Only the backup can begin reclaim\");\n        if (_timeout == 0) {\n            _timeout = block.timestamp + _reclaimPeriod;\n            emit ReclaimBegun();\n        }\n    }\n\n    function timeout() public view returns (uint256) { \n        return _timeout;\n    }\n\n    function canFinalize() public view returns (bool) { \n        if (_timeout != 0) {\n            return block.timestamp > _timeout;\n        }\n        return false;\n    }\n\n    function owner() public view returns (address) { \n        return _owner;\n    }\n\n    function send(address to, uint256 value, bytes memory data) public {\n        require(msg.sender == _owner, \"Only owner can send\");\n        (bool success,) = to.call{value: value}(data);\n        require(success, \"Send failed\");\n        emit Sent(to, value, data);\n    }\n\n    function reclaimStarted() public view returns (bool) { \n        return _timeout != 0;\n    }\n\n    function setReclaimPeriod(uint256 newPeriod) public { \n        require(msg.sender == _owner, \"Only owner can set reclaim period\");\n        emit ReclaimPeriodChanged(_reclaimPeriod, newPeriod);\n        _reclaimPeriod = newPeriod;\n    }\n\n    function setBackup(address newBackup) public { \n        require(msg.sender == _owner, \"Only owner can set backup\");\n        emit BackupChanged(_backup, newBackup);\n        _backup = newBackup;\n    }\n\n    function reset() public { \n        require(msg.sender == _backup || msg.sender == _owner, \"Only owner or backup can reset\");\n        _timeout = 0;\n        emit Reset();\n    }\n\n    function finalizeReclaim() public { \n        require(msg.sender == _backup, \"Only backup can finalize reclaim\");\n        require(_timeout != 0 && block.timestamp > _timeout, \"Cannot finalize reclaim yet\");\n        _owner = _backup;\n        _timeout = 0;\n        emit Reclaimed();\n    }\n}\n```\nThis contract is a simple wallet with a reclaim function, which can be useful in case the owner's account gets compromised. The owner can set a backup address and a reclaim period. If the backup address starts the reclaim process, ownership will be transferred to the backup after the reclaim period, unless the owner resets the process.",
				"role": "assistant"
			}
		}
	],
	"created": 1701457728,
	"id": "chatcmpl-8R3AWTXfxMIXt71Frogb2BW0Gq7rG",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 00:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _reclaimPeriod; // STORAGE[0x2]\nuint256 _timeout; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _backup; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nReceived(address, uint256, bytes);\nOwnerChanged(address, address);\nReclaimBegun();\nSent(address, uint256, bytes);\nReclaimPeriodChanged(uint256, uint256);\nBackupChanged(address, address);\nReset();\nReclaimed();\n\nfunction timeLeft() public nonPayable { \n    require(_timeout != 0);\n    if (block.timestamp > _timeout) {\n        v0 = v1 = 0;\n    } else {\n        v0 = v2 = _timeout - block.timestamp;\n    }\n    return v0;\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnerChanged(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction reclaimPeriod() public nonPayable { \n    return _reclaimPeriod;\n}\n\nfunction backup() public nonPayable { \n    return _backup;\n}\n\nfunction beginReclaim() public nonPayable { \n    require(msg.sender == _backup);\n    if (_timeout == 0) {\n        _timeout = block.timestamp + _reclaimPeriod;\n        emit ReclaimBegun();\n    }\n}\n\nfunction timeout() public nonPayable { \n    return _timeout;\n}\n\nfunction canFinalize() public nonPayable { \n    v0 = v1 = _timeout != 0;\n    if (v1) {\n        v0 = v2 = block.timestamp > _timeout;\n    }\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction send(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(msg.sender == _owner);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[v3.data + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v4 = v5 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    v6 = varg0.call(v3.data).value(varg1).gas(msg.gas - 34710);\n    require(v6);\n    v7 = new array[](v0.length);\n    v8 = v9 = 0;\n    while (v8 < v0.length) {\n        MEM[v7.data + v8] = MEM[v0.data + v8];\n        v8 = v8 + 32;\n    }\n    v10 = v11 = v0.length + v7.data;\n    if (0x1f & v0.length) {\n        MEM[v11 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v11 - (0x1f & v0.length)];\n    }\n    emit Sent(varg0, varg1, v7);\n}\n\nfunction reclaimStarted() public nonPayable { \n    return _timeout != 0;\n}\n\nfunction setReclaimPeriod(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit ReclaimPeriodChanged(_reclaimPeriod, varg0);\n    _reclaimPeriod = varg0;\n}\n\nfunction setBackup(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit BackupChanged(_backup, varg0);\n    _backup = varg0;\n}\n\nfunction reset() public nonPayable { \n    v0 = v1 = msg.sender != _backup;\n    if (v1) {\n        v0 = msg.sender != _owner;\n    }\n    require(!v0);\n    _timeout = 0;\n    emit Reset();\n}\n\nfunction finalizeReclaim() public nonPayable { \n    require(msg.sender == _backup);\n    v0 = v1 = _timeout != 0;\n    if (v1) {\n        v0 = block.timestamp > _timeout;\n    }\n    if (v0) {\n        _owner = _backup;\n        _timeout = 0;\n        emit Reclaimed();\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    if (msg.data.length) {\n        if (0x1300a6d1 == function_selector) {\n            timeLeft();\n        } else if (0x13af4035 == function_selector) {\n            setOwner(address);\n        } else if (0x46e9e3c2 == function_selector) {\n            reclaimPeriod();\n        } else if (0x50a9e127 == function_selector) {\n            backup();\n        } else if (0x6a3c62a7 == function_selector) {\n            beginReclaim();\n        } else if (0x70dea79a == function_selector) {\n            timeout();\n        } else if (0x71e28126 == function_selector) {\n            canFinalize();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9bd9bbc6 == function_selector) {\n            send(address,uint256,bytes);\n        } else if (0x9e33f72c == function_selector) {\n            reclaimStarted();\n        } else if (0xaf418e4c == function_selector) {\n            setReclaimPeriod(uint256);\n        } else if (0xb7dacbf1 == function_selector) {\n            setBackup(address);\n        } else if (0xd826f88f == function_selector) {\n            reset();\n        } else if (0xde4b45fa == function_selector) {\n            finalizeReclaim();\n        }\n    }\n    v0 = new array[](msg.data.length);\n    emit Received(msg.sender, msg.value, v0);\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 00:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _reclaimPeriod; // STORAGE[0x2]\nuint256 _timeout; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _backup; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nReceived(address, uint256, bytes);\nOwnerChanged(address, address);\nReclaimBegun();\nSent(address, uint256, bytes);\nReclaimPeriodChanged(uint256, uint256);\nBackupChanged(address, address);\nReset();\nReclaimed();\n\nfunction timeLeft() public nonPayable { \n    require(_timeout != 0);\n    if (block.timestamp > _timeout) {\n        v0 = v1 = 0;\n    } else {\n        v0 = v2 = _timeout - block.timestamp;\n    }\n    return v0;\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnerChanged(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction reclaimPeriod() public nonPayable { \n    return _reclaimPeriod;\n}\n\nfunction backup() public nonPayable { \n    return _backup;\n}\n\nfunction beginReclaim() public nonPayable { \n    require(msg.sender == _backup);\n    if (_timeout == 0) {\n        _timeout = block.timestamp + _reclaimPeriod;\n        emit ReclaimBegun();\n    }\n}\n\nfunction timeout() public nonPayable { \n    return _timeout;\n}\n\nfunction canFinalize() public nonPayable { \n    v0 = v1 = _timeout != 0;\n    if (v1) {\n        v0 = v2 = block.timestamp > _timeout;\n    }\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction send(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(msg.sender == _owner);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[v3.data + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v4 = v5 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    v6 = varg0.call(v3.data).value(varg1).gas(msg.gas - 34710);\n    require(v6);\n    v7 = new array[](v0.length);\n    v8 = v9 = 0;\n    while (v8 < v0.length) {\n        MEM[v7.data + v8] = MEM[v0.data + v8];\n        v8 = v8 + 32;\n    }\n    v10 = v11 = v0.length + v7.data;\n    if (0x1f & v0.length) {\n        MEM[v11 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v11 - (0x1f & v0.length)];\n    }\n    emit Sent(varg0, varg1, v7);\n}\n\nfunction reclaimStarted() public nonPayable { \n    return _timeout != 0;\n}\n\nfunction setReclaimPeriod(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit ReclaimPeriodChanged(_reclaimPeriod, varg0);\n    _reclaimPeriod = varg0;\n}\n\nfunction setBackup(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit BackupChanged(_backup, varg0);\n    _backup = varg0;\n}\n\nfunction reset() public nonPayable { \n    v0 = v1 = msg.sender != _backup;\n    if (v1) {\n        v0 = msg.sender != _owner;\n    }\n    require(!v0);\n    _timeout = 0;\n    emit Reset();\n}\n\nfunction finalizeReclaim() public nonPayable { \n    require(msg.sender == _backup);\n    v0 = v1 = _timeout != 0;\n    if (v1) {\n        v0 = block.timestamp > _timeout;\n    }\n    if (v0) {\n        _owner = _backup;\n        _timeout = 0;\n        emit Reclaimed();\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    if (msg.data.length) {\n        if (0x1300a6d1 == function_selector) {\n            timeLeft();\n        } else if (0x13af4035 == function_selector) {\n            setOwner(address);\n        } else if (0x46e9e3c2 == function_selector) {\n            reclaimPeriod();\n        } else if (0x50a9e127 == function_selector) {\n            backup();\n        } else if (0x6a3c62a7 == function_selector) {\n            beginReclaim();\n        } else if (0x70dea79a == function_selector) {\n            timeout();\n        } else if (0x71e28126 == function_selector) {\n            canFinalize();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9bd9bbc6 == function_selector) {\n            send(address,uint256,bytes);\n        } else if (0x9e33f72c == function_selector) {\n            reclaimStarted();\n        } else if (0xaf418e4c == function_selector) {\n            setReclaimPeriod(uint256);\n        } else if (0xb7dacbf1 == function_selector) {\n            setBackup(address);\n        } else if (0xd826f88f == function_selector) {\n            reset();\n        } else if (0xde4b45fa == function_selector) {\n            finalizeReclaim();\n        }\n    }\n    v0 = new array[](msg.data.length);\n    emit Received(msg.sender, msg.value, v0);\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 00:59 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _reclaimPeriod; // STORAGE[0x2]\nuint256 _timeout; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _backup; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nReceived(address, uint256, bytes);\nOwnerChanged(address, address);\nReclaimBegun();\nSent(address, uint256, bytes);\nReclaimPeriodChanged(uint256, uint256);\nBackupChanged(address, address);\nReset();\nReclaimed();\n\nfunction timeLeft() public nonPayable { \n    require(_timeout != 0);\n    if (block.timestamp > _timeout) {\n        v0 = v1 = 0;\n    } else {\n        v0 = v2 = _timeout - block.timestamp;\n    }\n    return v0;\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit OwnerChanged(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction reclaimPeriod() public nonPayable { \n    return _reclaimPeriod;\n}\n\nfunction backup() public nonPayable { \n    return _backup;\n}\n\nfunction beginReclaim() public nonPayable { \n    require(msg.sender == _backup);\n    if (_timeout == 0) {\n        _timeout = block.timestamp + _reclaimPeriod;\n        emit ReclaimBegun();\n    }\n}\n\nfunction timeout() public nonPayable { \n    return _timeout;\n}\n\nfunction canFinalize() public nonPayable { \n    v0 = v1 = _timeout != 0;\n    if (v1) {\n        v0 = v2 = block.timestamp > _timeout;\n    }\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction send(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    require(msg.sender == _owner);\n    v1 = v2 = 0;\n    while (v1 < v0.length) {\n        MEM[v3.data + v1] = MEM[v0.data + v1];\n        v1 = v1 + 32;\n    }\n    v4 = v5 = v0.length + v3.data;\n    if (0x1f & v0.length) {\n        MEM[v5 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v5 - (0x1f & v0.length)];\n    }\n    v6 = varg0.call(v3.data).value(varg1).gas(msg.gas - 34710);\n    require(v6);\n    v7 = new array[](v0.length);\n    v8 = v9 = 0;\n    while (v8 < v0.length) {\n        MEM[v7.data + v8] = MEM[v0.data + v8];\n        v8 = v8 + 32;\n    }\n    v10 = v11 = v0.length + v7.data;\n    if (0x1f & v0.length) {\n        MEM[v11 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v11 - (0x1f & v0.length)];\n    }\n    emit Sent(varg0, varg1, v7);\n}\n\nfunction reclaimStarted() public nonPayable { \n    return _timeout != 0;\n}\n\nfunction setReclaimPeriod(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit ReclaimPeriodChanged(_reclaimPeriod, varg0);\n    _reclaimPeriod = varg0;\n}\n\nfunction setBackup(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    emit BackupChanged(_backup, varg0);\n    _backup = varg0;\n}\n\nfunction reset() public nonPayable { \n    v0 = v1 = msg.sender != _backup;\n    if (v1) {\n        v0 = msg.sender != _owner;\n    }\n    require(!v0);\n    _timeout = 0;\n    emit Reset();\n}\n\nfunction finalizeReclaim() public nonPayable { \n    require(msg.sender == _backup);\n    v0 = v1 = _timeout != 0;\n    if (v1) {\n        v0 = block.timestamp > _timeout;\n    }\n    if (v0) {\n        _owner = _backup;\n        _timeout = 0;\n        emit Reclaimed();\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    if (msg.data.length) {\n        if (0x1300a6d1 == function_selector) {\n            timeLeft();\n        } else if (0x13af4035 == function_selector) {\n            setOwner(address);\n        } else if (0x46e9e3c2 == function_selector) {\n            reclaimPeriod();\n        } else if (0x50a9e127 == function_selector) {\n            backup();\n        } else if (0x6a3c62a7 == function_selector) {\n            beginReclaim();\n        } else if (0x70dea79a == function_selector) {\n            timeout();\n        } else if (0x71e28126 == function_selector) {\n            canFinalize();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x9bd9bbc6 == function_selector) {\n            send(address,uint256,bytes);\n        } else if (0x9e33f72c == function_selector) {\n            reclaimStarted();\n        } else if (0xaf418e4c == function_selector) {\n            setReclaimPeriod(uint256);\n        } else if (0xb7dacbf1 == function_selector) {\n            setBackup(address);\n        } else if (0xd826f88f == function_selector) {\n            reset();\n        } else if (0xde4b45fa == function_selector) {\n            finalizeReclaim();\n        }\n    }\n    v0 = new array[](msg.data.length);\n    emit Received(msg.sender, msg.value, v0);\n}\n.",
	"status": "1",
	"time_cost": 38.211456060409546,
	"usage": {
		"completion_tokens": 770,
		"prompt_tokens": 1487,
		"total_tokens": 2257
	}
}