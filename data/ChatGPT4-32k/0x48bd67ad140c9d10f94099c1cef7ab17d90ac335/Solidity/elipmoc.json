{
	"address": "0x48bd67ad140c9d10f94099c1cef7ab17d90ac335",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract for the given decompiled contract:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Token {\n    uint256 private _totalSupply;\n    uint256 private _airdropSupply;\n    uint256 private _airdropCount;\n    mapping (address => uint256) private owner_3;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => uint256) private _freezeOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    address private _owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event Unfreeze(address indexed from, uint256 value);\n    event Freeze(address indexed from, uint256 value);\n\n    modifier onlyOwner {\n        require(msg.sender == _owner, \"Caller is not the owner\");\n        _;\n    }\n\n    function name() public pure returns (string memory) {\n        return \"Leber Network\";\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_balanceOf[_from] >= _value);\n        require(_balanceOf[_to] + _value > _balanceOf[_to]);\n        require(_value <= _allowance[_from][msg.sender]);\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        _allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(_balanceOf[msg.sender] >= _value);\n        _balanceOf[msg.sender] -= _value;\n        _totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return _balanceOf[_owner];\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return \"LBN\";\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(_balanceOf[msg.sender] >= _value);\n        require(_balanceOf[_to] + _value > _balanceOf[_to]);\n        _balanceOf[msg.sender] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return _allowance[_owner][_spender];\n    }\n}\n```\nPlease note that the contract may not be an exact representation of the decompiled code due to possible optimizations, simplifications or other changes introduced during compilation. The provided code aims to implement the same functionality as described in the decompiled code. Some functions and variables from the decompiled code are not included in the Solidity contract because their purpose and functionality could not be inferred from the decompiled code. Additionally, the contract assumes that the Solidity version is 0.8.0, but the actual version may differ.",
				"role": "assistant"
			}
		}
	],
	"created": 1701464887,
	"id": "chatcmpl-8R51zHj9kFUVriqDzkExpFChTAfbX",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 08:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _airdropSupply; // STORAGE[0x1]\nuint256 _airdropCount; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction fallback() public payable { \n    require(_balanceOf[address(this)] > 0);\n    require(!(0xff & owner_3[msg.sender]));\n    require(_airdropCount < 40000);\n    owner_3[msg.sender] = 0x1 | ~0xff & owner_3[msg.sender];\n    v0 = _SafeAdd(1, _airdropCount);\n    _airdropCount = v0;\n    if (v0 > 20000) {\n        if (_airdropCount <= 40000) {\n            0x4c9(0x821ab0d4414980000, msg.sender, this);\n        }\n    } else {\n        0x4c9(0x1043561a8829300000, msg.sender, this);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (13) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffff & 'Leber Network';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction airdropNum1() public nonPayable { \n    return 0x1043561a8829300000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    v0 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v0;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction airdropNum2() public nonPayable { \n    return 0x821ab0d4414980000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public nonPayable { \n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = _freezeOf[msg.sender] - varg0;\n    v0 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction airdropCountLimit1() public nonPayable { \n    return 20000;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4c424e0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 > _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    v0 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public nonPayable { \n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction airdropCount() public nonPayable { \n    return _airdropCount;\n}\n\nfunction airdropSupply() public nonPayable { \n    return _airdropSupply;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\nfunction 0x4c9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    assert(varg0 <= _balanceOf[v2]);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v2] - varg0;\n    v4 = address(varg1);\n    v5 = _SafeAdd(varg0, _balanceOf[v4]);\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    emit Transfer(address(varg2), v6, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1e3faf22 == function_selector) {\n            airdropNum1();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2f34adb4 == function_selector) {\n            airdropNum2();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else {\n            if (0x857512b4 != function_selector) {\n                if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0xa9059cbb == function_selector) {\n                    transfer(address,uint256);\n                } else if (0xcd4217c1 == function_selector) {\n                    freezeOf(address);\n                } else if (0xd7a78db8 == function_selector) {\n                    freeze(uint256);\n                } else if (0xdd62ed3e == function_selector) {\n                    allowance(address,address);\n                } else if (0xe92ba335 != function_selector) {\n                    if (0xe952f74f == function_selector) {\n                        airdropCount();\n                    } else if (0xfb3ed5c7 == function_selector) {\n                        airdropSupply();\n                    }\n                }\n            }\n            airdropCountLimit1();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 08:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _airdropSupply; // STORAGE[0x1]\nuint256 _airdropCount; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction fallback() public payable { \n    require(_balanceOf[address(this)] > 0);\n    require(!(0xff & owner_3[msg.sender]));\n    require(_airdropCount < 40000);\n    owner_3[msg.sender] = 0x1 | ~0xff & owner_3[msg.sender];\n    v0 = _SafeAdd(1, _airdropCount);\n    _airdropCount = v0;\n    if (v0 > 20000) {\n        if (_airdropCount <= 40000) {\n            0x4c9(0x821ab0d4414980000, msg.sender, this);\n        }\n    } else {\n        0x4c9(0x1043561a8829300000, msg.sender, this);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (13) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffff & 'Leber Network';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction airdropNum1() public nonPayable { \n    return 0x1043561a8829300000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    v0 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v0;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction airdropNum2() public nonPayable { \n    return 0x821ab0d4414980000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public nonPayable { \n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = _freezeOf[msg.sender] - varg0;\n    v0 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction airdropCountLimit1() public nonPayable { \n    return 20000;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4c424e0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 > _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    v0 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public nonPayable { \n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction airdropCount() public nonPayable { \n    return _airdropCount;\n}\n\nfunction airdropSupply() public nonPayable { \n    return _airdropSupply;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\nfunction 0x4c9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    assert(varg0 <= _balanceOf[v2]);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v2] - varg0;\n    v4 = address(varg1);\n    v5 = _SafeAdd(varg0, _balanceOf[v4]);\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    emit Transfer(address(varg2), v6, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1e3faf22 == function_selector) {\n            airdropNum1();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2f34adb4 == function_selector) {\n            airdropNum2();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else {\n            if (0x857512b4 != function_selector) {\n                if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0xa9059cbb == function_selector) {\n                    transfer(address,uint256);\n                } else if (0xcd4217c1 == function_selector) {\n                    freezeOf(address);\n                } else if (0xd7a78db8 == function_selector) {\n                    freeze(uint256);\n                } else if (0xdd62ed3e == function_selector) {\n                    allowance(address,address);\n                } else if (0xe92ba335 != function_selector) {\n                    if (0xe952f74f == function_selector) {\n                        airdropCount();\n                    } else if (0xfb3ed5c7 == function_selector) {\n                        airdropSupply();\n                    }\n                }\n            }\n            airdropCountLimit1();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 08:38 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nuint256 _airdropSupply; // STORAGE[0x1]\nuint256 _airdropCount; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction fallback() public payable { \n    require(_balanceOf[address(this)] > 0);\n    require(!(0xff & owner_3[msg.sender]));\n    require(_airdropCount < 40000);\n    owner_3[msg.sender] = 0x1 | ~0xff & owner_3[msg.sender];\n    v0 = _SafeAdd(1, _airdropCount);\n    _airdropCount = v0;\n    if (v0 > 20000) {\n        if (_airdropCount <= 40000) {\n            0x4c9(0x821ab0d4414980000, msg.sender, this);\n        }\n    } else {\n        0x4c9(0x1043561a8829300000, msg.sender, this);\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (13) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffff & 'Leber Network';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction airdropNum1() public nonPayable { \n    return 0x1043561a8829300000;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 > _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    assert(varg2 <= _balanceOf[varg0]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n    v0 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v0;\n    assert(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction airdropNum2() public nonPayable { \n    return 0x821ab0d4414980000;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public nonPayable { \n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = _freezeOf[msg.sender] - varg0;\n    v0 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction airdropCountLimit1() public nonPayable { \n    return 20000;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (3) {\n        MEM[v0.data] = 0x4c424e0000000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 > _balanceOf[varg0]);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    v0 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public nonPayable { \n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    assert(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    v0 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction airdropCount() public nonPayable { \n    return _airdropCount;\n}\n\nfunction airdropSupply() public nonPayable { \n    return _airdropSupply;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    assert(v2);\n    return v0;\n}\n\nfunction 0x4c9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    require(_balanceOf[v0] >= varg0);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    assert(varg0 <= _balanceOf[v2]);\n    v3 = address(varg2);\n    _balanceOf[v3] = _balanceOf[v2] - varg0;\n    v4 = address(varg1);\n    v5 = _SafeAdd(varg0, _balanceOf[v4]);\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    emit Transfer(address(varg2), v6, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x1e3faf22 == function_selector) {\n            airdropNum1();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x2f34adb4 == function_selector) {\n            airdropNum2();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else {\n            if (0x857512b4 != function_selector) {\n                if (0x8da5cb5b == function_selector) {\n                    owner();\n                } else if (0x95d89b41 == function_selector) {\n                    symbol();\n                } else if (0xa9059cbb == function_selector) {\n                    transfer(address,uint256);\n                } else if (0xcd4217c1 == function_selector) {\n                    freezeOf(address);\n                } else if (0xd7a78db8 == function_selector) {\n                    freeze(uint256);\n                } else if (0xdd62ed3e == function_selector) {\n                    allowance(address,address);\n                } else if (0xe92ba335 != function_selector) {\n                    if (0xe952f74f == function_selector) {\n                        airdropCount();\n                    } else if (0xfb3ed5c7 == function_selector) {\n                        airdropSupply();\n                    }\n                }\n            }\n            airdropCountLimit1();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 33.37389397621155,
	"usage": {
		"completion_tokens": 766,
		"prompt_tokens": 2470,
		"total_tokens": 3236
	}
}