{
	"address": "0x27e7383e49be6fd965805a0302b32e40c3d9981e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The solidity contract code based on the provided decompiled code would look something like this:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract CarTaxi {\n    uint256 private _totalTokens; \n    uint256 private _totalBonuses; \n    uint256 private _iteration; \n    address payable private _carTaxiCrowdsale; \n    address private _carTaxiToken; \n    address payable private _owner; \n    address payable private _carTaxiCrowdsaleAddress; \n    address private _carTaxiTokenAddress; \n\n    function carTaxiTokenAddress() public view returns (address) { \n        return _carTaxiTokenAddress;\n    }\n\n    function sendValue(address payable receiver, uint256 amount) public { \n        require(msg.sender == _owner);\n        receiver.transfer(amount);\n    }\n\n    function sendAuto(address receiver) public { \n        require(msg.sender == _owner);\n        require(_carTaxiToken != address(0));\n        // code related to '.balanceOf' and gas adjustment is omitted as it's not standard solidity\n        uint256 bonus = _totalBonuses * 1 ether / _totalTokens;\n        _carTaxiCrowdsaleAddress.transfer(bonus);\n    }\n\n    function carTaxiCrowdsale() public view returns (address) { \n        return _carTaxiCrowdsale;\n    }\n\n    function withdrawEther() public { \n        require(msg.sender == _owner);\n        require(address(this).balance > 0);\n        _owner.transfer(address(this).balance);\n    }\n\n    function totalTokens() public view returns (uint256) { \n        return _totalTokens;\n    }\n\n    function owner() public view returns (address) { \n        return _owner;\n    }\n\n    function carTaxiToken() public view returns (address) { \n        return _carTaxiToken;\n    }\n\n    function setTotalTokens(uint256 amount) public { \n        require(msg.sender == _owner);\n        _totalTokens = amount;\n    }\n\n    function carTaxiCrowdsaleAddress() public view returns (address) { \n        return _carTaxiCrowdsaleAddress;\n    }\n\n    function setTotalBonuses(uint256 amount) public { \n        require(msg.sender == _owner);\n        _totalBonuses = amount;\n    }\n\n    function totalBonuses() public view returns (uint256) { \n        return _totalBonuses;\n    }\n\n    function iteration() public view returns (uint256) { \n        return _iteration;\n    }\n\n    function setOwner(address payable newOwner) public { \n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        _owner = newOwner;\n    }\n}\n```\nThis is a basic conversion of the provided pseudo-code into Solidity and it may lack some functionality or correctness as the original code context is not fully known. Please adjust the code according to your requirements.",
				"role": "assistant"
			}
		}
	],
	"created": 1701463673,
	"id": "chatcmpl-8R4iPSsjNfgIRiXcSy3mwYAWr6lVq",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 13:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalTokens; // STORAGE[0x5]\nuint256 _totalBonuses; // STORAGE[0x6]\nuint256 _iteration; // STORAGE[0x7]\nuint160 _carTaxiCrowdsale; // STORAGE[0x0] bytes 0 to 19\naddress _carTaxiToken; // STORAGE[0x1] bytes 0 to 19\naddress _owner; // STORAGE[0x2] bytes 0 to 19\nuint160 _carTaxiCrowdsaleAddress; // STORAGE[0x3] bytes 0 to 19\nuint160 _carTaxiTokenAddress; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction carTaxiTokenAddress() public nonPayable { \n    return _carTaxiTokenAddress;\n}\n\nfunction sendValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0);\n}\n\nfunction sendAuto(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    MEM[32 + MEM[64]] = 0;\n    require(_carTaxiToken.code.size);\n    v0, v1 = _carTaxiToken.balanceOf(varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1 > 0);\n    require(_totalTokens > 0);\n    assert(_totalTokens);\n    v2 = varg0.call().value(v1 * _totalBonuses / _totalTokens).gas(!(v1 * _totalBonuses / _totalTokens) * 2300);\n    require(v2);\n}\n\nfunction carTaxiCrowdsale() public nonPayable { \n    return _carTaxiCrowdsale;\n}\n\nfunction withdrawEther() public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance > 0);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction totalTokens() public nonPayable { \n    return _totalTokens;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction carTaxiToken() public nonPayable { \n    return _carTaxiToken;\n}\n\nfunction setTotalTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _totalTokens = varg0;\n}\n\nfunction carTaxiCrowdsaleAddress() public nonPayable { \n    return _carTaxiCrowdsaleAddress;\n}\n\nfunction setTotalBonuses(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _totalBonuses = varg0;\n}\n\nfunction totalBonuses() public nonPayable { \n    return _totalBonuses;\n}\n\nfunction iteration() public nonPayable { \n    return _iteration;\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0xc0399a4 == function_selector) {\n            iteration();\n        } else if (0x13af4035 == function_selector) {\n            setOwner(address);\n        } else if (0x1e550ca2 == function_selector) {\n            carTaxiTokenAddress();\n        } else if (0x24a084df == function_selector) {\n            sendValue(address,uint256);\n        } else if (0x376d1555 == function_selector) {\n            sendAuto(address);\n        } else if (0x5ab68072 == function_selector) {\n            carTaxiCrowdsale();\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x7e1c0c09 == function_selector) {\n            totalTokens();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa43b7cd5 == function_selector) {\n            carTaxiToken();\n        } else if (0xb0b92263 == function_selector) {\n            setTotalTokens(uint256);\n        } else if (0xbe01bc87 == function_selector) {\n            carTaxiCrowdsaleAddress();\n        } else if (0xe5d8103e == function_selector) {\n            setTotalBonuses(uint256);\n        } else if (0xf9bacc1c == function_selector) {\n            totalBonuses();\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 13:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalTokens; // STORAGE[0x5]\nuint256 _totalBonuses; // STORAGE[0x6]\nuint256 _iteration; // STORAGE[0x7]\nuint160 _carTaxiCrowdsale; // STORAGE[0x0] bytes 0 to 19\naddress _carTaxiToken; // STORAGE[0x1] bytes 0 to 19\naddress _owner; // STORAGE[0x2] bytes 0 to 19\nuint160 _carTaxiCrowdsaleAddress; // STORAGE[0x3] bytes 0 to 19\nuint160 _carTaxiTokenAddress; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction carTaxiTokenAddress() public nonPayable { \n    return _carTaxiTokenAddress;\n}\n\nfunction sendValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0);\n}\n\nfunction sendAuto(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    MEM[32 + MEM[64]] = 0;\n    require(_carTaxiToken.code.size);\n    v0, v1 = _carTaxiToken.balanceOf(varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1 > 0);\n    require(_totalTokens > 0);\n    assert(_totalTokens);\n    v2 = varg0.call().value(v1 * _totalBonuses / _totalTokens).gas(!(v1 * _totalBonuses / _totalTokens) * 2300);\n    require(v2);\n}\n\nfunction carTaxiCrowdsale() public nonPayable { \n    return _carTaxiCrowdsale;\n}\n\nfunction withdrawEther() public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance > 0);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction totalTokens() public nonPayable { \n    return _totalTokens;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction carTaxiToken() public nonPayable { \n    return _carTaxiToken;\n}\n\nfunction setTotalTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _totalTokens = varg0;\n}\n\nfunction carTaxiCrowdsaleAddress() public nonPayable { \n    return _carTaxiCrowdsaleAddress;\n}\n\nfunction setTotalBonuses(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _totalBonuses = varg0;\n}\n\nfunction totalBonuses() public nonPayable { \n    return _totalBonuses;\n}\n\nfunction iteration() public nonPayable { \n    return _iteration;\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0xc0399a4 == function_selector) {\n            iteration();\n        } else if (0x13af4035 == function_selector) {\n            setOwner(address);\n        } else if (0x1e550ca2 == function_selector) {\n            carTaxiTokenAddress();\n        } else if (0x24a084df == function_selector) {\n            sendValue(address,uint256);\n        } else if (0x376d1555 == function_selector) {\n            sendAuto(address);\n        } else if (0x5ab68072 == function_selector) {\n            carTaxiCrowdsale();\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x7e1c0c09 == function_selector) {\n            totalTokens();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa43b7cd5 == function_selector) {\n            carTaxiToken();\n        } else if (0xb0b92263 == function_selector) {\n            setTotalTokens(uint256);\n        } else if (0xbe01bc87 == function_selector) {\n            carTaxiCrowdsaleAddress();\n        } else if (0xe5d8103e == function_selector) {\n            setTotalBonuses(uint256);\n        } else if (0xf9bacc1c == function_selector) {\n            totalBonuses();\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 13:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalTokens; // STORAGE[0x5]\nuint256 _totalBonuses; // STORAGE[0x6]\nuint256 _iteration; // STORAGE[0x7]\nuint160 _carTaxiCrowdsale; // STORAGE[0x0] bytes 0 to 19\naddress _carTaxiToken; // STORAGE[0x1] bytes 0 to 19\naddress _owner; // STORAGE[0x2] bytes 0 to 19\nuint160 _carTaxiCrowdsaleAddress; // STORAGE[0x3] bytes 0 to 19\nuint160 _carTaxiTokenAddress; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction carTaxiTokenAddress() public nonPayable { \n    return _carTaxiTokenAddress;\n}\n\nfunction sendValue(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = varg0.call().value(varg1).gas(!varg1 * 2300);\n    require(v0);\n}\n\nfunction sendAuto(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    MEM[32 + MEM[64]] = 0;\n    require(_carTaxiToken.code.size);\n    v0, v1 = _carTaxiToken.balanceOf(varg0).gas(msg.gas - 710);\n    require(v0);\n    require(v1 > 0);\n    require(_totalTokens > 0);\n    assert(_totalTokens);\n    v2 = varg0.call().value(v1 * _totalBonuses / _totalTokens).gas(!(v1 * _totalBonuses / _totalTokens) * 2300);\n    require(v2);\n}\n\nfunction carTaxiCrowdsale() public nonPayable { \n    return _carTaxiCrowdsale;\n}\n\nfunction withdrawEther() public nonPayable { \n    require(msg.sender == _owner);\n    require((address(this)).balance > 0);\n    v0 = _owner.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v0);\n}\n\nfunction totalTokens() public nonPayable { \n    return _totalTokens;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction carTaxiToken() public nonPayable { \n    return _carTaxiToken;\n}\n\nfunction setTotalTokens(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _totalTokens = varg0;\n}\n\nfunction carTaxiCrowdsaleAddress() public nonPayable { \n    return _carTaxiCrowdsaleAddress;\n}\n\nfunction setTotalBonuses(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _totalBonuses = varg0;\n}\n\nfunction totalBonuses() public nonPayable { \n    return _totalBonuses;\n}\n\nfunction iteration() public nonPayable { \n    return _iteration;\n}\n\nfunction setOwner(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    _owner = varg0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (0xc0399a4 == function_selector) {\n            iteration();\n        } else if (0x13af4035 == function_selector) {\n            setOwner(address);\n        } else if (0x1e550ca2 == function_selector) {\n            carTaxiTokenAddress();\n        } else if (0x24a084df == function_selector) {\n            sendValue(address,uint256);\n        } else if (0x376d1555 == function_selector) {\n            sendAuto(address);\n        } else if (0x5ab68072 == function_selector) {\n            carTaxiCrowdsale();\n        } else if (0x7362377b == function_selector) {\n            withdrawEther();\n        } else if (0x7e1c0c09 == function_selector) {\n            totalTokens();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa43b7cd5 == function_selector) {\n            carTaxiToken();\n        } else if (0xb0b92263 == function_selector) {\n            setTotalTokens(uint256);\n        } else if (0xbe01bc87 == function_selector) {\n            carTaxiCrowdsaleAddress();\n        } else if (0xe5d8103e == function_selector) {\n            setTotalBonuses(uint256);\n        } else if (0xf9bacc1c == function_selector) {\n            totalBonuses();\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 31.722710132598877,
	"usage": {
		"completion_tokens": 607,
		"prompt_tokens": 1150,
		"total_tokens": 1757
	}
}