{
	"address": "0x65bcf8de5c59ee18a69733759c3b8040416c8fa2",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.24 05:26 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _startTime; // STORAGE[0x1]\nuint256 _endTime; // STORAGE[0x2]\nuint256 _rate; // STORAGE[0x4]\nuint256 _weiRaised; // STORAGE[0x5]\nuint256 _cap; // STORAGE[0x6]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 _token; // STORAGE[0x0] bytes 0 to 19\nuint256 _wallet; // STORAGE[0x3] bytes 0 to 19\nuint256 _owner; // STORAGE[0x7] bytes 0 to 19\nuint256 _partner; // STORAGE[0x8] bytes 0 to 19\nuint256 stor_c_0_19; // STORAGE[0xc] bytes 0 to 19\nuint256 owner_d_0_19; // STORAGE[0xd] bytes 0 to 19\nuint256 _paused; // STORAGE[0x7] bytes 20 to 20\n\n// Events\nTokenPurchase(address, address, uint256, uint256);\nWithdrawal(address, uint256);\nUnpause();\nPause();\nOwnershipTransferred(address, address);\n\nfunction cap() public nonPayable { \n    return _cap;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x760();\n    require(v0);\n    if ((address(this)).balance > 0) {\n        v1 = _partner.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n        require(v1);\n        emit Withdrawal(msg.sender, (address(this)).balance);\n    }\n}\n\nfunction unpause() public nonPayable { \n    require(_owner == msg.sender);\n    require(_paused);\n    _paused = 0;\n    emit Unpause();\n}\n\nfunction weiRaised() public nonPayable { \n    return _weiRaised;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction paused() public nonPayable { \n    return _paused;\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction pause() public nonPayable { \n    require(_owner == msg.sender);\n    require(!_paused);\n    _paused = 1;\n    emit Pause();\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction partner() public nonPayable { \n    return _partner;\n}\n\nfunction buyTokens(address varg0) public payable { \n    0x310(varg0);\n}\n\nfunction hasEnded() public nonPayable { \n    v0 = 0x760();\n    return v0;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction 0x310(uint256 varg0) private { \n    require(!_paused);\n    require(address(varg0));\n    v0 = 0x82b();\n    require(v0);\n    v1 = _SafeMul(_rate, msg.value);\n    v2 = _SafeAdd(msg.value, _weiRaised);\n    _weiRaised = v2;\n    v3 = address(varg0);\n    require(owner_d_0_19.code.size);\n    v4 = owner_d_0_19.createVesting(v3, _endTime, stor_9, stor_a).gas(msg.gas - 710);\n    require(v4);\n    MEM[32 + MEM[64]] = 0;\n    v5 = address(varg0);\n    require(owner_d_0_19.code.size);\n    v6, v7 = owner_d_0_19.getVesting(v5).gas(msg.gas - 710);\n    require(v6);\n    MEM[32 + MEM[64]] = 0;\n    require(stor_c_0_19.code.size);\n    v8, v9 = stor_c_0_19.mint(address(v7), v1).gas(msg.gas - 710);\n    require(v8);\n    emit TokenPurchase(msg.sender, address(varg0), msg.value, v1);\n    v10 = _SafeMul(100 - stor_b, msg.value);\n    assert(100);\n    v11 = _wallet.call().value(v10 / 100).gas(2300 * !(v10 / 100));\n    require(v11);\n    return ;\n}\n\nfunction 0x760() private { \n    v0 = v1 = _weiRaised >= _cap;\n    v0 = block.timestamp > _endTime;\n    return v0;\n}\n\nfunction 0x82b() private { \n    v0 = _SafeAdd(msg.value, _weiRaised);\n    v1 = v2 = block.timestamp >= _startTime;\n    if (v2) {\n        v1 = v3 = block.timestamp <= _endTime;\n    }\n    v1 = v4 = msg.value;\n    if (!v1) {\n        return v1;\n    } else {\n        return v0 <= _cap;\n    }\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction rate() public nonPayable { \n    return _rate;\n}\n\nfunction endTime() public nonPayable { \n    return _endTime;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x2c4e722e) {\n            rate();\n        } else if (0x3197cbb6 == v0) {\n            endTime();\n        } else if (0x355274ea == v0) {\n            cap();\n        } else if (0x3ccfd60b == v0) {\n            withdraw();\n        } else if (0x3f4ba83a == v0) {\n            unpause();\n        } else if (0x4042b66f == v0) {\n            weiRaised();\n        } else if (0x521eb273 == v0) {\n            wallet();\n        } else if (0x5c975abb == v0) {\n            paused();\n        } else if (0x78e97925 == v0) {\n            startTime();\n        } else if (0x8456cb59 == v0) {\n            pause();\n        } else if (0x8da5cb5b == v0) {\n            owner();\n        } else if (0xbe10862b == v0) {\n            partner();\n        } else if (0xec8ac4d8 == v0) {\n            buyTokens(address);\n        } else if (0xecb70fb7 == v0) {\n            hasEnded();\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == v0) {\n            token();\n        }\n    }\n    0x310(msg.sender);\n}\n",
	"language": "Solidity",
	"status": "Connection error."
}