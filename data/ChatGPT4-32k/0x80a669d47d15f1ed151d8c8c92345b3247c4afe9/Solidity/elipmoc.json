{
	"address": "0x80a669d47d15f1ed151d8c8c92345b3247c4afe9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's a simplified solidity version of the decompiled EVM bytecode. Note that the decompiled code isn't always a perfect match for the original source code. Here's a possible interpretation:\n\n```solidity\npragma solidity ^0.8.6;\n\ncontract MyContract {\n    // State variables\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => mapping (address => uint256)) private _allowance;\n    mapping (address => bool) private _isBot;\n    uint256 private _totalSupply;\n    address private _owner;\n    string private _name;\n    string private _symbol;\n\n    // Events\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _owner = msg.sender;\n        _totalSupply = 1 * 10**18; // For example, initial total supply is 1 token with 18 decimals\n        _balanceOf[_owner] = _totalSupply;\n        emit Transfer(address(0), _owner, _totalSupply);\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowance[sender][msg.sender] - amount);\n        return true;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowance[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        _balanceOf[sender] -= amount;\n        _balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n}\n```\nThis contract has basic functionalities of an ERC20 token, including `totalSupply`, `balanceOf`, `allowance`, `approve`, `transfer` and `transferFrom`. The `renounceOwnership` function allows the current owner to relinquish control of the contract. The `_approve` and `_transfer` functions are internal functions that are used to update balances and allowances.",
				"role": "assistant"
			}
		}
	],
	"created": 1702495531,
	"id": "chatcmpl-8VP9Hssmv0Ovwln1aiN8o7HHK5X8Q",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.17 19:55 UTC\n// Compiled using the solidity compiler version 0.8.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 >= varg1, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (v2 > v1.length) {\n        v0[v1.length] = 0;\n    }\n    return v0;\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    return 0x174876e800 * v4;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction delBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    v3 = v4 = varg0.data;\n    require(msg.data.length >= 32 + (4 + varg0 + (varg0.length << 5)));\n    v5 = v6 = 0;\n    while (v5 < varg0.length) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v5 += 1;\n        v1 += 32;\n        v3 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v7 = v8 = 0;\n    while (v7 < v0.length) {\n        require(v7 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v7])] = bool(0) | bytes31(_isBot[address(v0[v7])]);\n        require(v7 != ~0, Panic(17)); // arithmetic overflow or underflow\n        v7 += 1;\n    }\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction () public payable { \n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = 0x174876e800 * v4;\n    v12 = v13 = 10;\n    v14 = v15 = uint8(18);\n    if (v15) {\n        if (v13) {\n            if (v13 == 1) {\n                v16 = v17 = 1;\n            } else if (v13 == 2) {\n                require(v15 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v16 = v18 = 0x40000;\n            } else if (!1) {\n                v19 = v20 = 1;\n                while (v14 > v20) {\n                    require(v12 <= ~0 / v12, Panic(17)); // arithmetic overflow or underflow\n                    if (v14 & v20) {\n                        v19 *= v12;\n                    }\n                    v14 = v14 >> v20;\n                    v12 *= v12;\n                }\n                require(v19 <= ~0 / v12, Panic(17)); // arithmetic overflow or underflow\n                v16 = v21 = v12 * v19;\n            } else {\n                v16 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v16 = v22 = 0;\n        }\n    } else {\n        v16 = v23 = 1;\n    }\n    require(!(bool(0x174876e800) & (v16 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = 0x174876e800 * v16;\n    v24 = v25 = 10;\n    v26 = v27 = uint8(18);\n    if (v27) {\n        if (v25) {\n            if (v25 == 1) {\n                v28 = v29 = 1;\n            } else if (v25 == 2) {\n                require(v27 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v28 = v30 = 0x40000;\n            } else if (!1) {\n                v31 = v32 = 1;\n                while (v26 > v32) {\n                    require(v24 <= ~0 / v24, Panic(17)); // arithmetic overflow or underflow\n                    if (v26 & v32) {\n                        v31 *= v24;\n                    }\n                    v26 = v26 >> v32;\n                    v24 *= v24;\n                }\n                require(v31 <= ~0 / v24, Panic(17)); // arithmetic overflow or underflow\n                v28 = v33 = v24 * v31;\n            } else {\n                v28 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v28 = v34 = 0;\n        }\n    } else {\n        v28 = v35 = 1;\n    }\n    require(!(bool(0x174876e800) & (v28 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(0x174876e800 * v28);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (v2 > v1.length) {\n        v0[v1.length] = 0;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction MOMOv2Swap() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(0x174876e800 * v4, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    require(bool(stor_13_0_19.code.size));\n    v12, /* address */ v13 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v12), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v13 == address(v13));\n    require(bool(stor_13_0_19.code.size));\n    v14, /* address */ v15 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v14), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v15 == address(v15));\n    require(bool((address(v13)).code.size));\n    v16, /* address */ v17 = address(v13).createPair(address(this), address(v15)).gas(msg.gas);\n    require(bool(v16), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v17 == address(v17));\n    owner_14 = bytes12(owner_14) | address(v17);\n    require(bool(stor_13_0_19.code.size));\n    v18, /* uint256 */ v19, /* uint256 */ v20, /* uint256 */ v21 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v18), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    require(bool((address(owner_14)).code.size));\n    v22, /* bool */ v23 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v22), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v23 == bool(v23));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction addBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    v3 = v4 = varg0.data;\n    require(msg.data.length >= 32 + (4 + varg0 + (varg0.length << 5)));\n    v5 = v6 = 0;\n    while (v5 < varg0.length) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v5 += 1;\n        v1 += 32;\n        v3 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v7 = v8 = 0;\n    while (v7 < v0.length) {\n        require(v7 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v7])] = bool(1) | bytes31(_isBot[address(v0[v7])]);\n        require(v7 != ~0, Panic(17)); // arithmetic overflow or underflow\n        v7 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3609;\n        v10 = v11 = 100;\n        v12 = v13 = 9148;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (!varg0) {\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x23bc', '0x23e1'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x107d', '0xe19'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n                        require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= ~stor_6, Panic(17)); // arithmetic overflow or underflow\n                        if (3 + stor_6 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e != ~0, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n                        require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4221;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9185;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        require(bool(stor_13_0_19.code.size));\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    if (v58 > v57.length) {\n                        v56[v57.length] = 0;\n                    }\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x1321. Refer to 3-address code (TAC);\n                require(!(bool(varg0) & (v14 > ~0 / varg0)), Panic(17)); // arithmetic overflow or underflow\n                v17 = varg0 * v14;\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x23bc', '0x23e1'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x31c2d847 == function_selector >> 224) {\n            delBots(address[]);\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xb9b5aa46 == function_selector >> 224) {\n        MOMOv2Swap();\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xd34628cc == function_selector >> 224) {\n        addBots(address[]);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.17 19:55 UTC\n// Compiled using the solidity compiler version 0.8.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 >= varg1, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (v2 > v1.length) {\n        v0[v1.length] = 0;\n    }\n    return v0;\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    return 0x174876e800 * v4;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction delBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    v3 = v4 = varg0.data;\n    require(msg.data.length >= 32 + (4 + varg0 + (varg0.length << 5)));\n    v5 = v6 = 0;\n    while (v5 < varg0.length) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v5 += 1;\n        v1 += 32;\n        v3 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v7 = v8 = 0;\n    while (v7 < v0.length) {\n        require(v7 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v7])] = bool(0) | bytes31(_isBot[address(v0[v7])]);\n        require(v7 != ~0, Panic(17)); // arithmetic overflow or underflow\n        v7 += 1;\n    }\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction () public payable { \n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = 0x174876e800 * v4;\n    v12 = v13 = 10;\n    v14 = v15 = uint8(18);\n    if (v15) {\n        if (v13) {\n            if (v13 == 1) {\n                v16 = v17 = 1;\n            } else if (v13 == 2) {\n                require(v15 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v16 = v18 = 0x40000;\n            } else if (!1) {\n                v19 = v20 = 1;\n                while (v14 > v20) {\n                    require(v12 <= ~0 / v12, Panic(17)); // arithmetic overflow or underflow\n                    if (v14 & v20) {\n                        v19 *= v12;\n                    }\n                    v14 = v14 >> v20;\n                    v12 *= v12;\n                }\n                require(v19 <= ~0 / v12, Panic(17)); // arithmetic overflow or underflow\n                v16 = v21 = v12 * v19;\n            } else {\n                v16 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v16 = v22 = 0;\n        }\n    } else {\n        v16 = v23 = 1;\n    }\n    require(!(bool(0x174876e800) & (v16 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = 0x174876e800 * v16;\n    v24 = v25 = 10;\n    v26 = v27 = uint8(18);\n    if (v27) {\n        if (v25) {\n            if (v25 == 1) {\n                v28 = v29 = 1;\n            } else if (v25 == 2) {\n                require(v27 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v28 = v30 = 0x40000;\n            } else if (!1) {\n                v31 = v32 = 1;\n                while (v26 > v32) {\n                    require(v24 <= ~0 / v24, Panic(17)); // arithmetic overflow or underflow\n                    if (v26 & v32) {\n                        v31 *= v24;\n                    }\n                    v26 = v26 >> v32;\n                    v24 *= v24;\n                }\n                require(v31 <= ~0 / v24, Panic(17)); // arithmetic overflow or underflow\n                v28 = v33 = v24 * v31;\n            } else {\n                v28 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v28 = v34 = 0;\n        }\n    } else {\n        v28 = v35 = 1;\n    }\n    require(!(bool(0x174876e800) & (v28 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(0x174876e800 * v28);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (v2 > v1.length) {\n        v0[v1.length] = 0;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction MOMOv2Swap() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(0x174876e800 * v4, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    require(bool(stor_13_0_19.code.size));\n    v12, /* address */ v13 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v12), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v13 == address(v13));\n    require(bool(stor_13_0_19.code.size));\n    v14, /* address */ v15 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v14), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v15 == address(v15));\n    require(bool((address(v13)).code.size));\n    v16, /* address */ v17 = address(v13).createPair(address(this), address(v15)).gas(msg.gas);\n    require(bool(v16), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v17 == address(v17));\n    owner_14 = bytes12(owner_14) | address(v17);\n    require(bool(stor_13_0_19.code.size));\n    v18, /* uint256 */ v19, /* uint256 */ v20, /* uint256 */ v21 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v18), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    require(bool((address(owner_14)).code.size));\n    v22, /* bool */ v23 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v22), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v23 == bool(v23));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction addBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    v3 = v4 = varg0.data;\n    require(msg.data.length >= 32 + (4 + varg0 + (varg0.length << 5)));\n    v5 = v6 = 0;\n    while (v5 < varg0.length) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v5 += 1;\n        v1 += 32;\n        v3 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v7 = v8 = 0;\n    while (v7 < v0.length) {\n        require(v7 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v7])] = bool(1) | bytes31(_isBot[address(v0[v7])]);\n        require(v7 != ~0, Panic(17)); // arithmetic overflow or underflow\n        v7 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3609;\n        v10 = v11 = 100;\n        v12 = v13 = 9148;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (!varg0) {\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x23bc', '0x23e1'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x107d', '0xe19'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n                        require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= ~stor_6, Panic(17)); // arithmetic overflow or underflow\n                        if (3 + stor_6 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e != ~0, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n                        require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4221;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9185;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        require(bool(stor_13_0_19.code.size));\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    if (v58 > v57.length) {\n                        v56[v57.length] = 0;\n                    }\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x1321. Refer to 3-address code (TAC);\n                require(!(bool(varg0) & (v14 > ~0 / varg0)), Panic(17)); // arithmetic overflow or underflow\n                v17 = varg0 * v14;\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x23bc', '0x23e1'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x31c2d847 == function_selector >> 224) {\n            delBots(address[]);\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xb9b5aa46 == function_selector >> 224) {\n        MOMOv2Swap();\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xd34628cc == function_selector >> 224) {\n        addBots(address[]);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.17 19:55 UTC\n// Compiled using the solidity compiler version 0.8.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x4]\nuint256 stor_6; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 __maxTxAmount; // STORAGE[0xf]\nuint256 __maxWalletSize; // STORAGE[0x10]\nuint256 __taxSwapThreshold; // STORAGE[0x11]\nuint256 __maxTaxSwap; // STORAGE[0x12]\nuint256 owner_14; // STORAGE[0x14]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\nuint256 stor_13_0_19; // STORAGE[0x13] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 >= varg1, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        if (v1 > varg0.length) {\n            v0[varg0.length] = 0;\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (v2 > v1.length) {\n        v0[v1.length] = 0;\n    }\n    return v0;\n}\n\nfunction @min_1039(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    require(varg1 <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n    require(varg1 + varg0 >= varg1, Error('SafeMath: addition overflow'));\n    return varg1 + varg0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_716(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    return 0x174876e800 * v4;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1021(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_716(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction delBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    v3 = v4 = varg0.data;\n    require(msg.data.length >= 32 + (4 + varg0 + (varg0.length << 5)));\n    v5 = v6 = 0;\n    while (v5 < varg0.length) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v5 += 1;\n        v1 += 32;\n        v3 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v7 = v8 = 0;\n    while (v7 < v0.length) {\n        require(v7 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v7])] = bool(0) | bytes31(_isBot[address(v0[v7])]);\n        require(v7 != ~0, Panic(17)); // arithmetic overflow or underflow\n        v7 += 1;\n    }\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction () public payable { \n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = 0x174876e800 * v4;\n    v12 = v13 = 10;\n    v14 = v15 = uint8(18);\n    if (v15) {\n        if (v13) {\n            if (v13 == 1) {\n                v16 = v17 = 1;\n            } else if (v13 == 2) {\n                require(v15 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v16 = v18 = 0x40000;\n            } else if (!1) {\n                v19 = v20 = 1;\n                while (v14 > v20) {\n                    require(v12 <= ~0 / v12, Panic(17)); // arithmetic overflow or underflow\n                    if (v14 & v20) {\n                        v19 *= v12;\n                    }\n                    v14 = v14 >> v20;\n                    v12 *= v12;\n                }\n                require(v19 <= ~0 / v12, Panic(17)); // arithmetic overflow or underflow\n                v16 = v21 = v12 * v19;\n            } else {\n                v16 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v16 = v22 = 0;\n        }\n    } else {\n        v16 = v23 = 1;\n    }\n    require(!(bool(0x174876e800) & (v16 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = 0x174876e800 * v16;\n    v24 = v25 = 10;\n    v26 = v27 = uint8(18);\n    if (v27) {\n        if (v25) {\n            if (v25 == 1) {\n                v28 = v29 = 1;\n            } else if (v25 == 2) {\n                require(v27 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v28 = v30 = 0x40000;\n            } else if (!1) {\n                v31 = v32 = 1;\n                while (v26 > v32) {\n                    require(v24 <= ~0 / v24, Panic(17)); // arithmetic overflow or underflow\n                    if (v26 & v32) {\n                        v31 *= v24;\n                    }\n                    v26 = v26 >> v32;\n                    v24 *= v24;\n                }\n                require(v31 <= ~0 / v24, Panic(17)); // arithmetic overflow or underflow\n                v28 = v33 = v24 * v31;\n            } else {\n                v28 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v28 = v34 = 0;\n        }\n    } else {\n        v28 = v35 = 1;\n    }\n    require(!(bool(0x174876e800) & (v28 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(0x174876e800 * v28);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    if (v2 > v1.length) {\n        v0[v1.length] = 0;\n    }\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1021(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction MOMOv2Swap() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(owner_14 >> 160), Error('trading is already open'));\n    stor_13_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = v1 = 10;\n    v2 = v3 = uint8(18);\n    if (v3) {\n        if (v1) {\n            if (v1 == 1) {\n                v4 = v5 = 1;\n            } else if (v1 == 2) {\n                require(v3 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                v4 = v6 = 0x40000;\n            } else if (!1) {\n                v7 = v8 = 1;\n                while (v2 > v8) {\n                    require(v0 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                    if (v2 & v8) {\n                        v7 *= v0;\n                    }\n                    v2 = v2 >> v8;\n                    v0 *= v0;\n                }\n                require(v7 <= ~0 / v0, Panic(17)); // arithmetic overflow or underflow\n                v4 = v9 = v0 * v7;\n            } else {\n                v4 = 0xde0b6b3a7640000;\n            }\n        } else {\n            v4 = v10 = 0;\n        }\n    } else {\n        v4 = v11 = 1;\n    }\n    require(!(bool(0x174876e800) & (v4 > 0xafebff0bcb24aafef78f69a51539d748f2ff38ca3eda88b093e034f)), Panic(17)); // arithmetic overflow or underflow\n    @_approve_716(0x174876e800 * v4, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    require(bool(stor_13_0_19.code.size));\n    v12, /* address */ v13 = stor_13_0_19.factory().gas(msg.gas);\n    require(bool(v12), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v13 == address(v13));\n    require(bool(stor_13_0_19.code.size));\n    v14, /* address */ v15 = stor_13_0_19.WETH().gas(msg.gas);\n    require(bool(v14), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v15 == address(v15));\n    require(bool((address(v13)).code.size));\n    v16, /* address */ v17 = address(v13).createPair(address(this), address(v15)).gas(msg.gas);\n    require(bool(v16), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v17 == address(v17));\n    owner_14 = bytes12(owner_14) | address(v17);\n    require(bool(stor_13_0_19.code.size));\n    v18, /* uint256 */ v19, /* uint256 */ v20, /* uint256 */ v21 = stor_13_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v18), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    require(bool((address(owner_14)).code.size));\n    v22, /* bool */ v23 = address(owner_14).approve(stor_13_0_19, ~0).gas(msg.gas);\n    require(bool(v22), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v23 == bool(v23));\n    owner_14 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & owner_14;\n    stor_6 = block.number;\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction addBots(address[] varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= uint64.max);\n    require(4 + varg0 + 31 < msg.data.length);\n    require(varg0.length <= uint64.max, Panic(65)); // failed memory allocation (too much memory)\n    v0 = new address[](varg0.length);\n    require(!((v0 + ((varg0.length << 5) + 63 & ~0x1f) > uint64.max) | (v0 + ((varg0.length << 5) + 63 & ~0x1f) < v0)), Panic(65)); // failed memory allocation (too much memory)\n    v1 = v2 = v0.data;\n    v3 = v4 = varg0.data;\n    require(msg.data.length >= 32 + (4 + varg0 + (varg0.length << 5)));\n    v5 = v6 = 0;\n    while (v5 < varg0.length) {\n        require(msg.data[v3] == address(msg.data[v3]));\n        MEM[v1] = msg.data[v3];\n        v5 += 1;\n        v1 += 32;\n        v3 += 32;\n    }\n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v7 = v8 = 0;\n    while (v7 < v0.length) {\n        require(v7 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n        _isBot[address(v0[v7])] = bool(1) | bytes31(_isBot[address(v0[v7])]);\n        require(v7 != ~0, Panic(17)); // arithmetic overflow or underflow\n        v7 += 1;\n    }\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_716(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1021(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3609;\n        v10 = v11 = 100;\n        v12 = v13 = 9148;\n        if (stor_e > stor_b) {\n            v14 = v15 = stor_9;\n        } else {\n            v14 = v16 = stor_7;\n        }\n        while (1) {\n            while (!varg0) {\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x23bc', '0x23e1'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x107d', '0xe19'}. Refer to 3-address code (TAC);\n                    v19 = v20 = address(owner_14) == varg2;\n                    if (v20) {\n                        v19 = v21 = stor_13_0_19 != address(varg1);\n                    }\n                    if (v19) {\n                        v19 = v22 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v19) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n                        require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        require(3 <= ~stor_6, Panic(17)); // arithmetic overflow or underflow\n                        if (3 + stor_6 > block.number) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_e != ~0, Panic(17)); // arithmetic overflow or underflow\n                        stor_e += 1;\n                    }\n                    v23 = v24 = address(owner_14) != address(varg1);\n                    if (address(owner_14) != address(varg1)) {\n                        v23 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v23) {\n                        require(_balanceOf[address(varg1)] <= ~varg0, Panic(17)); // arithmetic overflow or underflow\n                        require(_balanceOf[address(varg1)] + varg0 <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                    }\n                    v26 = v27 = address(owner_14) == address(varg1);\n                    if (v27) {\n                        v26 = v28 = this != varg2;\n                    }\n                    if (v26) {\n                        v8 = v29 = 4221;\n                        v10 = v30 = 100;\n                        v12 = v31 = 9185;\n                        if (stor_e > stor_c) {\n                            v14 = v32 = stor_a;\n                        } else {\n                            v14 = v33 = stor_8;\n                            continue;\n                        }\n                    }\n                    v34 = v35 = !uint8(owner_14 >> 168);\n                    if (!bool(uint8(owner_14 >> 168))) {\n                        v34 = v36 = address(owner_14) == address(varg1);\n                    }\n                    if (v34) {\n                        v34 = v37 = uint8(owner_14 >> 176);\n                    }\n                    if (v34) {\n                        v34 = v38 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v34) {\n                        v34 = v39 = stor_e > stor_d;\n                    }\n                    if (v34) {\n                        v40 = @min_1039(__maxTaxSwap, _balanceOf[this]);\n                        v41 = @min_1039(v40, varg0);\n                        owner_14 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        v42 = new address[](2);\n                        CALLDATACOPY(v42.data, msg.data.length, 64);\n                        require(0 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v43 = v42.data;\n                        v42[0] = address(this);\n                        require(bool(stor_13_0_19.code.size));\n                        v44, /* address */ v45 = stor_13_0_19.WETH().gas(msg.gas);\n                        require(bool(v44), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        require(v45 == address(v45));\n                        require(1 < v42.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n                        v42[1] = address(v45);\n                        @_approve_716(v41, stor_13_0_19, this);\n                        v46 = new address[](v42.length);\n                        v47 = v48 = v46.data;\n                        v49 = v50 = v42.data;\n                        v51 = v52 = 0;\n                        while (v51 < v42.length) {\n                            MEM[v47] = address(MEM[v49]);\n                            v49 += 32;\n                            v47 += 32;\n                            v51 += 1;\n                        }\n                        require(bool(stor_13_0_19.code.size));\n                        v53 = stor_13_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(v41, 0, v46, address(this), block.timestamp, v54, address(this)).gas(msg.gas);\n                        require(bool(v53), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        owner_14 = ~0xff000000000000000000000000000000000000000000 & owner_14;\n                        if (this.balance) {\n                            v55 = stor_5_0_19.call().value(this.balance).gas(2300 * !this.balance);\n                            require(bool(v55), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                } else {\n                    v56 = new bytes[](v57.length);\n                    v58 = v59 = 0;\n                    while (v58 < v57.length) {\n                        v56[v58] = v57[v58];\n                        v58 += 32;\n                    }\n                    if (v58 > v57.length) {\n                        v56[v57.length] = 0;\n                    }\n                    revert(Error(v56));\n                }\n                // Unknown jump to Block 0x1321. Refer to 3-address code (TAC);\n                require(!(bool(varg0) & (v14 > ~0 / varg0)), Panic(17)); // arithmetic overflow or underflow\n                v17 = varg0 * v14;\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x23bc', '0x23e1'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v60 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v60;\n        emit Transfer(varg2, this, v0);\n    }\n    v61 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v61;\n    v62 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v63 = _SafeAdd(v62, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v63;\n    v64 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v64;\n    emit Transfer(varg2, address(varg1), v64);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x31c2d847 == function_selector >> 224) {\n            delBots(address[]);\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xb9b5aa46 == function_selector >> 224) {\n        MOMOv2Swap();\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xd34628cc == function_selector >> 224) {\n        addBots(address[]);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 38.96365737915039,
	"usage": {
		"completion_tokens": 774,
		"prompt_tokens": 7629,
		"total_tokens": 8403
	}
}