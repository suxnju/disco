{
	"address": "0xbf2aeab03b82c182599930217272ef0fc5cf662b",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 07:11 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _challengePeriod; // STORAGE[0x1]\nuint256 _totalChannelWei; // STORAGE[0x3]\nuint256 _totalChannelToken; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _channels; // STORAGE[0x5]\nmapping (uint256 => [uint256]) map_6; // STORAGE[0x6]\naddress _hub; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_1_0_0; // STORAGE[0x1] bytes 0 to 0\nuint8 _hubContractWithdraw; // STORAGE[0x7] bytes 0 to 0\nuint256 stor_11d2; // STORAGE[0x11d2]\nuint256 stor_11d3; // STORAGE[0x11d3]\nuint256 stor_11d5; // STORAGE[0x11d5]\nuint256 stor_11d6; // STORAGE[0x11d6]\naddress _approvedToken; // STORAGE[0x2] bytes 0 to 19\nuint256 stor_2b46; // STORAGE[0x2b46]\nuint256 stor_2b47; // STORAGE[0x2b47]\nuint256 stor_2b49; // STORAGE[0x2b49]\nuint256 stor_2b4a; // STORAGE[0x2b4a]\n\n// Events\nDidHubContractWithdraw(uint256, uint256);\nDidChallengeThread(address, address, uint256, address, uint256[2], uint256[2], uint256);\nDidEmptyThread(address, address, address, uint256, address, uint256[2], uint256[2], uint256[2], bytes32, uint256);\nDidStartExitThread(address, address, address, uint256, address, uint256[2], uint256[2], uint256);\nDidEmptyChannel(address, uint256, uint256[2], uint256[2], uint256[2], bytes32, uint256);\nDidUpdateChannel(address, uint256, uint256[2], uint256[2], uint256[4], uint256[4], uint256[2], bytes32, uint256);\nDidStartExitChannel(address, uint256, uint256[2], uint256[2], uint256[2], bytes32, uint256);\n\nfunction 0x1159(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) private { \n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        require(_hub == msg.sender);\n        v0 = address(v1);\n        varg5 = v2 = 4562;\n        varg5 = v3 = 1;\n        assert(0xff & _channels[v0][0xc] <= 2);\n        if (0xff & _channels[v0][0xc] == 0) {\n            v4 = v5 = !varg1;\n            if (varg1) {\n                v4 = block.timestamp < varg1;\n            }\n            if (v4) {\n                if (MEM[varg4] > _channels[v0][6]) {\n                    if (MEM[varg4 + 32] >= _channels[v0][7]) {\n                        v6 = MEM[0 + varg8];\n                        v7 = MEM[32 + varg8] + v6;\n                        require(v7 >= v6);\n                        if (v7 <= _channels[v0][2]) {\n                            v8 = MEM[0 + varg7];\n                            v9 = MEM[32 + varg7] + v8;\n                            require(v9 >= v8);\n                            if (v9 <= _channels[v0][5]) {\n                                if (!v3) {\n                                    v10 = 0x21c4();\n                                    if (MEM[varg6] <= v10) {\n                                        v11 = 0x1cc9();\n                                        if (MEM[varg5] > v11) {\n                                            goto 0x4540x30f4B0x11a8;\n                                        }\n                                    } else {\n                                        goto 0x4540x30f4B0x11a8;\n                                    }\n                                } else {\n                                    v12 = 0x21c4();\n                                    v13 = MEM[0 + varg6];\n                                    require(MEM[varg6 + 64] + v13 >= v13);\n                                    if (MEM[varg6 + 64] + v13 <= v12) {\n                                        v14 = 0x1cc9();\n                                        v15 = MEM[0 + varg5];\n                                        require(MEM[varg5 + 64] + v15 >= v15);\n                                        if (MEM[varg5 + 64] + v15 > v14) {\n                                            goto 0x4540x30f4B0x11a8;\n                                        }\n                                    } else {\n                                        goto 0x4540x30f4B0x11a8;\n                                    }\n                                }\n                                varg5 = v16 = MEM[varg6 + 96];\n                                varg5 = v17 = MEM[varg6 + 32];\n                                varg5 = v18 = 13069;\n                                varg5 = v19 = 13057;\n                                v20 = MEM[0 + varg8];\n                                varg5 = v21 = MEM[varg8 + 32] + v20;\n                                require(v21 >= v20);\n                                while (1) {\n                                    varg5 += varg5;\n                                    if (varg5 >= varg5) {\n                                        break;\n                                    }\n                                    require(varg5 >= varg5);\n                                    goto {'0x33010x30f4B0x11a8', '0x330dB0x11a8', '0x336dB0x11a8'};\n                                    varg5 = v22 = MEM[varg5 + 64];\n                                    varg5 = v23 = 13098;\n                                    varg5 = v24 = 13057;\n                                    varg5 = v25 = MEM[0 + varg5];\n                                    v26 = v27 = 2;\n                                    varg5 = v28 = STORAGE[v26 + varg5];\n                                    varg5 += varg5;\n                                    if (varg5 >= varg5) {\n                                        break;\n                                    }\n                                    require(varg5 >= varg5);\n                                    if (varg5 >= varg5) {\n                                        MEM[64] += 64;\n                                        MEM[MEM[64]] = address(varg9);\n                                        MEM[MEM[64] + 32] = address(varg8);\n                                        MEM[64] += 32;\n                                        MEM[MEM[64]] = 0;\n                                        MEM[64] += 64;\n                                        MEM[MEM[64]] = 0;\n                                        MEM[MEM[64] + 32] = 1;\n                                        0x33b8(MEM[64], v29, MEM[64], varg0, varg1, varg2, varg3, varg4, varg5, varg6, varg7, MEM[64]);\n                                        if (MEM[varg5] <= MEM[varg5 + 32]) {\n                                            stor_11d2 = MEM[varg7];\n                                        } else {\n                                            v30 = MEM[32 + varg5];\n                                            v31 = MEM[0 + varg5];\n                                            require(v30 <= v31);\n                                            v32 = MEM[0 + varg7];\n                                            require(v31 - v30 + v32 >= v32);\n                                            stor_11d2 = v31 - v30 + v32;\n                                        }\n                                        if (MEM[varg5 + 64] <= MEM[varg5 + 96]) {\n                                            stor_11d3 = MEM[varg7 + 32];\n                                        } else {\n                                            v33 = MEM[96 + varg5];\n                                            v34 = MEM[64 + varg5];\n                                            require(v33 <= v34);\n                                            v35 = MEM[32 + varg7];\n                                            require(v34 - v33 + v35 >= v35);\n                                            stor_11d3 = v34 - v33 + v35;\n                                        }\n                                        if (MEM[varg4] <= MEM[varg4 + 32]) {\n                                            stor_11d5 = MEM[varg6];\n                                        } else {\n                                            v36 = MEM[32 + varg4];\n                                            v37 = MEM[0 + varg4];\n                                            require(v36 <= v37);\n                                            v38 = MEM[0 + varg6];\n                                            require(v37 - v36 + v38 >= v38);\n                                            stor_11d5 = v37 - v36 + v38;\n                                        }\n                                        if (MEM[varg4 + 64] <= MEM[varg4 + 96]) {\n                                            stor_11d6 = MEM[varg6 + 32];\n                                        } else {\n                                            v39 = MEM[96 + varg4];\n                                            v40 = MEM[64 + varg4];\n                                            require(v39 <= v40);\n                                            v41 = MEM[32 + varg6];\n                                            require(v40 - v39 + v41 >= v41);\n                                            stor_11d6 = v40 - v39 + v41;\n                                        }\n                                        varg5 = v42 = MEM[varg5 + 96];\n                                        varg5 = v43 = MEM[varg5 + 32];\n                                        v44 = v45 = MEM[varg5 + 64];\n                                        varg5 = v46 = 14276;\n                                        varg5 = v47 = 3832;\n                                        v48 = v49 = MEM[varg5] + _totalChannelWei;\n                                        require(v49 >= _totalChannelWei);\n                                        while (1) {\n                                            v50 = v44 + v48;\n                                            if (v50 >= v48) {\n                                                break;\n                                            }\n                                            require(v50 >= v48);\n                                            while (varg5 > v50) {\n                                                require(varg5 <= v50);\n                                                STORAGE[2 + (varg5 + 3)] = v50;\n                                                v51 = MEM[varg3 + 96];\n                                                v52 = address(varg6).call().value(v51).gas(2300 * !v51);\n                                                require(v52); // checks call status, propagates error data on error\n                                                v53 = MEM[varg2 + 96];\n                                                v54 = address(varg6);\n                                                require(_approvedToken.code.size);\n                                                v55, v56 = _approvedToken.transfer(v54, v53).gas(msg.gas);\n                                                require(v55); // checks call status, propagates error data on error\n                                                MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                                                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                                                if (v56) {\n                                                    v57 = v58 = varg5 + 6;\n                                                    if (2) {\n                                                        while (varg1 + 64 > varg5) {\n                                                            STORAGE[v57] = MEM[varg5];\n                                                            varg5 += 32;\n                                                            v57 += 1;\n                                                        }\n                                                    }\n                                                    while (v58 + 2 > v57) {\n                                                        STORAGE[v57] = 0;\n                                                        v57 += 1;\n                                                    }\n                                                    STORAGE[varg5 + 8] = varg0;\n                                                    STORAGE[varg5 + 9] = v29;\n                                                    v59 = v60 = MEM[64] + 32;\n                                                    v61 = v62 = 0;\n                                                    while (v61 < 2) {\n                                                        v63 = MEM[varg5];\n                                                        MEM[v59] = v63;\n                                                        varg5 += 32;\n                                                        v59 += 32;\n                                                        v61 += 1;\n                                                    }\n                                                    v64 = v65 = MEM[64] + 96;\n                                                    v66 = v67 = 0;\n                                                    while (v66 < 2) {\n                                                        v68 = MEM[varg5];\n                                                        MEM[v64] = v68;\n                                                        varg5 += 32;\n                                                        v64 += 32;\n                                                        v66 += 1;\n                                                    }\n                                                    v69 = v70 = MEM[64] + 160;\n                                                    v71 = v72 = 0;\n                                                    while (v71 < 4) {\n                                                        v73 = MEM[varg3];\n                                                        MEM[v69] = v73;\n                                                        varg3 += 32;\n                                                        v69 += 32;\n                                                        v71 += 1;\n                                                    }\n                                                    v74 = v75 = MEM[64] + 288;\n                                                    v76 = v77 = 0;\n                                                    while (v76 < 4) {\n                                                        v78 = MEM[varg2];\n                                                        MEM[v74] = v78;\n                                                        varg2 += 32;\n                                                        v74 += 32;\n                                                        v76 += 1;\n                                                    }\n                                                    v79 = v80 = MEM[64] + 416;\n                                                    v81 = v82 = 0;\n                                                    while (v81 < 2) {\n                                                        v83 = MEM[varg5];\n                                                        MEM[v79] = v83;\n                                                        varg5 += 32;\n                                                        v79 += 32;\n                                                        v81 += 1;\n                                                    }\n                                                    emit DidUpdateChannel(address(varg7), 0, v84, v84, v84, v84, v84, v84, v84, v84, v84, v84, v84, v84, v84, v84, varg0, v29);\n                                                    _hubContractWithdraw = 0;\n                                                    return varg9;\n                                                } else {\n                                                    goto 0x4540x1159;\n                                                }\n                                                v50 = v50 - varg5;\n                                                goto {'0xef80x3781B0x122d', '0x37c4B0x122d', '0x3843B0x122d', '0x3819B0x122d', '0x37f1B0x122d'};\n                                            }\n                                            _totalChannelWei = v50;\n                                            varg5 = v85 = MEM[varg5 + 96];\n                                            varg5 = v86 = MEM[varg5 + 32];\n                                            v44 = v87 = MEM[varg5 + 64];\n                                            varg5 = v88 = 14321;\n                                            varg5 = v89 = 3832;\n                                            v48 = MEM[varg5] + _totalChannelToken;\n                                            require(v48 >= _totalChannelToken);\n                                            goto 0x33010x3781B0x122d;\n                                            _totalChannelToken = v50;\n                                            v48 = v90, v44 = v91, varg5 = v92, varg5 = v93, varg5 = v94, varg5 = v95, varg5 = v96, varg5, varg5, varg5, varg5, varg5 = v97 = 0x331d(0, varg5, 13057, MEM[varg5 + 64], 3832, MEM[varg5 + 32], 3832, MEM[varg5 + 96], 14361, varg5, varg5, varg5, varg5);\n                                            STORAGE[varg5 + 2] = v50;\n                                            v48 = v98, v44 = v99, varg5 = v100, varg5 = v101, varg5 = v102, varg5 = v103, varg5 = v104, varg5, varg5, varg5, varg5, varg5 = v105 = 0x337d(0, varg5, 13057, MEM[varg5 + 64], 3832, MEM[varg5 + 32], 3832, MEM[varg5 + 96], 14403, varg5, varg5, varg5, varg5);\n                                        }\n                                    } else {\n                                        goto 0x4540x30f4B0x11a8;\n                                    }\n                                    goto {'0x33010x30f4B0x11a8', '0x332aB0x11a8', '0x338dB0x11a8'};\n                                    if (varg5 >= varg5) {\n                                        varg5 = v106 = MEM[varg5 + 96];\n                                        varg5 = v107 = MEM[varg5 + 32];\n                                        varg5 = v108 = 13165;\n                                        varg5 = v109 = 13057;\n                                        varg5 = v110 = MEM[varg5 + 32] + MEM[0 + varg5];\n                                        require(v110 >= MEM[0 + varg5]);\n                                        goto 0x33010x30f4B0x11a8;\n                                    } else {\n                                        goto 0x4540x30f4B0x11a8;\n                                    }\n                                    varg5 = v111 = MEM[varg5 + 64];\n                                    varg5 = v112 = 13197;\n                                    varg5 = v113 = 13057;\n                                    varg5 = v114 = MEM[0 + varg5];\n                                    varg5 = v115 = varg5 + 3;\n                                    v26 = v116 = 2;\n                                    goto 0xaae0x30f4B0x11a8;\n                                }\n                            } else {\n                                goto 0x4540x30f4B0x11a8;\n                            }\n                        } else {\n                            goto 0x4540x30f4B0x11a8;\n                        }\n                    } else {\n                        goto 0x4540x30f4B0x11a8;\n                    }\n                } else {\n                    goto 0x4540x30f4B0x11a8;\n                }\n            } else {\n                goto 0x4540x30f4B0x11a8;\n            }\n        }\n        revert('insufficient token');\n    }\n    revert('user token withdrawal transfer failed');\n}\n\nfunction fallback() public payable { \n}\n\nfunction totalChannelWei() public nonPayable { \n    return _totalChannelWei;\n}\n\nfunction 0x1396(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10) private { \n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        v0 = address(MEM[varg10]);\n        assert(0xff & _channels[v0][0xc] <= 2);\n        if (0xff & _channels[v0][0xc] == 0) {\n            v1 = v2 = msg.sender == _hub;\n            if (msg.sender != _hub) {\n                v1 = v3 = msg.sender == address(MEM[varg10]);\n            }\n            if (v1) {\n                if (!varg2) {\n                    0x33b8(1, varg0, varg1, varg2, varg3, varg4, varg5, varg6, varg7, varg8, varg9, varg10);\n                    if (MEM[varg5] > _channels[v0][6]) {\n                        if (MEM[varg5 + 32] >= _channels[v0][7]) {\n                            v4 = v5 = _channels[v0][2];\n                            v6 = v7 = 5403;\n                            v8 = MEM[32 + varg9];\n                            v9 = v10 = 0;\n                            while (1) {\n                                v11 = MEM[(v9 << 5) + varg9];\n                                if (v8 + v11 >= v11) {\n                                    break;\n                                }\n                                require(v8 + v11 >= v11);\n                                if (v8 + v11 <= v4) {\n                                    if (MEM[varg5 + 32] != _channels[v0][7]) {\n                                        if (MEM[varg7] <= MEM[varg7 + 32]) {\n                                            v12 = MEM[varg7];\n                                            v13 = MEM[32 + varg7];\n                                            require(v12 <= v13);\n                                            v14 = MEM[0 + varg9];\n                                            require(v13 - v12 + v14 >= v14);\n                                            _channels[v0] = v13 - v12 + v14;\n                                        } else {\n                                            _channels[v0] = MEM[varg9];\n                                        }\n                                        if (MEM[varg7 + 64] <= MEM[varg7 + 96]) {\n                                            v15 = MEM[64 + varg7];\n                                            v16 = MEM[96 + varg7];\n                                            require(v15 <= v16);\n                                            v17 = MEM[32 + varg9];\n                                            require(v16 - v15 + v17 >= v17);\n                                            _channels[v0][1] = v16 - v15 + v17;\n                                        } else {\n                                            _channels[v0][1] = MEM[varg9 + 32];\n                                        }\n                                        if (MEM[varg6] <= MEM[varg6 + 32]) {\n                                            v18 = MEM[varg6];\n                                            v19 = MEM[32 + varg6];\n                                            require(v18 <= v19);\n                                            v20 = MEM[0 + varg8];\n                                            require(v19 - v18 + v20 >= v20);\n                                            _channels[v0][3] = v19 - v18 + v20;\n                                        } else {\n                                            _channels[v0][3] = MEM[varg8];\n                                        }\n                                        if (MEM[varg6 + 64] <= MEM[varg6 + 96]) {\n                                            v21 = MEM[64 + varg6];\n                                            v22 = MEM[96 + varg6];\n                                            require(v21 <= v22);\n                                            v23 = MEM[32 + varg8];\n                                            require(v22 - v21 + v23 >= v23);\n                                            STORAGE[4 + keccak256(v0, 5)] = v22 - v21 + v23;\n                                        } else {\n                                            STORAGE[4 + keccak256(v0, 5)] = MEM[varg8 + 32];\n                                        }\n                                        goto 0x15bd;\n                                    } else {\n                                        if (MEM[varg7] <= MEM[varg7 + 32]) {\n                                            _channels[v0] = MEM[varg9];\n                                        } else {\n                                            v24 = MEM[32 + varg7];\n                                            v25 = MEM[0 + varg7];\n                                            require(v24 <= v25);\n                                            v26 = MEM[0 + varg9];\n                                            require(v25 - v24 + v26 >= v26);\n                                            _channels[v0] = v25 - v24 + v26;\n                                        }\n                                        if (MEM[varg7 + 64] <= MEM[varg7 + 96]) {\n                                            _channels[v0][1] = MEM[varg9 + 32];\n                                        } else {\n                                            v27 = MEM[96 + varg7];\n                                            v28 = MEM[64 + varg7];\n                                            require(v27 <= v28);\n                                            v29 = MEM[32 + varg9];\n                                            require(v28 - v27 + v29 >= v29);\n                                            _channels[v0][1] = v28 - v27 + v29;\n                                        }\n                                        if (MEM[varg6] <= MEM[varg6 + 32]) {\n                                            _channels[v0][3] = MEM[varg8];\n                                        } else {\n                                            v30 = MEM[32 + varg6];\n                                            v31 = MEM[0 + varg6];\n                                            require(v30 <= v31);\n                                            v32 = MEM[0 + varg8];\n                                            require(v31 - v30 + v32 >= v32);\n                                            _channels[v0][3] = v31 - v30 + v32;\n                                        }\n                                        if (MEM[varg6 + 64] <= MEM[varg6 + 96]) {\n                                            STORAGE[4 + keccak256(v0, 5)] = MEM[varg8 + 32];\n                                        } else {\n                                            v33 = MEM[96 + varg6];\n                                            v34 = MEM[64 + varg6];\n                                            require(v33 <= v34);\n                                            v35 = MEM[32 + varg8];\n                                            require(v34 - v33 + v35 >= v35);\n                                            STORAGE[4 + keccak256(v0, 5)] = v34 - v33 + v35;\n                                        }\n                                    }\n                                    _channels[v0][6] = MEM[varg5];\n                                    _channels[v0][8] = varg4;\n                                    _channels[v0][9] = varg3;\n                                    _channels[v0][10] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _channels[v0][0xa];\n                                    require(_challengePeriod + block.timestamp >= block.timestamp);\n                                    _channels[v0][11] = _challengePeriod + block.timestamp;\n                                    _channels[v0][12] = 0x1 | ~0xff & _channels[v0][0xc];\n                                    if (_hub == msg.sender) {\n                                        v36 = v37 = 0;\n                                    } else {\n                                        v36 = v38 = 1;\n                                    }\n                                    v39 = v40 = MEM[64];\n                                    MEM[v40 + 32] = _channels[v0][1];\n                                    v41 = v42 = MEM[64];\n                                    MEM[v42 + 32] = _channels[v0][4];\n                                    v43 = v44 = keccak256(v0, 5) + 6;\n                                    v45 = v46 = MEM[64] + 32;\n                                    v47 = v48 = 0;\n                                    while (v47 < 2) {\n                                        MEM[v45] = MEM[v39];\n                                        v39 += 32;\n                                        v45 += 32;\n                                        v47 += 1;\n                                    }\n                                    v49 = v50 = MEM[64] + 96;\n                                    v51 = v52 = 0;\n                                    while (v51 < 2) {\n                                        MEM[v49] = MEM[v41];\n                                        v41 += 32;\n                                        v49 += 32;\n                                        v51 += 1;\n                                    }\n                                    v53 = v54 = MEM[64] + 160;\n                                    v55 = v56 = 0;\n                                    while (v55 < 2) {\n                                        MEM[v53] = STORAGE[v43];\n                                        v43 += 1;\n                                        v53 += 32;\n                                        v55 += 1;\n                                    }\n                                    emit DidStartExitChannel(address(MEM[varg10]), 0xff & v36, _channels[v0], v57, _channels[v0][3], v57, v57, v57, _channels[v0][8], _channels[v0][9]);\n                                    _hubContractWithdraw = 0;\n                                    return ;\n                                } else {\n                                    goto 0x4540x1396;\n                                }\n                                goto {'0x1555', '0x151b'};\n                                if (v8 + v11 <= v4) {\n                                    break;\n                                }\n                                if (v8 + v11 > v4) {\n                                    goto 0x4540x1396;\n                                }\n                                v4 = v58 = _channels[v0][5];\n                                v6 = v59 = 5461;\n                                v8 = v60 = MEM[32 + varg8];\n                                v9 = v61 = 0;\n                            }\n                        } else {\n                            goto 0x4540x1396;\n                        }\n                    } else {\n                        goto 0x4540x1396;\n                    }\n                } else {\n                    goto 0x4540x1396;\n                }\n            } else {\n                goto 0x4540x1396;\n            }\n        } else {\n            goto 0x4540x1396;\n        }\n    }\n    revert('tokens must be conserved');\n}\n\nfunction hubContractWithdraw(uint256 varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        require(_hub == msg.sender);\n        v0 = 0x21c4();\n        if (v0 >= varg0) {\n            v1 = 0x1cc9();\n            if (v1 >= varg1) {\n                v2 = _hub.call().value(varg0).gas(2300 * !varg0);\n                require(v2); // checks call status, propagates error data on error\n                require(_approvedToken.code.size);\n                v3, v4 = _approvedToken.transfer(_hub, varg1).gas(msg.gas);\n                require(v3); // checks call status, propagates error data on error\n                MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                if (v4) {\n                    emit DidHubContractWithdraw(varg0, varg1);\n                    _hubContractWithdraw = 0;\n                } else {\n                    goto 0x4540x150;\n                }\n            } else {\n                goto 0x4540x150;\n            }\n        } else {\n            goto 0x4540x150;\n        }\n    }\n    revert('hubContractWithdraw: Token transfer failure');\n}\n\nfunction 0x150e(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12, uint256 varg13) private { \n    v0 = MEM[0 + v1];\n    v2 = MEM[(varg0 << 5) + varg1] + v0;\n    require(v2 >= v0);\n    return v2, varg3, varg4, varg5, varg6, varg7, varg8, varg9, varg10, varg11, varg12;\n}\n\nfunction 0x1548(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12) private { \n    v0 = MEM[0 + v1];\n    v2 = MEM[(varg0 << 5) + varg1] + v0;\n    require(v2 >= v0);\n    return v2, varg3, varg4, varg5, varg6, varg7, varg8, varg9, varg10, varg11, varg12;\n}\n\nfunction 0x168c(uint256 varg0) private { \n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        if (_hub != address(varg0)) {\n            if (this != address(varg0)) {\n                v0 = address(varg0);\n                assert(0xff & _channels[v0][0xc] <= 2);\n                if (0xff & _channels[v0][0xc] == 0) {\n                    v1 = v2 = msg.sender == _hub;\n                    if (msg.sender != _hub) {\n                        v1 = v3 = address(varg0) == msg.sender;\n                    }\n                    if (v1) {\n                        _channels[v0][10] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _channels[v0][0xa];\n                        require(_challengePeriod + block.timestamp >= block.timestamp);\n                        _channels[v0][11] = _challengePeriod + block.timestamp;\n                        _channels[v0][12] = 0x1 | ~0xff & _channels[v0][0xc];\n                        if (_hub == msg.sender) {\n                            v4 = v5 = 0;\n                        } else {\n                            v4 = v6 = 1;\n                            goto 0x10f20x168c;\n                        }\n                        v7 = v8 = MEM[64];\n                        MEM[v8 + 32] = _channels[v0][1];\n                        v9 = v10 = MEM[64];\n                        MEM[v10 + 32] = _channels[v0][4];\n                        v11 = v12 = keccak256(v0, 5) + 6;\n                        v13 = v14 = MEM[64] + 32;\n                        v15 = v16 = 0;\n                        while (v15 < 2) {\n                            MEM[v13] = MEM[v7];\n                            v7 += 32;\n                            v13 += 32;\n                            v15 += 1;\n                        }\n                        v17 = v18 = MEM[64] + 96;\n                        v19 = v20 = 0;\n                        while (v19 < 2) {\n                            MEM[v17] = MEM[v9];\n                            v9 += 32;\n                            v17 += 32;\n                            v19 += 1;\n                        }\n                        v21 = v22 = MEM[64] + 160;\n                        v23 = v24 = 0;\n                        while (v23 < 2) {\n                            MEM[v21] = STORAGE[v11];\n                            v11 += 1;\n                            v21 += 32;\n                            v23 += 1;\n                        }\n                        emit DidStartExitChannel(address(varg0), 0xff & v4, _channels[v0], v25, _channels[v0][3], v25, v25, v25, _channels[v0][8], _channels[v0][9]);\n                        _hubContractWithdraw = 0;\n                        return ;\n                    } else {\n                        goto 0x4540x168c;\n                    }\n                } else {\n                    goto 0x4540x168c;\n                }\n            } else {\n                goto 0x4540x168c;\n            }\n        } else {\n            goto 0x4540x168c;\n        }\n    }\n    revert('exit initiator must be user or hub');\n}\n\nfunction startExitThreadWithUpdate(address varg0, address[2] varg1, uint256 varg2, uint256[2] varg3, uint256[2] varg4, bytes varg5) public nonPayable { \n    require(msg.data.length - 4 >= 512);\n    v0 = v1 = 36;\n    require(msg.data.length > v1 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = MEM[64];\n    require(!((v2 + 64 < v2) | (v2 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v2 + 64;\n    require(v1 + 64 <= msg.data.length);\n    v3 = v4 = 0;\n    while (v3 < 2) {\n        MEM[v2] = address(msg.data[v0]);\n        v2 += 32;\n        v0 += 32;\n        v3 += 1;\n    }\n    v5 = v6 = 132;\n    require(msg.data.length > v6 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v7 = MEM[64];\n    require(!((v7 + 64 < v7) | (v7 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v7 + 64;\n    require(v6 + 64 <= msg.data.length);\n    v8 = v9 = 0;\n    while (v8 < 2) {\n        MEM[v7] = msg.data[v5];\n        v7 += 32;\n        v5 += 32;\n        v8 += 1;\n    }\n    v10 = v11 = 196;\n    require(msg.data.length > v11 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v12 = MEM[64];\n    require(!((v12 + 64 < v12) | (v12 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v12 + 64;\n    require(v11 + 64 <= msg.data.length);\n    v13 = v14 = 0;\n    while (v13 < 2) {\n        MEM[v12] = msg.data[v10];\n        v12 += 32;\n        v10 += 32;\n        v13 += 1;\n    }\n    require(varg2 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg2 + 31);\n    require(varg2.length <= 0xffffffffffffffff);\n    v15 = new bytes[](varg2.length);\n    require(!((v15 + ((~0x1f & 31 + varg2.length) + 32) < v15) | (v15 + ((~0x1f & 31 + varg2.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg2 + 32 + varg2.length <= msg.data.length);\n    CALLDATACOPY(v15.data, 4 + varg2 + 32, varg2.length);\n    MEM[varg2.length + v15.data] = 0;\n    require(varg3 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg3 + 31);\n    require(varg3.length <= 0xffffffffffffffff);\n    v16 = new bytes[](varg3.length);\n    require(!((v16 + ((~0x1f & 31 + varg3.length) + 32) < v16) | (v16 + ((~0x1f & 31 + varg3.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg3 + 32 + varg3.length <= msg.data.length);\n    CALLDATACOPY(v16.data, 4 + varg3 + 32, varg3.length);\n    MEM[varg3.length + v16.data] = 0;\n    v17 = v18 = 324;\n    require(msg.data.length > v18 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v19 = v20 = MEM[64];\n    require(!((v20 + 64 < v20) | (v20 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v20 + 64;\n    require(v18 + 64 <= msg.data.length);\n    v21 = v22 = 0;\n    while (v21 < 2) {\n        MEM[v19] = msg.data[v17];\n        v19 += 32;\n        v17 += 32;\n        v21 += 1;\n    }\n    v23 = v24 = 388;\n    require(msg.data.length > v24 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v19 = MEM[64];\n    require(!((v19 + 64 < v19) | (v19 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v19 + 64;\n    require(v24 + 64 <= msg.data.length);\n    v25 = v26 = 0;\n    while (v25 < 2) {\n        MEM[v19] = msg.data[v23];\n        v19 += 32;\n        v23 += 32;\n        v25 += 1;\n    }\n    require(varg5 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg5 + 31);\n    require(varg5.length <= 0xffffffffffffffff);\n    v27 = new bytes[](varg5.length);\n    require(!((v27 + ((~0x1f & 31 + varg5.length) + 32) < v27) | (v27 + ((~0x1f & 31 + varg5.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg5 + 32 + varg5.length <= msg.data.length);\n    CALLDATACOPY(v27.data, 4 + varg5 + 32, varg5.length);\n    MEM[varg5.length + v27.data] = 0;\n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        assert(0xff & _channels[varg0][0xc] <= 2);\n        if (0xff & _channels[varg0][0xc] == 2) {\n            v28 = v29 = msg.sender == _hub;\n            if (msg.sender != _hub) {\n                v28 = v30 = varg0 == msg.sender;\n            }\n            if (v28) {\n                v31 = v32 = address(MEM[v2]) == varg0;\n                if (address(MEM[v2]) != varg0) {\n                    v31 = v33 = address(MEM[v2 + 32]) == varg0;\n                }\n                if (v31) {\n                    v34 = v35 = !MEM[v7 + 32];\n                    if (v35) {\n                        v34 = v36 = !MEM[v12 + 32];\n                    }\n                    if (v34) {\n                        if (0 == map_6[varg1][5]) {\n                            0x2dd7(_channels[varg0][8], v16, v15, 0, v12, v7, varg1, MEM[32 + v2], MEM[0 + v2]);\n                            if (varg4 > 0) {\n                                v37 = v38 = MEM[v7];\n                                v39 = v40 = 2101;\n                                v41 = MEM[32 + v20];\n                                v42 = v43 = 0;\n                                while (v41 + MEM[(v42 << 5) + v19] < MEM[(v42 << 5) + v19]) {\n                                    require(v41 + MEM[(v42 << 5) + v19] >= MEM[(v42 << 5) + v19]);\n                                    if (v41 + MEM[(v42 << 5) + v19] == v37) {\n                                        MEM[64] = MEM[64] + 32;\n                                        MEM[MEM[64]] = 0;\n                                        0x2dd7(0, v27, MEM[64], varg4, v19, v20, varg1, MEM[v2 + 32], MEM[v2]);\n                                        if (2) {\n                                            while (v20 + 64 > v19) {\n                                                STORAGE[v44] = MEM[v19];\n                                                v19 += 32;\n                                                v44 += 1;\n                                            }\n                                        }\n                                        while (v45 + 2 > v44) {\n                                            STORAGE[v44] = 0;\n                                            v44 += 1;\n                                        }\n                                        v46 = v47 = v45 + 2;\n                                        if (2) {\n                                            while (v19 + 64 > v19) {\n                                                STORAGE[v46] = MEM[v19];\n                                                v19 += 32;\n                                                v46 += 1;\n                                            }\n                                        }\n                                        while (v47 + 2 > v46) {\n                                            STORAGE[v46] = 0;\n                                            v46 += 1;\n                                        }\n                                        map_6[varg1][4] = varg4;\n                                        require(_challengePeriod + block.timestamp >= block.timestamp);\n                                        map_6[varg1][5] = _challengePeriod + block.timestamp;\n                                        if (msg.sender == _hub) {\n                                            v48 = v49 = 0;\n                                        } else {\n                                            v48 = v50 = 1;\n                                        }\n                                        v51 = v52 = v45 + 2;\n                                        v53 = v54 = MEM[64] + 96;\n                                        v55 = v56 = 0;\n                                        while (v55 < 2) {\n                                            MEM[v53] = STORAGE[v44];\n                                            v44 += 1;\n                                            v53 += 32;\n                                            v55 += 1;\n                                        }\n                                        v57 = v58 = MEM[64] + 160;\n                                        v59 = v60 = 0;\n                                        while (v59 < 2) {\n                                            MEM[v57] = STORAGE[v51];\n                                            v51 += 1;\n                                            v57 += 32;\n                                            v59 += 1;\n                                        }\n                                        emit DidStartExitThread(address(MEM[0 + v2]), address(MEM[32 + v2]), varg0, varg1, 0xff & v48, v61, v61, v61, v61, map_6[varg1][4]);\n                                        _hubContractWithdraw = 0;\n                                    } else {\n                                        goto 0x4540x170;\n                                    }\n                                    goto {'0x835', '0x86b'};\n                                    if (v41 + MEM[(v42 << 5) + v19] == v37) {\n                                        break;\n                                    }\n                                    if (v41 + MEM[(v42 << 5) + v19] != v37) {\n                                        goto 0x4540x170;\n                                    }\n                                    v37 = v62 = MEM[v12];\n                                    v39 = v63 = 2155;\n                                    v41 = v64 = MEM[32 + v19];\n                                    v42 = v65 = 0;\n                                }\n                            } else {\n                                goto 0x4540x170;\n                            }\n                        } else {\n                            goto 0x4540x170;\n                        }\n                    } else {\n                        goto 0x4540x170;\n                    }\n                } else {\n                    goto 0x4540x170;\n                }\n            } else {\n                goto 0x4540x170;\n            }\n        } else {\n            goto 0x4540x170;\n        }\n    }\n    revert(\"sum of updated token balances must match sender's initial token balance\");\n}\n\nfunction challengeThread(address varg0, address varg1, uint256 varg2, uint256[2] varg3, uint256[2] varg4) public nonPayable { \n    require(msg.data.length - 4 >= 288);\n    v0 = v1 = 100;\n    require(msg.data.length > v1 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = MEM[64];\n    require(!((v2 + 64 < v2) | (v2 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v2 + 64;\n    require(v1 + 64 <= msg.data.length);\n    v3 = v4 = 0;\n    while (v3 < 2) {\n        MEM[v2] = msg.data[v0];\n        v2 += 32;\n        v0 += 32;\n        v3 += 1;\n    }\n    v5 = v6 = 164;\n    require(msg.data.length > v6 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v7 = MEM[64];\n    require(!((v7 + 64 < v7) | (v7 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v7 + 64;\n    require(v6 + 64 <= msg.data.length);\n    v8 = v9 = 0;\n    while (v8 < 2) {\n        MEM[v7] = msg.data[v5];\n        v7 += 32;\n        v5 += 32;\n        v8 += 1;\n    }\n    require(varg4 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg4 + 31);\n    require(varg4.length <= 0xffffffffffffffff);\n    v10 = new bytes[](varg4.length);\n    require(!((v10 + ((~0x1f & 31 + varg4.length) + 32) < v10) | (v10 + ((~0x1f & 31 + varg4.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg4 + 32 + varg4.length <= msg.data.length);\n    CALLDATACOPY(v10.data, 4 + varg4 + 32, varg4.length);\n    MEM[varg4.length + v10.data] = 0;\n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        v11 = v12 = _hub == msg.sender;\n        if (_hub != msg.sender) {\n            v11 = v13 = varg0 == msg.sender;\n        }\n        if (!v11) {\n            v11 = v14 = varg1 == msg.sender;\n        }\n        if (v11) {\n            if (block.timestamp < map_6[varg2][5]) {\n                if (varg3 > map_6[varg2][4]) {\n                    require(map_6[varg2][1] + map_6[varg2][0] >= map_6[varg2][0]);\n                    require(MEM[32 + v2] + MEM[0 + v2] >= MEM[0 + v2]);\n                    if (MEM[32 + v2] + MEM[0 + v2] == map_6[varg2][1] + map_6[varg2][0]) {\n                        require(map_6[varg2][3] + STORAGE[0 + (v15 + 2)] >= STORAGE[0 + (v15 + 2)]);\n                        require(MEM[v7 + 32] + MEM[0 + v7] >= MEM[0 + v7]);\n                        if (MEM[v7 + 32] + MEM[0 + v7] == map_6[varg2][3] + STORAGE[0 + (v15 + 2)]) {\n                            v16 = v17 = MEM[v2 + 32] >= map_6[varg2][1];\n                            if (MEM[v2 + 32] >= map_6[varg2][1]) {\n                                v16 = v18 = MEM[v7 + 32] >= map_6[varg2][3];\n                            }\n                            if (v16) {\n                                MEM[64] = MEM[64] + 32;\n                                MEM[MEM[64]] = 0;\n                                0x2dd7(0, v10, MEM[64], varg3, v7, v2, varg2, varg1, varg0);\n                                if (2) {\n                                    while (v2 + 64 > v2) {\n                                        STORAGE[v19] = MEM[v2];\n                                        v2 += 32;\n                                        v19 += 1;\n                                    }\n                                }\n                                while (v15 + 2 > v19) {\n                                    STORAGE[v19] = 0;\n                                    v19 += 1;\n                                }\n                                v20 = v21 = v15 + 2;\n                                if (2) {\n                                    while (v7 + 64 > v7) {\n                                        STORAGE[v20] = MEM[v7];\n                                        v7 += 32;\n                                        v20 += 1;\n                                    }\n                                }\n                                while (v21 + 2 > v20) {\n                                    STORAGE[v20] = 0;\n                                    v20 += 1;\n                                }\n                                map_6[varg2][4] = varg3;\n                                v22 = v23 = v15 + 2;\n                                v24 = v25 = MEM[64] + 64;\n                                v26 = v27 = 0;\n                                while (v26 < 2) {\n                                    MEM[v24] = STORAGE[v19];\n                                    v19 += 1;\n                                    v24 += 32;\n                                    v26 += 1;\n                                }\n                                v28 = v29 = MEM[64] + 128;\n                                v30 = v31 = 0;\n                                while (v30 < 2) {\n                                    MEM[v28] = STORAGE[v22];\n                                    v22 += 1;\n                                    v28 += 32;\n                                    v30 += 1;\n                                }\n                                emit DidChallengeThread(varg0, varg1, varg2, msg.sender, v32, v32, v32, v32, varg3);\n                                _hubContractWithdraw = 0;\n                            } else {\n                                goto 0x4540x190;\n                            }\n                        } else {\n                            goto 0x4540x190;\n                        }\n                    } else {\n                        goto 0x4540x190;\n                    }\n                } else {\n                    goto 0x4540x190;\n                }\n            } else {\n                goto 0x4540x190;\n            }\n        } else {\n            goto 0x4540x190;\n        }\n    }\n    revert('receiver balances may never decrease');\n}\n\nfunction totalChannelToken() public nonPayable { \n    return _totalChannelToken;\n}\n\nfunction hub() public nonPayable { \n    return _hub;\n}\n\nfunction 0x1cc9() private { \n    require(_approvedToken.code.size);\n    v0, v1 = _approvedToken.balanceOf(address(this)).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(_totalChannelToken <= v1);\n    return v1 - _totalChannelToken;\n}\n\nfunction 0x1d5c(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) private { \n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        v0 = address(MEM[v1]);\n        assert(0xff & _channels[v0][0xc] <= 2);\n        if (0xff & _channels[v0][0xc] == 1) {\n            if (block.timestamp < _channels[v0][11]) {\n                if (msg.sender != address(_channels[v0][0xa])) {\n                    v2 = v3 = msg.sender == _hub;\n                    if (msg.sender != _hub) {\n                        v2 = v4 = msg.sender == address(MEM[v1]);\n                    }\n                    if (v2) {\n                        if (!varg2) {\n                            0x33b8(1, varg0, varg1, varg2, varg3, varg4, varg5, varg6, varg7, varg8, varg9, v1);\n                            if (MEM[varg5] > _channels[v0][6]) {\n                                if (MEM[varg5 + 32] >= _channels[v0][7]) {\n                                    v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 = 0x150e(1, varg9, 7985, _channels[v0][2], keccak256(v0, 5), varg0, varg1, varg2, varg3, varg4, varg5, varg6, varg7, varg8);\n                                    if (v5 <= v6) {\n                                        v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29 = 0x1548(1, v16, 8034, STORAGE[v7 + 5], v7, v8, v9, v10, v11, v12, v13, v14, v15);\n                                        if (v18 <= v19) {\n                                            if (MEM[v26 + 32] != STORAGE[v20 + 7]) {\n                                                if (MEM[v28] <= MEM[v28 + 32]) {\n                                                    require(MEM[v28] <= MEM[32 + v28]);\n                                                    require(MEM[32 + v28] - MEM[v28] + MEM[0 + v17] >= MEM[0 + v17]);\n                                                    STORAGE[v20] = MEM[32 + v28] - MEM[v28] + MEM[0 + v17];\n                                                } else {\n                                                    STORAGE[v20] = MEM[v17];\n                                                }\n                                                if (MEM[v28 + 64] <= MEM[v28 + 96]) {\n                                                    require(MEM[64 + v28] <= MEM[96 + v28]);\n                                                    require(MEM[96 + v28] - MEM[64 + v28] + MEM[32 + v17] >= MEM[32 + v17]);\n                                                    STORAGE[1 + v20] = MEM[96 + v28] - MEM[64 + v28] + MEM[32 + v17];\n                                                } else {\n                                                    STORAGE[1 + v20] = MEM[v17 + 32];\n                                                }\n                                                if (MEM[v27] <= MEM[v27 + 32]) {\n                                                    require(MEM[v27] <= MEM[32 + v27]);\n                                                    require(MEM[32 + v27] - MEM[v27] + MEM[0 + v29] >= MEM[0 + v29]);\n                                                    STORAGE[3 + v20] = MEM[32 + v27] - MEM[v27] + MEM[0 + v29];\n                                                } else {\n                                                    STORAGE[3 + v20] = MEM[v29];\n                                                }\n                                                if (MEM[v27 + 64] <= MEM[v27 + 96]) {\n                                                    require(MEM[64 + v27] <= MEM[96 + v27]);\n                                                    require(MEM[96 + v27] - MEM[64 + v27] + MEM[32 + v29] >= MEM[32 + v29]);\n                                                    STORAGE[4 + v20] = MEM[96 + v27] - MEM[64 + v27] + MEM[32 + v29];\n                                                } else {\n                                                    STORAGE[4 + v20] = MEM[v29 + 32];\n                                                }\n                                                goto 0x1fca;\n                                            } else {\n                                                if (MEM[v28] <= MEM[v28 + 32]) {\n                                                    STORAGE[v20] = MEM[v17];\n                                                } else {\n                                                    require(MEM[32 + v28] <= MEM[0 + v28]);\n                                                    require(MEM[0 + v28] - MEM[32 + v28] + MEM[0 + v17] >= MEM[0 + v17]);\n                                                    STORAGE[v20] = MEM[0 + v28] - MEM[32 + v28] + MEM[0 + v17];\n                                                }\n                                                if (MEM[v28 + 64] <= MEM[v28 + 96]) {\n                                                    STORAGE[1 + v20] = MEM[v17 + 32];\n                                                } else {\n                                                    require(MEM[96 + v28] <= MEM[64 + v28]);\n                                                    require(MEM[64 + v28] - MEM[96 + v28] + MEM[32 + v17] >= MEM[32 + v17]);\n                                                    STORAGE[1 + v20] = MEM[64 + v28] - MEM[96 + v28] + MEM[32 + v17];\n                                                }\n                                                if (MEM[v27] <= MEM[v27 + 32]) {\n                                                    STORAGE[3 + v20] = MEM[v29];\n                                                } else {\n                                                    require(MEM[32 + v27] <= MEM[0 + v27]);\n                                                    require(MEM[0 + v27] - MEM[32 + v27] + MEM[0 + v29] >= MEM[0 + v29]);\n                                                    STORAGE[3 + v20] = MEM[0 + v27] - MEM[32 + v27] + MEM[0 + v29];\n                                                }\n                                                if (MEM[v27 + 64] <= MEM[v27 + 96]) {\n                                                    STORAGE[4 + v20] = MEM[v29 + 32];\n                                                } else {\n                                                    require(MEM[96 + v27] <= MEM[64 + v27]);\n                                                    require(MEM[64 + v27] - MEM[96 + v27] + MEM[32 + v29] >= MEM[32 + v29]);\n                                                    STORAGE[4 + v20] = MEM[64 + v27] - MEM[96 + v27] + MEM[32 + v29];\n                                                }\n                                            }\n                                            require(STORAGE[v20] <= STORAGE[2 + v20]);\n                                            STORAGE[2 + STORAGE[1 + v20]] = STORAGE[2 + v20] - STORAGE[v20];\n                                            require(STORAGE[STORAGE[1 + v20] + 3] <= STORAGE[2 + (STORAGE[1 + v20] + 3)]);\n                                            require(STORAGE[1 + (STORAGE[1 + v20] + 3)] <= STORAGE[2 + (STORAGE[1 + v20] + 3)] - STORAGE[STORAGE[1 + v20] + 3]);\n                                            STORAGE[STORAGE[1 + v20] + 5] = STORAGE[2 + (STORAGE[1 + v20] + 3)] - STORAGE[STORAGE[1 + v20] + 3] - STORAGE[1 + (STORAGE[1 + v20] + 3)];\n                                            require(STORAGE[0 + STORAGE[1 + v20]] <= _totalChannelWei);\n                                            _totalChannelWei = _totalChannelWei - STORAGE[0 + STORAGE[1 + v20]];\n                                            v30 = address(MEM[v27]).call().value(STORAGE[STORAGE[1 + STORAGE[1 + v20]] + 1]).gas(2300 * !STORAGE[STORAGE[1 + STORAGE[1 + v20]] + 1]);\n                                            require(v30); // checks call status, propagates error data on error\n                                            STORAGE[0 + STORAGE[1 + STORAGE[1 + v20]]] = 0;\n                                            STORAGE[1 + STORAGE[1 + STORAGE[1 + v20]]] = 0;\n                                            v31 = STORAGE[1 + (STORAGE[1 + STORAGE[1 + v20]] + 3)];\n                                            require(STORAGE[0 + (STORAGE[1 + STORAGE[1 + v20]] + 3)] <= _totalChannelToken);\n                                            _totalChannelToken = _totalChannelToken - STORAGE[0 + (STORAGE[1 + STORAGE[1 + v20]] + 3)];\n                                            require(_approvedToken.code.size);\n                                            v32, v33 = _approvedToken.transfer(address(MEM[v25]), STORAGE[4 + v31]).gas(msg.gas);\n                                            require(v32); // checks call status, propagates error data on error\n                                            MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                                            if (v33) {\n                                                STORAGE[v31 + 3] = 0;\n                                                STORAGE[v31 + 4] = 0;\n                                                STORAGE[v31 + 6] = MEM[v20];\n                                                STORAGE[v31 + 8] = 8149;\n                                                STORAGE[v31 + 9] = STORAGE[1 + v20];\n                                                if (STORAGE[1 + v20] <= 0) {\n                                                    STORAGE[v31 + 11] = 0;\n                                                    STORAGE[v31 + 12] = ~0xff & STORAGE[v31 + 12];\n                                                } else {\n                                                    STORAGE[v31 + 12] = 0x2 | ~0xff & STORAGE[v31 + 12];\n                                                }\n                                                STORAGE[v31 + 10] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v31 + 10];\n                                                if (msg.sender == _hub) {\n                                                    v34 = v35 = 0;\n                                                } else {\n                                                    v34 = v36 = 1;\n                                                    goto 0x163b0x1d5c;\n                                                }\n                                                v37 = v38 = MEM[64];\n                                                MEM[v38 + 32] = STORAGE[v31 + 1];\n                                                v39 = v40 = MEM[64];\n                                                MEM[v40 + 32] = STORAGE[v31 + 4];\n                                                v41 = v42 = v31 + 6;\n                                                v43 = v44 = MEM[64] + 32;\n                                                v45 = v46 = 0;\n                                                while (v45 < 2) {\n                                                    MEM[v43] = MEM[v37];\n                                                    v37 += 32;\n                                                    v43 += 32;\n                                                    v45 += 1;\n                                                }\n                                                v47 = v48 = MEM[64] + 96;\n                                                v49 = v50 = 0;\n                                                while (v49 < 2) {\n                                                    MEM[v47] = MEM[v39];\n                                                    v39 += 32;\n                                                    v47 += 32;\n                                                    v49 += 1;\n                                                }\n                                                v51 = v52 = MEM[64] + 160;\n                                                v53 = v54 = 0;\n                                                while (v53 < 2) {\n                                                    MEM[v51] = STORAGE[v41];\n                                                    v41 += 1;\n                                                    v51 += 32;\n                                                    v53 += 1;\n                                                }\n                                                emit DidEmptyChannel(address(MEM[v25]), 0xff & v34, STORAGE[v31], v55, STORAGE[v31 + 3], v55, v55, v55, STORAGE[v31 + 8], STORAGE[v31 + 9]);\n                                                _hubContractWithdraw = 0;\n                                                return v27, v28, v29, v17, v1;\n                                            } else {\n                                                goto 0x4540x1d5c;\n                                            }\n                                        } else {\n                                            goto 0x4540x1d5c;\n                                        }\n                                    } else {\n                                        goto 0x4540x1d5c;\n                                    }\n                                } else {\n                                    goto 0x4540x1d5c;\n                                }\n                            } else {\n                                goto 0x4540x1d5c;\n                            }\n                        } else {\n                            goto 0x4540x1d5c;\n                        }\n                    } else {\n                        goto 0x4540x1d5c;\n                    }\n                } else {\n                    goto 0x4540x1d5c;\n                }\n            } else {\n                goto 0x4540x1d5c;\n            }\n        } else {\n            goto 0x4540x1d5c;\n        }\n    }\n    revert('user token withdrawal transfer failed');\n}\n\nfunction getChannelBalances(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    MEM[64] = MEM[64] + 416;\n    MEM[64] = MEM[64] + 96;\n    MEM[(MEM[64]) len 96] = this.code[this.code.size len 96];\n    MEM[MEM[64]] = MEM[64];\n    MEM[64] = MEM[64] + 96;\n    MEM[(MEM[64]) len 96] = this.code[this.code.size len 96];\n    MEM[32 + MEM[64]] = MEM[64];\n    MEM[(MEM[64]) len 64] = this.code[this.code.size len 64];\n    MEM[64 + MEM[64]] = MEM[64];\n    MEM[64 + MEM[64] + 32] = 0;\n    MEM[64 + MEM[64] + 64] = 0;\n    MEM[64 + MEM[64] + 96] = 0;\n    MEM[64 + MEM[64] + 128] = 0;\n    MEM[64 + MEM[64] + 160] = 0;\n    v0 = v1 = MEM[64] + 256;\n    do {\n        MEM[v0] = STORAGE[v2];\n        v0 += 32;\n        v2 += 1;\n    } while (v1 + 96 <= v0);\n    v3 = v4 = MEM[64];\n    v5 = v6 = 3 + v7;\n    do {\n        MEM[v3] = STORAGE[v5];\n        v3 += 32;\n        v5 += 1;\n    } while (v4 + 96 <= v3);\n    v8 = v9 = MEM[64];\n    v10 = v11 = v7 + 6;\n    do {\n        MEM[v8] = STORAGE[v10];\n        v8 += 32;\n        v10 += 1;\n    } while (64 + v9 <= v8);\n    MEM[MEM[64] + 32 + 32] = v9;\n    MEM[MEM[64] + 32 + 32 + 32] = _channels[varg0][8];\n    MEM[MEM[64] + 32 + 32 + 64] = _channels[varg0][9];\n    MEM[MEM[64] + 32 + 32 + 96] = address(_channels[address(varg0)][0xa]);\n    MEM[MEM[64] + 32 + 32 + 128] = _channels[varg0][11];\n    assert(0xff & _channels[varg0][0xc] <= 2);\n    assert(0xff & _channels[varg0][0xc] <= 2);\n    MEM[MEM[64] + 32 + 32 + 160] = 0xff & _channels[varg0][0xc];\n    return MEM[v1], MEM[v1 + 32], MEM[64 + v1], MEM[v4], MEM[v4 + 32], MEM[64 + v4];\n}\n\nfunction emptyChannel(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    v0 = 0xd8f();\n}\n\nfunction 0x21c4() private { \n    require(_totalChannelWei <= this.balance);\n    return this.balance - _totalChannelWei;\n}\n\nfunction 0x21dc(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7) private { \n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        v0 = address(varg7);\n        assert(0xff & _channels[v0][0xc] <= 2);\n        if (0xff & _channels[v0][0xc] == 2) {\n            v1 = v2 = msg.sender == _hub;\n            if (msg.sender != _hub) {\n                v1 = v3 = address(varg7) == msg.sender;\n            }\n            if (v1) {\n                v4 = v5 = address(varg7) == address(varg6);\n                if (address(varg7) != address(varg6)) {\n                    v4 = v6 = address(varg7) == address(varg5);\n                }\n                if (v4) {\n                    v7 = v8 = !MEM[varg3 + 32];\n                    if (v8) {\n                        v7 = v9 = !MEM[varg2 + 32];\n                    }\n                    if (v7) {\n                        v10 = address(varg6);\n                        v11 = address(varg5);\n                        v12 = !map_6[varg4][5];\n                        v13 = v14 = map_6[varg4][5];\n                        if (map_6[varg4][5]) {\n                            v13 = v15 = map_6[varg4][5] < block.timestamp;\n                        }\n                        if (v13) {\n                            if (address(varg7) == address(varg6)) {\n                                v16 = v17 = 0;\n                            } else {\n                                v16 = v18 = 1;\n                            }\n                            assert(0xff & v16 < 2);\n                            if (!(STORAGE[6 + v19 + ((0xff & v16) >> 5)] / 256 ** (0xff & v16 & 0x1f) & 0xff)) {\n                                0x2dd7(_channels[v0][8], varg0, varg1, 0, varg2, varg3, varg4, varg5, varg6);\n                                v20 = map_6[varg4][0];\n                                v21 = map_6[varg4][1] + v20;\n                                require(v21 >= v20);\n                                if (v21 == MEM[varg3]) {\n                                    v22 = map_6[varg4][3] + STORAGE[0 + (v19 + 2)];\n                                    require(v22 >= STORAGE[0 + (v19 + 2)]);\n                                    if (v22 == MEM[varg2]) {\n                                        v23 = v24 = 9362;\n                                        v25 = v26 = map_6[varg4][1];\n                                        v27 = map_6[varg4][0];\n                                        require(v27 <= _channels[v0][2]);\n                                        v28 = v29 = _channels[v0][2] - v27;\n                                        while (v25 > v28) {\n                                            require(v25 <= v28);\n                                            _totalChannelToken = v28 - v25;\n                                            if (address(varg5) != address(varg7)) {\n                                                if (address(varg7) == address(varg6)) {\n                                                    v30 = map_6[varg4][2];\n                                                    v31 = address(varg7);\n                                                    require(_approvedToken.code.size);\n                                                    v32, v33 = _approvedToken.transfer(v31, v30).gas(msg.gas);\n                                                    require(v32); // checks call status, propagates error data on error\n                                                    MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                                                    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                                                    if (!v33) {\n                                                        goto 0x4540x21dc;\n                                                    }\n                                                }\n                                            } else {\n                                                v34 = map_6[varg4][3];\n                                                v35 = address(varg7);\n                                                require(_approvedToken.code.size);\n                                                v36, v37 = _approvedToken.transfer(v35, v34).gas(msg.gas);\n                                                require(v36); // checks call status, propagates error data on error\n                                                MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                                                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                                                if (!v37) {\n                                                    goto 0x4540x21dc;\n                                                }\n                                            }\n                                            if (address(varg7) == address(varg6)) {\n                                                v38 = v39 = 0;\n                                            } else {\n                                                v38 = v40 = 1;\n                                            }\n                                            assert(0xff & v38 < 2);\n                                            STORAGE[((0xff & v38) >> 5) + (6 + v19)] = 256 ** ((0xff & v38) % 32) | ~(255 * 256 ** ((0xff & v38) % 32)) & STORAGE[((0xff & v38) >> 5) + (6 + v19)];\n                                            require(1 <= _channels[v0][9]);\n                                            _channels[v0][9] = _channels[v0][9] - 1;\n                                            if (!(_channels[v0][9] - 1)) {\n                                                _channels[v0][8] = 0;\n                                                _channels[v0][11] = 0;\n                                                _channels[v0][12] = ~0xff & _channels[v0][0xc];\n                                            }\n                                            v41 = v42 = MEM[64];\n                                            MEM[32 + v42] = _channels[v0][1];\n                                            v43 = v44 = MEM[64];\n                                            MEM[64] = 64 + v44;\n                                            MEM[v44 + 32] = _channels[v0][4];\n                                            v45 = v46 = keccak256(v0, 5) + 6;\n                                            v47 = address(varg7);\n                                            v48 = v49 = MEM[64] + 96;\n                                            v50 = v51 = 0;\n                                            while (v50 < 2) {\n                                                MEM[v48] = MEM[v41];\n                                                v41 += 32;\n                                                v48 += 32;\n                                                v50 += 1;\n                                            }\n                                            v52 = v53 = MEM[64] + 160;\n                                            v54 = v55 = 0;\n                                            while (v54 < 2) {\n                                                MEM[v52] = MEM[v43];\n                                                v43 += 32;\n                                                v52 += 32;\n                                                v54 += 1;\n                                            }\n                                            v56 = v57 = MEM[64] + 224;\n                                            v58 = v59 = 0;\n                                            while (v58 < 2) {\n                                                MEM[v56] = STORAGE[v45];\n                                                v45 += 1;\n                                                v56 += 32;\n                                                v58 += 1;\n                                            }\n                                            emit DidEmptyThread(address(varg6), address(varg5), v47, varg4, msg.sender, STORAGE[0 + keccak256(v0, 5)], v60, _channels[v0][3], v60, v60, v60, _channels[v0][8], _channels[v0][9]);\n                                            _hubContractWithdraw = 0;\n                                            return ;\n                                            goto {'0x2590', '0x24b8', '0x24d1', '0x2492'};\n                                            _channels[v0][2] = v28 - v25;\n                                            v23 = v61 = 9400;\n                                            v25 = v62 = STORAGE[1 + (v19 + 2)];\n                                            require(STORAGE[0 + (v19 + 2)] <= STORAGE[2 + (keccak256(v0, 5) + 3)]);\n                                            v28 = v63 = STORAGE[2 + (keccak256(v0, 5) + 3)] - STORAGE[0 + (v19 + 2)];\n                                            goto 0xef80x21dc;\n                                            _channels[v0][5] = v28 - v25;\n                                            v25 = v64 = map_6[varg4][1];\n                                            v23 = v65 = 9425;\n                                            v66 = map_6[varg4][0];\n                                            require(v66 <= _totalChannelWei);\n                                            v28 = v67 = _totalChannelWei - v66;\n                                            goto 0xef80x21dc;\n                                            _totalChannelWei = v28 - v25;\n                                            if (address(varg5) != address(varg7)) {\n                                                if (address(varg7) == address(varg6)) {\n                                                    v68 = map_6[varg4];\n                                                    v69 = address(varg7).call().value(v68).gas(2300 * !v68);\n                                                    require(v69); // checks call status, propagates error data on error\n                                                }\n                                            } else {\n                                                v70 = map_6[varg4][1];\n                                                v71 = address(varg7).call().value(v70).gas(2300 * !v70);\n                                                require(v71); // checks call status, propagates error data on error\n                                            }\n                                            v25 = v72 = map_6[varg4][3];\n                                            v23 = v73 = 9616;\n                                            require(STORAGE[0 + (v19 + 2)] <= _totalChannelToken);\n                                            v28 = _totalChannelToken - STORAGE[0 + (v19 + 2)];\n                                            goto 0xef80x21dc;\n                                        }\n                                    } else {\n                                        goto 0x4540x21dc;\n                                    }\n                                } else {\n                                    goto 0x4540x21dc;\n                                }\n                            } else {\n                                goto 0x4540x21dc;\n                            }\n                        } else {\n                            goto 0x4540x21dc;\n                        }\n                    } else {\n                        goto 0x4540x21dc;\n                    }\n                } else {\n                    goto 0x4540x21dc;\n                }\n            } else {\n                goto 0x4540x21dc;\n            }\n        } else {\n            goto 0x4540x21dc;\n        }\n    }\n    revert('user [sender] token withdrawal transfer failed');\n}\n\nfunction hubAuthorizedUpdate(address varg0, address varg1, uint256[2] varg2, uint256[2] varg3, uint256[4] varg4, uint256[4] varg5) public nonPayable { \n    require(msg.data.length - 4 >= 640);\n    v0 = v1 = 68;\n    require(msg.data.length > v1 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = MEM[64];\n    require(!((v2 + 64 < v2) | (v2 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v2 + 64;\n    require(v1 + 64 <= msg.data.length);\n    v3 = v4 = 0;\n    while (v3 < 2) {\n        MEM[v2] = msg.data[v0];\n        v2 += 32;\n        v0 += 32;\n        v3 += 1;\n    }\n    v5 = v6 = 132;\n    require(msg.data.length > v6 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v7 = MEM[64];\n    require(!((v7 + 64 < v7) | (v7 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v7 + 64;\n    require(v6 + 64 <= msg.data.length);\n    v8 = v9 = 0;\n    while (v8 < 2) {\n        MEM[v7] = msg.data[v5];\n        v7 += 32;\n        v5 += 32;\n        v8 += 1;\n    }\n    v10 = v11 = 196;\n    require(msg.data.length > v11 + 31);\n    require(4 <= 0xffffffffffffffff);\n    v12 = MEM[64];\n    require(!((v12 + 128 < v12) | (v12 + 128 > 0xffffffffffffffff)));\n    MEM[64] = v12 + 128;\n    require(v11 + 128 <= msg.data.length);\n    v13 = v14 = 0;\n    while (v13 < 4) {\n        MEM[v12] = msg.data[v10];\n        v12 += 32;\n        v10 += 32;\n        v13 += 1;\n    }\n    v15 = v16 = 324;\n    require(msg.data.length > v16 + 31);\n    require(4 <= 0xffffffffffffffff);\n    v17 = MEM[64];\n    require(!((v17 + 128 < v17) | (v17 + 128 > 0xffffffffffffffff)));\n    MEM[64] = v17 + 128;\n    require(v16 + 128 <= msg.data.length);\n    v18 = v19 = 0;\n    while (v18 < 4) {\n        MEM[v17] = msg.data[v15];\n        v17 += 32;\n        v15 += 32;\n        v18 += 1;\n    }\n    v20 = v21 = 452;\n    require(msg.data.length > v21 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v22 = MEM[64];\n    require(!((v22 + 64 < v22) | (v22 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v22 + 64;\n    require(v21 + 64 <= msg.data.length);\n    v23 = v24 = 0;\n    while (v23 < 2) {\n        MEM[v22] = msg.data[v20];\n        v22 += 32;\n        v20 += 32;\n        v23 += 1;\n    }\n    require(varg5 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg5 + 31);\n    require(varg5.length <= 0xffffffffffffffff);\n    v25 = new bytes[](varg5.length);\n    require(!((v25 + ((~0x1f & 31 + varg5.length) + 32) < v25) | (v25 + ((~0x1f & 31 + varg5.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg5 + 32 + varg5.length <= msg.data.length);\n    CALLDATACOPY(v25.data, 4 + varg5 + 32, varg5.length);\n    MEM[varg5.length + v25.data] = 0;\n    v26 = 0x1159(v25, varg4, varg3, varg2, v22, v17, v12, v7, v2, varg1);\n}\n\nfunction startExitWithUpdate(address[2] varg0, uint256[2] varg1) public nonPayable { \n    v0 = v1 = 4;\n    require(msg.data.length - v1 >= 672);\n    require(msg.data.length > v1 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = MEM[64];\n    require(!((v2 + 64 < v2) | (v2 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v2 + 64;\n    require(v1 + 64 <= msg.data.length);\n    v3 = v4 = 0;\n    while (v3 < 2) {\n        MEM[v2] = address(msg.data[v0]);\n        v2 += 32;\n        v0 += 32;\n        v3 += 1;\n    }\n    v5 = v6 = v1 + 64;\n    require(msg.data.length > v6 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v7 = MEM[64];\n    require(!((v7 + 64 < v7) | (v7 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v7 + 64;\n    require(v6 + 64 <= msg.data.length);\n    v8 = v9 = 0;\n    while (v8 < 2) {\n        MEM[v7] = msg.data[v5];\n        v7 += 32;\n        v5 += 32;\n        v8 += 1;\n    }\n    v10 = v11 = v1 + 128;\n    require(msg.data.length > v11 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v12 = MEM[64];\n    require(!((v12 + 64 < v12) | (v12 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v12 + 64;\n    require(v11 + 64 <= msg.data.length);\n    v13 = v14 = 0;\n    while (v13 < 2) {\n        MEM[v12] = msg.data[v10];\n        v12 += 32;\n        v10 += 32;\n        v13 += 1;\n    }\n    v15 = v16 = v1 + 192;\n    require(msg.data.length > v16 + 31);\n    require(4 <= 0xffffffffffffffff);\n    v17 = MEM[64];\n    require(!((v17 + 128 < v17) | (v17 + 128 > 0xffffffffffffffff)));\n    MEM[64] = v17 + 128;\n    require(v16 + 128 <= msg.data.length);\n    v18 = v19 = 0;\n    while (v18 < 4) {\n        MEM[v17] = msg.data[v15];\n        v17 += 32;\n        v15 += 32;\n        v18 += 1;\n    }\n    v20 = v21 = v1 + 320;\n    require(msg.data.length > v21 + 31);\n    require(4 <= 0xffffffffffffffff);\n    v22 = MEM[64];\n    require(!((v22 + 128 < v22) | (v22 + 128 > 0xffffffffffffffff)));\n    MEM[64] = v22 + 128;\n    require(v21 + 128 <= msg.data.length);\n    v23 = v24 = 0;\n    while (v23 < 4) {\n        MEM[v22] = msg.data[v20];\n        v22 += 32;\n        v20 += 32;\n        v23 += 1;\n    }\n    v25 = v26 = v1 + 448;\n    require(msg.data.length > v26 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v27 = MEM[64];\n    require(!((v27 + 64 < v27) | (v27 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v27 + 64;\n    require(v26 + 64 <= msg.data.length);\n    v28 = v29 = 0;\n    while (v28 < 2) {\n        MEM[v27] = msg.data[v25];\n        v27 += 32;\n        v25 += 32;\n        v28 += 1;\n    }\n    require(msg.data[v1 + 608] <= 0xffffffffffffffff);\n    require(msg.data.length > v1 + msg.data[v1 + 608] + 31);\n    require(varg0.length <= 0xffffffffffffffff);\n    v30 = new bytes[](varg0.length);\n    require(!((v30 + ((~0x1f & 31 + varg0.length) + 32) < v30) | (v30 + ((~0x1f & 31 + varg0.length) + 32) > 0xffffffffffffffff)));\n    require(v1 + msg.data[v1 + 608] + 32 + varg0.length <= msg.data.length);\n    CALLDATACOPY(v30.data, v1 + msg.data[v1 + 608] + 32, varg0.length);\n    MEM[varg0.length + v30.data] = 0;\n    require(msg.data[v1 + 640] <= 0xffffffffffffffff);\n    require(msg.data.length > v1 + msg.data[v1 + 640] + 31);\n    require(varg1.length <= 0xffffffffffffffff);\n    v31 = new bytes[](varg1.length);\n    require(!((v31 + ((~0x1f & 31 + varg1.length) + 32) < v31) | (v31 + ((~0x1f & 31 + varg1.length) + 32) > 0xffffffffffffffff)));\n    require(v1 + msg.data[v1 + 640] + 32 + varg1.length <= msg.data.length);\n    CALLDATACOPY(v31.data, v1 + msg.data[v1 + 640] + 32, varg1.length);\n    MEM[varg1.length + v31.data] = 0;\n    0x1396(v31, v30, msg.data[v1 + 576], msg.data[v1 + 544], msg.data[v1 + 512], v27, v22, v17, v12, v7);\n}\n\nfunction startExit(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0x168c(varg0);\n}\n\nfunction 0x2880(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7) private { \n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        v0 = address(varg7);\n        assert(0xff & _channels[v0][0xc] <= 2);\n        if (0xff & _channels[v0][0xc] == 2) {\n            v1 = v2 = msg.sender == _hub;\n            if (msg.sender != _hub) {\n                v1 = v3 = address(varg7) == msg.sender;\n            }\n            if (v1) {\n                v4 = v5 = address(varg7) == address(varg6);\n                if (address(varg7) != address(varg6)) {\n                    v4 = v6 = address(varg7) == address(varg5);\n                }\n                if (v4) {\n                    v7 = v8 = !MEM[varg3 + 32];\n                    if (v8) {\n                        v7 = v9 = !MEM[varg2 + 32];\n                    }\n                    if (v7) {\n                        v10 = address(varg6);\n                        v11 = address(varg5);\n                        if (!map_6[varg4][5]) {\n                            0x2dd7(_channels[v0][8], varg0, varg1, 0, varg2, varg3, varg4, varg5, varg6);\n                            if (2) {\n                                while (varg3 + 64 > varg3) {\n                                    STORAGE[v12] = MEM[varg3];\n                                    varg3 += 32;\n                                    v12 += 1;\n                                }\n                            }\n                            while (v13 + 2 > v12) {\n                                STORAGE[v12] = 0;\n                                v12 += 1;\n                            }\n                            v14 = v15 = v13 + 2;\n                            if (2) {\n                                while (varg2 + 64 > varg2) {\n                                    STORAGE[v14] = MEM[varg2];\n                                    varg2 += 32;\n                                    v14 += 1;\n                                }\n                            }\n                            while (v15 + 2 > v14) {\n                                STORAGE[v14] = 0;\n                                v14 += 1;\n                            }\n                            require(_challengePeriod + block.timestamp >= block.timestamp);\n                            map_6[varg4][5] = _challengePeriod + block.timestamp;\n                            v16 = map_6[varg4][4];\n                            v17 = v18 = v13 + 2;\n                            v19 = address(varg7);\n                            v20 = v21 = MEM[64] + 96;\n                            v22 = v23 = 0;\n                            while (v22 < 2) {\n                                MEM[v20] = STORAGE[v12];\n                                v12 += 1;\n                                v20 += 32;\n                                v22 += 1;\n                            }\n                            v24 = v25 = MEM[64] + 160;\n                            v26 = v27 = 0;\n                            while (v26 < 2) {\n                                MEM[v24] = STORAGE[v17];\n                                v17 += 1;\n                                v24 += 32;\n                                v26 += 1;\n                            }\n                            emit DidStartExitThread(address(varg6), address(varg5), v19, varg4, msg.sender, v28, v28, v28, v28, v16);\n                            _hubContractWithdraw = 0;\n                            return ;\n                        } else {\n                            goto 0x4540x2880;\n                        }\n                    } else {\n                        goto 0x4540x2880;\n                    }\n                } else {\n                    goto 0x4540x2880;\n                }\n            } else {\n                goto 0x4540x2880;\n            }\n        } else {\n            goto 0x4540x2880;\n        }\n    }\n    revert('thread closing time must be zero');\n}\n\nfunction getChannelDetails(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    MEM[64] = MEM[64] + 416;\n    MEM[64] = MEM[64] + 96;\n    MEM[(MEM[64]) len 96] = this.code[this.code.size len 96];\n    MEM[MEM[64]] = MEM[64];\n    MEM[64] = MEM[64] + 96;\n    MEM[(MEM[64]) len 96] = this.code[this.code.size len 96];\n    MEM[32 + MEM[64]] = MEM[64];\n    MEM[(MEM[64]) len 64] = this.code[this.code.size len 64];\n    MEM[64 + MEM[64]] = MEM[64];\n    MEM[64 + MEM[64] + 32] = 0;\n    MEM[64 + MEM[64] + 64] = 0;\n    MEM[64 + MEM[64] + 96] = 0;\n    MEM[64 + MEM[64] + 128] = 0;\n    MEM[64 + MEM[64] + 160] = 0;\n    MEM[64] = MEM[64] + 352;\n    v0 = v1 = MEM[64] + 256;\n    do {\n        MEM[v0] = STORAGE[v2];\n        v0 += 32;\n        v2 += 1;\n    } while (v1 + 96 <= v0);\n    MEM[MEM[64]] = v1;\n    v3 = v4 = MEM[64];\n    v5 = v6 = 3 + v7;\n    do {\n        MEM[v3] = STORAGE[v5];\n        v3 += 32;\n        v5 += 1;\n    } while (v4 + 96 <= v3);\n    MEM[MEM[64] + 32] = v4;\n    v8 = v9 = MEM[64];\n    v10 = v11 = v7 + 6;\n    do {\n        MEM[v8] = STORAGE[v10];\n        v8 += 32;\n        v10 += 1;\n    } while (64 + v9 <= v8);\n    assert(0xff & _channels[varg0][0xc] <= 2);\n    assert(0xff & _channels[varg0][0xc] <= 2);\n    assert(0xff & _channels[varg0][0xc] < 3);\n    return MEM[v9], MEM[v9 + 32], _channels[varg0][8], _channels[varg0][9], address(_channels[address(varg0)][0xa]), _channels[varg0][11], 0xff & _channels[varg0][0xc];\n}\n\nfunction nukeThreads(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        if (_hub != varg0) {\n            if (this != varg0) {\n                v0 = varg0;\n                assert(0xff & _channels[v0][0xc] <= 2);\n                if (0xff & _channels[v0][0xc] == 2) {\n                    if (stor_1_0_0) {\n                        v1 = v2 = 10 * _challengePeriod;\n                        assert(stor_1_0_0);\n                        require(v2 / _challengePeriod == 10);\n                    } else {\n                        v1 = v3 = 0;\n                    }\n                    require(v1 + _channels[v0][11] >= _channels[v0][11]);\n                    if (v1 + _channels[v0][11] < block.timestamp) {\n                        require(_channels[v0][2] <= _totalChannelWei);\n                        _totalChannelWei = _totalChannelWei - _channels[v0][2];\n                        v4 = varg0.call().value(_channels[v0][2]).gas(2300 * !_channels[v0][2]);\n                        require(v4); // checks call status, propagates error data on error\n                        _channels[v0][2] = 0;\n                        require(STORAGE[2 + (keccak256(v0, 5) + 3)] <= _totalChannelToken);\n                        _totalChannelToken = _totalChannelToken - STORAGE[2 + (keccak256(v0, 5) + 3)];\n                        require(_approvedToken.code.size);\n                        v5, v6 = _approvedToken.transfer(varg0, _channels[v0][5]).gas(msg.gas);\n                        require(v5); // checks call status, propagates error data on error\n                        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        if (v6) {\n                            _channels[v0][5] = 0;\n                            _channels[v0][9] = 0;\n                            _channels[v0][8] = 0;\n                            _channels[v0][11] = 0;\n                            _channels[v0][12] = ~0xff & _channels[v0][0xc];\n                            v7 = v8 = MEM[64];\n                            MEM[64] = 64 + v8;\n                            MEM[v8 + 32] = _channels[v0][1];\n                            v9 = v10 = MEM[64];\n                            MEM[64] = 64 + v10;\n                            MEM[v10 + 32] = _channels[v0][4];\n                            v11 = v12 = keccak256(v0, 5) + 6;\n                            v13 = v14 = MEM[64] + 96;\n                            v15 = v16 = 0;\n                            while (v15 < 2) {\n                                MEM[v13] = MEM[v7];\n                                v7 += 32;\n                                v13 += 32;\n                                v15 += 1;\n                            }\n                            v17 = v18 = MEM[64] + 160;\n                            v19 = v20 = 0;\n                            while (v19 < 2) {\n                                MEM[v17] = MEM[v9];\n                                v9 += 32;\n                                v17 += 32;\n                                v19 += 1;\n                            }\n                            v21 = v22 = MEM[64] + 224;\n                            v23 = v24 = 0;\n                            while (v23 < 2) {\n                                MEM[v21] = STORAGE[v11];\n                                v11 += 1;\n                                v21 += 32;\n                                v23 += 1;\n                            }\n                            emit 0x2d2d0f262d032138bbd82feccd6d357a4441f394333cfa7d61792f44a70a0ed(varg0, msg.sender, _channels[v0][2], _channels[v0][5], _channels[v0], v25, _channels[v0][3], v25, v25, v25, 0, 0);\n                            _hubContractWithdraw = 0;\n                        } else {\n                            goto 0x4540x2cc;\n                        }\n                    } else {\n                        goto 0x4540x2cc;\n                    }\n                } else {\n                    goto 0x4540x2cc;\n                }\n            } else {\n                goto 0x4540x2cc;\n            }\n        } else {\n            goto 0x4540x2cc;\n        }\n    }\n    revert('user token withdrawal transfer failed');\n}\n\nfunction 0x2dd7(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8) private { \n    if (address(varg7) != address(varg8)) {\n        v0 = _hub == address(varg8);\n        v1 = v2 = _hub != address(varg8);\n        if (_hub != address(varg8)) {\n            v1 = v3 = _hub != address(varg7);\n        }\n        if (v1) {\n            v4 = this == address(varg8);\n            v5 = v6 = this != address(varg8);\n            if (this != address(varg8)) {\n                v5 = v7 = this != address(varg7);\n            }\n            if (v5) {\n                v8 = address(varg8);\n                v9 = address(varg7);\n                v10 = v11 = 0;\n                while (v10 < 64) {\n                    MEM[v10 + (124 + MEM[64])] = MEM[v10 + varg5];\n                    v10 += 32;\n                }\n                v12 = v13 = 0;\n                while (v12 < 64) {\n                    MEM[v12 + (188 + MEM[64])] = MEM[v12 + varg4];\n                    v12 += 32;\n                }\n                v14 = v15 = v15.data;\n                v16 = v17 = 252;\n                v18 = v19 = 32 + MEM[64];\n                while (v16 >= 32) {\n                    MEM[v14] = MEM[v18];\n                    v16 = v16 + ~31;\n                    v14 += 32;\n                    v18 += 32;\n                }\n                MEM[v14] = MEM[v14] & ~0 + 256 ** (32 - v16) | MEM[v18] & ~(~0 + 256 ** (32 - v16));\n                v20 = v21 = keccak256(address(this), v8, v9, varg6, varg3);\n                MEM[v15.data] = 0x1052506f00000000000000000000000000000000000000000000000000000000;\n                v22 = new array[](varg1.length);\n                MEM[4 + v15.data] = v21;\n                MEM[4 + v15.data + 32] = 96;\n                v23 = v24 = 0;\n                while (v23 < varg1.length) {\n                    MEM[v23 + v22.data] = MEM[v23 + varg1.data];\n                    v23 += 32;\n                }\n                if (v23 > varg1.length) {\n                    MEM[v22.data + varg1.length] = 0;\n                }\n                v25 = address(varg8);\n                MEM[4 + v15.data + 64] = v25;\n                require(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.code.size);\n                v26, v27 = 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(v21, v22, v25).gas(msg.gas);\n                require(v26); // checks call status, propagates error data on error\n                MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                if (v27) {\n                    if (varg0) {\n                        v28 = v29 = 64;\n                        while (v28 <= varg2.length) {\n                            v30 = MEM[v28 + varg2];\n                            if (v20 >= v30) {\n                                MEM[MEM[64] + 32] = v30;\n                                MEM[64 + MEM[64]] = v20;\n                                v31 = v32 = MEM[64] + 96;\n                                v33 = v34 = 64;\n                                v35 = v36 = MEM[64] + 32;\n                                while (v33 >= 32) {\n                                    MEM[v31] = MEM[v35];\n                                    v33 = v33 + ~31;\n                                    v31 += 32;\n                                    v35 += 32;\n                                }\n                                MEM[v31] = MEM[v35] & ~(256 ** (32 - v33) - 1) | MEM[v31] & 256 ** (32 - v33) - 1;\n                                v20 = v37 = keccak256(v38.data);\n                            } else {\n                                MEM[MEM[64] + 32] = v20;\n                                MEM[64 + MEM[64]] = v30;\n                                v39 = v40 = MEM[64] + 96;\n                                v41 = v42 = 64;\n                                v43 = v44 = MEM[64] + 32;\n                                while (v41 >= 32) {\n                                    MEM[v39] = MEM[v43];\n                                    v41 = v41 + ~31;\n                                    v39 += 32;\n                                    v43 += 32;\n                                }\n                                MEM[v39] = MEM[v43] & ~(256 ** (32 - v41) - 1) | MEM[v39] & 256 ** (32 - v41) - 1;\n                                v20 = v45 = keccak256(v46.data);\n                            }\n                            v28 += 32;\n                        }\n                        if (v20 != varg0) {\n                            goto 0x4540x2dd7;\n                        }\n                    }\n                    return ;\n                } else {\n                    goto 0x4540x2dd7;\n                }\n            } else {\n                goto 0x4540x2dd7;\n            }\n        } else {\n            goto 0x4540x2dd7;\n        }\n    }\n    revert('initial thread state is not contained in threadRoot');\n}\n\nfunction channels(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    assert(0xff & _channels[varg0][0xc] < 3);\n    return _channels[varg0][8], _channels[varg0][9], address(_channels[varg0][0xa]), _channels[varg0][11], 0xff & _channels[varg0][0xc];\n}\n\nfunction getHubReserveTokens() public nonPayable { \n    v0 = 0x1cc9();\n    return v0;\n}\n\nfunction 0x331d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12) private { \n    v0 = STORAGE[2 + v1];\n    require(MEM[(varg0 << 5) + varg1] + v0 >= v0);\n    return MEM[(varg0 << 5) + varg1] + v0, varg3, varg4, varg5, varg6, varg7, varg8, varg9, varg10, varg11, varg12;\n}\n\nfunction emptyChannelWithChallenge(address[2] varg0, uint256[2] varg1) public nonPayable { \n    v0 = v1 = 4;\n    require(msg.data.length - v1 >= 672);\n    require(msg.data.length > v1 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = MEM[64];\n    require(!((v2 + 64 < v2) | (v2 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v2 + 64;\n    require(v1 + 64 <= msg.data.length);\n    v3 = v4 = 0;\n    while (v3 < 2) {\n        MEM[v2] = address(msg.data[v0]);\n        v2 += 32;\n        v0 += 32;\n        v3 += 1;\n    }\n    v5 = v6 = v1 + 64;\n    require(msg.data.length > v6 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v7 = MEM[64];\n    require(!((v7 + 64 < v7) | (v7 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v7 + 64;\n    require(v6 + 64 <= msg.data.length);\n    v8 = v9 = 0;\n    while (v8 < 2) {\n        MEM[v7] = msg.data[v5];\n        v7 += 32;\n        v5 += 32;\n        v8 += 1;\n    }\n    v10 = v11 = v1 + 128;\n    require(msg.data.length > v11 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v12 = MEM[64];\n    require(!((v12 + 64 < v12) | (v12 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v12 + 64;\n    require(v11 + 64 <= msg.data.length);\n    v13 = v14 = 0;\n    while (v13 < 2) {\n        MEM[v12] = msg.data[v10];\n        v12 += 32;\n        v10 += 32;\n        v13 += 1;\n    }\n    v15 = v16 = v1 + 192;\n    require(msg.data.length > v16 + 31);\n    require(4 <= 0xffffffffffffffff);\n    v17 = MEM[64];\n    require(!((v17 + 128 < v17) | (v17 + 128 > 0xffffffffffffffff)));\n    MEM[64] = v17 + 128;\n    require(v16 + 128 <= msg.data.length);\n    v18 = v19 = 0;\n    while (v18 < 4) {\n        MEM[v17] = msg.data[v15];\n        v17 += 32;\n        v15 += 32;\n        v18 += 1;\n    }\n    v20 = v21 = v1 + 320;\n    require(msg.data.length > v21 + 31);\n    require(4 <= 0xffffffffffffffff);\n    v22 = MEM[64];\n    require(!((v22 + 128 < v22) | (v22 + 128 > 0xffffffffffffffff)));\n    MEM[64] = v22 + 128;\n    require(v21 + 128 <= msg.data.length);\n    v23 = v24 = 0;\n    while (v23 < 4) {\n        MEM[v22] = msg.data[v20];\n        v22 += 32;\n        v20 += 32;\n        v23 += 1;\n    }\n    v25 = v26 = v1 + 448;\n    require(msg.data.length > v26 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v27 = MEM[64];\n    require(!((v27 + 64 < v27) | (v27 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v27 + 64;\n    require(v26 + 64 <= msg.data.length);\n    v28 = v29 = 0;\n    while (v28 < 2) {\n        MEM[v27] = msg.data[v25];\n        v27 += 32;\n        v25 += 32;\n        v28 += 1;\n    }\n    require(msg.data[v1 + 608] <= 0xffffffffffffffff);\n    require(msg.data.length > v1 + msg.data[v1 + 608] + 31);\n    require(varg0.length <= 0xffffffffffffffff);\n    v30 = new bytes[](varg0.length);\n    require(!((v30 + ((~0x1f & 31 + varg0.length) + 32) < v30) | (v30 + ((~0x1f & 31 + varg0.length) + 32) > 0xffffffffffffffff)));\n    require(v1 + msg.data[v1 + 608] + 32 + varg0.length <= msg.data.length);\n    CALLDATACOPY(v30.data, v1 + msg.data[v1 + 608] + 32, varg0.length);\n    MEM[varg0.length + v30.data] = 0;\n    require(msg.data[v1 + 640] <= 0xffffffffffffffff);\n    require(msg.data.length > v1 + msg.data[v1 + 640] + 31);\n    require(varg1.length <= 0xffffffffffffffff);\n    v31 = new bytes[](varg1.length);\n    require(!((v31 + ((~0x1f & 31 + varg1.length) + 32) < v31) | (v31 + ((~0x1f & 31 + varg1.length) + 32) > 0xffffffffffffffff)));\n    require(v1 + msg.data[v1 + 640] + 32 + varg1.length <= msg.data.length);\n    CALLDATACOPY(v31.data, v1 + msg.data[v1 + 640] + 32, varg1.length);\n    MEM[varg1.length + v31.data] = 0;\n    v32, v33, v34, v35, v36 = 0x1d5c(v31, v30, msg.data[v1 + 576], msg.data[v1 + 544], msg.data[v1 + 512], v27, v22, v17, v12, v7);\n}\n\nfunction 0x337d(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11, uint256 varg12) private { \n    require(MEM[(varg0 << 5) + varg1] + STORAGE[2 + (v0 + 3)] >= STORAGE[2 + (v0 + 3)]);\n    return MEM[(varg0 << 5) + varg1] + STORAGE[2 + (v0 + 3)], varg3, varg4, varg5, varg6, varg7, varg8, varg9, varg10, varg11, varg12;\n}\n\nfunction 0x33b8(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9, uint256 varg10, uint256 varg11) private { \n    if (_hub != address(MEM[varg11])) {\n        if (this != address(MEM[varg11])) {\n            v0 = v1 = 0;\n            while (v0 < 64) {\n                MEM[v0 + (52 + MEM[64])] = MEM[v0 + varg11];\n                v0 += 32;\n            }\n            v2 = v3 = 0;\n            while (v2 < 64) {\n                MEM[v2 + (116 + MEM[64])] = MEM[v2 + varg10];\n                v2 += 32;\n            }\n            v4 = v5 = 0;\n            while (v4 < 64) {\n                MEM[v4 + (180 + MEM[64])] = MEM[v4 + varg9];\n                v4 += 32;\n            }\n            v6 = v7 = 0;\n            while (v6 < 128) {\n                MEM[v6 + (244 + MEM[64])] = MEM[v6 + varg8];\n                v6 += 32;\n            }\n            v8 = v9 = 0;\n            while (v8 < 128) {\n                MEM[v8 + (372 + MEM[64])] = MEM[v8 + varg7];\n                v8 += 32;\n            }\n            v10 = v11 = 0;\n            while (v10 < 64) {\n                MEM[v10 + (500 + MEM[64])] = MEM[v10 + varg6];\n                v10 += 32;\n            }\n            v12 = ~0x0 & (~0x0 & varg5);\n            v13 = v14 = v14.data;\n            v15 = v16 = 628;\n            v17 = v18 = 32 + MEM[64];\n            while (v15 >= 32) {\n                MEM[v13] = MEM[v17];\n                v15 = v15 + ~31;\n                v13 += 32;\n                v17 += 32;\n            }\n            MEM[v13] = MEM[v13] & ~0 + 256 ** (32 - v15) | MEM[v17] & ~(~0 + 256 ** (32 - v15));\n            v19 = keccak256(address(this) << 96, v12, varg4, varg3);\n            if (MEM[0 + varg0]) {\n                v20 = new array[](varg2.length);\n                v21 = v22 = 0;\n                while (v21 < varg2.length) {\n                    MEM[v21 + v20.data] = MEM[v21 + varg2.data];\n                    v21 += 32;\n                }\n                if (v21 > varg2.length) {\n                    MEM[v20.data + varg2.length] = 0;\n                }\n                require(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.code.size);\n                v23, v24 = 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.recoverSigner(v19, v20).gas(msg.gas);\n                require(v23); // checks call status, propagates error data on error\n                MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                if (address(v24) != _hub) {\n                    goto 0x4540x33b8;\n                }\n            }\n            if (MEM[varg0.data]) {\n                v25 = new array[](varg1.length);\n                v26 = v27 = 0;\n                while (v26 < varg1.length) {\n                    MEM[v26 + v25.data] = MEM[v26 + varg1.data];\n                    v26 += 32;\n                }\n                if (v26 > varg1.length) {\n                    MEM[v25.data + varg1.length] = 0;\n                }\n                require(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.code.size);\n                v28, v29 = 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.recoverSigner(v19, v25).gas(msg.gas);\n                require(v28); // checks call status, propagates error data on error\n                MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                if (address(v29) != address(MEM[varg11])) {\n                    goto 0x4540x33b8;\n                }\n            }\n            return ;\n        } else {\n            goto 0x4540x33b8;\n        }\n    }\n    revert('user signature invalid');\n}\n\nfunction NAME() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (v2 > v1.length) {\n        MEM[v0.data + v1.length] = 0;\n    }\n    return v0, v4, 'Channel Manager';\n}\n\nfunction getHubReserveWei() public nonPayable { \n    v0 = 0x21c4();\n    return v0;\n}\n\nfunction emptyThread(address varg0, address varg1, address varg2, uint256 varg3, uint256[2] varg4, uint256[2] varg5) public nonPayable { \n    require(msg.data.length - 4 >= 320);\n    v0 = v1 = 132;\n    require(msg.data.length > v1 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = MEM[64];\n    require(!((v2 + 64 < v2) | (v2 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v2 + 64;\n    require(v1 + 64 <= msg.data.length);\n    v3 = v4 = 0;\n    while (v3 < 2) {\n        MEM[v2] = msg.data[v0];\n        v2 += 32;\n        v0 += 32;\n        v3 += 1;\n    }\n    v5 = v6 = 196;\n    require(msg.data.length > v6 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v7 = MEM[64];\n    require(!((v7 + 64 < v7) | (v7 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v7 + 64;\n    require(v6 + 64 <= msg.data.length);\n    v8 = v9 = 0;\n    while (v8 < 2) {\n        MEM[v7] = msg.data[v5];\n        v7 += 32;\n        v5 += 32;\n        v8 += 1;\n    }\n    require(varg4 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg4 + 31);\n    require(varg4.length <= 0xffffffffffffffff);\n    v10 = new bytes[](varg4.length);\n    require(!((v10 + ((~0x1f & 31 + varg4.length) + 32) < v10) | (v10 + ((~0x1f & 31 + varg4.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg4 + 32 + varg4.length <= msg.data.length);\n    CALLDATACOPY(v10.data, 4 + varg4 + 32, varg4.length);\n    MEM[varg4.length + v10.data] = 0;\n    require(varg5 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg5 + 31);\n    require(varg5.length <= 0xffffffffffffffff);\n    v11 = new bytes[](varg5.length);\n    require(!((v11 + ((~0x1f & 31 + varg5.length) + 32) < v11) | (v11 + ((~0x1f & 31 + varg5.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg5 + 32 + varg5.length <= msg.data.length);\n    CALLDATACOPY(v11.data, 4 + varg5 + 32, varg5.length);\n    MEM[varg5.length + v11.data] = 0;\n    0x21dc(v11, v10, v7, v2, varg3, varg2, varg1, varg0);\n}\n\nfunction approvedToken() public nonPayable { \n    return _approvedToken;\n}\n\nfunction startExitThread(address varg0, address varg1, address varg2, uint256 varg3, uint256[2] varg4, uint256[2] varg5) public nonPayable { \n    require(msg.data.length - 4 >= 320);\n    v0 = v1 = 132;\n    require(msg.data.length > v1 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = MEM[64];\n    require(!((v2 + 64 < v2) | (v2 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v2 + 64;\n    require(v1 + 64 <= msg.data.length);\n    v3 = v4 = 0;\n    while (v3 < 2) {\n        MEM[v2] = msg.data[v0];\n        v2 += 32;\n        v0 += 32;\n        v3 += 1;\n    }\n    v5 = v6 = 196;\n    require(msg.data.length > v6 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v7 = MEM[64];\n    require(!((v7 + 64 < v7) | (v7 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v7 + 64;\n    require(v6 + 64 <= msg.data.length);\n    v8 = v9 = 0;\n    while (v8 < 2) {\n        MEM[v7] = msg.data[v5];\n        v7 += 32;\n        v5 += 32;\n        v8 += 1;\n    }\n    require(varg4 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg4 + 31);\n    require(varg4.length <= 0xffffffffffffffff);\n    v10 = new bytes[](varg4.length);\n    require(!((v10 + ((~0x1f & 31 + varg4.length) + 32) < v10) | (v10 + ((~0x1f & 31 + varg4.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg4 + 32 + varg4.length <= msg.data.length);\n    CALLDATACOPY(v10.data, 4 + varg4 + 32, varg4.length);\n    MEM[varg4.length + v10.data] = 0;\n    require(varg5 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg5 + 31);\n    require(varg5.length <= 0xffffffffffffffff);\n    v11 = new bytes[](varg5.length);\n    require(!((v11 + ((~0x1f & 31 + varg5.length) + 32) < v11) | (v11 + ((~0x1f & 31 + varg5.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg5 + 32 + varg5.length <= msg.data.length);\n    CALLDATACOPY(v11.data, 4 + varg5 + 32, varg5.length);\n    MEM[varg5.length + v11.data] = 0;\n    0x2880(v11, v10, v7, v2, varg3, varg2, varg1, varg0);\n}\n\nfunction userAuthorizedUpdate(address varg0, uint256[2] varg1, uint256[2] varg2, uint256[4] varg3, uint256[4] varg4) public payable { \n    require(msg.data.length - 4 >= 608);\n    v0 = v1 = 36;\n    require(msg.data.length > v1 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = v3 = MEM[64];\n    require(!((v3 + 64 < v3) | (v3 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v3 + 64;\n    require(v1 + 64 <= msg.data.length);\n    v4 = v5 = 0;\n    while (v4 < 2) {\n        MEM[v2] = msg.data[v0];\n        v2 += 32;\n        v0 += 32;\n        v4 += 1;\n    }\n    v6 = v7 = 100;\n    require(msg.data.length > v7 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = v8 = MEM[64];\n    require(!((v8 + 64 < v8) | (v8 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v8 + 64;\n    require(v7 + 64 <= msg.data.length);\n    v9 = v10 = 0;\n    while (v9 < 2) {\n        MEM[v2] = msg.data[v6];\n        v2 += 32;\n        v6 += 32;\n        v9 += 1;\n    }\n    v11 = v12 = 164;\n    require(msg.data.length > v12 + 31);\n    require(4 <= 0xffffffffffffffff);\n    v2 = v13 = MEM[64];\n    require(!((v13 + 128 < v13) | (v13 + 128 > 0xffffffffffffffff)));\n    MEM[64] = v13 + 128;\n    require(v12 + 128 <= msg.data.length);\n    v14 = v15 = 0;\n    while (v14 < 4) {\n        MEM[v2] = msg.data[v11];\n        v2 += 32;\n        v11 += 32;\n        v14 += 1;\n    }\n    v16 = v17 = 292;\n    require(msg.data.length > v17 + 31);\n    require(4 <= 0xffffffffffffffff);\n    v2 = v18 = MEM[64];\n    require(!((v18 + 128 < v18) | (v18 + 128 > 0xffffffffffffffff)));\n    MEM[64] = v18 + 128;\n    require(v17 + 128 <= msg.data.length);\n    v19 = v20 = 0;\n    while (v19 < 4) {\n        MEM[v2] = msg.data[v16];\n        v2 += 32;\n        v16 += 32;\n        v19 += 1;\n    }\n    v21 = v22 = 420;\n    require(msg.data.length > v22 + 31);\n    require(2 <= 0xffffffffffffffff);\n    v2 = MEM[64];\n    require(!((v2 + 64 < v2) | (v2 + 64 > 0xffffffffffffffff)));\n    MEM[64] = v2 + 64;\n    require(v22 + 64 <= msg.data.length);\n    v23 = v24 = 0;\n    while (v23 < 2) {\n        MEM[v2] = msg.data[v21];\n        v2 += 32;\n        v21 += 32;\n        v23 += 1;\n    }\n    require(varg4 <= 0xffffffffffffffff);\n    require(msg.data.length > 4 + varg4 + 31);\n    require(varg4.length <= 0xffffffffffffffff);\n    v25 = new bytes[](varg4.length);\n    require(!((v25 + ((~0x1f & 31 + varg4.length) + 32) < v25) | (v25 + ((~0x1f & 31 + varg4.length) + 32) > 0xffffffffffffffff)));\n    require(4 + varg4 + 32 + varg4.length <= msg.data.length);\n    CALLDATACOPY(v25.data, 4 + varg4 + 32, varg4.length);\n    MEM[varg4.length + v25.data] = 0;\n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        if (msg.value == MEM[64 + v13]) {\n            v2 = v26 = 11078;\n            v2 = v27 = 0;\n            assert(0xff & _channels[msg.sender][0xc] <= 2);\n            if (0xff & _channels[msg.sender][0xc] == 0) {\n                v28 = v29 = !varg3;\n                if (varg3) {\n                    v28 = block.timestamp < varg3;\n                }\n                if (v28) {\n                    if (MEM[v2] > _channels[msg.sender][6]) {\n                        if (MEM[v2 + 32] >= _channels[msg.sender][7]) {\n                            require(MEM[32 + v3] + MEM[0 + v3] >= MEM[0 + v3]);\n                            if (MEM[32 + v3] + MEM[0 + v3] <= _channels[msg.sender][2]) {\n                                require(MEM[32 + v8] + MEM[0 + v8] >= MEM[0 + v8]);\n                                if (MEM[32 + v8] + MEM[0 + v8] <= _channels[msg.sender][5]) {\n                                    if (!v27) {\n                                        v30 = 0x21c4();\n                                        if (MEM[v13] <= v30) {\n                                            v31 = 0x1cc9();\n                                            if (MEM[v18] > v31) {\n                                                goto 0x4540x30f4B0x2b0e;\n                                            }\n                                        } else {\n                                            goto 0x4540x30f4B0x2b0e;\n                                        }\n                                    } else {\n                                        v32 = 0x21c4();\n                                        require(MEM[v13 + 64] + MEM[0 + v13] >= MEM[0 + v13]);\n                                        if (MEM[v13 + 64] + MEM[0 + v13] <= v32) {\n                                            v33 = 0x1cc9();\n                                            require(MEM[v18 + 64] + MEM[0 + v18] >= MEM[0 + v18]);\n                                            if (MEM[v18 + 64] + MEM[0 + v18] > v33) {\n                                                goto 0x4540x30f4B0x2b0e;\n                                            }\n                                        } else {\n                                            goto 0x4540x30f4B0x2b0e;\n                                        }\n                                    }\n                                    v2 = v34 = MEM[v13 + 96];\n                                    v2 = v35 = MEM[v13 + 32];\n                                    v2 = v36 = 13069;\n                                    v2 = v37 = 13057;\n                                    v2 = v38 = MEM[v3 + 32] + MEM[0 + v3];\n                                    require(v38 >= MEM[0 + v3]);\n                                    while (1) {\n                                        v2 += v2;\n                                        if (v2 >= v2) {\n                                            break;\n                                        }\n                                        require(v2 >= v2);\n                                        goto {'0x330dB0x2b0e', '0x336dB0x2b0e', '0x33010x30f4B0x2b0e'};\n                                        v2 = v39 = MEM[v2 + 64];\n                                        v2 = v40 = 13098;\n                                        v2 = v41 = 13057;\n                                        v2 = v42 = MEM[0 + v2];\n                                        v43 = v44 = 2;\n                                        v2 = v45 = STORAGE[v43 + v2];\n                                        v2 += v2;\n                                        if (v2 >= v2) {\n                                            break;\n                                        }\n                                        require(v2 >= v2);\n                                        if (v2 >= v2) {\n                                            MEM[MEM[64]] = msg.sender;\n                                            MEM[MEM[64] + 32] = address(v3);\n                                            MEM[MEM[64]] = 0;\n                                            0x33b8(0, MEM[64], v46, v25, varg3, varg2, varg1, v2, v18, v13, v8, MEM[64]);\n                                            require(_approvedToken.code.size);\n                                            v47, v48 = _approvedToken.transferFrom(msg.sender, address(this), varg4.length).gas(msg.gas);\n                                            require(v47); // checks call status, propagates error data on error\n                                            MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                                            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                                            if (v48) {\n                                                if (MEM[v18] <= MEM[v18 + 32]) {\n                                                    stor_2b46 = MEM[v8];\n                                                } else {\n                                                    require(MEM[32 + v18] <= MEM[0 + v18]);\n                                                    require(MEM[0 + v18] - MEM[32 + v18] + MEM[0 + v8] >= MEM[0 + v8]);\n                                                    stor_2b46 = MEM[0 + v18] - MEM[32 + v18] + MEM[0 + v8];\n                                                }\n                                                if (MEM[v18 + 64] <= MEM[v18 + 96]) {\n                                                    stor_2b47 = MEM[v8 + 32];\n                                                } else {\n                                                    require(MEM[96 + v18] <= MEM[64 + v18]);\n                                                    require(MEM[64 + v18] - MEM[96 + v18] + MEM[32 + v8] >= MEM[32 + v8]);\n                                                    stor_2b47 = MEM[64 + v18] - MEM[96 + v18] + MEM[32 + v8];\n                                                }\n                                                if (MEM[v2] <= MEM[v2 + 32]) {\n                                                    stor_2b49 = MEM[v13];\n                                                } else {\n                                                    require(MEM[32 + v2] <= MEM[0 + v2]);\n                                                    require(MEM[0 + v2] - MEM[32 + v2] + MEM[0 + v13] >= MEM[0 + v13]);\n                                                    stor_2b49 = MEM[0 + v2] - MEM[32 + v2] + MEM[0 + v13];\n                                                }\n                                                if (varg4.length <= MEM[v25.data]) {\n                                                    stor_2b4a = MEM[v13 + 32];\n                                                } else {\n                                                    require(MEM[v25.data] <= varg4.length);\n                                                    require(varg4.length - MEM[v25.data] + MEM[32 + v13] >= MEM[32 + v13]);\n                                                    stor_2b4a = varg4.length - MEM[v25.data] + MEM[32 + v13];\n                                                }\n                                                v2 = v49 = MEM[v18 + 96];\n                                                v2 = v50 = MEM[v18 + 32];\n                                                v51 = v52 = MEM[v18 + 64];\n                                                v2 = v53 = 14276;\n                                                v2 = v54 = 3832;\n                                                v55 = v56 = MEM[v18] + _totalChannelWei;\n                                                require(v56 >= _totalChannelWei);\n                                                while (1) {\n                                                    v57 = v51 + v55;\n                                                    if (v57 >= v55) {\n                                                        break;\n                                                    }\n                                                    require(v57 >= v55);\n                                                    while (v2 > v57) {\n                                                        require(v2 <= v57);\n                                                        STORAGE[2 + (v2 + 3)] = v57;\n                                                        v58 = address(v13).call().value(MEM[varg1 + 96]).gas(2300 * !MEM[varg1 + 96]);\n                                                        require(v58); // checks call status, propagates error data on error\n                                                        require(_approvedToken.code.size);\n                                                        v59, v60 = _approvedToken.transfer(address(v13), MEM[varg2 + 96]).gas(msg.gas);\n                                                        require(v59); // checks call status, propagates error data on error\n                                                        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                                                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                                                        if (v60) {\n                                                            v61 = v62 = v2 + 6;\n                                                            if (2) {\n                                                                while (varg3 + 64 > v2) {\n                                                                    STORAGE[v61] = MEM[v2];\n                                                                    v2 += 32;\n                                                                    v61 += 1;\n                                                                }\n                                                            }\n                                                            while (v62 + 2 > v61) {\n                                                                STORAGE[v61] = 0;\n                                                                v61 += 1;\n                                                            }\n                                                            STORAGE[v2 + 8] = v25;\n                                                            STORAGE[v2 + 9] = v46;\n                                                            v63 = v64 = v2 + 6;\n                                                            v65 = v66 = MEM[64] + 32;\n                                                            v67 = v68 = 0;\n                                                            while (v67 < 2) {\n                                                                MEM[v65] = MEM[v2];\n                                                                v2 += 32;\n                                                                v65 += 32;\n                                                                v67 += 1;\n                                                            }\n                                                            v69 = v70 = MEM[64] + 96;\n                                                            v71 = v72 = 0;\n                                                            while (v71 < 2) {\n                                                                MEM[v69] = MEM[v2];\n                                                                v2 += 32;\n                                                                v69 += 32;\n                                                                v71 += 1;\n                                                            }\n                                                            v73 = v74 = MEM[64] + 160;\n                                                            v75 = v76 = 0;\n                                                            while (v75 < 4) {\n                                                                MEM[v73] = MEM[v77];\n                                                                v77 += 32;\n                                                                v73 += 32;\n                                                                v75 += 1;\n                                                            }\n                                                            v78 = v79 = MEM[64] + 288;\n                                                            v80 = v81 = 0;\n                                                            while (v80 < 4) {\n                                                                MEM[v78] = MEM[v82];\n                                                                v82 += 32;\n                                                                v78 += 32;\n                                                                v80 += 1;\n                                                            }\n                                                            v83 = v84 = MEM[64] + 416;\n                                                            v85 = v86 = 0;\n                                                            while (v85 < 2) {\n                                                                MEM[v83] = STORAGE[v63];\n                                                                v63 += 1;\n                                                                v83 += 32;\n                                                                v85 += 1;\n                                                            }\n                                                            emit DidUpdateChannel(msg.sender, 1, v87, v87, v87, v87, v87, v87, v87, v87, v87, v87, v87, v87, v87, v87, v25, v46);\n                                                            _hubContractWithdraw = 0;\n                                                        } else {\n                                                            goto 0x4540x3eb;\n                                                        }\n                                                        v57 = v57 - v2;\n                                                        goto {'0xef80x3781B0x2c4d', '0x37f1B0x2c4d', '0x3819B0x2c4d', '0x37c4B0x2c4d', '0x3843B0x2c4d'};\n                                                    }\n                                                    _totalChannelWei = v57;\n                                                    v2 = v88 = MEM[v2 + 96];\n                                                    v2 = v89 = MEM[v2 + 32];\n                                                    v51 = v90 = MEM[v2 + 64];\n                                                    v2 = v91 = 14321;\n                                                    v2 = v92 = 3832;\n                                                    v55 = MEM[v2] + _totalChannelToken;\n                                                    require(v55 >= _totalChannelToken);\n                                                    goto 0x33010x3781B0x2c4d;\n                                                    _totalChannelToken = v57;\n                                                    v55 = v93, v51 = v94, v2 = v95, v2 = v96, v2 = v97, v2 = v98, v2 = v99, v2, v2, v2, v2, v2 = v100 = 0x331d(0, v2, 13057, MEM[v2 + 64], 3832, MEM[v2 + 32], 3832, MEM[v2 + 96], 14361, v2, v2, v2, v2);\n                                                    STORAGE[v2 + 2] = v57;\n                                                    v55 = v101, v51 = v102, v2 = v103, v2 = v104, v2 = v105, v2 = v106, v2 = v107, v2, v2, v2, v2, v2 = v108 = 0x337d(0, v2, 13057, MEM[v2 + 64], 3832, MEM[v2 + 32], 3832, MEM[v2 + 96], 14403, v2, v2, v2, v2);\n                                                }\n                                            } else {\n                                                goto 0x4540x3eb;\n                                            }\n                                        } else {\n                                            goto 0x4540x30f4B0x2b0e;\n                                        }\n                                        goto {'0x338dB0x2b0e', '0x332aB0x2b0e', '0x33010x30f4B0x2b0e'};\n                                        if (v2 >= v2) {\n                                            v2 = v109 = MEM[v2 + 96];\n                                            v2 = v110 = MEM[v2 + 32];\n                                            v2 = v111 = 13165;\n                                            v2 = v112 = 13057;\n                                            v113 = MEM[0 + v2];\n                                            v2 = v114 = MEM[v2 + 32] + v113;\n                                            require(v114 >= v113);\n                                            goto 0x33010x30f4B0x2b0e;\n                                        } else {\n                                            goto 0x4540x30f4B0x2b0e;\n                                        }\n                                        v2 = v115 = MEM[v2 + 64];\n                                        v2 = v116 = 13197;\n                                        v2 = v117 = 13057;\n                                        v2 = v118 = MEM[0 + v2];\n                                        v2 = v119 = v2 + 3;\n                                        v43 = v120 = 2;\n                                        goto 0xaae0x30f4B0x2b0e;\n                                    }\n                                } else {\n                                    goto 0x4540x30f4B0x2b0e;\n                                }\n                            } else {\n                                goto 0x4540x30f4B0x2b0e;\n                            }\n                        } else {\n                            goto 0x4540x30f4B0x2b0e;\n                        }\n                    } else {\n                        goto 0x4540x30f4B0x2b0e;\n                    }\n                } else {\n                    goto 0x4540x30f4B0x2b0e;\n                }\n            }\n            revert('insufficient token');\n        } else {\n            goto 0x4540x3eb;\n        }\n    }\n    revert('user token withdrawal transfer failed');\n}\n\nfunction challengePeriod() public nonPayable { \n    return _challengePeriod;\n}\n\nfunction VERSION() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (v2 > v1.length) {\n        MEM[v0.data + v1.length] = 0;\n    }\n    return v0, v4, '0.0.1';\n}\n\nfunction 0xd8f() private { \n    if (!_hubContractWithdraw) {\n        _hubContractWithdraw = 1;\n        if (_hub != address(v0)) {\n            if (this != address(v0)) {\n                v1 = address(v0);\n                assert(0xff & _channels[v1][0xc] <= 2);\n                if (0xff & _channels[v1][0xc] == 1) {\n                    v2 = v3 = _channels[v1][11] < block.timestamp;\n                    if (_channels[v1][11] >= block.timestamp) {\n                        v2 = v4 = msg.sender != address(_channels[v1][0xa]);\n                        if (msg.sender != address(_channels[v1][0xa])) {\n                            v2 = v5 = msg.sender == _hub;\n                            if (msg.sender != _hub) {\n                                v2 = v6 = address(v0) == msg.sender;\n                            }\n                        }\n                    }\n                    if (v2) {\n                        v0 = v7 = 3844;\n                        v8 = v9 = _channels[v1][1];\n                        v8 = _channels[v1];\n                        v0 = v10 = 3832;\n                        v11 = v12 = _channels[v1][2];\n                        while (v8 > v11) {\n                            v11 = v11 - v8;\n                            goto {'0xf26', '0xf04', '0xf4c', '0xfbd', '0xef80xd8f'};\n                            continue;\n                            STORAGE[2 + v8] = v11;\n                            v0 = v13 = 3878;\n                            v8 = v14 = STORAGE[1 + (v8 + 3)];\n                            require(STORAGE[v8 + 3] <= STORAGE[2 + (v8 + 3)]);\n                            v11 = STORAGE[2 + (v8 + 3)] - STORAGE[v8 + 3];\n                            goto 0xef80xd8f;\n                            STORAGE[v8 + 5] = v11;\n                            v0 = v15 = 3916;\n                            v8 = v16 = STORAGE[1 + v8];\n                            v0 = v17 = 3832;\n                            v8 = v18 = STORAGE[0 + v8];\n                            v11 = v19 = _totalChannelWei;\n                            continue;\n                            _totalChannelWei = v11;\n                            v20 = address(v0).call().value(STORAGE[v8 + 1]).gas(2300 * !STORAGE[v8 + 1]);\n                            require(v20); // checks call status, propagates error data on error\n                            STORAGE[0 + v8] = 0;\n                            STORAGE[1 + v8] = 0;\n                            v0 = v21 = 4029;\n                            v8 = v22 = STORAGE[1 + (v8 + 3)];\n                            v0 = v23 = 3832;\n                            v8 = v24 = STORAGE[0 + (v8 + 3)];\n                            v11 = v25 = _totalChannelToken;\n                        }\n                        revert();\n                        _totalChannelToken = v11;\n                        require(_approvedToken.code.size);\n                        v26, v27 = _approvedToken.transfer(address(v0), STORAGE[1 + (v8 + 3)]).gas(msg.gas);\n                        require(v26); // checks call status, propagates error data on error\n                        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);\n                        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n                        if (v27) {\n                            STORAGE[v8 + 3] = 0;\n                            STORAGE[v8 + 4] = 0;\n                            if (STORAGE[v8 + 9] <= 0) {\n                                STORAGE[v8 + 11] = 0;\n                                STORAGE[v8 + 12] = ~0xff & STORAGE[v8 + 12];\n                            } else {\n                                STORAGE[v8 + 12] = 0x2 | ~0xff & STORAGE[v8 + 12];\n                            }\n                            STORAGE[v8 + 10] = ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v8 + 10];\n                            if (msg.sender == _hub) {\n                                v28 = v29 = 0;\n                            } else {\n                                v28 = v30 = 1;\n                            }\n                            v31 = v32 = MEM[64];\n                            MEM[v32 + 32] = STORAGE[v8 + 1];\n                            v33 = v34 = MEM[64];\n                            MEM[v34 + 32] = STORAGE[v8 + 4];\n                            v35 = v36 = v8 + 6;\n                            v37 = v38 = MEM[64] + 32;\n                            v39 = v40 = 0;\n                            while (v39 < 2) {\n                                MEM[v37] = MEM[v31];\n                                v31 += 32;\n                                v37 += 32;\n                                v39 += 1;\n                            }\n                            v41 = v42 = MEM[64] + 96;\n                            v43 = v44 = 0;\n                            while (v43 < 2) {\n                                MEM[v41] = MEM[v33];\n                                v33 += 32;\n                                v41 += 32;\n                                v43 += 1;\n                            }\n                            v45 = v46 = MEM[64] + 160;\n                            v47 = v48 = 0;\n                            while (v47 < 2) {\n                                MEM[v45] = STORAGE[v35];\n                                v35 += 1;\n                                v45 += 32;\n                                v47 += 1;\n                            }\n                            emit DidEmptyChannel(address(v0), 0xff & v28, STORAGE[v8], v49, STORAGE[v8 + 3], v49, v49, v49, STORAGE[v8 + 8], STORAGE[v8 + 9]);\n                            _hubContractWithdraw = 0;\n                            return v0;\n                        } else {\n                            goto 0x4540xd8f;\n                        }\n                    } else {\n                        goto 0x4540xd8f;\n                    }\n                } else {\n                    goto 0x4540xd8f;\n                }\n            } else {\n                goto 0x4540xd8f;\n            }\n        } else {\n            goto 0x4540xd8f;\n        }\n    }\n    revert('user token withdrawal transfer failed');\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x9e8690) {\n            totalChannelWei();\n        } else if (0x1dd7da9 == v0) {\n            hubContractWithdraw(uint256,uint256);\n        } else if (0x955acd4 == v0) {\n            startExitThreadWithUpdate(address,address[2],uint256,uint256[2],uint256[2],bytes,string,uint256[2],uint256[2],uint256,string);\n        } else if (0x25c29be0 == v0) {\n            challengeThread(address,address,uint256,uint256[2],uint256[2],uint256,string);\n        } else if (0x32b573e1 == v0) {\n            totalChannelToken();\n        } else if (0x365a86fc == v0) {\n            hub();\n        } else if (0x45a92009 == v0) {\n            getChannelBalances(address);\n        } else if (0x4e2a5c5a == v0) {\n            emptyChannel(address);\n        } else if (0x686bf460 == v0) {\n            hubAuthorizedUpdate(address,address,uint256[2],uint256[2],uint256[4],uint256[4],uint256[2],bytes32,uint256,uint256,string);\n        } else if (0x69f81776 == v0) {\n            startExitWithUpdate(address[2],uint256[2],uint256[2],uint256[4],uint256[4],uint256[2],bytes32,uint256,uint256,string,string);\n        } else if (0x72cc174c == v0) {\n            startExit(address);\n        } else if (0x74c25c20 == v0) {\n            getChannelDetails(address);\n        } else if (0x7651a86b == v0) {\n            nukeThreads(address);\n        } else if (0x7dce34f7 == v0) {\n            channels(address);\n        } else if (0x9bcf63cd == v0) {\n            getHubReserveTokens();\n        } else if (0xa1e1fe93 == v0) {\n            emptyChannelWithChallenge(address[2],uint256[2],uint256[2],uint256[4],uint256[4],uint256[2],bytes32,uint256,uint256,string,string);\n        } else if (0xa3f4df7e == v0) {\n            NAME();\n        } else if (0xad872d03 == v0) {\n            getHubReserveWei();\n        } else if (0xb04993ef == v0) {\n            emptyThread(address,address,address,uint256,uint256[2],uint256[2],bytes,string);\n        } else if (0xbab46259 == v0) {\n            approvedToken();\n        } else if (0xc8b2f7d6 == v0) {\n            startExitThread(address,address,address,uint256,uint256[2],uint256[2],bytes,string);\n        } else if (0xea682e37 == v0) {\n            userAuthorizedUpdate(address,uint256[2],uint256[2],uint256[4],uint256[4],uint256[2],bytes32,uint256,uint256,string);\n        } else if (0xf3f480d9 == v0) {\n            challengePeriod();\n        } else if (0xffa1ad74 == v0) {\n            VERSION();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"status": "This model's maximum context length is 32768 tokens. However, your messages resulted in 34979 tokens. Please reduce the length of the messages."
}