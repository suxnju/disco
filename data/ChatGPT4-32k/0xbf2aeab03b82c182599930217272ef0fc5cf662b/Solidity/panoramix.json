{
	"address": "0xbf2aeab03b82c182599930217272ef0fc5cf662b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "From the provided decompiled code, it seems like the original Solidity contract provides several functionalities related to a hub-and-spoke system where channels can be opened, challenged, updated, and closed. \n\nHere is a simplified Solidity version of the contract based on the decompiled code. Note that the decompiled code is not complete, so the resulting Solidity code is also not complete and some functions and mappings are not defined.\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract ChannelManager {\n    address public hubAddress;\n    uint256 public challengePeriod;\n    address public approvedTokenAddress;\n    uint256 public totalChannelWei;\n    uint256 public totalChannelToken;\n    uint8 stor7;\n\n    mapping(address => Channel) public channels;\n    mapping(address => mapping(address => mapping(uint256 => Thread))) stor6;\n\n    struct Channel {\n        // struct fields based on decompiled code\n    }\n\n    struct Thread {\n        // struct fields based on decompiled code\n    }\n\n    function totalChannelWei() public view returns (uint256) {\n        return totalChannelWei;\n    }\n\n    function totalChannelToken() public view returns (uint256) {\n        return totalChannelToken;\n    }\n\n    function hub() public view returns (address) {\n        return hubAddress;\n    }\n\n    function approvedToken() public view returns (address) {\n        return approvedTokenAddress;\n    }\n\n    function challengePeriod() public view returns (uint256) {\n        return challengePeriod;\n    }\n\n    // Other functions based on decompiled code...\n\n    function _fallback() external payable {\n        revert();\n    }\n}\n```\n\nPlease note that Solidity code generated from decompiled EVM bytecode might not accurately represent the original Solidity code due to the loss of certain high-level constructs during the compilation process.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472585,
	"id": "chatcmpl-8Mut7LKDsyckHZFXxAlhRF8LUkzV9",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst NAME = '', 0\nconst VERSION = '', 0\n\ndef storage:\n  hubAddress is address at storage 0\n  challengePeriod is uint256 at storage 1\n  approvedTokenAddress is address at storage 2\n  totalChannelWei is uint256 at storage 3\n  totalChannelToken is uint256 at storage 4\n  channels is mapping of struct at storage 5\n  stor6 is mapping of struct at storage 6\n  stor7 is uint8 at storage 7\n\ndef totalChannelWei(): # not payable\n  return totalChannelWei\n\ndef totalChannelToken(): # not payable\n  return totalChannelToken\n\ndef hub(): # not payable\n  return hubAddress\n\ndef channels(address _param1): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require channels[_param1].field_3072 < 3\n  return channels[_param1].field_2048, \n         channels[_param1].field_2304,\n         channels[_param1].field_2560,\n         channels[_param1].field_2816,\n         channels[_param1].field_3072\n\ndef approvedToken(): # not payable\n  return approvedTokenAddress\n\ndef challengePeriod(): # not payable\n  return challengePeriod\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef getHubReserveWei(): # not payable\n  require totalChannelWei <= eth.balance(this.address)\n  return (eth.balance(this.address) - totalChannelWei)\n\ndef getHubReserveTokens(): # not payable\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= ext_call.return_data[0]\n  return (ext_call.return_data[0] - totalChannelToken)\n\ndef getChannelBalances(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  idx = 1024\n  s = 0\n  while 1120 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1120\n  s = 3\n  while 1216 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1216\n  s = 6\n  while 1280 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if channels[address(user)].field_3072 <= 2:\n      return channels[address(user)].field_0, mem[1056], mem[1088], channels[address(user)].field_768, mem[1152], mem[1184]\n  revert\n\ndef hubContractWithdraw(uint256 weiAmount, uint256 tokenAmount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require hubAddress == caller\n  require totalChannelWei <= eth.balance(this.address)\n  if eth.balance(this.address) - totalChannelWei < weiAmount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  'hubContractWithdraw: Contract wei funds not sufficient to withdraw'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= ext_call.return_data[0]\n  if ext_call.return_data[0] - totalChannelToken < tokenAmount:\n      revert with 0, 'hubContractWithdraw: Contract token funds not sufficient to withdraw'\n  call hubAddress with:\n     value weiAmount wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args hubAddress, tokenAmount\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'hubContractWithdraw: Token transfer failure'\n  log DidHubContractWithdraw(\n        uint256 weiAmount=weiAmount,\n        uint256 tokenAmount=tokenAmount)\n  stor7 = 0\n\ndef startExit(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072:\n      revert with 0, 'channel must be open'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'exit initiator must be user or hub'\n  channels[address(user)].field_2560 = caller\n  require challengePeriod + block.timestamp >= block.timestamp\n  channels[address(user)].field_2816 = challengePeriod + block.timestamp\n  channels[address(user)].field_3072 = 1\n  idx = 0\n  s = 6\n  t = 384\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  if hubAddress == caller:\n      log 0x746e6511: 0, channels[address(user)].field_256, channels[address(user)].field_1024, mem[384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  else:\n      log 0x746e6511: 1, channels[address(user)].field_256, channels[address(user)].field_1024, mem[384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  stor7 = 0\n\ndef getChannelDetails(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  idx = 1024\n  s = 0\n  while 1120 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1120\n  s = 3\n  while 1216 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1216\n  s = 6\n  while 1280 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if channels[address(user)].field_3072 <= 2:\n      if channels[address(user)].field_3072 < 3:\n          return channels[address(user)].field_1536, \n                 mem[1248],\n                 channels[address(user)].field_2048,\n                 channels[address(user)].field_2304,\n                 channels[address(user)].field_2560,\n                 channels[address(user)].field_2816,\n                 channels[address(user)].field_3072\n  revert\n\ndef startExitWithUpdate(address[2] user, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 672\n  require calldata.size >\u2032 35\n  require 68 <= calldata.size\n  idx = 0\n  s = 4\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 288\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 416\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 544\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 640 >= 608 and ceil32(('cd', 612).length) + 640 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  require cd[644] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[644] + 35\n  require ('cd', 644).length <= LOCK8605463013()\n  require ceil32(('cd', 644).length) + 672 >= 640 and ceil32(('cd', 612).length) + ceil32(('cd', 644).length) + 672 <= LOCK8605463013()\n  require cd[644] + ('cd', 644).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[mem[108 len 20]].field_3072 <= 2\n  if channels[mem[108 len 20]].field_3072:\n      revert with 0, 'channel must be open'\n  if hubAddress != caller:\n      if mem[108 len 20] != caller:\n          revert with 0, 'exit initiator must be user or hub'\n  if cd[580]:\n      revert with 0, 'can't start exit with time-sensitive states'\n  if hubAddress == mem[108 len 20]:\n      revert with 0, 'user can not be hub'\n  if this.address == mem[108 len 20]:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyThread(address user, address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig): # not payable\n  require calldata.size - 4 >=\u2032 320\n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  require cd[292] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[292] + 35\n  require ('cd', 292).length <= LOCK8605463013()\n  require ceil32(('cd', 292).length) + 288 >= 256 and ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288 <= LOCK8605463013()\n  require cd[292] + ('cd', 292).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0, 'only hub or user can empty thread'\n  if user != sender:\n      if user != receiver:\n          revert with 0, 'user must be thread sender or receiver'\n  if mem[128]:\n      revert with 0, 'initial receiver balances must be zero'\n  if mem[192]:\n      revert with 0, 'initial receiver balances must be zero'\n  if not stor6[address(sender)][address(receiver)][threadId].field_1280:\n      revert with 0, 'Thread closing time must have passed'\n  if stor6[address(sender)][address(receiver)][threadId].field_1280 >= block.timestamp:\n      revert with 0, 'Thread closing time must have passed'\n  if user == sender:\n      if stor6[address(sender)][address(receiver)][threadId].field_1536:\n          revert with 0, 'user cannot empty twice'\n  else:\n      if stor6[address(sender)][address(receiver)][threadId].field_1544:\n          revert with 0, 'user cannot empty twice'\n  if receiver == sender:\n      revert with 0, 'sender can not be receiver'\n  if hubAddress == sender:\n      revert with 0, 'hub can not be sender or receiver'\n  if hubAddress == receiver:\n      revert with 0, 'hub can not be sender or receiver'\n  if this.address == sender:\n      revert with 0, 'channel manager can not be sender or receiver'\n  if this.address == receiver:\n      revert with 0, 'channel manager can not be sender or receiver'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyChannelWithChallenge(address[2] user, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 672\n  require calldata.size >\u2032 35\n  require 68 <= calldata.size\n  idx = 0\n  s = 4\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 288\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 416\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 544\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 640 >= 608 and ceil32(('cd', 612).length) + 640 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  require cd[644] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[644] + 35\n  require ('cd', 644).length <= LOCK8605463013()\n  require ceil32(('cd', 644).length) + 672 >= 640 and ceil32(('cd', 612).length) + ceil32(('cd', 644).length) + 672 <= LOCK8605463013()\n  require cd[644] + ('cd', 644).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[mem[108 len 20]].field_3072 <= 2\n  if channels[mem[108 len 20]].field_3072 != 1:\n      revert with 0, 'channel must be in dispute'\n  if block.timestamp >= channels[mem[108 len 20]].field_2816:\n      revert with 0, 'channel closing time must not have passed'\n  if caller == channels[mem[108 len 20]].field_2560:\n      revert with 0, 'challenger can not be exit initiator'\n  if hubAddress != caller:\n      if mem[108 len 20] != caller:\n          revert with 0, 'challenger must be either user or hub'\n  if cd[580]:\n      revert with 0, 'can't start exit with time-sensitive states'\n  if hubAddress == mem[108 len 20]:\n      revert with 0, 'user can not be hub'\n  if this.address == mem[108 len 20]:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef nukeThreads(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'channel must be in thread dispue'\n  if not challengePeriod:\n      require channels[address(user)].field_2816 >= channels[address(user)].field_2816\n      if channels[address(user)].field_2816 >= block.timestamp:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      61,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed by 10 challenge periods'\n  else:\n      require 10 * challengePeriod / challengePeriod == 10\n      require (10 * challengePeriod) + channels[address(user)].field_2816 >= channels[address(user)].field_2816\n      if (10 * challengePeriod) + channels[address(user)].field_2816 >= block.timestamp:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      61,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed by 10 challenge periods'\n  require channels[address(user)].field_512 <= totalChannelWei\n  totalChannelWei -= channels[address(user)].field_512\n  call user with:\n     value channels[address(user)].field_512 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  channels[address(user)].field_512 = 0\n  require channels[address(user)].field_1280 <= totalChannelToken\n  totalChannelToken -= channels[address(user)].field_1280\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args address(user), channels[address(user)].field_1280\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'user token withdrawal transfer failed'\n  channels[address(user)].field_1280 = 0\n  channels[address(user)].field_2304 = 0\n  channels[address(user)].field_2048 = 0\n  channels[address(user)].field_2816 = 0\n  channels[address(user)].field_3072 = 0\n  idx = 0\n  s = 6\n  t = ceil32(return_data.size) + 448\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  log DidNukeThreads(\n        address user=caller,\n        address senderAddress=channels[address(user)].field_512,\n        uint256 weiAmount=channels[address(user)].field_1280,\n        uint256 tokenAmount=channels[address(user)].field_256,\n        uint256[2] channelWeiBalances=channels[address(user)].field_1024,\n        uint256[2] channelTokenBalances=mem[ceil32(return_data.size) + 448 len 64],\n        uint256[2] channelTxCount=0,\n        bytes32 channelThreadRoot=0,\n        uint256 channelThreadCount=user)\n  stor7 = 0\n\ndef userAuthorizedUpdate(address recipient, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub) payable: \n  require calldata.size - 4 >=\u2032 608\n  require calldata.size >\u2032 67\n  require 100 <= calldata.size\n  idx = 0\n  s = 36\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 131\n  require 164 <= calldata.size\n  idx = 0\n  s = 100\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 195\n  require 292 <= calldata.size\n  idx = 0\n  s = 164\n  t = 224\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 323\n  require 420 <= calldata.size\n  idx = 0\n  s = 292\n  t = 352\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 451\n  require 484 <= calldata.size\n  idx = 0\n  s = 420\n  t = 480\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[580] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[580] + 35\n  require ('cd', 580).length <= LOCK8605463013()\n  require ceil32(('cd', 580).length) + 576 >= 544 and ceil32(('cd', 580).length) + 576 <= LOCK8605463013()\n  require cd[580] + ('cd', 580).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if mem[288] != call.value:\n      revert with 0, 'msg.value is not equal to pending user deposit'\n  require channels[caller].field_3072 <= 2\n  if channels[caller].field_3072:\n      revert with 0, 'channel must be open'\n  if cd[548]:\n      if block.timestamp >= cd[548]:\n          revert with 0, 'the timeout must be zero or not have passed'\n  if mem[480] <= channels[caller].field_1536:\n      revert with 0, 'global txCount must be higher than the current global txCount'\n  if mem[512] < channels[caller].field_1792:\n      revert with 0, 'onchain txCount must be higher or equal to the current onchain txCount'\n  require mem[128] + mem[96] >= mem[96]\n  if mem[128] + mem[96] > channels[caller].field_512:\n      revert with 0, 'wei must be conserved'\n  require mem[192] + mem[160] >= mem[160]\n  if mem[192] + mem[160] > channels[caller].field_1280:\n      revert with 0, 'tokens must be conserved'\n  require totalChannelWei <= eth.balance(this.address)\n  if mem[224] > eth.balance(this.address) - totalChannelWei:\n      revert with 0, 'insufficient reserve wei for deposits'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args address(this.address)\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= 0, ext_call.return_data[4 len 28]\n  if mem[352] > 0, ext_call.return_data[4 len 28] - totalChannelToken:\n      revert with 0, 'insufficient reserve tokens for deposits'\n  require mem[128] + mem[96] >= mem[96]\n  require mem[256] >= 0\n  require mem[320] >= 0\n  require mem[224] + channels[caller].field_512 >= channels[caller].field_512\n  require mem[288] >= 0\n  if mem[288] + mem[224] + channels[caller].field_512 < mem[320] + mem[256] + mem[128] + mem[96]:\n      revert with 0, 'insufficient wei'\n  require mem[192] + mem[160] >= mem[160]\n  require mem[384] >= 0\n  require mem[448] >= 0\n  require mem[352] + channels[caller].field_1280 >= channels[caller].field_1280\n  require mem[416] >= 0\n  if mem[416] + mem[352] + channels[caller].field_1280 < mem[448] + mem[384] + mem[192] + mem[160]:\n      revert with 0, 'insufficient token'\n  if hubAddress == caller:\n      revert with 0, 'user can not be hub'\n  if this.address == caller:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef hubAuthorizedUpdate(address user, address recipient, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 640\n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 224\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 352\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 480\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 576 >= 544 and ceil32(('cd', 612).length) + 576 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require hubAddress == caller\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072:\n      revert with 0, 'channel must be open'\n  if cd[580]:\n      if block.timestamp >= cd[580]:\n          revert with 0, 'the timeout must be zero or not have passed'\n  if mem[480] <= channels[address(user)].field_1536:\n      revert with 0, 'global txCount must be higher than the current global txCount'\n  if mem[512] < channels[address(user)].field_1792:\n      revert with 0, 'onchain txCount must be higher or equal to the current onchain txCount'\n  require mem[128] + mem[96] >= mem[96]\n  if mem[128] + mem[96] > channels[address(user)].field_512:\n      revert with 0, 'wei must be conserved'\n  require mem[192] + mem[160] >= mem[160]\n  if mem[192] + mem[160] > channels[address(user)].field_1280:\n      revert with 0, 'tokens must be conserved'\n  require totalChannelWei <= eth.balance(this.address)\n  require mem[288] + mem[224] >= mem[224]\n  if mem[288] + mem[224] > eth.balance(this.address) - totalChannelWei:\n      revert with 0, 'insufficient reserve wei for deposits'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args address(this.address)\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= 0, ext_call.return_data[4 len 28]\n  require mem[416] + mem[352] >= mem[352]\n  if mem[416] + mem[352] > 0, ext_call.return_data[4 len 28] - totalChannelToken:\n      revert with 0, 'insufficient reserve tokens for deposits'\n  require mem[128] + mem[96] >= mem[96]\n  require mem[256] >= 0\n  require mem[320] >= 0\n  require mem[224] + channels[address(user)].field_512 >= channels[address(user)].field_512\n  require mem[288] >= 0\n  if mem[288] + mem[224] + channels[address(user)].field_512 < mem[320] + mem[256] + mem[128] + mem[96]:\n      revert with 0, 'insufficient wei'\n  require mem[192] + mem[160] >= mem[160]\n  require mem[384] >= 0\n  require mem[448] >= 0\n  require mem[352] + channels[address(user)].field_1280 >= channels[address(user)].field_1280\n  require mem[416] >= 0\n  if mem[416] + mem[352] + channels[address(user)].field_1280 < mem[448] + mem[384] + mem[192] + mem[160]:\n      revert with 0, 'insufficient token'\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyChannel(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 1:\n      revert with 0, 'channel must be in dispute'\n  if channels[address(user)].field_2816 >= block.timestamp:\n      if caller == channels[address(user)].field_2560:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      85,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed or msg.sender must be non-',\n                      'exit-initiating party' << 88\n      if hubAddress != caller:\n          if user != caller:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          85,\n                          0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                          'assed or msg.sender must be non-',\n                          'exit-initiating party' << 88\n  require channels[address(user)].field_0 <= channels[address(user)].field_512\n  require channels[address(user)].field_256 <= channels[address(user)].field_512 - channels[address(user)].field_0\n  channels[address(user)].field_512 = channels[address(user)].field_512 - channels[address(user)].field_0 - channels[address(user)].field_256\n  require channels[address(user)].field_768 <= channels[address(user)].field_1280\n  require channels[address(user)].field_1024 <= channels[address(user)].field_1280 - channels[address(user)].field_768\n  channels[address(user)].field_1280 = channels[address(user)].field_1280 - channels[address(user)].field_768 - channels[address(user)].field_1024\n  require channels[address(user)].field_0 <= totalChannelWei\n  require channels[address(user)].field_256 <= totalChannelWei - channels[address(user)].field_0\n  totalChannelWei = totalChannelWei - channels[address(user)].field_0 - channels[address(user)].field_256\n  call user with:\n     value channels[address(user)].field_256 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  channels[address(user)].field_0 = 0\n  channels[address(user)].field_256 = 0\n  require channels[address(user)].field_768 <= totalChannelToken\n  require channels[address(user)].field_1024 <= totalChannelToken - channels[address(user)].field_768\n  totalChannelToken = totalChannelToken - channels[address(user)].field_768 - channels[address(user)].field_1024\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args address(user), channels[address(user)].field_1024\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'user token withdrawal transfer failed'\n  channels[address(user)].field_768 = 0\n  channels[address(user)].field_1024 = 0\n  if channels[address(user)].field_2304 > 0:\n      channels[address(user)].field_3072 = 2\n  else:\n      channels[address(user)].field_2816 = 0\n      channels[address(user)].field_3072 = 0\n  channels[address(user)].field_2560 = 0\n  idx = 0\n  s = 6\n  t = ceil32(return_data.size) + 384\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  if caller == hubAddress:\n      log 0x70ff678d: 0, channels[address(user)].field_256, channels[address(user)].field_1024, mem[ceil32(return_data.size) + 384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  else:\n      log 0x70ff678d: 1, channels[address(user)].field_256, channels[address(user)].field_1024, mem[ceil32(return_data.size) + 384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  stor7 = 0\n\ndef startExitThread(address user, address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig): # not payable\n  require calldata.size - 4 >=\u2032 320\n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  require cd[292] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[292] + 35\n  require ('cd', 292).length <= LOCK8605463013()\n  require ceil32(('cd', 292).length) + 288 >= 256 and ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288 <= LOCK8605463013()\n  require cd[292] + ('cd', 292).length + 36 <= calldata.size\n  mem[ceil32(('cd', 260).length) + 288 len ('cd', 292).length] = call.data[cd[292] + 36 len ('cd', 292).length]\n  mem[('cd', 292).length + ceil32(('cd', 260).length) + 288] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue phase'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0, 'thread exit initiator must be user or hub'\n  if user != sender:\n      if user != receiver:\n          revert with 0, 'user must be thread sender or receiver'\n  if mem[128]:\n      revert with 0, 'initial receiver balances must be zero'\n  if mem[192]:\n      revert with 0, 'initial receiver balances must be zero'\n  mem[0] = threadId\n  mem[32] = sha3(address(receiver), sha3(address(sender), 6))\n  if stor6[address(sender)][address(receiver)][threadId].field_1280:\n      revert with 0, 'thread closing time must be zero'\n  if receiver == sender:\n      revert with 0, 'sender can not be receiver'\n  if hubAddress == sender:\n      revert with 0, 'hub can not be sender or receiver'\n  if hubAddress == receiver:\n      revert with 0, 'hub can not be sender or receiver'\n  if this.address == sender:\n      revert with 0, 'channel manager can not be sender or receiver'\n  if this.address == receiver:\n      revert with 0, 'channel manager can not be sender or receiver'\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 320] = address(this.address)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 340] = address(sender)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 360] = address(receiver)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 380] = threadId\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 412 len 64] = mem[96 len 64]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 476 len 64] = mem[160 len 64]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 540] = 0\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288] = 252\n  mem[64] = ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572 len floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)])] = mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 320 len floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)])]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 572] = mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 572] and 256^(-(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)] % 32) + 32) - 1 or mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 320] and !(256^(-(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)] % 32) + 32) - 1)\n  require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n  delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n       gas gas_remaining wei\n      args sha3(mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572 len Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]]), Array(len=('cd', 292).length, data=call.data[cd[292] + 36 len ('cd', 292).length]), sender\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not delegate.return_data[0]:\n      revert with 0, 'signature invalid'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef challengeThread(address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount, string sig): # not payable\n  require calldata.size - 4 >=\u2032 288\n  require calldata.size >\u2032 131\n  require 164 <= calldata.size\n  idx = 0\n  s = 100\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 195\n  require 228 <= calldata.size\n  idx = 0\n  s = 164\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  mem[224] = ('cd', 260).length\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  mem[256 len ('cd', 260).length] = call.data[cd[260] + 36 len ('cd', 260).length]\n  mem[('cd', 260).length + 256] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress != caller:\n      if sender != caller:\n          if receiver != caller:\n              revert with 0, 'only hub, sender, or receiver can call this function'\n      if block.timestamp >= stor6[address(sender)][address(receiver)][threadId].field_1280:\n          revert with 0, 'thread closing time must not have passed'\n      if cd[228] <= stor6[address(sender)][address(receiver)][threadId].field_1024:\n          revert with 0, 'thread txCount must be higher than the current thread txCount'\n      require stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0 >= stor6[address(sender)][address(receiver)][threadId].field_0\n      require mem[128] + mem[96] >= mem[96]\n      if mem[128] + mem[96] != stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0:\n          revert with 0, 'updated wei balances must match sum of thread wei balances'\n      require stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512 >= stor6[address(sender)][address(receiver)][threadId].field_512\n      require mem[192] + mem[160] >= mem[160]\n      if mem[192] + mem[160] != stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512:\n          revert with 0, 'updated token balances must match sum of thread token balances'\n      if mem[128] < stor6[address(sender)][address(receiver)][threadId].field_256:\n          revert with 0, 'receiver balances may never decrease'\n      if mem[192] < stor6[address(sender)][address(receiver)][threadId].field_768:\n          revert with 0, 'receiver balances may never decrease'\n      mem[ceil32(('cd', 260).length) + 256] = 0\n      if receiver == sender:\n          revert with 0, 'sender can not be receiver'\n      if hubAddress == sender:\n          revert with 0, 'hub can not be sender or receiver'\n      if hubAddress == receiver:\n          revert with 0, 'hub can not be sender or receiver'\n      if this.address == sender:\n          revert with 0, 'channel manager can not be sender or receiver'\n      if this.address == receiver:\n          revert with 0, 'channel manager can not be sender or receiver'\n      mem[ceil32(('cd', 260).length) + 572 len 224] = this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228])\n      mem[ceil32(('cd', 260).length) + 796 len 28] = Mask(224, 0, cd[228])\n      mem[ceil32(('cd', 260).length) + 608] = 96\n      mem[ceil32(('cd', 260).length) + 672] = ('cd', 260).length\n      mem[ceil32(('cd', 260).length) + 704 len ceil32(('cd', 260).length)] = call.data[cd[260] + 36 len ('cd', 260).length], mem[('cd', 260).length + 256 len ceil32(('cd', 260).length) - ('cd', 260).length]\n      if ceil32(('cd', 260).length) > ('cd', 260).length:\n          mem[ceil32(('cd', 260).length) + ('cd', 260).length + 704] = 0\n      mem[ceil32(('cd', 260).length) + 640] = sender\n      require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n      delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n           gas gas_remaining wei\n          args sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228])), Array(len=('cd', 260).length, data=call.data[cd[260] + 36 len ('cd', 260).length]), sender\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >=\u2032 32\n      if not delegate.return_data[0]:\n          revert with 0, 'signature invalid'\n      s = 0\n      idx = 96\n      while 160 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 2\n      while 2 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      s = 2\n      idx = 160\n      while 224 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      while 4 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      stor6[address(sender)][address(receiver)][threadId].field_1024 = cd[228]\n      idx = 0\n      s = 0\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 636\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      idx = 0\n      s = 2\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 700\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      log DidChallengeThread(address sender, address receiver, uint256 threadId, address senderAddress, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount):\n                             threadId,\n                             caller,\n                             mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 636 len 128],\n                             cd[228],\n                             sender,\n                             receiver,\n  else:\n      if block.timestamp >= stor6[address(sender)][address(receiver)][threadId].field_1280:\n          revert with 0, 'thread closing time must not have passed'\n      if cd[228] <= stor6[address(sender)][address(receiver)][threadId].field_1024:\n          revert with 0, 'thread txCount must be higher than the current thread txCount'\n      require stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0 >= stor6[address(sender)][address(receiver)][threadId].field_0\n      require mem[128] + mem[96] >= mem[96]\n      if mem[128] + mem[96] != stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0:\n          revert with 0, 'updated wei balances must match sum of thread wei balances'\n      require stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512 >= stor6[address(sender)][address(receiver)][threadId].field_512\n      require mem[192] + mem[160] >= mem[160]\n      if mem[192] + mem[160] != stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512:\n          revert with 0, 'updated token balances must match sum of thread token balances'\n      if mem[128] < stor6[address(sender)][address(receiver)][threadId].field_256:\n          revert with 0, 'receiver balances may never decrease'\n      if mem[192] < stor6[address(sender)][address(receiver)][threadId].field_768:\n          revert with 0, 'receiver balances may never decrease'\n      mem[ceil32(('cd', 260).length) + 256] = 0\n      if receiver == sender:\n          revert with 0, 'sender can not be receiver'\n      if hubAddress == sender:\n          revert with 0, 'hub can not be sender or receiver'\n      if hubAddress == receiver:\n          revert with 0, 'hub can not be sender or receiver'\n      if this.address == sender:\n          revert with 0, 'channel manager can not be sender or receiver'\n      if this.address == receiver:\n          revert with 0, 'channel manager can not be sender or receiver'\n      mem[ceil32(('cd', 260).length) + 320] = address(this.address)\n      mem[ceil32(('cd', 260).length) + 340] = address(sender)\n      mem[ceil32(('cd', 260).length) + 360] = address(receiver)\n      mem[ceil32(('cd', 260).length) + 380] = threadId\n      mem[ceil32(('cd', 260).length) + 412 len 64] = mem[96 len 64]\n      mem[ceil32(('cd', 260).length) + 476 len 64] = mem[160 len 64]\n      mem[ceil32(('cd', 260).length) + 540] = cd[228]\n      mem[ceil32(('cd', 260).length) + 288] = 252\n      mem[ceil32(('cd', 260).length) + 572 len 224] = this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228])\n      mem[ceil32(('cd', 260).length) + 796 len 28] = Mask(224, 0, cd[228])\n      mem[ceil32(('cd', 260).length) + 576] = sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228]))\n      mem[ceil32(('cd', 260).length) + 608] = 96\n      mem[ceil32(('cd', 260).length) + 672] = ('cd', 260).length\n      mem[ceil32(('cd', 260).length) + 704 len ceil32(('cd', 260).length)] = call.data[cd[260] + 36 len ('cd', 260).length], mem[('cd', 260).length + 256 len ceil32(('cd', 260).length) - ('cd', 260).length]\n      if ceil32(('cd', 260).length) > ('cd', 260).length:\n          mem[ceil32(('cd', 260).length) + ('cd', 260).length + 704] = 0\n      mem[ceil32(('cd', 260).length) + 640] = sender\n      require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n      delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n           gas gas_remaining wei\n          args sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228])), Array(len=('cd', 260).length, data=call.data[cd[260] + 36 len ('cd', 260).length]), sender\n      mem[ceil32(('cd', 260).length) + 572] = delegate.return_data[0]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[64] = ceil32(('cd', 260).length) + ceil32(return_data.size) + 572\n      require return_data.size >=\u2032 32\n      if not delegate.return_data[0]:\n          revert with 0, 'signature invalid'\n      s = 0\n      idx = 96\n      while 160 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 2\n      while 2 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      s = 2\n      idx = 160\n      while 224 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      while 4 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      stor6[address(sender)][address(receiver)][threadId].field_1024 = cd[228]\n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 572] = threadId\n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 604] = caller\n      idx = 0\n      s = 0\n      t = mem[64] + 64\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      idx = 0\n      s = 2\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 700\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 764] = cd[228]\n      log DidChallengeThread(address sender, address receiver, uint256 threadId, address senderAddress, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount):\n                             mem[mem[64] len ceil32(('cd', 260).length) + ceil32(return_data.size) + -mem[64] + 796],\n                             sender,\n                             receiver,\n  stor7 = 0\n\ndef startExitThreadWithUpdate(address user, address[2] threadMembers, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig, uint256[2] updatedWeiBalances, uint256[2] updatedTokenBalances, uint256 updatedTxCount, string updateSig): # not payable\n  require calldata.size - 4 >=\u2032 512\n  require calldata.size >\u2032 67\n  require 100 <= calldata.size\n  idx = 0\n  s = 36\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require updatedTokenBalances <= LOCK8605463013()\n  require calldata.size >\u2032 updatedTokenBalances + 35\n  require updatedTokenBalances.length <= LOCK8605463013()\n  require ceil32(updatedTokenBalances.length) + 320 >= 288 and ceil32(updatedTokenBalances.length) + 320 <= LOCK8605463013()\n  mem[288] = updatedTokenBalances.length\n  require updatedTokenBalances + updatedTokenBalances.length + 36 <= calldata.size\n  mem[320 len updatedTokenBalances.length] = updatedTokenBalances[all]\n  mem[updatedTokenBalances.length + 320] = 0\n  require updatedTxCount <= LOCK8605463013()\n  require calldata.size >\u2032 updatedTxCount + 35\n  require updatedTxCount.length <= LOCK8605463013()\n  require ceil32(updatedTxCount.length) + 352 >= 320 and ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352 <= LOCK8605463013()\n  mem[ceil32(updatedTokenBalances.length) + 320] = updatedTxCount.length\n  require updatedTxCount + updatedTxCount.length + 36 <= calldata.size\n  mem[ceil32(updatedTokenBalances.length) + 352 len updatedTxCount.length] = updatedTxCount[all]\n  mem[updatedTxCount.length + ceil32(updatedTokenBalances.length) + 352] = 0\n  require calldata.size >\u2032 355\n  require bool(ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416 <= LOCK8605463013())\n  require 388 <= calldata.size\n  idx = 0\n  s = 324\n  t = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 419\n  require bool(ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 480 <= LOCK8605463013())\n  require 452 <= calldata.size\n  idx = 0\n  s = 388\n  t = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[484] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[484] + 35\n  require ('cd', 484).length <= LOCK8605463013()\n  require ceil32(('cd', 484).length) + 512 >= 480 and ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512 <= LOCK8605463013()\n  mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 480] = ('cd', 484).length\n  require cd[484] + ('cd', 484).length + 36 <= calldata.size\n  mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 512 len ('cd', 484).length] = call.data[cd[484] + 36 len ('cd', 484).length]\n  mem[('cd', 484).length + ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 512] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue phase'\n  if caller == hubAddress:\n      if mem[108 len 20] == user:\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _821 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _821\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _821, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _821, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n      else:\n          if mem[140 len 20] != user:\n              revert with 0, 'user must be thread sender or receiver'\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _826 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _826\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _826, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _826, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n  else:\n      if user != caller:\n          revert with 0, 'thread exit initiator must be user or hub'\n      if mem[108 len 20] == user:\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _831 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _831\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _831, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _831, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n      else:\n          if mem[140 len 20] != user:\n              revert with 0, 'user must be thread sender or receiver'\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _836 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _836\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _836, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _836, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst NAME = '', 0\nconst VERSION = '', 0\n\ndef storage:\n  hubAddress is address at storage 0\n  challengePeriod is uint256 at storage 1\n  approvedTokenAddress is address at storage 2\n  totalChannelWei is uint256 at storage 3\n  totalChannelToken is uint256 at storage 4\n  channels is mapping of struct at storage 5\n  stor6 is mapping of struct at storage 6\n  stor7 is uint8 at storage 7\n\ndef totalChannelWei(): # not payable\n  return totalChannelWei\n\ndef totalChannelToken(): # not payable\n  return totalChannelToken\n\ndef hub(): # not payable\n  return hubAddress\n\ndef channels(address _param1): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require channels[_param1].field_3072 < 3\n  return channels[_param1].field_2048, \n         channels[_param1].field_2304,\n         channels[_param1].field_2560,\n         channels[_param1].field_2816,\n         channels[_param1].field_3072\n\ndef approvedToken(): # not payable\n  return approvedTokenAddress\n\ndef challengePeriod(): # not payable\n  return challengePeriod\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef getHubReserveWei(): # not payable\n  require totalChannelWei <= eth.balance(this.address)\n  return (eth.balance(this.address) - totalChannelWei)\n\ndef getHubReserveTokens(): # not payable\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= ext_call.return_data[0]\n  return (ext_call.return_data[0] - totalChannelToken)\n\ndef getChannelBalances(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  idx = 1024\n  s = 0\n  while 1120 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1120\n  s = 3\n  while 1216 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1216\n  s = 6\n  while 1280 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if channels[address(user)].field_3072 <= 2:\n      return channels[address(user)].field_0, mem[1056], mem[1088], channels[address(user)].field_768, mem[1152], mem[1184]\n  revert\n\ndef hubContractWithdraw(uint256 weiAmount, uint256 tokenAmount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require hubAddress == caller\n  require totalChannelWei <= eth.balance(this.address)\n  if eth.balance(this.address) - totalChannelWei < weiAmount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  'hubContractWithdraw: Contract wei funds not sufficient to withdraw'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= ext_call.return_data[0]\n  if ext_call.return_data[0] - totalChannelToken < tokenAmount:\n      revert with 0, 'hubContractWithdraw: Contract token funds not sufficient to withdraw'\n  call hubAddress with:\n     value weiAmount wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args hubAddress, tokenAmount\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'hubContractWithdraw: Token transfer failure'\n  log DidHubContractWithdraw(\n        uint256 weiAmount=weiAmount,\n        uint256 tokenAmount=tokenAmount)\n  stor7 = 0\n\ndef startExit(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072:\n      revert with 0, 'channel must be open'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'exit initiator must be user or hub'\n  channels[address(user)].field_2560 = caller\n  require challengePeriod + block.timestamp >= block.timestamp\n  channels[address(user)].field_2816 = challengePeriod + block.timestamp\n  channels[address(user)].field_3072 = 1\n  idx = 0\n  s = 6\n  t = 384\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  if hubAddress == caller:\n      log 0x746e6511: 0, channels[address(user)].field_256, channels[address(user)].field_1024, mem[384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  else:\n      log 0x746e6511: 1, channels[address(user)].field_256, channels[address(user)].field_1024, mem[384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  stor7 = 0\n\ndef getChannelDetails(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  idx = 1024\n  s = 0\n  while 1120 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1120\n  s = 3\n  while 1216 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1216\n  s = 6\n  while 1280 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if channels[address(user)].field_3072 <= 2:\n      if channels[address(user)].field_3072 < 3:\n          return channels[address(user)].field_1536, \n                 mem[1248],\n                 channels[address(user)].field_2048,\n                 channels[address(user)].field_2304,\n                 channels[address(user)].field_2560,\n                 channels[address(user)].field_2816,\n                 channels[address(user)].field_3072\n  revert\n\ndef startExitWithUpdate(address[2] user, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 672\n  require calldata.size >\u2032 35\n  require 68 <= calldata.size\n  idx = 0\n  s = 4\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 288\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 416\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 544\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 640 >= 608 and ceil32(('cd', 612).length) + 640 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  require cd[644] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[644] + 35\n  require ('cd', 644).length <= LOCK8605463013()\n  require ceil32(('cd', 644).length) + 672 >= 640 and ceil32(('cd', 612).length) + ceil32(('cd', 644).length) + 672 <= LOCK8605463013()\n  require cd[644] + ('cd', 644).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[mem[108 len 20]].field_3072 <= 2\n  if channels[mem[108 len 20]].field_3072:\n      revert with 0, 'channel must be open'\n  if hubAddress != caller:\n      if mem[108 len 20] != caller:\n          revert with 0, 'exit initiator must be user or hub'\n  if cd[580]:\n      revert with 0, 'can't start exit with time-sensitive states'\n  if hubAddress == mem[108 len 20]:\n      revert with 0, 'user can not be hub'\n  if this.address == mem[108 len 20]:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyThread(address user, address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig): # not payable\n  require calldata.size - 4 >=\u2032 320\n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  require cd[292] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[292] + 35\n  require ('cd', 292).length <= LOCK8605463013()\n  require ceil32(('cd', 292).length) + 288 >= 256 and ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288 <= LOCK8605463013()\n  require cd[292] + ('cd', 292).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0, 'only hub or user can empty thread'\n  if user != sender:\n      if user != receiver:\n          revert with 0, 'user must be thread sender or receiver'\n  if mem[128]:\n      revert with 0, 'initial receiver balances must be zero'\n  if mem[192]:\n      revert with 0, 'initial receiver balances must be zero'\n  if not stor6[address(sender)][address(receiver)][threadId].field_1280:\n      revert with 0, 'Thread closing time must have passed'\n  if stor6[address(sender)][address(receiver)][threadId].field_1280 >= block.timestamp:\n      revert with 0, 'Thread closing time must have passed'\n  if user == sender:\n      if stor6[address(sender)][address(receiver)][threadId].field_1536:\n          revert with 0, 'user cannot empty twice'\n  else:\n      if stor6[address(sender)][address(receiver)][threadId].field_1544:\n          revert with 0, 'user cannot empty twice'\n  if receiver == sender:\n      revert with 0, 'sender can not be receiver'\n  if hubAddress == sender:\n      revert with 0, 'hub can not be sender or receiver'\n  if hubAddress == receiver:\n      revert with 0, 'hub can not be sender or receiver'\n  if this.address == sender:\n      revert with 0, 'channel manager can not be sender or receiver'\n  if this.address == receiver:\n      revert with 0, 'channel manager can not be sender or receiver'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyChannelWithChallenge(address[2] user, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 672\n  require calldata.size >\u2032 35\n  require 68 <= calldata.size\n  idx = 0\n  s = 4\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 288\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 416\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 544\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 640 >= 608 and ceil32(('cd', 612).length) + 640 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  require cd[644] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[644] + 35\n  require ('cd', 644).length <= LOCK8605463013()\n  require ceil32(('cd', 644).length) + 672 >= 640 and ceil32(('cd', 612).length) + ceil32(('cd', 644).length) + 672 <= LOCK8605463013()\n  require cd[644] + ('cd', 644).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[mem[108 len 20]].field_3072 <= 2\n  if channels[mem[108 len 20]].field_3072 != 1:\n      revert with 0, 'channel must be in dispute'\n  if block.timestamp >= channels[mem[108 len 20]].field_2816:\n      revert with 0, 'channel closing time must not have passed'\n  if caller == channels[mem[108 len 20]].field_2560:\n      revert with 0, 'challenger can not be exit initiator'\n  if hubAddress != caller:\n      if mem[108 len 20] != caller:\n          revert with 0, 'challenger must be either user or hub'\n  if cd[580]:\n      revert with 0, 'can't start exit with time-sensitive states'\n  if hubAddress == mem[108 len 20]:\n      revert with 0, 'user can not be hub'\n  if this.address == mem[108 len 20]:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef nukeThreads(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'channel must be in thread dispue'\n  if not challengePeriod:\n      require channels[address(user)].field_2816 >= channels[address(user)].field_2816\n      if channels[address(user)].field_2816 >= block.timestamp:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      61,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed by 10 challenge periods'\n  else:\n      require 10 * challengePeriod / challengePeriod == 10\n      require (10 * challengePeriod) + channels[address(user)].field_2816 >= channels[address(user)].field_2816\n      if (10 * challengePeriod) + channels[address(user)].field_2816 >= block.timestamp:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      61,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed by 10 challenge periods'\n  require channels[address(user)].field_512 <= totalChannelWei\n  totalChannelWei -= channels[address(user)].field_512\n  call user with:\n     value channels[address(user)].field_512 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  channels[address(user)].field_512 = 0\n  require channels[address(user)].field_1280 <= totalChannelToken\n  totalChannelToken -= channels[address(user)].field_1280\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args address(user), channels[address(user)].field_1280\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'user token withdrawal transfer failed'\n  channels[address(user)].field_1280 = 0\n  channels[address(user)].field_2304 = 0\n  channels[address(user)].field_2048 = 0\n  channels[address(user)].field_2816 = 0\n  channels[address(user)].field_3072 = 0\n  idx = 0\n  s = 6\n  t = ceil32(return_data.size) + 448\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  log DidNukeThreads(\n        address user=caller,\n        address senderAddress=channels[address(user)].field_512,\n        uint256 weiAmount=channels[address(user)].field_1280,\n        uint256 tokenAmount=channels[address(user)].field_256,\n        uint256[2] channelWeiBalances=channels[address(user)].field_1024,\n        uint256[2] channelTokenBalances=mem[ceil32(return_data.size) + 448 len 64],\n        uint256[2] channelTxCount=0,\n        bytes32 channelThreadRoot=0,\n        uint256 channelThreadCount=user)\n  stor7 = 0\n\ndef userAuthorizedUpdate(address recipient, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub) payable: \n  require calldata.size - 4 >=\u2032 608\n  require calldata.size >\u2032 67\n  require 100 <= calldata.size\n  idx = 0\n  s = 36\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 131\n  require 164 <= calldata.size\n  idx = 0\n  s = 100\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 195\n  require 292 <= calldata.size\n  idx = 0\n  s = 164\n  t = 224\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 323\n  require 420 <= calldata.size\n  idx = 0\n  s = 292\n  t = 352\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 451\n  require 484 <= calldata.size\n  idx = 0\n  s = 420\n  t = 480\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[580] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[580] + 35\n  require ('cd', 580).length <= LOCK8605463013()\n  require ceil32(('cd', 580).length) + 576 >= 544 and ceil32(('cd', 580).length) + 576 <= LOCK8605463013()\n  require cd[580] + ('cd', 580).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if mem[288] != call.value:\n      revert with 0, 'msg.value is not equal to pending user deposit'\n  require channels[caller].field_3072 <= 2\n  if channels[caller].field_3072:\n      revert with 0, 'channel must be open'\n  if cd[548]:\n      if block.timestamp >= cd[548]:\n          revert with 0, 'the timeout must be zero or not have passed'\n  if mem[480] <= channels[caller].field_1536:\n      revert with 0, 'global txCount must be higher than the current global txCount'\n  if mem[512] < channels[caller].field_1792:\n      revert with 0, 'onchain txCount must be higher or equal to the current onchain txCount'\n  require mem[128] + mem[96] >= mem[96]\n  if mem[128] + mem[96] > channels[caller].field_512:\n      revert with 0, 'wei must be conserved'\n  require mem[192] + mem[160] >= mem[160]\n  if mem[192] + mem[160] > channels[caller].field_1280:\n      revert with 0, 'tokens must be conserved'\n  require totalChannelWei <= eth.balance(this.address)\n  if mem[224] > eth.balance(this.address) - totalChannelWei:\n      revert with 0, 'insufficient reserve wei for deposits'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args address(this.address)\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= 0, ext_call.return_data[4 len 28]\n  if mem[352] > 0, ext_call.return_data[4 len 28] - totalChannelToken:\n      revert with 0, 'insufficient reserve tokens for deposits'\n  require mem[128] + mem[96] >= mem[96]\n  require mem[256] >= 0\n  require mem[320] >= 0\n  require mem[224] + channels[caller].field_512 >= channels[caller].field_512\n  require mem[288] >= 0\n  if mem[288] + mem[224] + channels[caller].field_512 < mem[320] + mem[256] + mem[128] + mem[96]:\n      revert with 0, 'insufficient wei'\n  require mem[192] + mem[160] >= mem[160]\n  require mem[384] >= 0\n  require mem[448] >= 0\n  require mem[352] + channels[caller].field_1280 >= channels[caller].field_1280\n  require mem[416] >= 0\n  if mem[416] + mem[352] + channels[caller].field_1280 < mem[448] + mem[384] + mem[192] + mem[160]:\n      revert with 0, 'insufficient token'\n  if hubAddress == caller:\n      revert with 0, 'user can not be hub'\n  if this.address == caller:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef hubAuthorizedUpdate(address user, address recipient, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 640\n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 224\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 352\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 480\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 576 >= 544 and ceil32(('cd', 612).length) + 576 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require hubAddress == caller\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072:\n      revert with 0, 'channel must be open'\n  if cd[580]:\n      if block.timestamp >= cd[580]:\n          revert with 0, 'the timeout must be zero or not have passed'\n  if mem[480] <= channels[address(user)].field_1536:\n      revert with 0, 'global txCount must be higher than the current global txCount'\n  if mem[512] < channels[address(user)].field_1792:\n      revert with 0, 'onchain txCount must be higher or equal to the current onchain txCount'\n  require mem[128] + mem[96] >= mem[96]\n  if mem[128] + mem[96] > channels[address(user)].field_512:\n      revert with 0, 'wei must be conserved'\n  require mem[192] + mem[160] >= mem[160]\n  if mem[192] + mem[160] > channels[address(user)].field_1280:\n      revert with 0, 'tokens must be conserved'\n  require totalChannelWei <= eth.balance(this.address)\n  require mem[288] + mem[224] >= mem[224]\n  if mem[288] + mem[224] > eth.balance(this.address) - totalChannelWei:\n      revert with 0, 'insufficient reserve wei for deposits'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args address(this.address)\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= 0, ext_call.return_data[4 len 28]\n  require mem[416] + mem[352] >= mem[352]\n  if mem[416] + mem[352] > 0, ext_call.return_data[4 len 28] - totalChannelToken:\n      revert with 0, 'insufficient reserve tokens for deposits'\n  require mem[128] + mem[96] >= mem[96]\n  require mem[256] >= 0\n  require mem[320] >= 0\n  require mem[224] + channels[address(user)].field_512 >= channels[address(user)].field_512\n  require mem[288] >= 0\n  if mem[288] + mem[224] + channels[address(user)].field_512 < mem[320] + mem[256] + mem[128] + mem[96]:\n      revert with 0, 'insufficient wei'\n  require mem[192] + mem[160] >= mem[160]\n  require mem[384] >= 0\n  require mem[448] >= 0\n  require mem[352] + channels[address(user)].field_1280 >= channels[address(user)].field_1280\n  require mem[416] >= 0\n  if mem[416] + mem[352] + channels[address(user)].field_1280 < mem[448] + mem[384] + mem[192] + mem[160]:\n      revert with 0, 'insufficient token'\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyChannel(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 1:\n      revert with 0, 'channel must be in dispute'\n  if channels[address(user)].field_2816 >= block.timestamp:\n      if caller == channels[address(user)].field_2560:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      85,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed or msg.sender must be non-',\n                      'exit-initiating party' << 88\n      if hubAddress != caller:\n          if user != caller:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          85,\n                          0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                          'assed or msg.sender must be non-',\n                          'exit-initiating party' << 88\n  require channels[address(user)].field_0 <= channels[address(user)].field_512\n  require channels[address(user)].field_256 <= channels[address(user)].field_512 - channels[address(user)].field_0\n  channels[address(user)].field_512 = channels[address(user)].field_512 - channels[address(user)].field_0 - channels[address(user)].field_256\n  require channels[address(user)].field_768 <= channels[address(user)].field_1280\n  require channels[address(user)].field_1024 <= channels[address(user)].field_1280 - channels[address(user)].field_768\n  channels[address(user)].field_1280 = channels[address(user)].field_1280 - channels[address(user)].field_768 - channels[address(user)].field_1024\n  require channels[address(user)].field_0 <= totalChannelWei\n  require channels[address(user)].field_256 <= totalChannelWei - channels[address(user)].field_0\n  totalChannelWei = totalChannelWei - channels[address(user)].field_0 - channels[address(user)].field_256\n  call user with:\n     value channels[address(user)].field_256 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  channels[address(user)].field_0 = 0\n  channels[address(user)].field_256 = 0\n  require channels[address(user)].field_768 <= totalChannelToken\n  require channels[address(user)].field_1024 <= totalChannelToken - channels[address(user)].field_768\n  totalChannelToken = totalChannelToken - channels[address(user)].field_768 - channels[address(user)].field_1024\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args address(user), channels[address(user)].field_1024\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'user token withdrawal transfer failed'\n  channels[address(user)].field_768 = 0\n  channels[address(user)].field_1024 = 0\n  if channels[address(user)].field_2304 > 0:\n      channels[address(user)].field_3072 = 2\n  else:\n      channels[address(user)].field_2816 = 0\n      channels[address(user)].field_3072 = 0\n  channels[address(user)].field_2560 = 0\n  idx = 0\n  s = 6\n  t = ceil32(return_data.size) + 384\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  if caller == hubAddress:\n      log 0x70ff678d: 0, channels[address(user)].field_256, channels[address(user)].field_1024, mem[ceil32(return_data.size) + 384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  else:\n      log 0x70ff678d: 1, channels[address(user)].field_256, channels[address(user)].field_1024, mem[ceil32(return_data.size) + 384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  stor7 = 0\n\ndef startExitThread(address user, address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig): # not payable\n  require calldata.size - 4 >=\u2032 320\n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  require cd[292] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[292] + 35\n  require ('cd', 292).length <= LOCK8605463013()\n  require ceil32(('cd', 292).length) + 288 >= 256 and ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288 <= LOCK8605463013()\n  require cd[292] + ('cd', 292).length + 36 <= calldata.size\n  mem[ceil32(('cd', 260).length) + 288 len ('cd', 292).length] = call.data[cd[292] + 36 len ('cd', 292).length]\n  mem[('cd', 292).length + ceil32(('cd', 260).length) + 288] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue phase'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0, 'thread exit initiator must be user or hub'\n  if user != sender:\n      if user != receiver:\n          revert with 0, 'user must be thread sender or receiver'\n  if mem[128]:\n      revert with 0, 'initial receiver balances must be zero'\n  if mem[192]:\n      revert with 0, 'initial receiver balances must be zero'\n  mem[0] = threadId\n  mem[32] = sha3(address(receiver), sha3(address(sender), 6))\n  if stor6[address(sender)][address(receiver)][threadId].field_1280:\n      revert with 0, 'thread closing time must be zero'\n  if receiver == sender:\n      revert with 0, 'sender can not be receiver'\n  if hubAddress == sender:\n      revert with 0, 'hub can not be sender or receiver'\n  if hubAddress == receiver:\n      revert with 0, 'hub can not be sender or receiver'\n  if this.address == sender:\n      revert with 0, 'channel manager can not be sender or receiver'\n  if this.address == receiver:\n      revert with 0, 'channel manager can not be sender or receiver'\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 320] = address(this.address)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 340] = address(sender)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 360] = address(receiver)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 380] = threadId\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 412 len 64] = mem[96 len 64]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 476 len 64] = mem[160 len 64]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 540] = 0\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288] = 252\n  mem[64] = ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572 len floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)])] = mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 320 len floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)])]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 572] = mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 572] and 256^(-(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)] % 32) + 32) - 1 or mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 320] and !(256^(-(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)] % 32) + 32) - 1)\n  require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n  delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n       gas gas_remaining wei\n      args sha3(mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572 len Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]]), Array(len=('cd', 292).length, data=call.data[cd[292] + 36 len ('cd', 292).length]), sender\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not delegate.return_data[0]:\n      revert with 0, 'signature invalid'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef challengeThread(address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount, string sig): # not payable\n  require calldata.size - 4 >=\u2032 288\n  require calldata.size >\u2032 131\n  require 164 <= calldata.size\n  idx = 0\n  s = 100\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 195\n  require 228 <= calldata.size\n  idx = 0\n  s = 164\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  mem[224] = ('cd', 260).length\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  mem[256 len ('cd', 260).length] = call.data[cd[260] + 36 len ('cd', 260).length]\n  mem[('cd', 260).length + 256] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress != caller:\n      if sender != caller:\n          if receiver != caller:\n              revert with 0, 'only hub, sender, or receiver can call this function'\n      if block.timestamp >= stor6[address(sender)][address(receiver)][threadId].field_1280:\n          revert with 0, 'thread closing time must not have passed'\n      if cd[228] <= stor6[address(sender)][address(receiver)][threadId].field_1024:\n          revert with 0, 'thread txCount must be higher than the current thread txCount'\n      require stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0 >= stor6[address(sender)][address(receiver)][threadId].field_0\n      require mem[128] + mem[96] >= mem[96]\n      if mem[128] + mem[96] != stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0:\n          revert with 0, 'updated wei balances must match sum of thread wei balances'\n      require stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512 >= stor6[address(sender)][address(receiver)][threadId].field_512\n      require mem[192] + mem[160] >= mem[160]\n      if mem[192] + mem[160] != stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512:\n          revert with 0, 'updated token balances must match sum of thread token balances'\n      if mem[128] < stor6[address(sender)][address(receiver)][threadId].field_256:\n          revert with 0, 'receiver balances may never decrease'\n      if mem[192] < stor6[address(sender)][address(receiver)][threadId].field_768:\n          revert with 0, 'receiver balances may never decrease'\n      mem[ceil32(('cd', 260).length) + 256] = 0\n      if receiver == sender:\n          revert with 0, 'sender can not be receiver'\n      if hubAddress == sender:\n          revert with 0, 'hub can not be sender or receiver'\n      if hubAddress == receiver:\n          revert with 0, 'hub can not be sender or receiver'\n      if this.address == sender:\n          revert with 0, 'channel manager can not be sender or receiver'\n      if this.address == receiver:\n          revert with 0, 'channel manager can not be sender or receiver'\n      mem[ceil32(('cd', 260).length) + 572 len 224] = this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228])\n      mem[ceil32(('cd', 260).length) + 796 len 28] = Mask(224, 0, cd[228])\n      mem[ceil32(('cd', 260).length) + 608] = 96\n      mem[ceil32(('cd', 260).length) + 672] = ('cd', 260).length\n      mem[ceil32(('cd', 260).length) + 704 len ceil32(('cd', 260).length)] = call.data[cd[260] + 36 len ('cd', 260).length], mem[('cd', 260).length + 256 len ceil32(('cd', 260).length) - ('cd', 260).length]\n      if ceil32(('cd', 260).length) > ('cd', 260).length:\n          mem[ceil32(('cd', 260).length) + ('cd', 260).length + 704] = 0\n      mem[ceil32(('cd', 260).length) + 640] = sender\n      require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n      delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n           gas gas_remaining wei\n          args sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228])), Array(len=('cd', 260).length, data=call.data[cd[260] + 36 len ('cd', 260).length]), sender\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >=\u2032 32\n      if not delegate.return_data[0]:\n          revert with 0, 'signature invalid'\n      s = 0\n      idx = 96\n      while 160 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 2\n      while 2 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      s = 2\n      idx = 160\n      while 224 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      while 4 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      stor6[address(sender)][address(receiver)][threadId].field_1024 = cd[228]\n      idx = 0\n      s = 0\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 636\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      idx = 0\n      s = 2\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 700\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      log DidChallengeThread(address sender, address receiver, uint256 threadId, address senderAddress, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount):\n                             threadId,\n                             caller,\n                             mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 636 len 128],\n                             cd[228],\n                             sender,\n                             receiver,\n  else:\n      if block.timestamp >= stor6[address(sender)][address(receiver)][threadId].field_1280:\n          revert with 0, 'thread closing time must not have passed'\n      if cd[228] <= stor6[address(sender)][address(receiver)][threadId].field_1024:\n          revert with 0, 'thread txCount must be higher than the current thread txCount'\n      require stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0 >= stor6[address(sender)][address(receiver)][threadId].field_0\n      require mem[128] + mem[96] >= mem[96]\n      if mem[128] + mem[96] != stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0:\n          revert with 0, 'updated wei balances must match sum of thread wei balances'\n      require stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512 >= stor6[address(sender)][address(receiver)][threadId].field_512\n      require mem[192] + mem[160] >= mem[160]\n      if mem[192] + mem[160] != stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512:\n          revert with 0, 'updated token balances must match sum of thread token balances'\n      if mem[128] < stor6[address(sender)][address(receiver)][threadId].field_256:\n          revert with 0, 'receiver balances may never decrease'\n      if mem[192] < stor6[address(sender)][address(receiver)][threadId].field_768:\n          revert with 0, 'receiver balances may never decrease'\n      mem[ceil32(('cd', 260).length) + 256] = 0\n      if receiver == sender:\n          revert with 0, 'sender can not be receiver'\n      if hubAddress == sender:\n          revert with 0, 'hub can not be sender or receiver'\n      if hubAddress == receiver:\n          revert with 0, 'hub can not be sender or receiver'\n      if this.address == sender:\n          revert with 0, 'channel manager can not be sender or receiver'\n      if this.address == receiver:\n          revert with 0, 'channel manager can not be sender or receiver'\n      mem[ceil32(('cd', 260).length) + 320] = address(this.address)\n      mem[ceil32(('cd', 260).length) + 340] = address(sender)\n      mem[ceil32(('cd', 260).length) + 360] = address(receiver)\n      mem[ceil32(('cd', 260).length) + 380] = threadId\n      mem[ceil32(('cd', 260).length) + 412 len 64] = mem[96 len 64]\n      mem[ceil32(('cd', 260).length) + 476 len 64] = mem[160 len 64]\n      mem[ceil32(('cd', 260).length) + 540] = cd[228]\n      mem[ceil32(('cd', 260).length) + 288] = 252\n      mem[ceil32(('cd', 260).length) + 572 len 224] = this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228])\n      mem[ceil32(('cd', 260).length) + 796 len 28] = Mask(224, 0, cd[228])\n      mem[ceil32(('cd', 260).length) + 576] = sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228]))\n      mem[ceil32(('cd', 260).length) + 608] = 96\n      mem[ceil32(('cd', 260).length) + 672] = ('cd', 260).length\n      mem[ceil32(('cd', 260).length) + 704 len ceil32(('cd', 260).length)] = call.data[cd[260] + 36 len ('cd', 260).length], mem[('cd', 260).length + 256 len ceil32(('cd', 260).length) - ('cd', 260).length]\n      if ceil32(('cd', 260).length) > ('cd', 260).length:\n          mem[ceil32(('cd', 260).length) + ('cd', 260).length + 704] = 0\n      mem[ceil32(('cd', 260).length) + 640] = sender\n      require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n      delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n           gas gas_remaining wei\n          args sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228])), Array(len=('cd', 260).length, data=call.data[cd[260] + 36 len ('cd', 260).length]), sender\n      mem[ceil32(('cd', 260).length) + 572] = delegate.return_data[0]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[64] = ceil32(('cd', 260).length) + ceil32(return_data.size) + 572\n      require return_data.size >=\u2032 32\n      if not delegate.return_data[0]:\n          revert with 0, 'signature invalid'\n      s = 0\n      idx = 96\n      while 160 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 2\n      while 2 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      s = 2\n      idx = 160\n      while 224 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      while 4 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      stor6[address(sender)][address(receiver)][threadId].field_1024 = cd[228]\n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 572] = threadId\n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 604] = caller\n      idx = 0\n      s = 0\n      t = mem[64] + 64\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      idx = 0\n      s = 2\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 700\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 764] = cd[228]\n      log DidChallengeThread(address sender, address receiver, uint256 threadId, address senderAddress, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount):\n                             mem[mem[64] len ceil32(('cd', 260).length) + ceil32(return_data.size) + -mem[64] + 796],\n                             sender,\n                             receiver,\n  stor7 = 0\n\ndef startExitThreadWithUpdate(address user, address[2] threadMembers, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig, uint256[2] updatedWeiBalances, uint256[2] updatedTokenBalances, uint256 updatedTxCount, string updateSig): # not payable\n  require calldata.size - 4 >=\u2032 512\n  require calldata.size >\u2032 67\n  require 100 <= calldata.size\n  idx = 0\n  s = 36\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require updatedTokenBalances <= LOCK8605463013()\n  require calldata.size >\u2032 updatedTokenBalances + 35\n  require updatedTokenBalances.length <= LOCK8605463013()\n  require ceil32(updatedTokenBalances.length) + 320 >= 288 and ceil32(updatedTokenBalances.length) + 320 <= LOCK8605463013()\n  mem[288] = updatedTokenBalances.length\n  require updatedTokenBalances + updatedTokenBalances.length + 36 <= calldata.size\n  mem[320 len updatedTokenBalances.length] = updatedTokenBalances[all]\n  mem[updatedTokenBalances.length + 320] = 0\n  require updatedTxCount <= LOCK8605463013()\n  require calldata.size >\u2032 updatedTxCount + 35\n  require updatedTxCount.length <= LOCK8605463013()\n  require ceil32(updatedTxCount.length) + 352 >= 320 and ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352 <= LOCK8605463013()\n  mem[ceil32(updatedTokenBalances.length) + 320] = updatedTxCount.length\n  require updatedTxCount + updatedTxCount.length + 36 <= calldata.size\n  mem[ceil32(updatedTokenBalances.length) + 352 len updatedTxCount.length] = updatedTxCount[all]\n  mem[updatedTxCount.length + ceil32(updatedTokenBalances.length) + 352] = 0\n  require calldata.size >\u2032 355\n  require bool(ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416 <= LOCK8605463013())\n  require 388 <= calldata.size\n  idx = 0\n  s = 324\n  t = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 419\n  require bool(ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 480 <= LOCK8605463013())\n  require 452 <= calldata.size\n  idx = 0\n  s = 388\n  t = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[484] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[484] + 35\n  require ('cd', 484).length <= LOCK8605463013()\n  require ceil32(('cd', 484).length) + 512 >= 480 and ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512 <= LOCK8605463013()\n  mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 480] = ('cd', 484).length\n  require cd[484] + ('cd', 484).length + 36 <= calldata.size\n  mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 512 len ('cd', 484).length] = call.data[cd[484] + 36 len ('cd', 484).length]\n  mem[('cd', 484).length + ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 512] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue phase'\n  if caller == hubAddress:\n      if mem[108 len 20] == user:\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _821 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _821\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _821, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _821, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n      else:\n          if mem[140 len 20] != user:\n              revert with 0, 'user must be thread sender or receiver'\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _826 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _826\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _826, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _826, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n  else:\n      if user != caller:\n          revert with 0, 'thread exit initiator must be user or hub'\n      if mem[108 len 20] == user:\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _831 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _831\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _831, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _831, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n      else:\n          if mem[140 len 20] != user:\n              revert with 0, 'user must be thread sender or receiver'\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _836 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _836\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _836, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _836, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst NAME = '', 0\nconst VERSION = '', 0\n\ndef storage:\n  hubAddress is address at storage 0\n  challengePeriod is uint256 at storage 1\n  approvedTokenAddress is address at storage 2\n  totalChannelWei is uint256 at storage 3\n  totalChannelToken is uint256 at storage 4\n  channels is mapping of struct at storage 5\n  stor6 is mapping of struct at storage 6\n  stor7 is uint8 at storage 7\n\ndef totalChannelWei(): # not payable\n  return totalChannelWei\n\ndef totalChannelToken(): # not payable\n  return totalChannelToken\n\ndef hub(): # not payable\n  return hubAddress\n\ndef channels(address _param1): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require channels[_param1].field_3072 < 3\n  return channels[_param1].field_2048, \n         channels[_param1].field_2304,\n         channels[_param1].field_2560,\n         channels[_param1].field_2816,\n         channels[_param1].field_3072\n\ndef approvedToken(): # not payable\n  return approvedTokenAddress\n\ndef challengePeriod(): # not payable\n  return challengePeriod\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  stop\n\ndef getHubReserveWei(): # not payable\n  require totalChannelWei <= eth.balance(this.address)\n  return (eth.balance(this.address) - totalChannelWei)\n\ndef getHubReserveTokens(): # not payable\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= ext_call.return_data[0]\n  return (ext_call.return_data[0] - totalChannelToken)\n\ndef getChannelBalances(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  idx = 1024\n  s = 0\n  while 1120 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1120\n  s = 3\n  while 1216 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1216\n  s = 6\n  while 1280 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if channels[address(user)].field_3072 <= 2:\n      return channels[address(user)].field_0, mem[1056], mem[1088], channels[address(user)].field_768, mem[1152], mem[1184]\n  revert\n\ndef hubContractWithdraw(uint256 weiAmount, uint256 tokenAmount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require hubAddress == caller\n  require totalChannelWei <= eth.balance(this.address)\n  if eth.balance(this.address) - totalChannelWei < weiAmount:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  'hubContractWithdraw: Contract wei funds not sufficient to withdraw'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args this.address\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= ext_call.return_data[0]\n  if ext_call.return_data[0] - totalChannelToken < tokenAmount:\n      revert with 0, 'hubContractWithdraw: Contract token funds not sufficient to withdraw'\n  call hubAddress with:\n     value weiAmount wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args hubAddress, tokenAmount\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'hubContractWithdraw: Token transfer failure'\n  log DidHubContractWithdraw(\n        uint256 weiAmount=weiAmount,\n        uint256 tokenAmount=tokenAmount)\n  stor7 = 0\n\ndef startExit(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072:\n      revert with 0, 'channel must be open'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'exit initiator must be user or hub'\n  channels[address(user)].field_2560 = caller\n  require challengePeriod + block.timestamp >= block.timestamp\n  channels[address(user)].field_2816 = challengePeriod + block.timestamp\n  channels[address(user)].field_3072 = 1\n  idx = 0\n  s = 6\n  t = 384\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  if hubAddress == caller:\n      log 0x746e6511: 0, channels[address(user)].field_256, channels[address(user)].field_1024, mem[384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  else:\n      log 0x746e6511: 1, channels[address(user)].field_256, channels[address(user)].field_1024, mem[384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  stor7 = 0\n\ndef getChannelDetails(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  idx = 1024\n  s = 0\n  while 1120 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1120\n  s = 3\n  while 1216 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  idx = 1216\n  s = 6\n  while 1280 > idx + 32:\n      mem[idx + 32] = channels[address(user)][s].field_256\n      idx = idx + 32\n      s = s + 1\n      continue \n  if channels[address(user)].field_3072 <= 2:\n      if channels[address(user)].field_3072 < 3:\n          return channels[address(user)].field_1536, \n                 mem[1248],\n                 channels[address(user)].field_2048,\n                 channels[address(user)].field_2304,\n                 channels[address(user)].field_2560,\n                 channels[address(user)].field_2816,\n                 channels[address(user)].field_3072\n  revert\n\ndef startExitWithUpdate(address[2] user, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 672\n  require calldata.size >\u2032 35\n  require 68 <= calldata.size\n  idx = 0\n  s = 4\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 288\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 416\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 544\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 640 >= 608 and ceil32(('cd', 612).length) + 640 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  require cd[644] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[644] + 35\n  require ('cd', 644).length <= LOCK8605463013()\n  require ceil32(('cd', 644).length) + 672 >= 640 and ceil32(('cd', 612).length) + ceil32(('cd', 644).length) + 672 <= LOCK8605463013()\n  require cd[644] + ('cd', 644).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[mem[108 len 20]].field_3072 <= 2\n  if channels[mem[108 len 20]].field_3072:\n      revert with 0, 'channel must be open'\n  if hubAddress != caller:\n      if mem[108 len 20] != caller:\n          revert with 0, 'exit initiator must be user or hub'\n  if cd[580]:\n      revert with 0, 'can't start exit with time-sensitive states'\n  if hubAddress == mem[108 len 20]:\n      revert with 0, 'user can not be hub'\n  if this.address == mem[108 len 20]:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyThread(address user, address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig): # not payable\n  require calldata.size - 4 >=\u2032 320\n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  require cd[292] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[292] + 35\n  require ('cd', 292).length <= LOCK8605463013()\n  require ceil32(('cd', 292).length) + 288 >= 256 and ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288 <= LOCK8605463013()\n  require cd[292] + ('cd', 292).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0, 'only hub or user can empty thread'\n  if user != sender:\n      if user != receiver:\n          revert with 0, 'user must be thread sender or receiver'\n  if mem[128]:\n      revert with 0, 'initial receiver balances must be zero'\n  if mem[192]:\n      revert with 0, 'initial receiver balances must be zero'\n  if not stor6[address(sender)][address(receiver)][threadId].field_1280:\n      revert with 0, 'Thread closing time must have passed'\n  if stor6[address(sender)][address(receiver)][threadId].field_1280 >= block.timestamp:\n      revert with 0, 'Thread closing time must have passed'\n  if user == sender:\n      if stor6[address(sender)][address(receiver)][threadId].field_1536:\n          revert with 0, 'user cannot empty twice'\n  else:\n      if stor6[address(sender)][address(receiver)][threadId].field_1544:\n          revert with 0, 'user cannot empty twice'\n  if receiver == sender:\n      revert with 0, 'sender can not be receiver'\n  if hubAddress == sender:\n      revert with 0, 'hub can not be sender or receiver'\n  if hubAddress == receiver:\n      revert with 0, 'hub can not be sender or receiver'\n  if this.address == sender:\n      revert with 0, 'channel manager can not be sender or receiver'\n  if this.address == receiver:\n      revert with 0, 'channel manager can not be sender or receiver'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyChannelWithChallenge(address[2] user, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 672\n  require calldata.size >\u2032 35\n  require 68 <= calldata.size\n  idx = 0\n  s = 4\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 288\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 416\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 544\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 640 >= 608 and ceil32(('cd', 612).length) + 640 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  require cd[644] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[644] + 35\n  require ('cd', 644).length <= LOCK8605463013()\n  require ceil32(('cd', 644).length) + 672 >= 640 and ceil32(('cd', 612).length) + ceil32(('cd', 644).length) + 672 <= LOCK8605463013()\n  require cd[644] + ('cd', 644).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[mem[108 len 20]].field_3072 <= 2\n  if channels[mem[108 len 20]].field_3072 != 1:\n      revert with 0, 'channel must be in dispute'\n  if block.timestamp >= channels[mem[108 len 20]].field_2816:\n      revert with 0, 'channel closing time must not have passed'\n  if caller == channels[mem[108 len 20]].field_2560:\n      revert with 0, 'challenger can not be exit initiator'\n  if hubAddress != caller:\n      if mem[108 len 20] != caller:\n          revert with 0, 'challenger must be either user or hub'\n  if cd[580]:\n      revert with 0, 'can't start exit with time-sensitive states'\n  if hubAddress == mem[108 len 20]:\n      revert with 0, 'user can not be hub'\n  if this.address == mem[108 len 20]:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef nukeThreads(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'channel must be in thread dispue'\n  if not challengePeriod:\n      require channels[address(user)].field_2816 >= channels[address(user)].field_2816\n      if channels[address(user)].field_2816 >= block.timestamp:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      61,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed by 10 challenge periods'\n  else:\n      require 10 * challengePeriod / challengePeriod == 10\n      require (10 * challengePeriod) + channels[address(user)].field_2816 >= channels[address(user)].field_2816\n      if (10 * challengePeriod) + channels[address(user)].field_2816 >= block.timestamp:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      61,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed by 10 challenge periods'\n  require channels[address(user)].field_512 <= totalChannelWei\n  totalChannelWei -= channels[address(user)].field_512\n  call user with:\n     value channels[address(user)].field_512 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  channels[address(user)].field_512 = 0\n  require channels[address(user)].field_1280 <= totalChannelToken\n  totalChannelToken -= channels[address(user)].field_1280\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args address(user), channels[address(user)].field_1280\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'user token withdrawal transfer failed'\n  channels[address(user)].field_1280 = 0\n  channels[address(user)].field_2304 = 0\n  channels[address(user)].field_2048 = 0\n  channels[address(user)].field_2816 = 0\n  channels[address(user)].field_3072 = 0\n  idx = 0\n  s = 6\n  t = ceil32(return_data.size) + 448\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  log DidNukeThreads(\n        address user=caller,\n        address senderAddress=channels[address(user)].field_512,\n        uint256 weiAmount=channels[address(user)].field_1280,\n        uint256 tokenAmount=channels[address(user)].field_256,\n        uint256[2] channelWeiBalances=channels[address(user)].field_1024,\n        uint256[2] channelTokenBalances=mem[ceil32(return_data.size) + 448 len 64],\n        uint256[2] channelTxCount=0,\n        bytes32 channelThreadRoot=0,\n        uint256 channelThreadCount=user)\n  stor7 = 0\n\ndef userAuthorizedUpdate(address recipient, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigHub) payable: \n  require calldata.size - 4 >=\u2032 608\n  require calldata.size >\u2032 67\n  require 100 <= calldata.size\n  idx = 0\n  s = 36\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 131\n  require 164 <= calldata.size\n  idx = 0\n  s = 100\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 195\n  require 292 <= calldata.size\n  idx = 0\n  s = 164\n  t = 224\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 323\n  require 420 <= calldata.size\n  idx = 0\n  s = 292\n  t = 352\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 451\n  require 484 <= calldata.size\n  idx = 0\n  s = 420\n  t = 480\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[580] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[580] + 35\n  require ('cd', 580).length <= LOCK8605463013()\n  require ceil32(('cd', 580).length) + 576 >= 544 and ceil32(('cd', 580).length) + 576 <= LOCK8605463013()\n  require cd[580] + ('cd', 580).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if mem[288] != call.value:\n      revert with 0, 'msg.value is not equal to pending user deposit'\n  require channels[caller].field_3072 <= 2\n  if channels[caller].field_3072:\n      revert with 0, 'channel must be open'\n  if cd[548]:\n      if block.timestamp >= cd[548]:\n          revert with 0, 'the timeout must be zero or not have passed'\n  if mem[480] <= channels[caller].field_1536:\n      revert with 0, 'global txCount must be higher than the current global txCount'\n  if mem[512] < channels[caller].field_1792:\n      revert with 0, 'onchain txCount must be higher or equal to the current onchain txCount'\n  require mem[128] + mem[96] >= mem[96]\n  if mem[128] + mem[96] > channels[caller].field_512:\n      revert with 0, 'wei must be conserved'\n  require mem[192] + mem[160] >= mem[160]\n  if mem[192] + mem[160] > channels[caller].field_1280:\n      revert with 0, 'tokens must be conserved'\n  require totalChannelWei <= eth.balance(this.address)\n  if mem[224] > eth.balance(this.address) - totalChannelWei:\n      revert with 0, 'insufficient reserve wei for deposits'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args address(this.address)\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= 0, ext_call.return_data[4 len 28]\n  if mem[352] > 0, ext_call.return_data[4 len 28] - totalChannelToken:\n      revert with 0, 'insufficient reserve tokens for deposits'\n  require mem[128] + mem[96] >= mem[96]\n  require mem[256] >= 0\n  require mem[320] >= 0\n  require mem[224] + channels[caller].field_512 >= channels[caller].field_512\n  require mem[288] >= 0\n  if mem[288] + mem[224] + channels[caller].field_512 < mem[320] + mem[256] + mem[128] + mem[96]:\n      revert with 0, 'insufficient wei'\n  require mem[192] + mem[160] >= mem[160]\n  require mem[384] >= 0\n  require mem[448] >= 0\n  require mem[352] + channels[caller].field_1280 >= channels[caller].field_1280\n  require mem[416] >= 0\n  if mem[416] + mem[352] + channels[caller].field_1280 < mem[448] + mem[384] + mem[192] + mem[160]:\n      revert with 0, 'insufficient token'\n  if hubAddress == caller:\n      revert with 0, 'user can not be hub'\n  if this.address == caller:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef hubAuthorizedUpdate(address user, address recipient, uint256[2] weiBalances, uint256[2] tokenBalances, uint256[4] pendingWeiUpdates, uint256[4] pendingTokenUpdates, uint256[2] txCount, bytes32 threadRoot, uint256 threadCount, uint256 timeout, string sigUser): # not payable\n  require calldata.size - 4 >=\u2032 640\n  require calldata.size >\u2032 99\n  require 132 <= calldata.size\n  idx = 0\n  s = 68\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 324 <= calldata.size\n  idx = 0\n  s = 196\n  t = 224\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 355\n  require 452 <= calldata.size\n  idx = 0\n  s = 324\n  t = 352\n  while idx < 4:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 483\n  require 516 <= calldata.size\n  idx = 0\n  s = 452\n  t = 480\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[612] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[612] + 35\n  require ('cd', 612).length <= LOCK8605463013()\n  require ceil32(('cd', 612).length) + 576 >= 544 and ceil32(('cd', 612).length) + 576 <= LOCK8605463013()\n  require cd[612] + ('cd', 612).length + 36 <= calldata.size\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require hubAddress == caller\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072:\n      revert with 0, 'channel must be open'\n  if cd[580]:\n      if block.timestamp >= cd[580]:\n          revert with 0, 'the timeout must be zero or not have passed'\n  if mem[480] <= channels[address(user)].field_1536:\n      revert with 0, 'global txCount must be higher than the current global txCount'\n  if mem[512] < channels[address(user)].field_1792:\n      revert with 0, 'onchain txCount must be higher or equal to the current onchain txCount'\n  require mem[128] + mem[96] >= mem[96]\n  if mem[128] + mem[96] > channels[address(user)].field_512:\n      revert with 0, 'wei must be conserved'\n  require mem[192] + mem[160] >= mem[160]\n  if mem[192] + mem[160] > channels[address(user)].field_1280:\n      revert with 0, 'tokens must be conserved'\n  require totalChannelWei <= eth.balance(this.address)\n  require mem[288] + mem[224] >= mem[224]\n  if mem[288] + mem[224] > eth.balance(this.address) - totalChannelWei:\n      revert with 0, 'insufficient reserve wei for deposits'\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.balanceOf(address account) with:\n       gas gas_remaining wei\n      args address(this.address)\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  require totalChannelToken <= 0, ext_call.return_data[4 len 28]\n  require mem[416] + mem[352] >= mem[352]\n  if mem[416] + mem[352] > 0, ext_call.return_data[4 len 28] - totalChannelToken:\n      revert with 0, 'insufficient reserve tokens for deposits'\n  require mem[128] + mem[96] >= mem[96]\n  require mem[256] >= 0\n  require mem[320] >= 0\n  require mem[224] + channels[address(user)].field_512 >= channels[address(user)].field_512\n  require mem[288] >= 0\n  if mem[288] + mem[224] + channels[address(user)].field_512 < mem[320] + mem[256] + mem[128] + mem[96]:\n      revert with 0, 'insufficient wei'\n  require mem[192] + mem[160] >= mem[160]\n  require mem[384] >= 0\n  require mem[448] >= 0\n  require mem[352] + channels[address(user)].field_1280 >= channels[address(user)].field_1280\n  require mem[416] >= 0\n  if mem[416] + mem[352] + channels[address(user)].field_1280 < mem[448] + mem[384] + mem[192] + mem[160]:\n      revert with 0, 'insufficient token'\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef emptyChannel(address user): # not payable\n  require calldata.size - 4 >=\u2032 32\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress == user:\n      revert with 0, 'user can not be hub'\n  if this.address == user:\n      revert with 0, 'user can not be channel manager'\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 1:\n      revert with 0, 'channel must be in dispute'\n  if channels[address(user)].field_2816 >= block.timestamp:\n      if caller == channels[address(user)].field_2560:\n          revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                      32,\n                      85,\n                      0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                      'assed or msg.sender must be non-',\n                      'exit-initiating party' << 88\n      if hubAddress != caller:\n          if user != caller:\n              revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                          32,\n                          85,\n                          0x1c6368616e6e656c20636c6f73696e672074696d65206d757374206861766520,\n                          'assed or msg.sender must be non-',\n                          'exit-initiating party' << 88\n  require channels[address(user)].field_0 <= channels[address(user)].field_512\n  require channels[address(user)].field_256 <= channels[address(user)].field_512 - channels[address(user)].field_0\n  channels[address(user)].field_512 = channels[address(user)].field_512 - channels[address(user)].field_0 - channels[address(user)].field_256\n  require channels[address(user)].field_768 <= channels[address(user)].field_1280\n  require channels[address(user)].field_1024 <= channels[address(user)].field_1280 - channels[address(user)].field_768\n  channels[address(user)].field_1280 = channels[address(user)].field_1280 - channels[address(user)].field_768 - channels[address(user)].field_1024\n  require channels[address(user)].field_0 <= totalChannelWei\n  require channels[address(user)].field_256 <= totalChannelWei - channels[address(user)].field_0\n  totalChannelWei = totalChannelWei - channels[address(user)].field_0 - channels[address(user)].field_256\n  call user with:\n     value channels[address(user)].field_256 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  channels[address(user)].field_0 = 0\n  channels[address(user)].field_256 = 0\n  require channels[address(user)].field_768 <= totalChannelToken\n  require channels[address(user)].field_1024 <= totalChannelToken - channels[address(user)].field_768\n  totalChannelToken = totalChannelToken - channels[address(user)].field_768 - channels[address(user)].field_1024\n  require ext_code.size(approvedTokenAddress)\n  call approvedTokenAddress.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining wei\n      args address(user), channels[address(user)].field_1024\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not ext_call.return_data[0]:\n      revert with 0, 'user token withdrawal transfer failed'\n  channels[address(user)].field_768 = 0\n  channels[address(user)].field_1024 = 0\n  if channels[address(user)].field_2304 > 0:\n      channels[address(user)].field_3072 = 2\n  else:\n      channels[address(user)].field_2816 = 0\n      channels[address(user)].field_3072 = 0\n  channels[address(user)].field_2560 = 0\n  idx = 0\n  s = 6\n  t = ceil32(return_data.size) + 384\n  while idx < 2:\n      mem[t] = channels[address(user)][s].field_0\n      idx = idx + 1\n      s = s + 1\n      t = t + 32\n      continue \n  if caller == hubAddress:\n      log 0x70ff678d: 0, channels[address(user)].field_256, channels[address(user)].field_1024, mem[ceil32(return_data.size) + 384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  else:\n      log 0x70ff678d: 1, channels[address(user)].field_256, channels[address(user)].field_1024, mem[ceil32(return_data.size) + 384 len 64], channels[address(user)].field_2048, channels[address(user)].field_2304, user\n  stor7 = 0\n\ndef startExitThread(address user, address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig): # not payable\n  require calldata.size - 4 >=\u2032 320\n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  require cd[292] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[292] + 35\n  require ('cd', 292).length <= LOCK8605463013()\n  require ceil32(('cd', 292).length) + 288 >= 256 and ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288 <= LOCK8605463013()\n  require cd[292] + ('cd', 292).length + 36 <= calldata.size\n  mem[ceil32(('cd', 260).length) + 288 len ('cd', 292).length] = call.data[cd[292] + 36 len ('cd', 292).length]\n  mem[('cd', 292).length + ceil32(('cd', 260).length) + 288] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue phase'\n  if hubAddress != caller:\n      if user != caller:\n          revert with 0, 'thread exit initiator must be user or hub'\n  if user != sender:\n      if user != receiver:\n          revert with 0, 'user must be thread sender or receiver'\n  if mem[128]:\n      revert with 0, 'initial receiver balances must be zero'\n  if mem[192]:\n      revert with 0, 'initial receiver balances must be zero'\n  mem[0] = threadId\n  mem[32] = sha3(address(receiver), sha3(address(sender), 6))\n  if stor6[address(sender)][address(receiver)][threadId].field_1280:\n      revert with 0, 'thread closing time must be zero'\n  if receiver == sender:\n      revert with 0, 'sender can not be receiver'\n  if hubAddress == sender:\n      revert with 0, 'hub can not be sender or receiver'\n  if hubAddress == receiver:\n      revert with 0, 'hub can not be sender or receiver'\n  if this.address == sender:\n      revert with 0, 'channel manager can not be sender or receiver'\n  if this.address == receiver:\n      revert with 0, 'channel manager can not be sender or receiver'\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 320] = address(this.address)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 340] = address(sender)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 360] = address(receiver)\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 380] = threadId\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 412 len 64] = mem[96 len 64]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 476 len 64] = mem[160 len 64]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 540] = 0\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 288] = 252\n  mem[64] = ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572 len floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)])] = mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 320 len floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)])]\n  mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 572] = mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 572] and 256^(-(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)] % 32) + 32) - 1 or mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + floor32(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]) + 320] and !(256^(-(Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)] % 32) + 32) - 1)\n  require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n  delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n       gas gas_remaining wei\n      args sha3(mem[ceil32(('cd', 260).length) + ceil32(('cd', 292).length) + 572 len Mask(8 * -ceil32(('cd', 292).length) + ('cd', 292).length + 32, 0, 0), mem[ceil32(('cd', 260).length) + ('cd', 292).length + 320 len -('cd', 292).length + ceil32(('cd', 292).length)]]), Array(len=('cd', 292).length, data=call.data[cd[292] + 36 len ('cd', 292).length]), sender\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  require return_data.size >=\u2032 32\n  if not delegate.return_data[0]:\n      revert with 0, 'signature invalid'\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef challengeThread(address sender, address receiver, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount, string sig): # not payable\n  require calldata.size - 4 >=\u2032 288\n  require calldata.size >\u2032 131\n  require 164 <= calldata.size\n  idx = 0\n  s = 100\n  t = 96\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 195\n  require 228 <= calldata.size\n  idx = 0\n  s = 164\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[260] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[260] + 35\n  require ('cd', 260).length <= LOCK8605463013()\n  require ceil32(('cd', 260).length) + 256 >= 224 and ceil32(('cd', 260).length) + 256 <= LOCK8605463013()\n  mem[224] = ('cd', 260).length\n  require cd[260] + ('cd', 260).length + 36 <= calldata.size\n  mem[256 len ('cd', 260).length] = call.data[cd[260] + 36 len ('cd', 260).length]\n  mem[('cd', 260).length + 256] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  if hubAddress != caller:\n      if sender != caller:\n          if receiver != caller:\n              revert with 0, 'only hub, sender, or receiver can call this function'\n      if block.timestamp >= stor6[address(sender)][address(receiver)][threadId].field_1280:\n          revert with 0, 'thread closing time must not have passed'\n      if cd[228] <= stor6[address(sender)][address(receiver)][threadId].field_1024:\n          revert with 0, 'thread txCount must be higher than the current thread txCount'\n      require stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0 >= stor6[address(sender)][address(receiver)][threadId].field_0\n      require mem[128] + mem[96] >= mem[96]\n      if mem[128] + mem[96] != stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0:\n          revert with 0, 'updated wei balances must match sum of thread wei balances'\n      require stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512 >= stor6[address(sender)][address(receiver)][threadId].field_512\n      require mem[192] + mem[160] >= mem[160]\n      if mem[192] + mem[160] != stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512:\n          revert with 0, 'updated token balances must match sum of thread token balances'\n      if mem[128] < stor6[address(sender)][address(receiver)][threadId].field_256:\n          revert with 0, 'receiver balances may never decrease'\n      if mem[192] < stor6[address(sender)][address(receiver)][threadId].field_768:\n          revert with 0, 'receiver balances may never decrease'\n      mem[ceil32(('cd', 260).length) + 256] = 0\n      if receiver == sender:\n          revert with 0, 'sender can not be receiver'\n      if hubAddress == sender:\n          revert with 0, 'hub can not be sender or receiver'\n      if hubAddress == receiver:\n          revert with 0, 'hub can not be sender or receiver'\n      if this.address == sender:\n          revert with 0, 'channel manager can not be sender or receiver'\n      if this.address == receiver:\n          revert with 0, 'channel manager can not be sender or receiver'\n      mem[ceil32(('cd', 260).length) + 572 len 224] = this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228])\n      mem[ceil32(('cd', 260).length) + 796 len 28] = Mask(224, 0, cd[228])\n      mem[ceil32(('cd', 260).length) + 608] = 96\n      mem[ceil32(('cd', 260).length) + 672] = ('cd', 260).length\n      mem[ceil32(('cd', 260).length) + 704 len ceil32(('cd', 260).length)] = call.data[cd[260] + 36 len ('cd', 260).length], mem[('cd', 260).length + 256 len ceil32(('cd', 260).length) - ('cd', 260).length]\n      if ceil32(('cd', 260).length) > ('cd', 260).length:\n          mem[ceil32(('cd', 260).length) + ('cd', 260).length + 704] = 0\n      mem[ceil32(('cd', 260).length) + 640] = sender\n      require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n      delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n           gas gas_remaining wei\n          args sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228])), Array(len=('cd', 260).length, data=call.data[cd[260] + 36 len ('cd', 260).length]), sender\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      require return_data.size >=\u2032 32\n      if not delegate.return_data[0]:\n          revert with 0, 'signature invalid'\n      s = 0\n      idx = 96\n      while 160 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 2\n      while 2 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      s = 2\n      idx = 160\n      while 224 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      while 4 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      stor6[address(sender)][address(receiver)][threadId].field_1024 = cd[228]\n      idx = 0\n      s = 0\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 636\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      idx = 0\n      s = 2\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 700\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      log DidChallengeThread(address sender, address receiver, uint256 threadId, address senderAddress, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount):\n                             threadId,\n                             caller,\n                             mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 636 len 128],\n                             cd[228],\n                             sender,\n                             receiver,\n  else:\n      if block.timestamp >= stor6[address(sender)][address(receiver)][threadId].field_1280:\n          revert with 0, 'thread closing time must not have passed'\n      if cd[228] <= stor6[address(sender)][address(receiver)][threadId].field_1024:\n          revert with 0, 'thread txCount must be higher than the current thread txCount'\n      require stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0 >= stor6[address(sender)][address(receiver)][threadId].field_0\n      require mem[128] + mem[96] >= mem[96]\n      if mem[128] + mem[96] != stor6[address(sender)][address(receiver)][threadId].field_256 + stor6[address(sender)][address(receiver)][threadId].field_0:\n          revert with 0, 'updated wei balances must match sum of thread wei balances'\n      require stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512 >= stor6[address(sender)][address(receiver)][threadId].field_512\n      require mem[192] + mem[160] >= mem[160]\n      if mem[192] + mem[160] != stor6[address(sender)][address(receiver)][threadId].field_768 + stor6[address(sender)][address(receiver)][threadId].field_512:\n          revert with 0, 'updated token balances must match sum of thread token balances'\n      if mem[128] < stor6[address(sender)][address(receiver)][threadId].field_256:\n          revert with 0, 'receiver balances may never decrease'\n      if mem[192] < stor6[address(sender)][address(receiver)][threadId].field_768:\n          revert with 0, 'receiver balances may never decrease'\n      mem[ceil32(('cd', 260).length) + 256] = 0\n      if receiver == sender:\n          revert with 0, 'sender can not be receiver'\n      if hubAddress == sender:\n          revert with 0, 'hub can not be sender or receiver'\n      if hubAddress == receiver:\n          revert with 0, 'hub can not be sender or receiver'\n      if this.address == sender:\n          revert with 0, 'channel manager can not be sender or receiver'\n      if this.address == receiver:\n          revert with 0, 'channel manager can not be sender or receiver'\n      mem[ceil32(('cd', 260).length) + 320] = address(this.address)\n      mem[ceil32(('cd', 260).length) + 340] = address(sender)\n      mem[ceil32(('cd', 260).length) + 360] = address(receiver)\n      mem[ceil32(('cd', 260).length) + 380] = threadId\n      mem[ceil32(('cd', 260).length) + 412 len 64] = mem[96 len 64]\n      mem[ceil32(('cd', 260).length) + 476 len 64] = mem[160 len 64]\n      mem[ceil32(('cd', 260).length) + 540] = cd[228]\n      mem[ceil32(('cd', 260).length) + 288] = 252\n      mem[ceil32(('cd', 260).length) + 572 len 224] = this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228])\n      mem[ceil32(('cd', 260).length) + 796 len 28] = Mask(224, 0, cd[228])\n      mem[ceil32(('cd', 260).length) + 576] = sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228]))\n      mem[ceil32(('cd', 260).length) + 608] = 96\n      mem[ceil32(('cd', 260).length) + 672] = ('cd', 260).length\n      mem[ceil32(('cd', 260).length) + 704 len ceil32(('cd', 260).length)] = call.data[cd[260] + 36 len ('cd', 260).length], mem[('cd', 260).length + 256 len ceil32(('cd', 260).length) - ('cd', 260).length]\n      if ceil32(('cd', 260).length) > ('cd', 260).length:\n          mem[ceil32(('cd', 260).length) + ('cd', 260).length + 704] = 0\n      mem[ceil32(('cd', 260).length) + 640] = sender\n      require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n      delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n           gas gas_remaining wei\n          args sha3(this.address, sender, receiver, threadId, mem[96 len 64], mem[160 len 64], uint32(cd[228]), Mask(224, 0, cd[228])), Array(len=('cd', 260).length, data=call.data[cd[260] + 36 len ('cd', 260).length]), sender\n      mem[ceil32(('cd', 260).length) + 572] = delegate.return_data[0]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      mem[64] = ceil32(('cd', 260).length) + ceil32(return_data.size) + 572\n      require return_data.size >=\u2032 32\n      if not delegate.return_data[0]:\n          revert with 0, 'signature invalid'\n      s = 0\n      idx = 96\n      while 160 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 2\n      while 2 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      s = 2\n      idx = 160\n      while 224 > idx:\n          stor6[address(sender)][address(receiver)][threadId][s].field_0 = mem[idx]\n          s = s + 1\n          idx = idx + 32\n          continue \n      idx = 4\n      while 4 > idx:\n          stor6[address(sender)][address(receiver)][threadId][idx].field_0 = 0\n          idx = idx + 1\n          continue \n      stor6[address(sender)][address(receiver)][threadId].field_1024 = cd[228]\n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 572] = threadId\n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 604] = caller\n      idx = 0\n      s = 0\n      t = mem[64] + 64\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      idx = 0\n      s = 2\n      t = ceil32(('cd', 260).length) + ceil32(return_data.size) + 700\n      while idx < 2:\n          mem[t] = stor6[address(sender)][address(receiver)][threadId][s].field_0\n          idx = idx + 1\n          s = s + 1\n          t = t + 32\n          continue \n      mem[ceil32(('cd', 260).length) + ceil32(return_data.size) + 764] = cd[228]\n      log DidChallengeThread(address sender, address receiver, uint256 threadId, address senderAddress, uint256[2] weiBalances, uint256[2] tokenBalances, uint256 txCount):\n                             mem[mem[64] len ceil32(('cd', 260).length) + ceil32(return_data.size) + -mem[64] + 796],\n                             sender,\n                             receiver,\n  stor7 = 0\n\ndef startExitThreadWithUpdate(address user, address[2] threadMembers, uint256 threadId, uint256[2] weiBalances, uint256[2] tokenBalances, bytes proof, string sig, uint256[2] updatedWeiBalances, uint256[2] updatedTokenBalances, uint256 updatedTxCount, string updateSig): # not payable\n  require calldata.size - 4 >=\u2032 512\n  require calldata.size >\u2032 67\n  require 100 <= calldata.size\n  idx = 0\n  s = 36\n  t = 96\n  while idx < 2:\n      mem[t] = address(cd[s])\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 163\n  require 196 <= calldata.size\n  idx = 0\n  s = 132\n  t = 160\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 227\n  require 260 <= calldata.size\n  idx = 0\n  s = 196\n  t = 224\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require updatedTokenBalances <= LOCK8605463013()\n  require calldata.size >\u2032 updatedTokenBalances + 35\n  require updatedTokenBalances.length <= LOCK8605463013()\n  require ceil32(updatedTokenBalances.length) + 320 >= 288 and ceil32(updatedTokenBalances.length) + 320 <= LOCK8605463013()\n  mem[288] = updatedTokenBalances.length\n  require updatedTokenBalances + updatedTokenBalances.length + 36 <= calldata.size\n  mem[320 len updatedTokenBalances.length] = updatedTokenBalances[all]\n  mem[updatedTokenBalances.length + 320] = 0\n  require updatedTxCount <= LOCK8605463013()\n  require calldata.size >\u2032 updatedTxCount + 35\n  require updatedTxCount.length <= LOCK8605463013()\n  require ceil32(updatedTxCount.length) + 352 >= 320 and ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352 <= LOCK8605463013()\n  mem[ceil32(updatedTokenBalances.length) + 320] = updatedTxCount.length\n  require updatedTxCount + updatedTxCount.length + 36 <= calldata.size\n  mem[ceil32(updatedTokenBalances.length) + 352 len updatedTxCount.length] = updatedTxCount[all]\n  mem[updatedTxCount.length + ceil32(updatedTokenBalances.length) + 352] = 0\n  require calldata.size >\u2032 355\n  require bool(ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416 <= LOCK8605463013())\n  require 388 <= calldata.size\n  idx = 0\n  s = 324\n  t = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require calldata.size >\u2032 419\n  require bool(ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 480 <= LOCK8605463013())\n  require 452 <= calldata.size\n  idx = 0\n  s = 388\n  t = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416\n  while idx < 2:\n      mem[t] = cd[s]\n      idx = idx + 1\n      s = s + 32\n      t = t + 32\n      continue \n  require cd[484] <= LOCK8605463013()\n  require calldata.size >\u2032 cd[484] + 35\n  require ('cd', 484).length <= LOCK8605463013()\n  require ceil32(('cd', 484).length) + 512 >= 480 and ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512 <= LOCK8605463013()\n  mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 480] = ('cd', 484).length\n  require cd[484] + ('cd', 484).length + 36 <= calldata.size\n  mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 512 len ('cd', 484).length] = call.data[cd[484] + 36 len ('cd', 484).length]\n  mem[('cd', 484).length + ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 512] = 0\n  if stor7:\n      revert with 0, 'Reentrant call.'\n  stor7 = 1\n  require channels[address(user)].field_3072 <= 2\n  if channels[address(user)].field_3072 != 2:\n      revert with 0, 'channel must be in thread dispue phase'\n  if caller == hubAddress:\n      if mem[108 len 20] == user:\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _821 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _821\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _821, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _821, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n      else:\n          if mem[140 len 20] != user:\n              revert with 0, 'user must be thread sender or receiver'\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _826 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _826\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _826, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _826, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n  else:\n      if user != caller:\n          revert with 0, 'thread exit initiator must be user or hub'\n      if mem[108 len 20] == user:\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _831 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _831\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _831, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _831, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n      else:\n          if mem[140 len 20] != user:\n              revert with 0, 'user must be thread sender or receiver'\n          if mem[192]:\n              revert with 0, 'initial receiver balances must be zero'\n          if mem[256]:\n              revert with 0, 'initial receiver balances must be zero'\n          mem[0] = weiBalances\n          mem[32] = sha3(mem[140 len 20], sha3(mem[108 len 20], 6))\n          if stor6[mem[108 len 20]][mem[140 len 20]][weiBalances].field_1280:\n              revert with 0, 'thread closing time must be zero'\n          if mem[140 len 20] == mem[108 len 20]:\n              revert with 0, 'sender can not be receiver'\n          if hubAddress == mem[108 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if hubAddress == mem[140 len 20]:\n              revert with 0, 'hub can not be sender or receiver'\n          if this.address == mem[108 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          if this.address == mem[140 len 20]:\n              revert with 0, 'channel manager can not be sender or receiver'\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544] = address(this.address)\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 564] = address(mem[96])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 584] = address(mem[128])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 604] = weiBalances\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 636 len 64] = mem[160 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 700 len 64] = mem[224 len 64]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 764] = 0\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 512] = 252\n          mem[64] = ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 544 len floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)])]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] = mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 796] and 256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1 or mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + floor32(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]) + 544] and !(256^(-(Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)] % 32) + 32) - 1)\n          _836 = sha3(mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796 len Mask(8 * -ceil32(('cd', 484).length) + ('cd', 484).length + 32, 0, 0), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ('cd', 484).length + 544 len -('cd', 484).length + ceil32(('cd', 484).length)]])\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 796] = 0x1052506f00000000000000000000000000000000000000000000000000000000\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 800] = _836\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 832] = 96\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896] = Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]\n          mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 928 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])] = mem[ceil32(updatedTokenBalances.length) + 352 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)])]\n          if ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) <= Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]:\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _836, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n                          if hubAddress != mem[140 len 20]:\n          else:\n              mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)] + 928] = 0\n              require ext_code.size(0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26)\n              delegate 0xb01c6adaf785f06f2c01bcfe782e30ceefa90a26.isSignedBy(bytes32 _param1, string _param2, address _param3) with:\n                   gas gas_remaining wei\n                  args _836, 96, address(mem[96]), mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + ceil32(('cd', 484).length) + 896 len ceil32(Mask(8 * -ceil32(updatedTokenBalances.length) + updatedTokenBalances.length + 32, 0, 0), mem[updatedTokenBalances.length + 352 len -updatedTokenBalances.length + ceil32(updatedTokenBalances.length)]) + 32]\n              if not delegate.return_code:\n                  revert with ext_call.return_data[0 len return_data.size]\n              require return_data.size >=\u2032 32\n              if not delegate.return_data[0]:\n                  revert with 0, 'signature invalid'\n              if not channels[address(user)].field_2048:\n                  if cd[452] <= 0:\n                      revert with 0, 'updated thread txCount must be higher than 0'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 384] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 352] != mem[160]:\n                      revert with 0, 'sum of updated wei balances must match sender's initial wei balance'\n                  require mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] >= mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416]\n                  if mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 448] + mem[ceil32(updatedTokenBalances.length) + ceil32(updatedTxCount.length) + 416] != mem[224]:\n                      revert with 0, 'sum of updated token balances must match sender's initial token balance'\n                  if mem[140 len 20] != mem[108 len 20]:\n                      if hubAddress != mem[108 len 20]:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
	"status": "1",
	"time_cost": 42.614909648895264,
	"usage": {
		"completion_tokens": 366,
		"prompt_tokens": 30541,
		"total_tokens": 30907
	}
}