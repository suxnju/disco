{
	"address": "0xa146240bf2c04005a743032dc0d241ec0bb2ba2b",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Please note that this decompiled code is quite complex with multiple functions and mapping. However, here's a simplified version of a Solidity contract that captures some key elements of the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => uint256) private balances;\n    mapping (address => mapping (address => bool)) private administrators;\n    uint256 private stakingRequirement;\n    uint256 private totalSupply;\n    uint8 private onlyAmbassadors;\n    \n    event onWithdraw(address indexed user, uint256 amount);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    constructor(uint256 _stakingRequirement) {\n        stakingRequirement = _stakingRequirement;\n    }\n    \n    function transfer(address to, uint256 value) public returns (bool success) {\n        require(balances[msg.sender] >= value);\n        balances[msg.sender] -= value;\n        balances[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n    \n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n    \n    function setStakingRequirement(uint256 _stakingRequirement) public {\n        require(administrators[msg.sender][address(this)] == true);\n        stakingRequirement = _stakingRequirement;\n    }\n    \n    function setAdministrator(address admin, bool _status) public {\n        require(administrators[msg.sender][address(this)] == true);\n        administrators[admin][address(this)] = _status;\n    }\n    \n    function disableInitialStage() public {\n        require(administrators[msg.sender][address(this)] == true);\n        onlyAmbassadors = 0;\n    }\n    \n    function withdraw() public {\n        uint256 amount = balances[msg.sender];\n        require(amount > 0);\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n        emit onWithdraw(msg.sender, amount);\n    }\n}\n```\nPlease understand that this is a simplified version and may not cover all the functionalities in the decompiled code. Also, this code has not been tested and should not be used in production without proper testing and auditing.",
				"role": "assistant"
			}
		}
	],
	"created": 1698040566,
	"id": "chatcmpl-8CiD0oo9M1Xm24nfPiRoDi7ABtHM1",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 13:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _stakingRequirement; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0xa]\nuint8 _onlyAmbassadors; // STORAGE[0xb] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x121d(uint256 varg0) private { \n    v0 = 0xebc();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = 0x154f(varg0);\n    assert(5);\n    assert(v1 / 5 <= v1);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v1 - v1 / 5 << 64) + varg0 * stor_9);\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert((v1 / 5 << 64) / _totalSupply + stor_9 >= stor_9);\n        stor_9 += (v1 / 5 << 64) / _totalSupply;\n    }\n    emit onTokenSell(msg.sender, varg0, v1 - v1 / 5);\n    return ;\n}\n\nfunction 0x14b7(uint256 varg0) private { \n    v0 = v1 = 0x197d4df19d605767337e9f14d3eec8920e400000000000000 + (_totalSupply * 0x5e0a1fd2712875988becaad0000000000 + (_totalSupply ** 2 * 0x56bc75e2d63100000 + varg0 * 0x380d4bd8a8678c1bb542c80deb4800000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x1431e0fae6d7217caa0000000 <= v0);\n    assert(0x2540be400);\n    return (v0 - 0x1431e0fae6d7217caa0000000) / 0x2540be400 - _totalSupply;\n}\n\nfunction 0x154f(uint256 varg0) private { \n    v0 = varg0 * (0x2540be400 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000) + 0x14f46b0400);\n    v1 = 0x2540be400 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    v0 = 0x4e1(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * stor_9 - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    assert(5);\n    assert(varg0 <= varg0);\n    v0 = 0x14b7(varg0 - varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x154f(varg0);\n    assert(5);\n    assert(v0 / 5 <= v0);\n    return v0 - v0 / 5;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0xc19();\n}\n\nfunction sellPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x154f(0xde0b6b3a7640000);\n        assert(5);\n        assert(v0 / 5 <= v0);\n        v1 = v0 - v0 / 5;\n    } else {\n        v1 = v2 = 0x14f46b0400;\n    }\n    return v1;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xd3f(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x154f(0xde0b6b3a7640000);\n        assert(5);\n        v1 = v0 / 5 + v0;\n        assert(v1 >= v0);\n    } else {\n        v1 = v2 = 0x199c82cc00;\n    }\n    return v1;\n}\n\nfunction setAdministrator(bytes32 varg0, bool varg1) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _administrators[varg0] = varg1 | ~0xff & _administrators[varg0];\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xebc();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xebc();\n    require(v0 > 0);\n    v1 = v2 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v1 = v3 = varg1 <= _exit[msg.sender];\n    }\n    require(v1);\n    v4 = 0xd3f(1);\n    if (v4 > 0) {\n        0xc19();\n    }\n    assert(5);\n    assert(varg1 <= varg1);\n    v5 = 0x154f(varg1);\n    assert(varg1 <= _totalSupply);\n    _totalSupply = _totalSupply - varg1;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(varg1 - varg1 + _exit[varg0] >= _exit[varg0]);\n    _exit[varg0] += varg1 - varg1;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg1 * stor_9;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (varg1 - varg1) * stor_9;\n    assert(_totalSupply);\n    assert((v5 << 64) / _totalSupply + stor_9 >= stor_9);\n    stor_9 += (v5 << 64) / _totalSupply;\n    emit Transfer(msg.sender, varg0, varg1 - varg1);\n    return 1;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x121d(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x121d(_exit[msg.sender]);\n    }\n    0xc19();\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x4e1(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xd3f(1);\n    require(v0 > 0);\n    v1 = 0xd3f(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x4e1(0, v1 + _dividendsOf[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + _dividendsOf[msg.sender], v2);\n}\n\nfunction 0x4e1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = _onlyAmbassadors;\n    if (v1) {\n        v0 = v2 = (address(this)).balance - varg1 <= 0x1158e460913d00000;\n    }\n    if (!v0) {\n        _onlyAmbassadors = 0;\n        assert(5);\n        v3 = varg1 / 5;\n        assert(3);\n        assert(v3 / 3 <= v3);\n        v4 = v5 = v3 - v3 / 3;\n        assert(v3 <= varg1);\n        v6 = v7 = 0x14b7(varg1 - v3);\n        v8 = v9 = v5 << 64;\n        v10 = v11 = v7 > 0;\n        if (v11) {\n            assert(_totalSupply + v7 >= v7);\n            v10 = v12 = _totalSupply + v7 > _totalSupply;\n        }\n        require(v10);\n        v13 = !address(varg0);\n        v14 = v15 = address(varg0);\n        if (address(varg0)) {\n            v14 = v16 = address(varg0) != msg.sender;\n        }\n        if (v14) {\n            v17 = address(varg0);\n            v14 = v18 = _exit[v17] >= _stakingRequirement;\n        }\n        if (!v14) {\n            v4 = v3 / 3 + v5;\n            assert(v4 >= v5);\n            v8 = v19 = v4 << 64;\n        } else {\n            v20 = address(varg0);\n            assert(v3 / 3 + owner_5[v20] >= owner_5[v20]);\n            v21 = address(varg0);\n            owner_5[v21] = v3 / 3 + owner_5[v20];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v7;\n        } else {\n            assert(v7 + _totalSupply >= _totalSupply);\n            _totalSupply += v7;\n            assert(v7 + _totalSupply);\n            stor_9 = stor_9 + (v4 << 64) / (v7 + _totalSupply);\n            assert(_totalSupply);\n            v8 = v22 = v8 - (v8 - v7 * ((v4 << 64) / _totalSupply));\n        }\n        assert(v7 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v7;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v7 - v8);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v7);\n    } else {\n        v23 = v24 = 1 == 0xff & owner_3[msg.sender];\n        if (v24) {\n            v23 = v25 = varg1 + owner_7[msg.sender] <= 0xde0b6b3a7640000;\n        }\n        require(v23);\n        v26 = varg1 + owner_7[msg.sender];\n        assert(v26 >= owner_7[msg.sender]);\n        owner_7[msg.sender] = v26;\n        assert(5);\n        v27 = varg1 / 5;\n        assert(3);\n        assert(v27 / 3 <= v27);\n        v28 = v29 = v27 - v27 / 3;\n        assert(v27 <= varg1);\n        v6 = v30 = 0x14b7(varg1 - v27);\n        v31 = v32 = v29 << 64;\n        v33 = v34 = v30 > 0;\n        if (v34) {\n            assert(_totalSupply + v30 >= v30);\n            v33 = v35 = _totalSupply + v30 > _totalSupply;\n        }\n        require(v33);\n        v36 = !address(varg0);\n        v37 = v38 = address(varg0);\n        if (address(varg0)) {\n            v37 = v39 = address(varg0) != msg.sender;\n        }\n        if (v37) {\n            v40 = address(varg0);\n            v37 = v41 = _exit[v40] >= _stakingRequirement;\n        }\n        if (!v37) {\n            v28 = v27 / 3 + v29;\n            assert(v28 >= v29);\n            v31 = v42 = v28 << 64;\n        } else {\n            v43 = address(varg0);\n            assert(v27 / 3 + owner_5[v43] >= owner_5[v43]);\n            v44 = address(varg0);\n            owner_5[v44] = v27 / 3 + owner_5[v43];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v30;\n        } else {\n            assert(v30 + _totalSupply >= _totalSupply);\n            _totalSupply += v30;\n            assert(v30 + _totalSupply);\n            stor_9 = stor_9 + (v28 << 64) / (v30 + _totalSupply);\n            assert(_totalSupply);\n            v31 = v45 = v31 - (v31 - v30 * ((v28 << 64) / _totalSupply));\n        }\n        assert(v30 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v30;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v30 - v31);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v30);\n    }\n    return v6;\n}\n\nfunction 0xc19() private { \n    v0 = 0xd3f(1);\n    require(v0 > 0);\n    v1 = 0xd3f(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0xd3f(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * stor_9 - _dividendsOf[msg.sender] >> 64) + owner_5[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * stor_9 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0xebc() private { \n    return _exit[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x89135ae9 == function_selector) {\n            setAdministrator(bytes32,bool);\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 13:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _stakingRequirement; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0xa]\nuint8 _onlyAmbassadors; // STORAGE[0xb] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x121d(uint256 varg0) private { \n    v0 = 0xebc();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = 0x154f(varg0);\n    assert(5);\n    assert(v1 / 5 <= v1);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v1 - v1 / 5 << 64) + varg0 * stor_9);\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert((v1 / 5 << 64) / _totalSupply + stor_9 >= stor_9);\n        stor_9 += (v1 / 5 << 64) / _totalSupply;\n    }\n    emit onTokenSell(msg.sender, varg0, v1 - v1 / 5);\n    return ;\n}\n\nfunction 0x14b7(uint256 varg0) private { \n    v0 = v1 = 0x197d4df19d605767337e9f14d3eec8920e400000000000000 + (_totalSupply * 0x5e0a1fd2712875988becaad0000000000 + (_totalSupply ** 2 * 0x56bc75e2d63100000 + varg0 * 0x380d4bd8a8678c1bb542c80deb4800000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x1431e0fae6d7217caa0000000 <= v0);\n    assert(0x2540be400);\n    return (v0 - 0x1431e0fae6d7217caa0000000) / 0x2540be400 - _totalSupply;\n}\n\nfunction 0x154f(uint256 varg0) private { \n    v0 = varg0 * (0x2540be400 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000) + 0x14f46b0400);\n    v1 = 0x2540be400 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    v0 = 0x4e1(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * stor_9 - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    assert(5);\n    assert(varg0 <= varg0);\n    v0 = 0x14b7(varg0 - varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x154f(varg0);\n    assert(5);\n    assert(v0 / 5 <= v0);\n    return v0 - v0 / 5;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0xc19();\n}\n\nfunction sellPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x154f(0xde0b6b3a7640000);\n        assert(5);\n        assert(v0 / 5 <= v0);\n        v1 = v0 - v0 / 5;\n    } else {\n        v1 = v2 = 0x14f46b0400;\n    }\n    return v1;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xd3f(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x154f(0xde0b6b3a7640000);\n        assert(5);\n        v1 = v0 / 5 + v0;\n        assert(v1 >= v0);\n    } else {\n        v1 = v2 = 0x199c82cc00;\n    }\n    return v1;\n}\n\nfunction setAdministrator(bytes32 varg0, bool varg1) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _administrators[varg0] = varg1 | ~0xff & _administrators[varg0];\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xebc();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xebc();\n    require(v0 > 0);\n    v1 = v2 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v1 = v3 = varg1 <= _exit[msg.sender];\n    }\n    require(v1);\n    v4 = 0xd3f(1);\n    if (v4 > 0) {\n        0xc19();\n    }\n    assert(5);\n    assert(varg1 <= varg1);\n    v5 = 0x154f(varg1);\n    assert(varg1 <= _totalSupply);\n    _totalSupply = _totalSupply - varg1;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(varg1 - varg1 + _exit[varg0] >= _exit[varg0]);\n    _exit[varg0] += varg1 - varg1;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg1 * stor_9;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (varg1 - varg1) * stor_9;\n    assert(_totalSupply);\n    assert((v5 << 64) / _totalSupply + stor_9 >= stor_9);\n    stor_9 += (v5 << 64) / _totalSupply;\n    emit Transfer(msg.sender, varg0, varg1 - varg1);\n    return 1;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x121d(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x121d(_exit[msg.sender]);\n    }\n    0xc19();\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x4e1(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xd3f(1);\n    require(v0 > 0);\n    v1 = 0xd3f(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x4e1(0, v1 + _dividendsOf[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + _dividendsOf[msg.sender], v2);\n}\n\nfunction 0x4e1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = _onlyAmbassadors;\n    if (v1) {\n        v0 = v2 = (address(this)).balance - varg1 <= 0x1158e460913d00000;\n    }\n    if (!v0) {\n        _onlyAmbassadors = 0;\n        assert(5);\n        v3 = varg1 / 5;\n        assert(3);\n        assert(v3 / 3 <= v3);\n        v4 = v5 = v3 - v3 / 3;\n        assert(v3 <= varg1);\n        v6 = v7 = 0x14b7(varg1 - v3);\n        v8 = v9 = v5 << 64;\n        v10 = v11 = v7 > 0;\n        if (v11) {\n            assert(_totalSupply + v7 >= v7);\n            v10 = v12 = _totalSupply + v7 > _totalSupply;\n        }\n        require(v10);\n        v13 = !address(varg0);\n        v14 = v15 = address(varg0);\n        if (address(varg0)) {\n            v14 = v16 = address(varg0) != msg.sender;\n        }\n        if (v14) {\n            v17 = address(varg0);\n            v14 = v18 = _exit[v17] >= _stakingRequirement;\n        }\n        if (!v14) {\n            v4 = v3 / 3 + v5;\n            assert(v4 >= v5);\n            v8 = v19 = v4 << 64;\n        } else {\n            v20 = address(varg0);\n            assert(v3 / 3 + owner_5[v20] >= owner_5[v20]);\n            v21 = address(varg0);\n            owner_5[v21] = v3 / 3 + owner_5[v20];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v7;\n        } else {\n            assert(v7 + _totalSupply >= _totalSupply);\n            _totalSupply += v7;\n            assert(v7 + _totalSupply);\n            stor_9 = stor_9 + (v4 << 64) / (v7 + _totalSupply);\n            assert(_totalSupply);\n            v8 = v22 = v8 - (v8 - v7 * ((v4 << 64) / _totalSupply));\n        }\n        assert(v7 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v7;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v7 - v8);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v7);\n    } else {\n        v23 = v24 = 1 == 0xff & owner_3[msg.sender];\n        if (v24) {\n            v23 = v25 = varg1 + owner_7[msg.sender] <= 0xde0b6b3a7640000;\n        }\n        require(v23);\n        v26 = varg1 + owner_7[msg.sender];\n        assert(v26 >= owner_7[msg.sender]);\n        owner_7[msg.sender] = v26;\n        assert(5);\n        v27 = varg1 / 5;\n        assert(3);\n        assert(v27 / 3 <= v27);\n        v28 = v29 = v27 - v27 / 3;\n        assert(v27 <= varg1);\n        v6 = v30 = 0x14b7(varg1 - v27);\n        v31 = v32 = v29 << 64;\n        v33 = v34 = v30 > 0;\n        if (v34) {\n            assert(_totalSupply + v30 >= v30);\n            v33 = v35 = _totalSupply + v30 > _totalSupply;\n        }\n        require(v33);\n        v36 = !address(varg0);\n        v37 = v38 = address(varg0);\n        if (address(varg0)) {\n            v37 = v39 = address(varg0) != msg.sender;\n        }\n        if (v37) {\n            v40 = address(varg0);\n            v37 = v41 = _exit[v40] >= _stakingRequirement;\n        }\n        if (!v37) {\n            v28 = v27 / 3 + v29;\n            assert(v28 >= v29);\n            v31 = v42 = v28 << 64;\n        } else {\n            v43 = address(varg0);\n            assert(v27 / 3 + owner_5[v43] >= owner_5[v43]);\n            v44 = address(varg0);\n            owner_5[v44] = v27 / 3 + owner_5[v43];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v30;\n        } else {\n            assert(v30 + _totalSupply >= _totalSupply);\n            _totalSupply += v30;\n            assert(v30 + _totalSupply);\n            stor_9 = stor_9 + (v28 << 64) / (v30 + _totalSupply);\n            assert(_totalSupply);\n            v31 = v45 = v31 - (v31 - v30 * ((v28 << 64) / _totalSupply));\n        }\n        assert(v30 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v30;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v30 - v31);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v30);\n    }\n    return v6;\n}\n\nfunction 0xc19() private { \n    v0 = 0xd3f(1);\n    require(v0 > 0);\n    v1 = 0xd3f(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0xd3f(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * stor_9 - _dividendsOf[msg.sender] >> 64) + owner_5[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * stor_9 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0xebc() private { \n    return _exit[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x89135ae9 == function_selector) {\n            setAdministrator(bytes32,bool);\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 13:42 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _stakingRequirement; // STORAGE[0x2]\nmapping (uint256 => [uint256]) owner_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_5; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) owner_7; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0xa]\nuint8 _onlyAmbassadors; // STORAGE[0xb] bytes 0 to 0\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x121d(uint256 varg0) private { \n    v0 = 0xebc();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = 0x154f(varg0);\n    assert(5);\n    assert(v1 / 5 <= v1);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v1 - v1 / 5 << 64) + varg0 * stor_9);\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert((v1 / 5 << 64) / _totalSupply + stor_9 >= stor_9);\n        stor_9 += (v1 / 5 << 64) / _totalSupply;\n    }\n    emit onTokenSell(msg.sender, varg0, v1 - v1 / 5);\n    return ;\n}\n\nfunction 0x14b7(uint256 varg0) private { \n    v0 = v1 = 0x197d4df19d605767337e9f14d3eec8920e400000000000000 + (_totalSupply * 0x5e0a1fd2712875988becaad0000000000 + (_totalSupply ** 2 * 0x56bc75e2d63100000 + varg0 * 0x380d4bd8a8678c1bb542c80deb4800000000000));\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x1431e0fae6d7217caa0000000 <= v0);\n    assert(0x2540be400);\n    return (v0 - 0x1431e0fae6d7217caa0000000) / 0x2540be400 - _totalSupply;\n}\n\nfunction 0x154f(uint256 varg0) private { \n    v0 = varg0 * (0x2540be400 * ((0xde0b6b3a7640000 + _totalSupply) / 0xde0b6b3a7640000) + 0x14f46b0400);\n    v1 = 0x2540be400 * (((0xde0b6b3a7640000 + varg0) ** 2 - varg0 + ~0xde0b6b3a763ffff) / 0xde0b6b3a7640000) >> 1;\n    assert(v1 <= v0);\n    assert(0xde0b6b3a7640000);\n    return (v0 - v1) / 0xde0b6b3a7640000;\n}\n\nfunction fallback() public payable { \n    v0 = 0x4e1(0, msg.value);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * stor_9 - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    assert(5);\n    assert(varg0 <= varg0);\n    v0 = 0x14b7(varg0 - varg0);\n    return v0;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x154f(varg0);\n    assert(5);\n    assert(v0 / 5 <= v0);\n    return v0 - v0 / 5;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0xc19();\n}\n\nfunction sellPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x154f(0xde0b6b3a7640000);\n        assert(5);\n        assert(v0 / 5 <= v0);\n        v1 = v0 - v0 / 5;\n    } else {\n        v1 = v2 = 0x14f46b0400;\n    }\n    return v1;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0xd3f(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    if (0 != _totalSupply) {\n        v0 = 0x154f(0xde0b6b3a7640000);\n        assert(5);\n        v1 = v0 / 5 + v0;\n        assert(v1 >= v0);\n    } else {\n        v1 = v2 = 0x199c82cc00;\n    }\n    return v1;\n}\n\nfunction setAdministrator(bytes32 varg0, bool varg1) public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _administrators[varg0] = varg1 | ~0xff & _administrators[varg0];\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0xebc();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(0xff & _administrators[keccak256(msg.sender)]);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0xebc();\n    require(v0 > 0);\n    v1 = v2 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v1 = v3 = varg1 <= _exit[msg.sender];\n    }\n    require(v1);\n    v4 = 0xd3f(1);\n    if (v4 > 0) {\n        0xc19();\n    }\n    assert(5);\n    assert(varg1 <= varg1);\n    v5 = 0x154f(varg1);\n    assert(varg1 <= _totalSupply);\n    _totalSupply = _totalSupply - varg1;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(varg1 - varg1 + _exit[varg0] >= _exit[varg0]);\n    _exit[varg0] += varg1 - varg1;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg1 * stor_9;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (varg1 - varg1) * stor_9;\n    assert(_totalSupply);\n    assert((v5 << 64) / _totalSupply + stor_9 >= stor_9);\n    stor_9 += (v5 << 64) / _totalSupply;\n    emit Transfer(msg.sender, varg0, varg1 - varg1);\n    return 1;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(0xff & _administrators[keccak256(msg.sender)]);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x121d(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x121d(_exit[msg.sender]);\n    }\n    0xc19();\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x4e1(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0xd3f(1);\n    require(v0 > 0);\n    v1 = 0xd3f(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x4e1(0, v1 + _dividendsOf[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + _dividendsOf[msg.sender], v2);\n}\n\nfunction 0x4e1(uint256 varg0, uint256 varg1) private { \n    v0 = v1 = _onlyAmbassadors;\n    if (v1) {\n        v0 = v2 = (address(this)).balance - varg1 <= 0x1158e460913d00000;\n    }\n    if (!v0) {\n        _onlyAmbassadors = 0;\n        assert(5);\n        v3 = varg1 / 5;\n        assert(3);\n        assert(v3 / 3 <= v3);\n        v4 = v5 = v3 - v3 / 3;\n        assert(v3 <= varg1);\n        v6 = v7 = 0x14b7(varg1 - v3);\n        v8 = v9 = v5 << 64;\n        v10 = v11 = v7 > 0;\n        if (v11) {\n            assert(_totalSupply + v7 >= v7);\n            v10 = v12 = _totalSupply + v7 > _totalSupply;\n        }\n        require(v10);\n        v13 = !address(varg0);\n        v14 = v15 = address(varg0);\n        if (address(varg0)) {\n            v14 = v16 = address(varg0) != msg.sender;\n        }\n        if (v14) {\n            v17 = address(varg0);\n            v14 = v18 = _exit[v17] >= _stakingRequirement;\n        }\n        if (!v14) {\n            v4 = v3 / 3 + v5;\n            assert(v4 >= v5);\n            v8 = v19 = v4 << 64;\n        } else {\n            v20 = address(varg0);\n            assert(v3 / 3 + owner_5[v20] >= owner_5[v20]);\n            v21 = address(varg0);\n            owner_5[v21] = v3 / 3 + owner_5[v20];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v7;\n        } else {\n            assert(v7 + _totalSupply >= _totalSupply);\n            _totalSupply += v7;\n            assert(v7 + _totalSupply);\n            stor_9 = stor_9 + (v4 << 64) / (v7 + _totalSupply);\n            assert(_totalSupply);\n            v8 = v22 = v8 - (v8 - v7 * ((v4 << 64) / _totalSupply));\n        }\n        assert(v7 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v7;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v7 - v8);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v7);\n    } else {\n        v23 = v24 = 1 == 0xff & owner_3[msg.sender];\n        if (v24) {\n            v23 = v25 = varg1 + owner_7[msg.sender] <= 0xde0b6b3a7640000;\n        }\n        require(v23);\n        v26 = varg1 + owner_7[msg.sender];\n        assert(v26 >= owner_7[msg.sender]);\n        owner_7[msg.sender] = v26;\n        assert(5);\n        v27 = varg1 / 5;\n        assert(3);\n        assert(v27 / 3 <= v27);\n        v28 = v29 = v27 - v27 / 3;\n        assert(v27 <= varg1);\n        v6 = v30 = 0x14b7(varg1 - v27);\n        v31 = v32 = v29 << 64;\n        v33 = v34 = v30 > 0;\n        if (v34) {\n            assert(_totalSupply + v30 >= v30);\n            v33 = v35 = _totalSupply + v30 > _totalSupply;\n        }\n        require(v33);\n        v36 = !address(varg0);\n        v37 = v38 = address(varg0);\n        if (address(varg0)) {\n            v37 = v39 = address(varg0) != msg.sender;\n        }\n        if (v37) {\n            v40 = address(varg0);\n            v37 = v41 = _exit[v40] >= _stakingRequirement;\n        }\n        if (!v37) {\n            v28 = v27 / 3 + v29;\n            assert(v28 >= v29);\n            v31 = v42 = v28 << 64;\n        } else {\n            v43 = address(varg0);\n            assert(v27 / 3 + owner_5[v43] >= owner_5[v43]);\n            v44 = address(varg0);\n            owner_5[v44] = v27 / 3 + owner_5[v43];\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v30;\n        } else {\n            assert(v30 + _totalSupply >= _totalSupply);\n            _totalSupply += v30;\n            assert(v30 + _totalSupply);\n            stor_9 = stor_9 + (v28 << 64) / (v30 + _totalSupply);\n            assert(_totalSupply);\n            v31 = v45 = v31 - (v31 - v30 * ((v28 << 64) / _totalSupply));\n        }\n        assert(v30 + _exit[msg.sender] >= _exit[msg.sender]);\n        _exit[msg.sender] += v30;\n        _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v30 - v31);\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(msg.sender, address(varg0), varg1, v30);\n    }\n    return v6;\n}\n\nfunction 0xc19() private { \n    v0 = 0xd3f(1);\n    require(v0 > 0);\n    v1 = 0xd3f(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0xd3f(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * stor_9 - _dividendsOf[msg.sender] >> 64) + owner_5[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * stor_9 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0xebc() private { \n    return _exit[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x89135ae9 == function_selector) {\n            setAdministrator(bytes32,bool);\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 31.380297660827637,
	"usage": {
		"completion_tokens": 449,
		"prompt_tokens": 5524,
		"total_tokens": 5973
	}
}