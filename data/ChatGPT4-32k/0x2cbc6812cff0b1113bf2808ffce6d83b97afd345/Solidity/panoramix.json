{
	"address": "0x2cbc6812cff0b1113bf2808ffce6d83b97afd345",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code provided, the solidity contract code can be as follows:\n\n```solidity\npragma solidity ^0.6.0;\n\ncontract MyContract {\n    uint8 state;\n    address payable owner;\n    mapping(address => uint256) deposited;\n    address payable walletAddress;\n\n    event RefundsEnabled();\n    event OwnershipTransferred(address previousOwner, address newOwner);\n    event FundsDrained(uint256 weiAmount);\n    event Closed();\n    event Refunded(address beneficiary, uint256 weiAmount);\n\n    constructor(address payable _walletAddress) public {\n        owner = msg.sender;\n        walletAddress = _walletAddress;\n    }\n\n    function wallet() public view returns (address) {\n        return walletAddress;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function getState() public view returns (uint8) {\n        require(state <= 2);\n        return state;\n    }\n\n    function getDeposited(address _address) public view returns (uint256) {\n        return deposited[_address];\n    }\n\n    function enableRefunds() public {\n        require(msg.sender == owner);\n        require(state <= 2);\n        require(state == 0);\n        state = 1;\n        emit RefundsEnabled();\n    }\n\n    function transferOwnership(address payable newOwner) public {\n        require(msg.sender == owner);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function unhold() public {\n        require(msg.sender == owner);\n        require(state <= 2);\n        require(state == 0);\n        emit FundsDrained(address(this).balance);\n        (bool success, ) = walletAddress.call.value(address(this).balance)(\"\");\n        require(success);\n    }\n\n    function close() public {\n        require(msg.sender == owner);\n        require(state <= 2);\n        require(state == 0);\n        state = 2;\n        emit Closed();\n        emit FundsDrained(address(this).balance);\n        (bool success, ) = walletAddress.call.value(address(this).balance)(\"\");\n        require(success);\n    }\n\n    function deposit(address account) public payable {\n        require(msg.sender == owner);\n        require(state <= 2);\n        require(state == 0);\n        require(deposited[account] + msg.value >= deposited[account]);\n        deposited[account] += msg.value;\n    }\n\n    function refund(address payable investor) public {\n        require(state <= 2);\n        require(state == 1);\n        uint256 amount = deposited[investor];\n        deposited[investor] = 0;\n        (bool success, ) = investor.call.value(amount)(\"\");\n        require(success);\n        emit Refunded(investor, amount);\n    }\n\n    fallback() external payable {\n        revert();\n    }\n}\n```\n\nThis contract includes a wallet, owner, state, and deposited mapping. There are also functions to get the wallet address, get the contract owner, and get the state. Plus, there are functions for enabling refunds, transferring ownership, unholding funds, closing the contract, depositing funds, and refunding investors. It also includes a fallback function that reverts any Ether sent to it.",
				"role": "assistant"
			}
		}
	],
	"created": 1700474182,
	"id": "chatcmpl-8MvIsNkfbqqXh2Q0oulzQej6m0wY2",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  state is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  walletAddress is address at storage 2\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef enableRefunds(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef unhold(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  log FundsDrained(uint256 weiAmount=eth.balance(this.address))\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef close(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  log FundsDrained(uint256 weiAmount=eth.balance(this.address))\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef deposit(address account) payable: \n  require caller == owner\n  require state <= 2\n  require not state\n  require deposited[address(account)] + call.value >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  state is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  walletAddress is address at storage 2\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef enableRefunds(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef unhold(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  log FundsDrained(uint256 weiAmount=eth.balance(this.address))\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef close(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  log FundsDrained(uint256 weiAmount=eth.balance(this.address))\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef deposit(address account) payable: \n  require caller == owner\n  require state <= 2\n  require not state\n  require deposited[address(account)] + call.value >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  state is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  deposited is mapping of uint256 at storage 1\n  walletAddress is address at storage 2\n\ndef wallet(): # not payable\n  return walletAddress\n\ndef owner(): # not payable\n  return owner\n\ndef state(): # not payable\n  require state <= 2\n  return state\n\ndef deposited(address _param1): # not payable\n  return deposited[_param1]\n\n#\n#  Regular functions\n#\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef enableRefunds(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  state = 1\n  log RefundsEnabled()\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef unhold(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  log FundsDrained(uint256 weiAmount=eth.balance(this.address))\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef close(): # not payable\n  require caller == owner\n  require state <= 2\n  require not state\n  state = 2\n  log Closed()\n  log FundsDrained(uint256 weiAmount=eth.balance(this.address))\n  call walletAddress with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n\ndef deposit(address account) payable: \n  require caller == owner\n  require state <= 2\n  require not state\n  require deposited[address(account)] + call.value >= deposited[address(account)]\n  deposited[address(account)] += call.value\n\ndef refund(address investor): # not payable\n  require state <= 2\n  require state == 1\n  deposited[address(investor)] = 0\n  call investor with:\n     value deposited[address(investor)] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log Refunded(\n        address beneficiary=deposited[address(investor)],\n        uint256 weiAmount=investor)\n\n.",
	"status": "1",
	"time_cost": 48.46428942680359,
	"usage": {
		"completion_tokens": 657,
		"prompt_tokens": 582,
		"total_tokens": 1239
	}
}