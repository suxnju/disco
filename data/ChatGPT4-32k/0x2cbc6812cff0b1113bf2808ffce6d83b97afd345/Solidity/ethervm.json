{
	"address": "0x2cbc6812cff0b1113bf2808ffce6d83b97afd345",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's the Solidity code for the decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.4.0;\n\ncontract Contract {\n    mapping (address => uint256) deposits;\n    address private owner;\n    address private wallet;\n    uint8 private state;\n\n    // Fallback function\n    function () public payable { revert(); }\n\n    function close() public {\n        require(msg.sender == owner);\n        state = 2;\n        wallet.transfer(address(this).balance);\n    }\n\n    function wallet() public view returns (address) {\n        return wallet;\n    }\n\n    function enableRefunds() public {\n        require(msg.sender == owner);\n        state = 1;\n    }\n\n    function owner() public view returns (address) {\n        return owner;\n    }\n\n    function state() public view returns (uint8) {\n        return state;\n    }\n\n    function deposited(address addr) public view returns (uint256) {\n        return deposits[addr];\n    }\n\n    function unhold() public {\n        require(msg.sender == owner);\n        wallet.transfer(address(this).balance);\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == owner);\n        owner = newOwner;\n    }\n\n    function deposit(address depositor) public payable {\n        require(msg.sender == owner);\n        deposits[depositor] += msg.value;\n    }\n\n    function refund(address refundee) public {\n        require(state == 1);\n        uint256 refundAmount = deposits[refundee];\n        deposits[refundee] = 0;\n        refundee.transfer(refundAmount);\n    }\n}\n```\n\nPlease note that the original EVM Bytecode uses very low level operations, and the Solidity code above is a representation of those operations in a higher level language. Some aspects of the original Bytecode (like manual memory management) are not represented in the Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1700474576,
	"id": "chatcmpl-8MvPEk2BxwvgUMHC2UjRW56xk3YES",
	"input_format": "DecompiledCode",
	"ir": "contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (msg.data.length < 0x04) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x43d726d6) {\n            // Dispatch table entry for close()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00bc;\n            close();\n            stop();\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d1;\n            var var2 = wallet();\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0xffffffffffffffffffffffffffffffffffffffff;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0126;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x013b;\n            var2 = owner();\n            var temp2 = memory[0x40:0x60];\n            memory[temp2:temp2 + 0x20] = var2 & 0xffffffffffffffffffffffffffffffffffffffff;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0190;\n            var2 = state();\n            var var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp4 = var4;\n            memory[temp4:temp4 + 0x20] = var5 & 0xff;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x01eb;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            var2 = deposited(var2);\n            var temp6 = memory[0x40:0x60];\n            memory[temp6:temp6 + 0x20] = var2;\n            var temp7 = memory[0x40:0x60];\n            return memory[temp7:temp7 + (temp6 + 0x20) - temp7];\n        } else if (var0 == 0xd13209f9) {\n            // Dispatch table entry for unhold()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0214;\n            unhold();\n            stop();\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x024d;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x027b;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x02b4;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function close() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x02;\n        var1 = 0x00;\n        var var3 = 0x0100 ** 0x14;\n        var var2 = ~(var3 * 0xff) & storage[var1];\n        var var4 = var0;\n    \n        if (var4 > 0x02) { assert(); }\n    \n        storage[var1] = var4 * var3 | var2;\n        var temp0 = memory[0x40:0x60];\n        log(memory[temp0:temp0 + memory[0x40:0x60] - temp0], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = address(this).balance;\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + (temp1 + 0x20) - temp2], [0xb71503fc488e5e21cf011cfe957816bd59637b7740d015c19152ada520bb9933]);\n        var temp3 = address(this).balance;\n        var temp4 = memory[0x40:0x60];\n        var temp5;\n        temp5, memory[temp4:temp4 + 0x00] = address(storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!temp3 * 0x08fc).value(temp3)(memory[temp4:temp4 + memory[0x40:0x60] - temp4]);\n    \n        if (temp5) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function wallet() returns (var r0) { return storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff; }\n    \n    function enableRefunds() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x01;\n        var1 = 0x00;\n        var var2 = storage[var1] & ~(0xff * 0x0100 ** 0x14);\n        var var3 = 0x0100 ** 0x14;\n        var var4 = var0;\n    \n        if (var4 > 0x02) { assert(); }\n    \n        storage[var1] = var4 * var3 | var2;\n        var temp0 = memory[0x40:0x60];\n        log(memory[temp0:temp0 + memory[0x40:0x60] - temp0], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff; }\n    \n    function state() returns (var r0) { return storage[0x00] / 0x0100 ** 0x14 & 0xff; }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function unhold() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = address(this).balance;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + (temp0 + 0x20) - temp1], [0xb71503fc488e5e21cf011cfe957816bd59637b7740d015c19152ada520bb9933]);\n        var temp2 = address(this).balance;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!temp2 * 0x08fc).value(temp2)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (temp4) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function transferOwnership(var arg0) {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 & 0xffffffffffffffffffffffffffffffffffffffff == 0xffffffffffffffffffffffffffffffffffffffff & 0x00) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff, stack[-1] & 0xffffffffffffffffffffffffffffffffffffffff]);\n        storage[0x00] = (temp0 & 0xffffffffffffffffffffffffffffffffffffffff) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x0943;\n        memory[0x00:0x20] = arg0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0AD8(var1, var2);\n        memory[0x00:0x20] = arg0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        var var2 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0;\n        memory[0x00:0x20] = temp0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = storage[keccak256(memory[0x00:0x40])];\n        var0 = temp1;\n        memory[0x00:0x20] = temp0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = 0x00;\n        var temp2 = memory[0x40:0x60];\n        var temp3;\n        temp3, memory[temp2:temp2 + 0x00] = address(temp0 & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!var0 * 0x08fc).value(var0)(memory[temp2:temp2 + memory[0x40:0x60] - temp2]);\n    \n        if (!temp3) { revert(memory[0x00:0x00]); }\n    \n        var temp4 = memory[0x40:0x60];\n        memory[temp4:temp4 + 0x20] = var0;\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + (temp4 + 0x20) - temp5], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0xffffffffffffffffffffffffffffffffffffffff]);\n    }\n    \n    function func_0AD8(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = temp0 + arg1;\n    \n        if (var1 >= temp0) { return var1; }\n        else { revert(memory[0x00:0x00]); }\n    }\n}\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (msg.data.length < 0x04) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x43d726d6) {\n            // Dispatch table entry for close()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00bc;\n            close();\n            stop();\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d1;\n            var var2 = wallet();\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0xffffffffffffffffffffffffffffffffffffffff;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0126;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x013b;\n            var2 = owner();\n            var temp2 = memory[0x40:0x60];\n            memory[temp2:temp2 + 0x20] = var2 & 0xffffffffffffffffffffffffffffffffffffffff;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0190;\n            var2 = state();\n            var var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp4 = var4;\n            memory[temp4:temp4 + 0x20] = var5 & 0xff;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x01eb;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            var2 = deposited(var2);\n            var temp6 = memory[0x40:0x60];\n            memory[temp6:temp6 + 0x20] = var2;\n            var temp7 = memory[0x40:0x60];\n            return memory[temp7:temp7 + (temp6 + 0x20) - temp7];\n        } else if (var0 == 0xd13209f9) {\n            // Dispatch table entry for unhold()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0214;\n            unhold();\n            stop();\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x024d;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x027b;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x02b4;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function close() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x02;\n        var1 = 0x00;\n        var var3 = 0x0100 ** 0x14;\n        var var2 = ~(var3 * 0xff) & storage[var1];\n        var var4 = var0;\n    \n        if (var4 > 0x02) { assert(); }\n    \n        storage[var1] = var4 * var3 | var2;\n        var temp0 = memory[0x40:0x60];\n        log(memory[temp0:temp0 + memory[0x40:0x60] - temp0], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = address(this).balance;\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + (temp1 + 0x20) - temp2], [0xb71503fc488e5e21cf011cfe957816bd59637b7740d015c19152ada520bb9933]);\n        var temp3 = address(this).balance;\n        var temp4 = memory[0x40:0x60];\n        var temp5;\n        temp5, memory[temp4:temp4 + 0x00] = address(storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!temp3 * 0x08fc).value(temp3)(memory[temp4:temp4 + memory[0x40:0x60] - temp4]);\n    \n        if (temp5) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function wallet() returns (var r0) { return storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff; }\n    \n    function enableRefunds() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x01;\n        var1 = 0x00;\n        var var2 = storage[var1] & ~(0xff * 0x0100 ** 0x14);\n        var var3 = 0x0100 ** 0x14;\n        var var4 = var0;\n    \n        if (var4 > 0x02) { assert(); }\n    \n        storage[var1] = var4 * var3 | var2;\n        var temp0 = memory[0x40:0x60];\n        log(memory[temp0:temp0 + memory[0x40:0x60] - temp0], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff; }\n    \n    function state() returns (var r0) { return storage[0x00] / 0x0100 ** 0x14 & 0xff; }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function unhold() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = address(this).balance;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + (temp0 + 0x20) - temp1], [0xb71503fc488e5e21cf011cfe957816bd59637b7740d015c19152ada520bb9933]);\n        var temp2 = address(this).balance;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!temp2 * 0x08fc).value(temp2)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (temp4) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function transferOwnership(var arg0) {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 & 0xffffffffffffffffffffffffffffffffffffffff == 0xffffffffffffffffffffffffffffffffffffffff & 0x00) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff, stack[-1] & 0xffffffffffffffffffffffffffffffffffffffff]);\n        storage[0x00] = (temp0 & 0xffffffffffffffffffffffffffffffffffffffff) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x0943;\n        memory[0x00:0x20] = arg0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0AD8(var1, var2);\n        memory[0x00:0x20] = arg0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        var var2 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0;\n        memory[0x00:0x20] = temp0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = storage[keccak256(memory[0x00:0x40])];\n        var0 = temp1;\n        memory[0x00:0x20] = temp0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = 0x00;\n        var temp2 = memory[0x40:0x60];\n        var temp3;\n        temp3, memory[temp2:temp2 + 0x00] = address(temp0 & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!var0 * 0x08fc).value(var0)(memory[temp2:temp2 + memory[0x40:0x60] - temp2]);\n    \n        if (!temp3) { revert(memory[0x00:0x00]); }\n    \n        var temp4 = memory[0x40:0x60];\n        memory[temp4:temp4 + 0x20] = var0;\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + (temp4 + 0x20) - temp5], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0xffffffffffffffffffffffffffffffffffffffff]);\n    }\n    \n    function func_0AD8(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = temp0 + arg1;\n    \n        if (var1 >= temp0) { return var1; }\n        else { revert(memory[0x00:0x00]); }\n    }\n}\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: contract Contract {\n    function main() {\n        memory[0x40:0x60] = 0x60;\n    \n        if (msg.data.length < 0x04) { revert(memory[0x00:0x00]); }\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 & 0xffffffff;\n    \n        if (var0 == 0x43d726d6) {\n            // Dispatch table entry for close()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var var1 = 0x00bc;\n            close();\n            stop();\n        } else if (var0 == 0x521eb273) {\n            // Dispatch table entry for wallet()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x00d1;\n            var var2 = wallet();\n            var temp0 = memory[0x40:0x60];\n            memory[temp0:temp0 + 0x20] = var2 & 0xffffffffffffffffffffffffffffffffffffffff;\n            var temp1 = memory[0x40:0x60];\n            return memory[temp1:temp1 + (temp0 + 0x20) - temp1];\n        } else if (var0 == 0x8c52dc41) {\n            // Dispatch table entry for enableRefunds()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0126;\n            enableRefunds();\n            stop();\n        } else if (var0 == 0x8da5cb5b) {\n            // Dispatch table entry for owner()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x013b;\n            var2 = owner();\n            var temp2 = memory[0x40:0x60];\n            memory[temp2:temp2 + 0x20] = var2 & 0xffffffffffffffffffffffffffffffffffffffff;\n            var temp3 = memory[0x40:0x60];\n            return memory[temp3:temp3 + (temp2 + 0x20) - temp3];\n        } else if (var0 == 0xc19d93fb) {\n            // Dispatch table entry for state()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0190;\n            var2 = state();\n            var var3 = memory[0x40:0x60];\n            var var4 = var3;\n            var var5 = var2;\n        \n            if (var5 > 0x02) { assert(); }\n        \n            var temp4 = var4;\n            memory[temp4:temp4 + 0x20] = var5 & 0xff;\n            var temp5 = memory[0x40:0x60];\n            return memory[temp5:temp5 + (temp4 + 0x20) - temp5];\n        } else if (var0 == 0xcb13cddb) {\n            // Dispatch table entry for deposited(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x01eb;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            var2 = deposited(var2);\n            var temp6 = memory[0x40:0x60];\n            memory[temp6:temp6 + 0x20] = var2;\n            var temp7 = memory[0x40:0x60];\n            return memory[temp7:temp7 + (temp6 + 0x20) - temp7];\n        } else if (var0 == 0xd13209f9) {\n            // Dispatch table entry for unhold()\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x0214;\n            unhold();\n            stop();\n        } else if (var0 == 0xf2fde38b) {\n            // Dispatch table entry for transferOwnership(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x024d;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            transferOwnership(var2);\n            stop();\n        } else if (var0 == 0xf340fa01) {\n            // Dispatch table entry for deposit(address)\n            var1 = 0x027b;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            deposit(var2);\n            stop();\n        } else if (var0 == 0xfa89401a) {\n            // Dispatch table entry for refund(address)\n            if (msg.value) { revert(memory[0x00:0x00]); }\n        \n            var1 = 0x02b4;\n            var2 = msg.data[0x04:0x24] & 0xffffffffffffffffffffffffffffffffffffffff;\n            refund(var2);\n            stop();\n        } else { revert(memory[0x00:0x00]); }\n    }\n    \n    function close() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x02;\n        var1 = 0x00;\n        var var3 = 0x0100 ** 0x14;\n        var var2 = ~(var3 * 0xff) & storage[var1];\n        var var4 = var0;\n    \n        if (var4 > 0x02) { assert(); }\n    \n        storage[var1] = var4 * var3 | var2;\n        var temp0 = memory[0x40:0x60];\n        log(memory[temp0:temp0 + memory[0x40:0x60] - temp0], [0x1cdde67b72a90f19919ac732a437ac2f7a10fc128d28c2a6e525d89ce5cd9d3a]);\n        var temp1 = memory[0x40:0x60];\n        memory[temp1:temp1 + 0x20] = address(this).balance;\n        var temp2 = memory[0x40:0x60];\n        log(memory[temp2:temp2 + (temp1 + 0x20) - temp2], [0xb71503fc488e5e21cf011cfe957816bd59637b7740d015c19152ada520bb9933]);\n        var temp3 = address(this).balance;\n        var temp4 = memory[0x40:0x60];\n        var temp5;\n        temp5, memory[temp4:temp4 + 0x00] = address(storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!temp3 * 0x08fc).value(temp3)(memory[temp4:temp4 + memory[0x40:0x60] - temp4]);\n    \n        if (temp5) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function wallet() returns (var r0) { return storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff; }\n    \n    function enableRefunds() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x01;\n        var1 = 0x00;\n        var var2 = storage[var1] & ~(0xff * 0x0100 ** 0x14);\n        var var3 = 0x0100 ** 0x14;\n        var var4 = var0;\n    \n        if (var4 > 0x02) { assert(); }\n    \n        storage[var1] = var4 * var3 | var2;\n        var temp0 = memory[0x40:0x60];\n        log(memory[temp0:temp0 + memory[0x40:0x60] - temp0], [0x599d8e5a83cffb867d051598c4d70e805d59802d8081c1c7d6dffc5b6aca2b89]);\n    }\n    \n    function owner() returns (var r0) { return storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff; }\n    \n    function state() returns (var r0) { return storage[0x00] / 0x0100 ** 0x14 & 0xff; }\n    \n    function deposited(var arg0) returns (var arg0) {\n        memory[0x20:0x40] = 0x01;\n        memory[0x00:0x20] = arg0;\n        return storage[keccak256(memory[0x00:0x40])];\n    }\n    \n    function unhold() {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] = address(this).balance;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + (temp0 + 0x20) - temp1], [0xb71503fc488e5e21cf011cfe957816bd59637b7740d015c19152ada520bb9933]);\n        var temp2 = address(this).balance;\n        var temp3 = memory[0x40:0x60];\n        var temp4;\n        temp4, memory[temp3:temp3 + 0x00] = address(storage[0x02] & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!temp2 * 0x08fc).value(temp2)(memory[temp3:temp3 + memory[0x40:0x60] - temp3]);\n    \n        if (temp4) { return; }\n        else { revert(memory[0x00:0x00]); }\n    }\n    \n    function transferOwnership(var arg0) {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        if (arg0 & 0xffffffffffffffffffffffffffffffffffffffff == 0xffffffffffffffffffffffffffffffffffffffff & 0x00) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0;\n        var temp1 = memory[0x40:0x60];\n        log(memory[temp1:temp1 + memory[0x40:0x60] - temp1], [0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0, storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff, stack[-1] & 0xffffffffffffffffffffffffffffffffffffffff]);\n        storage[0x00] = (temp0 & 0xffffffffffffffffffffffffffffffffffffffff) | (storage[0x00] & ~0xffffffffffffffffffffffffffffffffffffffff);\n    }\n    \n    function deposit(var arg0) {\n        if (msg.sender != storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { revert(memory[0x00:0x00]); }\n    \n        var var0 = 0x00;\n    \n        if (var0 > 0x02) { assert(); }\n    \n        var var1 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        if (var1 != var0) { revert(memory[0x00:0x00]); }\n    \n        var0 = 0x0943;\n        memory[0x00:0x20] = arg0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        var1 = storage[keccak256(memory[0x00:0x40])];\n        var var2 = msg.value;\n        var0 = func_0AD8(var1, var2);\n        memory[0x00:0x20] = arg0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = var0;\n    }\n    \n    function refund(var arg0) {\n        var var0 = 0x00;\n        var var1 = 0x01;\n    \n        if (var1 > 0x02) { assert(); }\n    \n        var var2 = storage[0x00] / 0x0100 ** 0x14 & 0xff;\n    \n        if (var2 > 0x02) { assert(); }\n    \n        if (var2 != var1) { revert(memory[0x00:0x00]); }\n    \n        var temp0 = arg0;\n        memory[0x00:0x20] = temp0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        var temp1 = storage[keccak256(memory[0x00:0x40])];\n        var0 = temp1;\n        memory[0x00:0x20] = temp0 & 0xffffffffffffffffffffffffffffffffffffffff;\n        memory[0x20:0x40] = 0x01;\n        storage[keccak256(memory[0x00:0x40])] = 0x00;\n        var temp2 = memory[0x40:0x60];\n        var temp3;\n        temp3, memory[temp2:temp2 + 0x00] = address(temp0 & 0xffffffffffffffffffffffffffffffffffffffff).call.gas(!var0 * 0x08fc).value(var0)(memory[temp2:temp2 + memory[0x40:0x60] - temp2]);\n    \n        if (!temp3) { revert(memory[0x00:0x00]); }\n    \n        var temp4 = memory[0x40:0x60];\n        memory[temp4:temp4 + 0x20] = var0;\n        var temp5 = memory[0x40:0x60];\n        log(memory[temp5:temp5 + (temp4 + 0x20) - temp5], [0xd7dee2702d63ad89917b6a4da9981c90c4d24f8c2bdfd64c604ecae57d8d0651, stack[-2] & 0xffffffffffffffffffffffffffffffffffffffff]);\n    }\n    \n    function func_0AD8(var arg0, var arg1) returns (var r0) {\n        var var0 = 0x00;\n        var temp0 = arg0;\n        var var1 = temp0 + arg1;\n    \n        if (var1 >= temp0) { return var1; }\n        else { revert(memory[0x00:0x00]); }\n    }\n}\n\n.",
	"status": "1",
	"time_cost": 17.099485158920288,
	"usage": {
		"completion_tokens": 381,
		"prompt_tokens": 3715,
		"total_tokens": 4096
	}
}