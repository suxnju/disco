{
	"address": "0x09b4c8200f0cb51e6d44a1974a1bc07336b9f47f",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Based on the given decompiled code, here is the Solidity contract:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MyToken is ERC20 {\n    constructor(uint256 initialSupply) ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, initialSupply);\n    }\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public {\n        _burn(from, amount);\n    }\n    \n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, allowance(_msgSender(), spender) + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        uint256 currentAllowance = allowance(_msgSender(), spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\n}\n```\nNote: The given decompiled code is not complete, and it is reconstructed based on the general structure of a standard ERC20 token contract. The above Solidity code is a simplified version and does not cover all the details of the decompiled code, such as the flashmint function. It's also worth mentioning that it does not include any error handling for transferring to or from the zero address, and it does not check for overflow on addition or underflow on subtraction. It also does not include the function selector logic from the decompiled code. Please make necessary adjustments based on your specific needs.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711532282,
	"id": "chatcmpl-97K1KNPzp7yJezNlVJ18YyJVvzq3L",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.06 02:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x11b5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, Error('ERC20: transfer from the zero address'));\n    require(address(varg1) != 0, Error('ERC20: transfer to the zero address'));\n    v0 = new struct(3);\n    v0.word0 = 38;\n    v1 = address(varg2);\n    v2 = _SafeSub(v0, varg0, _balanceOf[v1]);\n    v3 = address(varg2);\n    _balanceOf[v3] = v2;\n    v4 = address(varg1);\n    v5 = _balanceOf[v4] + varg0;\n    require(v5 >= _balanceOf[v4], Error('SafeMath: addition overflow'));\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new array[](varg0.word0);\n        v1 = v2 = 0;\n        while (v1 < varg0.word0) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v3 = v4 = varg0.word0 + v0.data;\n        if (0x1f & varg0.word0) {\n            MEM[v4 - (0x1f & varg0.word0)] = ~(256 ** (32 - (0x1f & varg0.word0)) - 1) & MEM[v4 - (0x1f & varg0.word0)];\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0xc4b(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction mint() public payable { \n    0xe42(msg.value, msg.sender);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction flashMint(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xe42(varg0, msg.sender);\n    require(msg.sender.code.size);\n    v0 = msg.sender.executeOnFlashMint(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    0xffd(varg0, msg.sender);\n    require(this.balance >= _totalSupply, Error('redeemability was broken'));\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    0x11b5(varg2, varg1, varg0);\n    v0 = new struct(3);\n    v0.word0 = 40;\n    v1 = _SafeSub(v0, varg2, STORAGE[keccak256(msg.sender, keccak256(varg0, 1))]);\n    0xc4b(v1, msg.sender, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_allowance[varg0] + varg1 >= _allowance[varg0], Error('SafeMath: addition overflow'));\n    0xc4b(_allowance[varg0] + varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = new struct(3);\n    v0.word0 = 37;\n    v1 = _SafeSub(v0, varg1, _allowance[varg0]);\n    0xc4b(v1, varg0, msg.sender);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x11b5(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction redeem(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xffd(varg0, msg.sender);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction 0xc4b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, Error('ERC20: approve from the zero address'));\n    require(address(varg1) != 0, Error('ERC20: approve to the zero address'));\n    v0 = address(varg2);\n    v1 = address(varg1);\n    _allowance[v1] = varg0;\n    emit Approval(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0xe42(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0, Error('ERC20: mint to the zero address'));\n    v0 = _totalSupply + varg0;\n    require(v0 >= _totalSupply, Error('SafeMath: addition overflow'));\n    _totalSupply = v0;\n    v1 = address(varg1);\n    v2 = _balanceOf[v1] + varg0;\n    require(v2 >= _balanceOf[v1], Error('SafeMath: addition overflow'));\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(0, address(varg1), varg0);\n    return ;\n}\n\nfunction 0xffd(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0, Error('ERC20: burn from the zero address'));\n    v0 = new struct(3);\n    v0.word0 = 34;\n    v1 = address(varg1);\n    v2 = _SafeSub(v0, varg0, _balanceOf[v1]);\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    v4 = new struct(2);\n    v4.word0 = 30;\n    v5 = v4.data;\n    v4.word1 = 'SafeMath: subtraction overflow';\n    v6 = _SafeSub(v4, varg0, _totalSupply);\n    _totalSupply = v6;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(address(varg1), 0, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x39509351 > function_selector >> 224) {\n        if (0x18160ddd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else {\n                require(0x1249c58b == function_selector >> 224);\n                mint();\n            }\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x19ffd7ce == function_selector >> 224) {\n            flashMint(uint256);\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0xa457c2d7 > function_selector >> 224) {\n        if (0x39509351 == function_selector >> 224) {\n            increaseAllowance(address,uint256);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdb006a75 == function_selector >> 224) {\n        redeem(uint256);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.06 02:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x11b5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, Error('ERC20: transfer from the zero address'));\n    require(address(varg1) != 0, Error('ERC20: transfer to the zero address'));\n    v0 = new struct(3);\n    v0.word0 = 38;\n    v1 = address(varg2);\n    v2 = _SafeSub(v0, varg0, _balanceOf[v1]);\n    v3 = address(varg2);\n    _balanceOf[v3] = v2;\n    v4 = address(varg1);\n    v5 = _balanceOf[v4] + varg0;\n    require(v5 >= _balanceOf[v4], Error('SafeMath: addition overflow'));\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new array[](varg0.word0);\n        v1 = v2 = 0;\n        while (v1 < varg0.word0) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v3 = v4 = varg0.word0 + v0.data;\n        if (0x1f & varg0.word0) {\n            MEM[v4 - (0x1f & varg0.word0)] = ~(256 ** (32 - (0x1f & varg0.word0)) - 1) & MEM[v4 - (0x1f & varg0.word0)];\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0xc4b(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction mint() public payable { \n    0xe42(msg.value, msg.sender);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction flashMint(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xe42(varg0, msg.sender);\n    require(msg.sender.code.size);\n    v0 = msg.sender.executeOnFlashMint(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    0xffd(varg0, msg.sender);\n    require(this.balance >= _totalSupply, Error('redeemability was broken'));\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    0x11b5(varg2, varg1, varg0);\n    v0 = new struct(3);\n    v0.word0 = 40;\n    v1 = _SafeSub(v0, varg2, STORAGE[keccak256(msg.sender, keccak256(varg0, 1))]);\n    0xc4b(v1, msg.sender, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_allowance[varg0] + varg1 >= _allowance[varg0], Error('SafeMath: addition overflow'));\n    0xc4b(_allowance[varg0] + varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = new struct(3);\n    v0.word0 = 37;\n    v1 = _SafeSub(v0, varg1, _allowance[varg0]);\n    0xc4b(v1, varg0, msg.sender);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x11b5(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction redeem(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xffd(varg0, msg.sender);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction 0xc4b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, Error('ERC20: approve from the zero address'));\n    require(address(varg1) != 0, Error('ERC20: approve to the zero address'));\n    v0 = address(varg2);\n    v1 = address(varg1);\n    _allowance[v1] = varg0;\n    emit Approval(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0xe42(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0, Error('ERC20: mint to the zero address'));\n    v0 = _totalSupply + varg0;\n    require(v0 >= _totalSupply, Error('SafeMath: addition overflow'));\n    _totalSupply = v0;\n    v1 = address(varg1);\n    v2 = _balanceOf[v1] + varg0;\n    require(v2 >= _balanceOf[v1], Error('SafeMath: addition overflow'));\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(0, address(varg1), varg0);\n    return ;\n}\n\nfunction 0xffd(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0, Error('ERC20: burn from the zero address'));\n    v0 = new struct(3);\n    v0.word0 = 34;\n    v1 = address(varg1);\n    v2 = _SafeSub(v0, varg0, _balanceOf[v1]);\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    v4 = new struct(2);\n    v4.word0 = 30;\n    v5 = v4.data;\n    v4.word1 = 'SafeMath: subtraction overflow';\n    v6 = _SafeSub(v4, varg0, _totalSupply);\n    _totalSupply = v6;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(address(varg1), 0, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x39509351 > function_selector >> 224) {\n        if (0x18160ddd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else {\n                require(0x1249c58b == function_selector >> 224);\n                mint();\n            }\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x19ffd7ce == function_selector >> 224) {\n            flashMint(uint256);\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0xa457c2d7 > function_selector >> 224) {\n        if (0x39509351 == function_selector >> 224) {\n            increaseAllowance(address,uint256);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdb006a75 == function_selector >> 224) {\n        redeem(uint256);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.06 02:34 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x2]\nuint256[] _name; // STORAGE[0x3]\nuint256[] _symbol; // STORAGE[0x4]\nuint256 _decimals; // STORAGE[0x5] bytes 0 to 0\n\n// Events\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction 0x11b5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, Error('ERC20: transfer from the zero address'));\n    require(address(varg1) != 0, Error('ERC20: transfer to the zero address'));\n    v0 = new struct(3);\n    v0.word0 = 38;\n    v1 = address(varg2);\n    v2 = _SafeSub(v0, varg0, _balanceOf[v1]);\n    v3 = address(varg2);\n    _balanceOf[v3] = v2;\n    v4 = address(varg1);\n    v5 = _balanceOf[v4] + varg0;\n    require(v5 >= _balanceOf[v4], Error('SafeMath: addition overflow'));\n    v6 = address(varg1);\n    _balanceOf[v6] = v5;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        return varg2 - varg1;\n    } else {\n        v0 = new array[](varg0.word0);\n        v1 = v2 = 0;\n        while (v1 < varg0.word0) {\n            v0[v1] = varg0[v1];\n            v1 = v1 + 32;\n        }\n        v3 = v4 = varg0.word0 + v0.data;\n        if (0x1f & varg0.word0) {\n            MEM[v4 - (0x1f & varg0.word0)] = ~(256 ** (32 - (0x1f & varg0.word0)) - 1) & MEM[v4 - (0x1f & varg0.word0)];\n        }\n        revert(Error(v0));\n    }\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0xc4b(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction mint() public payable { \n    0xe42(msg.value, msg.sender);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction flashMint(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xe42(varg0, msg.sender);\n    require(msg.sender.code.size);\n    v0 = msg.sender.executeOnFlashMint(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    0xffd(varg0, msg.sender);\n    require(this.balance >= _totalSupply, Error('redeemability was broken'));\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    0x11b5(varg2, varg1, varg0);\n    v0 = new struct(3);\n    v0.word0 = 40;\n    v1 = _SafeSub(v0, varg2, STORAGE[keccak256(msg.sender, keccak256(varg0, 1))]);\n    0xc4b(v1, msg.sender, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_allowance[varg0] + varg1 >= _allowance[varg0], Error('SafeMath: addition overflow'));\n    0xc4b(_allowance[varg0] + varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = new struct(3);\n    v0.word0 = 37;\n    v1 = _SafeSub(v0, varg1, _allowance[varg0]);\n    0xc4b(v1, varg0, msg.sender);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x11b5(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction redeem(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    0xffd(varg0, msg.sender);\n    v0 = msg.sender.call().value(varg0).gas(!varg0 * 2300);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction 0xc4b(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, Error('ERC20: approve from the zero address'));\n    require(address(varg1) != 0, Error('ERC20: approve to the zero address'));\n    v0 = address(varg2);\n    v1 = address(varg1);\n    _allowance[v1] = varg0;\n    emit Approval(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        v4[v5] = v0[v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction 0xe42(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0, Error('ERC20: mint to the zero address'));\n    v0 = _totalSupply + varg0;\n    require(v0 >= _totalSupply, Error('SafeMath: addition overflow'));\n    _totalSupply = v0;\n    v1 = address(varg1);\n    v2 = _balanceOf[v1] + varg0;\n    require(v2 >= _balanceOf[v1], Error('SafeMath: addition overflow'));\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    emit Transfer(0, address(varg1), varg0);\n    return ;\n}\n\nfunction 0xffd(uint256 varg0, uint256 varg1) private { \n    require(address(varg1) != 0, Error('ERC20: burn from the zero address'));\n    v0 = new struct(3);\n    v0.word0 = 34;\n    v1 = address(varg1);\n    v2 = _SafeSub(v0, varg0, _balanceOf[v1]);\n    v3 = address(varg1);\n    _balanceOf[v3] = v2;\n    v4 = new struct(2);\n    v4.word0 = 30;\n    v5 = v4.data;\n    v4.word1 = 'SafeMath: subtraction overflow';\n    v6 = _SafeSub(v4, varg0, _totalSupply);\n    _totalSupply = v6;\n    MEM[MEM[64]] = varg0;\n    emit Transfer(address(varg1), 0, varg0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        ();\n    } else if (0x39509351 > function_selector >> 224) {\n        if (0x18160ddd > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else {\n                require(0x1249c58b == function_selector >> 224);\n                mint();\n            }\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x19ffd7ce == function_selector >> 224) {\n            flashMint(uint256);\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else {\n            require(0x313ce567 == function_selector >> 224);\n            decimals();\n        }\n    } else if (0xa457c2d7 > function_selector >> 224) {\n        if (0x39509351 == function_selector >> 224) {\n            increaseAllowance(address,uint256);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa457c2d7 == function_selector >> 224) {\n        decreaseAllowance(address,uint256);\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xdb006a75 == function_selector >> 224) {\n        redeem(uint256);\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 111.95729660987854,
	"usage": {
		"completion_tokens": 373,
		"prompt_tokens": 2865,
		"total_tokens": 3238
	}
}