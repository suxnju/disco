{
	"address": "0x92579f2fa430b20bf6ce9d19938fe061aad992e2",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity contract that matches the decompiled code would look like this:\n\n```solidity\npragma solidity >=0.4.22 <0.7.0;\n\ncontract Crowdsale {\n    // Variables\n    uint256[] private _name;\n    uint256 private _fundingGoal;\n    uint256 private _amountRaised;\n    uint256 private _deadline;\n    uint256 private _price;\n    uint256 private _tokensLeft;\n    mapping (address => uint256) private _balanceOf;\n    uint256 private _fundingGoalReached;\n    address private _beneficiary;\n    address private _tokenReward;\n\n    // Events\n    event FundTransfer(address backer, uint256 amount, bool isContribution);\n    event GoalReached(address recipient, uint256 totalAmountRaised);\n\n    // Functions\n    function checkGoalReached() public {\n        if (now >= _deadline) {\n            if (_amountRaised >= _fundingGoal) {\n                _fundingGoalReached = 1;\n                emit GoalReached(_beneficiary, _amountRaised);\n            }\n        }\n    }\n\n    function bringBackTokens() public {\n        if (now >= _deadline && _tokensLeft > 0 && _beneficiary == msg.sender) {\n            // This part of the code would require interaction with another contract\n            // that manages tokens. Here, we assume the existence of a TokenReward contract\n            // with a certain API (transfer, getBalanceOf)\n            // TokenReward token = TokenReward(_tokenReward);\n            // token.transfer(_beneficiary, _tokensLeft);\n            // _tokensLeft = token.getBalanceOf(address(this));\n        }\n    }\n\n    function name() public view returns (uint256[] memory) {\n        return _name;\n    }\n\n    function deadline() public view returns (uint256) {\n        return _deadline;\n    }\n\n    function beneficiary() public view returns (address) {\n        return _beneficiary;\n    }\n\n    function tokenReward() public view returns (address) {\n        return _tokenReward;\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balanceOf[user];\n    }\n\n    function fundingGoal() public view returns (uint256) {\n        return _fundingGoal;\n    }\n\n    function amountRaised() public view returns (uint256) {\n        return _amountRaised;\n    }\n\n    function price() public view returns (uint256) {\n        return _price;\n    }\n\n    function tokensLeft() public view returns (uint256) {\n        return _tokensLeft;\n    }\n    \n    function crowdsaleClosed() public view returns (bool) {\n        return _fundingGoalReached == 1;\n    }\n    \n    function updateTokensAvailable() public {\n        // This part of the code would require interaction with another contract\n        // that manages tokens. Here, we assume the existence of a TokenReward contract\n        // with a certain API (getBalanceOf)\n        // TokenReward token = TokenReward(_tokenReward);\n        // _tokensLeft = token.getBalanceOf(address(this));\n    }\n\n    function safeWithdrawal() public {\n        if (now >= _deadline) {\n            if (_fundingGoalReached == 0 && _balanceOf[msg.sender] > 0) {\n                uint256 amount = _balanceOf[msg.sender];\n                _balanceOf[msg.sender] = 0;\n                if (msg.sender.send(amount)) {\n                    emit FundTransfer(msg.sender, amount, false);\n                } else {\n                    _balanceOf[msg.sender] = amount;\n                }\n            }\n\n            if (_fundingGoalReached == 1 && _beneficiary == msg.sender) {\n                if (_beneficiary.send(_amountRaised)) {\n                    emit FundTransfer(_beneficiary, _amountRaised, false);\n                } else {\n                    _fundingGoalReached = 0;\n                }\n            }\n        }\n    }\n}\n```\n\nPlease note that the \"__function_selector__\" function from the decompiled code is not included in the Solidity contract. This function is used at a lower level (EVM bytecode) and does not have a direct equivalent in Solidity. Also, the parts of the code that deal with the token contract have been commented out because the actual implementation depends on the specifics of the token contract used.",
				"role": "assistant"
			}
		}
	],
	"created": 1701460604,
	"id": "chatcmpl-8R3uu2FrvJOUCwzp2kP78gLQabbVy",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 21:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _fundingGoal; // STORAGE[0x2]\nuint256 _amountRaised; // STORAGE[0x3]\nuint256 _deadline; // STORAGE[0x4]\nuint256 _price; // STORAGE[0x5]\nuint256 _tokensLeft; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x8]\nuint256 _fundingGoalReached; // STORAGE[0x9]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x1] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _fundingGoalReached = ~0xff00 & (0x1 | _fundingGoalReached & ~0xff) | 0x100;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n    }\n}\n\nfunction bringBackTokens() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        require(_tokensLeft > 0);\n        if (_beneficiary == msg.sender) {\n            require(_tokenReward.code.size);\n            v0 = _tokenReward.transfer(_beneficiary, _tokensLeft).gas(msg.gas - 710);\n            require(v0);\n            MEM[32 + MEM[64]] = 0;\n            require(_tokenReward.code.size);\n            v1, v2 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n            require(v1);\n            _tokensLeft = v2;\n            goto 0x27e0x295;\n        }\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction tokensLeft() public nonPayable { \n    return _tokensLeft;\n}\n\nfunction crowdsaleClosed() public nonPayable { \n    return 0xff & _fundingGoalReached >> 8;\n}\n\nfunction fundingGoalReached() public nonPayable { \n    return 0xff & _fundingGoalReached;\n}\n\nfunction updateTokensAvailable() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    _tokensLeft = v1;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!(0xff & _fundingGoalReached)) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = 0xff & _fundingGoalReached;\n        if (v2) {\n            v1 = _beneficiary == msg.sender;\n        }\n        if (v1) {\n            v3 = _beneficiary.call().value(_amountRaised).gas(2300 * !_amountRaised);\n            if (!v3) {\n                _fundingGoalReached = ~0xff & _fundingGoalReached;\n                goto 0x27e0x4e0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1cb3b20) {\n            checkGoalReached();\n        } else if (0x263379b == v0) {\n            bringBackTokens();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x29dcb0cf == v0) {\n            deadline();\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == v0) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == v0) {\n            amountRaised();\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xb31f8f93 == v0) {\n            tokensLeft();\n        } else if (0xccb07cef == v0) {\n            crowdsaleClosed();\n        } else if (0xd424f628 == v0) {\n            fundingGoalReached();\n        } else if (0xfd6133a6 == v0) {\n            updateTokensAvailable();\n        } else if (0xfd6b7ef8 == v0) {\n            safeWithdrawal();\n        }\n    }\n    require(!(0xff & _fundingGoalReached >> 8));\n    assert(stor_5_0_0);\n    require(_tokensLeft >= 0 / _price);\n    _balanceOf[msg.sender] += msg.value;\n    _amountRaised += msg.value;\n    assert(stor_5_0_0);\n    require(_tokenReward.code.size);\n    v1 = _tokenReward.transfer(msg.sender, msg.value / _price).gas(msg.gas - 710);\n    require(v1);\n    emit FundTransfer(msg.sender, msg.value, 1);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v2, v3 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n    require(v2);\n    _tokensLeft = v3;\n    if (!v3) {\n        _fundingGoalReached = 0x100 | ~0xff00 & _fundingGoalReached;\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 21:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _fundingGoal; // STORAGE[0x2]\nuint256 _amountRaised; // STORAGE[0x3]\nuint256 _deadline; // STORAGE[0x4]\nuint256 _price; // STORAGE[0x5]\nuint256 _tokensLeft; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x8]\nuint256 _fundingGoalReached; // STORAGE[0x9]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x1] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _fundingGoalReached = ~0xff00 & (0x1 | _fundingGoalReached & ~0xff) | 0x100;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n    }\n}\n\nfunction bringBackTokens() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        require(_tokensLeft > 0);\n        if (_beneficiary == msg.sender) {\n            require(_tokenReward.code.size);\n            v0 = _tokenReward.transfer(_beneficiary, _tokensLeft).gas(msg.gas - 710);\n            require(v0);\n            MEM[32 + MEM[64]] = 0;\n            require(_tokenReward.code.size);\n            v1, v2 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n            require(v1);\n            _tokensLeft = v2;\n            goto 0x27e0x295;\n        }\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction tokensLeft() public nonPayable { \n    return _tokensLeft;\n}\n\nfunction crowdsaleClosed() public nonPayable { \n    return 0xff & _fundingGoalReached >> 8;\n}\n\nfunction fundingGoalReached() public nonPayable { \n    return 0xff & _fundingGoalReached;\n}\n\nfunction updateTokensAvailable() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    _tokensLeft = v1;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!(0xff & _fundingGoalReached)) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = 0xff & _fundingGoalReached;\n        if (v2) {\n            v1 = _beneficiary == msg.sender;\n        }\n        if (v1) {\n            v3 = _beneficiary.call().value(_amountRaised).gas(2300 * !_amountRaised);\n            if (!v3) {\n                _fundingGoalReached = ~0xff & _fundingGoalReached;\n                goto 0x27e0x4e0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1cb3b20) {\n            checkGoalReached();\n        } else if (0x263379b == v0) {\n            bringBackTokens();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x29dcb0cf == v0) {\n            deadline();\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == v0) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == v0) {\n            amountRaised();\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xb31f8f93 == v0) {\n            tokensLeft();\n        } else if (0xccb07cef == v0) {\n            crowdsaleClosed();\n        } else if (0xd424f628 == v0) {\n            fundingGoalReached();\n        } else if (0xfd6133a6 == v0) {\n            updateTokensAvailable();\n        } else if (0xfd6b7ef8 == v0) {\n            safeWithdrawal();\n        }\n    }\n    require(!(0xff & _fundingGoalReached >> 8));\n    assert(stor_5_0_0);\n    require(_tokensLeft >= 0 / _price);\n    _balanceOf[msg.sender] += msg.value;\n    _amountRaised += msg.value;\n    assert(stor_5_0_0);\n    require(_tokenReward.code.size);\n    v1 = _tokenReward.transfer(msg.sender, msg.value / _price).gas(msg.gas - 710);\n    require(v1);\n    emit FundTransfer(msg.sender, msg.value, 1);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v2, v3 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n    require(v2);\n    _tokensLeft = v3;\n    if (!v3) {\n        _fundingGoalReached = 0x100 | ~0xff00 & _fundingGoalReached;\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 21:06 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _fundingGoal; // STORAGE[0x2]\nuint256 _amountRaised; // STORAGE[0x3]\nuint256 _deadline; // STORAGE[0x4]\nuint256 _price; // STORAGE[0x5]\nuint256 _tokensLeft; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x8]\nuint256 _fundingGoalReached; // STORAGE[0x9]\nuint8 stor_5_0_0; // STORAGE[0x5] bytes 0 to 0\naddress _beneficiary; // STORAGE[0x1] bytes 0 to 19\naddress _tokenReward; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _fundingGoalReached = ~0xff00 & (0x1 | _fundingGoalReached & ~0xff) | 0x100;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n    }\n}\n\nfunction bringBackTokens() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        require(_tokensLeft > 0);\n        if (_beneficiary == msg.sender) {\n            require(_tokenReward.code.size);\n            v0 = _tokenReward.transfer(_beneficiary, _tokensLeft).gas(msg.gas - 710);\n            require(v0);\n            MEM[32 + MEM[64]] = 0;\n            require(_tokenReward.code.size);\n            v1, v2 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n            require(v1);\n            _tokensLeft = v2;\n            goto 0x27e0x295;\n        }\n    }\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction tokensLeft() public nonPayable { \n    return _tokensLeft;\n}\n\nfunction crowdsaleClosed() public nonPayable { \n    return 0xff & _fundingGoalReached >> 8;\n}\n\nfunction fundingGoalReached() public nonPayable { \n    return 0xff & _fundingGoalReached;\n}\n\nfunction updateTokensAvailable() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v0, v1 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    _tokensLeft = v1;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!(0xff & _fundingGoalReached)) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(2300 * !_balanceOf[msg.sender]);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = 0xff & _fundingGoalReached;\n        if (v2) {\n            v1 = _beneficiary == msg.sender;\n        }\n        if (v1) {\n            v3 = _beneficiary.call().value(_amountRaised).gas(2300 * !_amountRaised);\n            if (!v3) {\n                _fundingGoalReached = ~0xff & _fundingGoalReached;\n                goto 0x27e0x4e0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        v0 = uint32(function_selector >> 224);\n        if (v0 == 0x1cb3b20) {\n            checkGoalReached();\n        } else if (0x263379b == v0) {\n            bringBackTokens();\n        } else if (0x6fdde03 == v0) {\n            name();\n        } else if (0x29dcb0cf == v0) {\n            deadline();\n        } else if (0x38af3eed == v0) {\n            beneficiary();\n        } else if (0x6e66f6e9 == v0) {\n            tokenReward();\n        } else if (0x70a08231 == v0) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == v0) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == v0) {\n            amountRaised();\n        } else if (0xa035b1fe == v0) {\n            price();\n        } else if (0xb31f8f93 == v0) {\n            tokensLeft();\n        } else if (0xccb07cef == v0) {\n            crowdsaleClosed();\n        } else if (0xd424f628 == v0) {\n            fundingGoalReached();\n        } else if (0xfd6133a6 == v0) {\n            updateTokensAvailable();\n        } else if (0xfd6b7ef8 == v0) {\n            safeWithdrawal();\n        }\n    }\n    require(!(0xff & _fundingGoalReached >> 8));\n    assert(stor_5_0_0);\n    require(_tokensLeft >= 0 / _price);\n    _balanceOf[msg.sender] += msg.value;\n    _amountRaised += msg.value;\n    assert(stor_5_0_0);\n    require(_tokenReward.code.size);\n    v1 = _tokenReward.transfer(msg.sender, msg.value / _price).gas(msg.gas - 710);\n    require(v1);\n    emit FundTransfer(msg.sender, msg.value, 1);\n    MEM[32 + MEM[64]] = 0;\n    require(_tokenReward.code.size);\n    v2, v3 = _tokenReward.getBalanceOf(address(this)).gas(msg.gas - 710);\n    require(v2);\n    _tokensLeft = v3;\n    if (!v3) {\n        _fundingGoalReached = 0x100 | ~0xff00 & _fundingGoalReached;\n    }\n}\n.",
	"status": "1",
	"time_cost": 38.6624321937561,
	"usage": {
		"completion_tokens": 878,
		"prompt_tokens": 1893,
		"total_tokens": 2771
	}
}