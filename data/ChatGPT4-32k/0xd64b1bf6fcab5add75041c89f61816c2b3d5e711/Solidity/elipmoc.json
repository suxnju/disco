{
	"address": "0xd64b1bf6fcab5add75041c89f61816c2b3d5e711",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here is the Solidity code from the decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract GuardianRegistry {\n    uint256 private _registrationDepositWei;\n    uint256 private _registrationMinTime;\n    address[] private guardians;\n    mapping (address => Guardian) private _isGuardian;\n\n    struct Guardian {\n        string name;\n        string website;\n        uint256 index;\n        uint256 registrationBlock;\n        uint256 updateBlock;\n        uint256 registrationTime;\n    }\n\n    event GuardianRegistered(address indexed guardian);\n    event GuardianLeft(address indexed guardian);\n    event GuardianUpdated(address indexed guardian);\n\n    function register(string memory name, string memory website) public payable { \n        require(msg.sender == tx.origin, 'Only EOA may register as Guardian');\n        require(bytes(name).length > 0, 'Please provide a valid name');\n        require(bytes(website).length > 0, 'Please provide a valid website');\n        require(_isGuardian[msg.sender].registrationBlock == 0, 'Cannot be a guardian');\n        require(msg.value == _registrationDepositWei, 'Please provide the exact registration deposit');\n        _isGuardian[msg.sender] = Guardian(name, website, guardians.length, block.number, block.number, block.timestamp);\n        guardians.push(msg.sender);\n        emit GuardianRegistered(msg.sender);\n    }\n\n    function getGuardianData(address guardian) public view returns (string memory, string memory) { \n        require(_isGuardian[guardian].registrationBlock > 0, 'Please provide a listed Guardian');\n        return (_isGuardian[guardian].name, _isGuardian[guardian].website);\n    }\n\n    function getRegistrationBlockNumber(address guardian) public view returns (uint256, uint256) { \n        require(_isGuardian[guardian].registrationBlock > 0, 'Please provide a listed Guardian');\n        return (_isGuardian[guardian].registrationBlock, _isGuardian[guardian].updateBlock);\n    }\n\n    function leave() public { \n        require(_isGuardian[msg.sender].registrationBlock > 0, 'You must be a registered guardian');\n        require(msg.sender == tx.origin, 'Only EOA may register as Guardian');\n        require(block.timestamp >= _registrationMinTime + _isGuardian[msg.sender].registrationTime, 'Minimal guardian time didnt pass');\n        uint256 guardianIndex = _isGuardian[msg.sender].index;\n        address lastGuardian = guardians[guardians.length - 1];\n        guardians[guardianIndex] = lastGuardian;\n        _isGuardian[lastGuardian].index = guardianIndex;\n        guardians.pop();\n        delete _isGuardian[msg.sender];\n        payable(msg.sender).transfer(_registrationDepositWei);\n        emit GuardianLeft(msg.sender);\n    }\n\n    function update(string memory name, string memory website) public { \n        require(_isGuardian[msg.sender].registrationBlock > 0, 'You must be a registered guardian');\n        require(msg.sender == tx.origin, 'Only EOA may register as Guardian');\n        require(bytes(name).length > 0, 'Please provide a valid name');\n        require(bytes(website).length > 0, 'Please provide a valid website');\n        _isGuardian[msg.sender].name = name;\n        _isGuardian[msg.sender].website = website;\n        _isGuardian[msg.sender].updateBlock = block.number;\n        emit GuardianUpdated(msg.sender);\n    }\n\n    function registrationMinTime() public view returns (uint256) { \n        return _registrationMinTime;\n    }\n\n    function VERSION() public pure returns (uint256) { \n        return 1;\n    }\n\n    function isGuardian(address guardian) public view returns (bool) { \n        return _isGuardian[guardian].registrationBlock > 0;\n    }\n\n    function registrationDepositWei() public view returns (uint256) { \n        return _registrationDepositWei;\n    }\n}\n```\n\nPlease note that this is a conceptual conversion and might not be perfectly accurate. It's also worth mentioning that the original bytecode seems to have some undefined variables and mysterious operations, which are not translated in this solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039108,
	"id": "chatcmpl-8ChpUip6icDpqcY7ACa0XhwOJeyjO",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.13 12:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _registrationDepositWei; // STORAGE[0x0]\nuint256 _registrationMinTime; // STORAGE[0x1]\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _isGuardian; // STORAGE[0x3]\n\n// Events\nGuardianRegistered(address);\nGuardianLeft(address);\nGuardianUpdated(address);\n\nfunction register(string varg0, string varg1) public payable { \n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require((?).length > 0, 'Please provide a valid name');\n    require((?).length > 0, 'Please provide a valid website');\n    require(_isGuardian[msg.sender][3] <= 0, 'Cannot be a guardian');\n    require(msg.value == _registrationDepositWei, 'Please provide the exact registration deposit');\n    array_2.length = array_2.length + 1;\n    STORAGE[array_2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[array_2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace];\n    MEM[MEM[64] + 192] = (?).length;\n    CALLDATACOPY(MEM[64] + 224, varg0 + 36, (?).length);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    v1 = msg.sender;\n    v2 = v3 = 32 + (MEM[64] + 192);\n    if (31 < MEM[MEM[64] + 192]) {\n        _isGuardian[v1][0] = 1 + (MEM[MEM[64] + 192] + MEM[MEM[64] + 192]);\n        if (MEM[MEM[64] + 192]) {\n            while (v3 + MEM[MEM[64] + 192] > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _isGuardian[v1][0] = MEM[MEM[64] + 192] + MEM[MEM[64] + 192] | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + (((!(0x1 & _isGuardian[v1][0x0]) << 8) - 1 & _isGuardian[v1][0x0]) >> 1) >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = v7 = v0 + 32;\n    if (31 < MEM[v0]) {\n        _isGuardian[v1][1] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v7 + MEM[v0] > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _isGuardian[v1][1] = MEM[v0] + MEM[v0] | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + (((!(0x1 & _isGuardian[v1][0x1]) << 8) - 1 & _isGuardian[v1][0x1]) >> 1) >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    _isGuardian[v1][2] = array_2.length;\n    _isGuardian[v1][3] = block.number;\n    _isGuardian[v1][4] = block.number;\n    _isGuardian[v1][5] = block.timestamp;\n    emit GuardianRegistered(msg.sender);\n}\n\nfunction getGuardianData(address varg0) public nonPayable { \n    require(_isGuardian[varg0][3] > 0, 'Please provide a listed Guardian');\n    v0 = new bytes[](v1);\n    v1 = (_isGuardian[varg0] & (!(_isGuardian[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _isGuardian[varg0] >> 8 << 8;\n        }\n    }\n    v5 = ((!(0x1 & _isGuardian[varg0][0x1]) << 8) - 1 & _isGuardian[varg0][0x1]) >> 1;\n    v6 = new bytes[](v5);\n    v7 = v8 = v6.data;\n    v9 = ((!(0x1 & _isGuardian[varg0][0x1]) << 8) - 1 & _isGuardian[varg0][0x1]) >> 1;\n    if (v9) {\n        if (31 < v9) {\n            do {\n                MEM[v7] = STORAGE[v10];\n                v10 += 1;\n                v7 += 32;\n            } while (v8 + v9 <= v7);\n        } else {\n            MEM[v8] = _isGuardian[varg0][1] >> 8 << 8;\n        }\n    }\n    v11 = new array[](v0.length);\n    v12 = v13 = 0;\n    while (v12 < v0.length) {\n        MEM[v12 + v11.data] = MEM[v12 + v0.data];\n        v12 += 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v11.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v11.data - (0x1f & v0.length)];\n    }\n    v14 = new array[](v6.length);\n    v15 = v16 = 0;\n    while (v15 < v6.length) {\n        MEM[v15 + v14.data] = MEM[v15 + v6.data];\n        v15 += 32;\n    }\n    v17 = v18 = v6.length + v14.data;\n    if (0x1f & v6.length) {\n        MEM[v18 - (0x1f & v6.length)] = ~(256 ** (32 - (0x1f & v6.length)) - 1) & MEM[v18 - (0x1f & v6.length)];\n    }\n    return v11, v14;\n}\n\nfunction getGuardiansBytes20(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = 0xd56(varg1, varg0);\n    v1 = new uint256[](MEM[v0]);\n    if (MEM[v0]) {\n        MEM[(v1.data) len (MEM[v0] << 5)] = this.code[this.code.size len (MEM[v0] << 5)];\n    }\n    v2 = v3 = 0;\n    while (v2 < MEM[v0]) {\n        assert(v2 < MEM[v0]);\n        assert(v2 < v1.length);\n        v1[v2] = MEM[(v2 << 5) + (32 + v0)] << 96 & ~0xffffffffffffffffffffffff;\n        v2 += 1;\n    }\n    v4 = new array[](v1.length);\n    v5 = v6 = 0;\n    while (v5 < v1.length << 5) {\n        MEM[v5 + v4.data] = MEM[v5 + v1.data];\n        v5 += 32;\n    }\n    return v4;\n}\n\nfunction getRegistrationBlockNumber(address varg0) public nonPayable { \n    require(_isGuardian[varg0][3] > 0, 'Please provide a listed Guardian');\n    return _isGuardian[varg0][3], _isGuardian[varg0][4];\n}\n\nfunction leave() public nonPayable { \n    require(_isGuardian[msg.sender][3] > 0, 'You must be a registered guardian');\n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require(_registrationMinTime + _isGuardian[msg.sender][5] >= _isGuardian[msg.sender][5]);\n    require(block.timestamp >= _registrationMinTime + _isGuardian[msg.sender][5], 'Minimal guardian time didnt pass');\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    assert(address(array_2[_isGuardian[msg.sender][2]]) == msg.sender);\n    assert(array_2.length + ~0 < array_2.length);\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    array_2[_isGuardian[msg.sender][2]] = address(array_2[array_2.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[_isGuardian[msg.sender][2]];\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    _isGuardian[address(array_2[_isGuardian[msg.sender][2]])][2] = _isGuardian[msg.sender][2];\n    array_2.length = array_2.length + ~0;\n    if (array_2.length > array_2.length + ~0) {\n        v0 = v1 = array_2.length + ~0 + keccak256(2);\n        while (keccak256(2) + array_2.length > v0) {\n            STORAGE[v0] = 0;\n            v0 += 1;\n        }\n        goto 0x1161B0xc57;\n    }\n    _isGuardian[msg.sender] = 0;\n    if (31 < ((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) {\n        while (v2 + (31 + (((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) >> 5) > v3) {\n            STORAGE[v3] = 0;\n            v3 += 1;\n        }\n        goto 0x11aaB0xc95;\n    }\n    _isGuardian[msg.sender][1] = 0;\n    if (31 < ((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) {\n        while (v4 + (31 + (((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) >> 5) > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        goto 0x11aaB0xcb9;\n    }\n    _isGuardian[msg.sender][2] = 0;\n    _isGuardian[msg.sender][3] = 0;\n    _isGuardian[msg.sender][4] = 0;\n    _isGuardian[msg.sender][5] = 0;\n    v6 = msg.sender.call().value(_registrationDepositWei).gas(2300 * !_registrationDepositWei);\n    require(v6); // checks call status, propagates error data on error\n    emit GuardianLeft(msg.sender);\n}\n\nfunction getGuardians(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = 0xd56(varg1, varg0);\n    v1 = new array[](MEM[v0]);\n    v2 = v3 = 0;\n    while (v2 < MEM[v0] << 5) {\n        MEM[v2 + v1.data] = MEM[v2 + (32 + v0)];\n        v2 += 32;\n    }\n    return v1;\n}\n\nfunction update(string varg0, string varg1) public nonPayable { \n    v0 = v1 = varg0 + 36;\n    v2 = v3 = varg1 + 36;\n    require(_isGuardian[msg.sender][3] > 0, 'You must be a registered guardian');\n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require((?).length > 0, 'Please provide a valid name');\n    require((?).length > 0, 'Please provide a valid website');\n    if (31 < (?).length) {\n        _isGuardian[msg.sender] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v1 + (?).length > v0) {\n                STORAGE[v4] = msg.data[v0];\n                v0 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _isGuardian[msg.sender] = msg.data[v1] & ~0xff | (?).length + (?).length;\n    }\n    while (v5 + (31 + (((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    if (31 < (?).length) {\n        _isGuardian[msg.sender][1] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v3 + (?).length > v2) {\n                STORAGE[v6] = msg.data[v2];\n                v2 += 32;\n                v6 += 1;\n            }\n        }\n    } else {\n        _isGuardian[msg.sender][1] = msg.data[v3] & ~0xff | (?).length + (?).length;\n    }\n    while (v7 + (31 + (((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) >> 5) > v6) {\n        STORAGE[v6] = 0;\n        v6 += 1;\n    }\n    _isGuardian[msg.sender][4] = block.number;\n    emit GuardianUpdated(msg.sender);\n}\n\nfunction registrationMinTime() public nonPayable { \n    return _registrationMinTime;\n}\n\nfunction VERSION() public nonPayable { \n    return 1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isGuardian(address varg0) public nonPayable { \n    return _isGuardian[varg0][3] > 0;\n}\n\nfunction 0xd56(uint256 varg0, uint256 varg1) private { \n    if (varg1 < array_2.length) {\n        v0 = varg0 + varg1;\n        require(v0 >= varg1);\n        if (v0 > array_2.length) {\n            require(varg1 <= array_2.length);\n            varg0 = v1 = array_2.length - varg1;\n        }\n        v2 = v3 = new uint256[](varg0);\n        if (varg0) {\n            v4 = varg0 << 5;\n            MEM[(v3.data) len v4] = this.code[this.code.size len v4];\n        }\n        v5 = v6 = 0;\n        while (v5 < v3.length) {\n            v7 = v5 + varg1;\n            require(v7 >= varg1);\n            assert(v7 < array_2.length);\n            assert(v5 < v3.length);\n            v3[v5] = address(array_2[v7]);\n            v5 += 1;\n        }\n    } else {\n        v2 = v8 = MEM[64];\n        MEM[v8] = 0;\n        MEM[64] = v8 + 32;\n    }\n    return v2;\n}\n\nfunction registrationDepositWei() public nonPayable { \n    return _registrationDepositWei;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc68ba21) {\n            isGuardian(address);\n        } else if (0x1201b4bd == function_selector) {\n            registrationDepositWei();\n        } else if (0x3ffbd47f == function_selector) {\n            register(string,string);\n        } else if (0x4b139a47 == function_selector) {\n            getGuardianData(address);\n        } else if (0x4cf1f60b == function_selector) {\n            getGuardiansBytes20(uint256,uint256);\n        } else if (0x50d8f786 == function_selector) {\n            getRegistrationBlockNumber(address);\n        } else if (0xd66d9e19 == function_selector) {\n            leave();\n        } else if (0xd93d7d29 == function_selector) {\n            getGuardians(uint256,uint256);\n        } else if (0xf4c84d19 == function_selector) {\n            update(string,string);\n        } else if (0xf5660650 == function_selector) {\n            registrationMinTime();\n        } else if (0xffa1ad74 == function_selector) {\n            VERSION();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 12:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _registrationDepositWei; // STORAGE[0x0]\nuint256 _registrationMinTime; // STORAGE[0x1]\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _isGuardian; // STORAGE[0x3]\n\n// Events\nGuardianRegistered(address);\nGuardianLeft(address);\nGuardianUpdated(address);\n\nfunction register(string varg0, string varg1) public payable { \n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require((?).length > 0, 'Please provide a valid name');\n    require((?).length > 0, 'Please provide a valid website');\n    require(_isGuardian[msg.sender][3] <= 0, 'Cannot be a guardian');\n    require(msg.value == _registrationDepositWei, 'Please provide the exact registration deposit');\n    array_2.length = array_2.length + 1;\n    STORAGE[array_2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[array_2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace];\n    MEM[MEM[64] + 192] = (?).length;\n    CALLDATACOPY(MEM[64] + 224, varg0 + 36, (?).length);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    v1 = msg.sender;\n    v2 = v3 = 32 + (MEM[64] + 192);\n    if (31 < MEM[MEM[64] + 192]) {\n        _isGuardian[v1][0] = 1 + (MEM[MEM[64] + 192] + MEM[MEM[64] + 192]);\n        if (MEM[MEM[64] + 192]) {\n            while (v3 + MEM[MEM[64] + 192] > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _isGuardian[v1][0] = MEM[MEM[64] + 192] + MEM[MEM[64] + 192] | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + (((!(0x1 & _isGuardian[v1][0x0]) << 8) - 1 & _isGuardian[v1][0x0]) >> 1) >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = v7 = v0 + 32;\n    if (31 < MEM[v0]) {\n        _isGuardian[v1][1] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v7 + MEM[v0] > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _isGuardian[v1][1] = MEM[v0] + MEM[v0] | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + (((!(0x1 & _isGuardian[v1][0x1]) << 8) - 1 & _isGuardian[v1][0x1]) >> 1) >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    _isGuardian[v1][2] = array_2.length;\n    _isGuardian[v1][3] = block.number;\n    _isGuardian[v1][4] = block.number;\n    _isGuardian[v1][5] = block.timestamp;\n    emit GuardianRegistered(msg.sender);\n}\n\nfunction getGuardianData(address varg0) public nonPayable { \n    require(_isGuardian[varg0][3] > 0, 'Please provide a listed Guardian');\n    v0 = new bytes[](v1);\n    v1 = (_isGuardian[varg0] & (!(_isGuardian[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _isGuardian[varg0] >> 8 << 8;\n        }\n    }\n    v5 = ((!(0x1 & _isGuardian[varg0][0x1]) << 8) - 1 & _isGuardian[varg0][0x1]) >> 1;\n    v6 = new bytes[](v5);\n    v7 = v8 = v6.data;\n    v9 = ((!(0x1 & _isGuardian[varg0][0x1]) << 8) - 1 & _isGuardian[varg0][0x1]) >> 1;\n    if (v9) {\n        if (31 < v9) {\n            do {\n                MEM[v7] = STORAGE[v10];\n                v10 += 1;\n                v7 += 32;\n            } while (v8 + v9 <= v7);\n        } else {\n            MEM[v8] = _isGuardian[varg0][1] >> 8 << 8;\n        }\n    }\n    v11 = new array[](v0.length);\n    v12 = v13 = 0;\n    while (v12 < v0.length) {\n        MEM[v12 + v11.data] = MEM[v12 + v0.data];\n        v12 += 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v11.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v11.data - (0x1f & v0.length)];\n    }\n    v14 = new array[](v6.length);\n    v15 = v16 = 0;\n    while (v15 < v6.length) {\n        MEM[v15 + v14.data] = MEM[v15 + v6.data];\n        v15 += 32;\n    }\n    v17 = v18 = v6.length + v14.data;\n    if (0x1f & v6.length) {\n        MEM[v18 - (0x1f & v6.length)] = ~(256 ** (32 - (0x1f & v6.length)) - 1) & MEM[v18 - (0x1f & v6.length)];\n    }\n    return v11, v14;\n}\n\nfunction getGuardiansBytes20(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = 0xd56(varg1, varg0);\n    v1 = new uint256[](MEM[v0]);\n    if (MEM[v0]) {\n        MEM[(v1.data) len (MEM[v0] << 5)] = this.code[this.code.size len (MEM[v0] << 5)];\n    }\n    v2 = v3 = 0;\n    while (v2 < MEM[v0]) {\n        assert(v2 < MEM[v0]);\n        assert(v2 < v1.length);\n        v1[v2] = MEM[(v2 << 5) + (32 + v0)] << 96 & ~0xffffffffffffffffffffffff;\n        v2 += 1;\n    }\n    v4 = new array[](v1.length);\n    v5 = v6 = 0;\n    while (v5 < v1.length << 5) {\n        MEM[v5 + v4.data] = MEM[v5 + v1.data];\n        v5 += 32;\n    }\n    return v4;\n}\n\nfunction getRegistrationBlockNumber(address varg0) public nonPayable { \n    require(_isGuardian[varg0][3] > 0, 'Please provide a listed Guardian');\n    return _isGuardian[varg0][3], _isGuardian[varg0][4];\n}\n\nfunction leave() public nonPayable { \n    require(_isGuardian[msg.sender][3] > 0, 'You must be a registered guardian');\n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require(_registrationMinTime + _isGuardian[msg.sender][5] >= _isGuardian[msg.sender][5]);\n    require(block.timestamp >= _registrationMinTime + _isGuardian[msg.sender][5], 'Minimal guardian time didnt pass');\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    assert(address(array_2[_isGuardian[msg.sender][2]]) == msg.sender);\n    assert(array_2.length + ~0 < array_2.length);\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    array_2[_isGuardian[msg.sender][2]] = address(array_2[array_2.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[_isGuardian[msg.sender][2]];\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    _isGuardian[address(array_2[_isGuardian[msg.sender][2]])][2] = _isGuardian[msg.sender][2];\n    array_2.length = array_2.length + ~0;\n    if (array_2.length > array_2.length + ~0) {\n        v0 = v1 = array_2.length + ~0 + keccak256(2);\n        while (keccak256(2) + array_2.length > v0) {\n            STORAGE[v0] = 0;\n            v0 += 1;\n        }\n        goto 0x1161B0xc57;\n    }\n    _isGuardian[msg.sender] = 0;\n    if (31 < ((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) {\n        while (v2 + (31 + (((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) >> 5) > v3) {\n            STORAGE[v3] = 0;\n            v3 += 1;\n        }\n        goto 0x11aaB0xc95;\n    }\n    _isGuardian[msg.sender][1] = 0;\n    if (31 < ((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) {\n        while (v4 + (31 + (((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) >> 5) > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        goto 0x11aaB0xcb9;\n    }\n    _isGuardian[msg.sender][2] = 0;\n    _isGuardian[msg.sender][3] = 0;\n    _isGuardian[msg.sender][4] = 0;\n    _isGuardian[msg.sender][5] = 0;\n    v6 = msg.sender.call().value(_registrationDepositWei).gas(2300 * !_registrationDepositWei);\n    require(v6); // checks call status, propagates error data on error\n    emit GuardianLeft(msg.sender);\n}\n\nfunction getGuardians(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = 0xd56(varg1, varg0);\n    v1 = new array[](MEM[v0]);\n    v2 = v3 = 0;\n    while (v2 < MEM[v0] << 5) {\n        MEM[v2 + v1.data] = MEM[v2 + (32 + v0)];\n        v2 += 32;\n    }\n    return v1;\n}\n\nfunction update(string varg0, string varg1) public nonPayable { \n    v0 = v1 = varg0 + 36;\n    v2 = v3 = varg1 + 36;\n    require(_isGuardian[msg.sender][3] > 0, 'You must be a registered guardian');\n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require((?).length > 0, 'Please provide a valid name');\n    require((?).length > 0, 'Please provide a valid website');\n    if (31 < (?).length) {\n        _isGuardian[msg.sender] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v1 + (?).length > v0) {\n                STORAGE[v4] = msg.data[v0];\n                v0 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _isGuardian[msg.sender] = msg.data[v1] & ~0xff | (?).length + (?).length;\n    }\n    while (v5 + (31 + (((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    if (31 < (?).length) {\n        _isGuardian[msg.sender][1] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v3 + (?).length > v2) {\n                STORAGE[v6] = msg.data[v2];\n                v2 += 32;\n                v6 += 1;\n            }\n        }\n    } else {\n        _isGuardian[msg.sender][1] = msg.data[v3] & ~0xff | (?).length + (?).length;\n    }\n    while (v7 + (31 + (((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) >> 5) > v6) {\n        STORAGE[v6] = 0;\n        v6 += 1;\n    }\n    _isGuardian[msg.sender][4] = block.number;\n    emit GuardianUpdated(msg.sender);\n}\n\nfunction registrationMinTime() public nonPayable { \n    return _registrationMinTime;\n}\n\nfunction VERSION() public nonPayable { \n    return 1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isGuardian(address varg0) public nonPayable { \n    return _isGuardian[varg0][3] > 0;\n}\n\nfunction 0xd56(uint256 varg0, uint256 varg1) private { \n    if (varg1 < array_2.length) {\n        v0 = varg0 + varg1;\n        require(v0 >= varg1);\n        if (v0 > array_2.length) {\n            require(varg1 <= array_2.length);\n            varg0 = v1 = array_2.length - varg1;\n        }\n        v2 = v3 = new uint256[](varg0);\n        if (varg0) {\n            v4 = varg0 << 5;\n            MEM[(v3.data) len v4] = this.code[this.code.size len v4];\n        }\n        v5 = v6 = 0;\n        while (v5 < v3.length) {\n            v7 = v5 + varg1;\n            require(v7 >= varg1);\n            assert(v7 < array_2.length);\n            assert(v5 < v3.length);\n            v3[v5] = address(array_2[v7]);\n            v5 += 1;\n        }\n    } else {\n        v2 = v8 = MEM[64];\n        MEM[v8] = 0;\n        MEM[64] = v8 + 32;\n    }\n    return v2;\n}\n\nfunction registrationDepositWei() public nonPayable { \n    return _registrationDepositWei;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc68ba21) {\n            isGuardian(address);\n        } else if (0x1201b4bd == function_selector) {\n            registrationDepositWei();\n        } else if (0x3ffbd47f == function_selector) {\n            register(string,string);\n        } else if (0x4b139a47 == function_selector) {\n            getGuardianData(address);\n        } else if (0x4cf1f60b == function_selector) {\n            getGuardiansBytes20(uint256,uint256);\n        } else if (0x50d8f786 == function_selector) {\n            getRegistrationBlockNumber(address);\n        } else if (0xd66d9e19 == function_selector) {\n            leave();\n        } else if (0xd93d7d29 == function_selector) {\n            getGuardians(uint256,uint256);\n        } else if (0xf4c84d19 == function_selector) {\n            update(string,string);\n        } else if (0xf5660650 == function_selector) {\n            registrationMinTime();\n        } else if (0xffa1ad74 == function_selector) {\n            VERSION();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.13 12:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _registrationDepositWei; // STORAGE[0x0]\nuint256 _registrationMinTime; // STORAGE[0x1]\nuint256[] array_2; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _isGuardian; // STORAGE[0x3]\n\n// Events\nGuardianRegistered(address);\nGuardianLeft(address);\nGuardianUpdated(address);\n\nfunction register(string varg0, string varg1) public payable { \n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require((?).length > 0, 'Please provide a valid name');\n    require((?).length > 0, 'Please provide a valid website');\n    require(_isGuardian[msg.sender][3] <= 0, 'Cannot be a guardian');\n    require(msg.value == _registrationDepositWei, 'Please provide the exact registration deposit');\n    array_2.length = array_2.length + 1;\n    STORAGE[array_2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[array_2.length + 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace];\n    MEM[MEM[64] + 192] = (?).length;\n    CALLDATACOPY(MEM[64] + 224, varg0 + 36, (?).length);\n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, varg1 + 36, (?).length);\n    v1 = msg.sender;\n    v2 = v3 = 32 + (MEM[64] + 192);\n    if (31 < MEM[MEM[64] + 192]) {\n        _isGuardian[v1][0] = 1 + (MEM[MEM[64] + 192] + MEM[MEM[64] + 192]);\n        if (MEM[MEM[64] + 192]) {\n            while (v3 + MEM[MEM[64] + 192] > v2) {\n                STORAGE[v4] = MEM[v2];\n                v2 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _isGuardian[v1][0] = MEM[MEM[64] + 192] + MEM[MEM[64] + 192] | ~0xff & MEM[v3];\n    }\n    while (v5 + (31 + (((!(0x1 & _isGuardian[v1][0x0]) << 8) - 1 & _isGuardian[v1][0x0]) >> 1) >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    v6 = v7 = v0 + 32;\n    if (31 < MEM[v0]) {\n        _isGuardian[v1][1] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v7 + MEM[v0] > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _isGuardian[v1][1] = MEM[v0] + MEM[v0] | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + (((!(0x1 & _isGuardian[v1][0x1]) << 8) - 1 & _isGuardian[v1][0x1]) >> 1) >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    _isGuardian[v1][2] = array_2.length;\n    _isGuardian[v1][3] = block.number;\n    _isGuardian[v1][4] = block.number;\n    _isGuardian[v1][5] = block.timestamp;\n    emit GuardianRegistered(msg.sender);\n}\n\nfunction getGuardianData(address varg0) public nonPayable { \n    require(_isGuardian[varg0][3] > 0, 'Please provide a listed Guardian');\n    v0 = new bytes[](v1);\n    v1 = (_isGuardian[varg0] & (!(_isGuardian[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _isGuardian[varg0] >> 8 << 8;\n        }\n    }\n    v5 = ((!(0x1 & _isGuardian[varg0][0x1]) << 8) - 1 & _isGuardian[varg0][0x1]) >> 1;\n    v6 = new bytes[](v5);\n    v7 = v8 = v6.data;\n    v9 = ((!(0x1 & _isGuardian[varg0][0x1]) << 8) - 1 & _isGuardian[varg0][0x1]) >> 1;\n    if (v9) {\n        if (31 < v9) {\n            do {\n                MEM[v7] = STORAGE[v10];\n                v10 += 1;\n                v7 += 32;\n            } while (v8 + v9 <= v7);\n        } else {\n            MEM[v8] = _isGuardian[varg0][1] >> 8 << 8;\n        }\n    }\n    v11 = new array[](v0.length);\n    v12 = v13 = 0;\n    while (v12 < v0.length) {\n        MEM[v12 + v11.data] = MEM[v12 + v0.data];\n        v12 += 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v11.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v11.data - (0x1f & v0.length)];\n    }\n    v14 = new array[](v6.length);\n    v15 = v16 = 0;\n    while (v15 < v6.length) {\n        MEM[v15 + v14.data] = MEM[v15 + v6.data];\n        v15 += 32;\n    }\n    v17 = v18 = v6.length + v14.data;\n    if (0x1f & v6.length) {\n        MEM[v18 - (0x1f & v6.length)] = ~(256 ** (32 - (0x1f & v6.length)) - 1) & MEM[v18 - (0x1f & v6.length)];\n    }\n    return v11, v14;\n}\n\nfunction getGuardiansBytes20(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = 0xd56(varg1, varg0);\n    v1 = new uint256[](MEM[v0]);\n    if (MEM[v0]) {\n        MEM[(v1.data) len (MEM[v0] << 5)] = this.code[this.code.size len (MEM[v0] << 5)];\n    }\n    v2 = v3 = 0;\n    while (v2 < MEM[v0]) {\n        assert(v2 < MEM[v0]);\n        assert(v2 < v1.length);\n        v1[v2] = MEM[(v2 << 5) + (32 + v0)] << 96 & ~0xffffffffffffffffffffffff;\n        v2 += 1;\n    }\n    v4 = new array[](v1.length);\n    v5 = v6 = 0;\n    while (v5 < v1.length << 5) {\n        MEM[v5 + v4.data] = MEM[v5 + v1.data];\n        v5 += 32;\n    }\n    return v4;\n}\n\nfunction getRegistrationBlockNumber(address varg0) public nonPayable { \n    require(_isGuardian[varg0][3] > 0, 'Please provide a listed Guardian');\n    return _isGuardian[varg0][3], _isGuardian[varg0][4];\n}\n\nfunction leave() public nonPayable { \n    require(_isGuardian[msg.sender][3] > 0, 'You must be a registered guardian');\n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require(_registrationMinTime + _isGuardian[msg.sender][5] >= _isGuardian[msg.sender][5]);\n    require(block.timestamp >= _registrationMinTime + _isGuardian[msg.sender][5], 'Minimal guardian time didnt pass');\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    assert(address(array_2[_isGuardian[msg.sender][2]]) == msg.sender);\n    assert(array_2.length + ~0 < array_2.length);\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    array_2[_isGuardian[msg.sender][2]] = address(array_2[array_2.length + ~0]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[_isGuardian[msg.sender][2]];\n    assert(_isGuardian[msg.sender][2] < array_2.length);\n    _isGuardian[address(array_2[_isGuardian[msg.sender][2]])][2] = _isGuardian[msg.sender][2];\n    array_2.length = array_2.length + ~0;\n    if (array_2.length > array_2.length + ~0) {\n        v0 = v1 = array_2.length + ~0 + keccak256(2);\n        while (keccak256(2) + array_2.length > v0) {\n            STORAGE[v0] = 0;\n            v0 += 1;\n        }\n        goto 0x1161B0xc57;\n    }\n    _isGuardian[msg.sender] = 0;\n    if (31 < ((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) {\n        while (v2 + (31 + (((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) >> 5) > v3) {\n            STORAGE[v3] = 0;\n            v3 += 1;\n        }\n        goto 0x11aaB0xc95;\n    }\n    _isGuardian[msg.sender][1] = 0;\n    if (31 < ((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) {\n        while (v4 + (31 + (((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) >> 5) > v5) {\n            STORAGE[v5] = 0;\n            v5 += 1;\n        }\n        goto 0x11aaB0xcb9;\n    }\n    _isGuardian[msg.sender][2] = 0;\n    _isGuardian[msg.sender][3] = 0;\n    _isGuardian[msg.sender][4] = 0;\n    _isGuardian[msg.sender][5] = 0;\n    v6 = msg.sender.call().value(_registrationDepositWei).gas(2300 * !_registrationDepositWei);\n    require(v6); // checks call status, propagates error data on error\n    emit GuardianLeft(msg.sender);\n}\n\nfunction getGuardians(uint256 varg0, uint256 varg1) public nonPayable { \n    v0 = 0xd56(varg1, varg0);\n    v1 = new array[](MEM[v0]);\n    v2 = v3 = 0;\n    while (v2 < MEM[v0] << 5) {\n        MEM[v2 + v1.data] = MEM[v2 + (32 + v0)];\n        v2 += 32;\n    }\n    return v1;\n}\n\nfunction update(string varg0, string varg1) public nonPayable { \n    v0 = v1 = varg0 + 36;\n    v2 = v3 = varg1 + 36;\n    require(_isGuardian[msg.sender][3] > 0, 'You must be a registered guardian');\n    require(msg.sender.code.size <= 0, 'Only EOA may register as Guardian');\n    require((?).length > 0, 'Please provide a valid name');\n    require((?).length > 0, 'Please provide a valid website');\n    if (31 < (?).length) {\n        _isGuardian[msg.sender] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v1 + (?).length > v0) {\n                STORAGE[v4] = msg.data[v0];\n                v0 += 32;\n                v4 += 1;\n            }\n        }\n    } else {\n        _isGuardian[msg.sender] = msg.data[v1] & ~0xff | (?).length + (?).length;\n    }\n    while (v5 + (31 + (((!(0x1 & _isGuardian[msg.sender]) << 8) - 1 & _isGuardian[msg.sender]) >> 1) >> 5) > v4) {\n        STORAGE[v4] = 0;\n        v4 += 1;\n    }\n    if (31 < (?).length) {\n        _isGuardian[msg.sender][1] = 1 + ((?).length + (?).length);\n        if ((?).length) {\n            while (v3 + (?).length > v2) {\n                STORAGE[v6] = msg.data[v2];\n                v2 += 32;\n                v6 += 1;\n            }\n        }\n    } else {\n        _isGuardian[msg.sender][1] = msg.data[v3] & ~0xff | (?).length + (?).length;\n    }\n    while (v7 + (31 + (((!(0x1 & _isGuardian[msg.sender][0x1]) << 8) - 1 & _isGuardian[msg.sender][0x1]) >> 1) >> 5) > v6) {\n        STORAGE[v6] = 0;\n        v6 += 1;\n    }\n    _isGuardian[msg.sender][4] = block.number;\n    emit GuardianUpdated(msg.sender);\n}\n\nfunction registrationMinTime() public nonPayable { \n    return _registrationMinTime;\n}\n\nfunction VERSION() public nonPayable { \n    return 1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction isGuardian(address varg0) public nonPayable { \n    return _isGuardian[varg0][3] > 0;\n}\n\nfunction 0xd56(uint256 varg0, uint256 varg1) private { \n    if (varg1 < array_2.length) {\n        v0 = varg0 + varg1;\n        require(v0 >= varg1);\n        if (v0 > array_2.length) {\n            require(varg1 <= array_2.length);\n            varg0 = v1 = array_2.length - varg1;\n        }\n        v2 = v3 = new uint256[](varg0);\n        if (varg0) {\n            v4 = varg0 << 5;\n            MEM[(v3.data) len v4] = this.code[this.code.size len v4];\n        }\n        v5 = v6 = 0;\n        while (v5 < v3.length) {\n            v7 = v5 + varg1;\n            require(v7 >= varg1);\n            assert(v7 < array_2.length);\n            assert(v5 < v3.length);\n            v3[v5] = address(array_2[v7]);\n            v5 += 1;\n        }\n    } else {\n        v2 = v8 = MEM[64];\n        MEM[v8] = 0;\n        MEM[64] = v8 + 32;\n    }\n    return v2;\n}\n\nfunction registrationDepositWei() public nonPayable { \n    return _registrationDepositWei;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0xc68ba21) {\n            isGuardian(address);\n        } else if (0x1201b4bd == function_selector) {\n            registrationDepositWei();\n        } else if (0x3ffbd47f == function_selector) {\n            register(string,string);\n        } else if (0x4b139a47 == function_selector) {\n            getGuardianData(address);\n        } else if (0x4cf1f60b == function_selector) {\n            getGuardiansBytes20(uint256,uint256);\n        } else if (0x50d8f786 == function_selector) {\n            getRegistrationBlockNumber(address);\n        } else if (0xd66d9e19 == function_selector) {\n            leave();\n        } else if (0xd93d7d29 == function_selector) {\n            getGuardians(uint256,uint256);\n        } else if (0xf4c84d19 == function_selector) {\n            update(string,string);\n        } else if (0xf5660650 == function_selector) {\n            registrationMinTime();\n        } else if (0xffa1ad74 == function_selector) {\n            VERSION();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 56.64663243293762,
	"usage": {
		"completion_tokens": 864,
		"prompt_tokens": 4053,
		"total_tokens": 4917
	}
}