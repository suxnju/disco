{
	"address": "0xd494938d0524edadfc239adc2c233e50550fa152",
	"choices": {
		"finish_reason": "stop",
		"index": 0,
		"logprobs": null,
		"message": {
			"content": "Here is a simplified Solidity contract based on the decompiled code. Please note that the decompiled code may not be 100% accurate as it was inferred from EVM Bytecode, and it is not in a form that can be directly converted into a Solidity contract.\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract MyContract {\n    mapping (address => bool) public isAdmin;\n    mapping (address => uint256) public balances;\n    mapping (address => uint256) public userRanks;\n    mapping (address => uint256) public tokenRanks;\n    mapping (address => uint256) public lockTimes;\n    mapping (bytes32 => uint256) public orderFills;\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Upgraded(address indexed newAddress);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function upgrade(address newAddress) public onlyOwner {\n        emit Upgraded(newAddress);\n    }\n\n    function activateAdmin(address user) public onlyOwner {\n        isAdmin[user] = true;\n    }\n\n    function deactivateAdmin(address user) public onlyOwner {\n        isAdmin[user] = false;\n    }\n\n    function updateUserRank(address user, uint256 rank) public onlyOwner {\n        userRanks[user] = rank;\n    }\n\n    function updateTokenRank(address token, uint256 rank) public onlyOwner {\n        tokenRanks[token] = rank;\n    }\n    // Other functions...\n}\n```\n\nThis code outlines a basic contract with an owner who can transfer ownership, upgrade the contract, and manage administrative users. The contract also includes mappings to keep track of balances, user ranks, token ranks, lock times, and order fills.",
			"function_call": null,
			"role": "assistant",
			"tool_calls": null
		}
	},
	"created": 1711532948,
	"id": "chatcmpl-97KC4VsXEZvwhA2LApLFF8g7jdCc8",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.28 12:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _isAdmin; // STORAGE[0x1]\nuint256 _forceDeactivateAdmin; // STORAGE[0x2]\nuint256 _setAdminLimit; // STORAGE[0x3]\nuint256 _processTime; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _userID_Address; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _tokenID_Address; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _userRanks; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokenRanks; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _lockTimes; // STORAGE[0xb]\nuint256 _isOwner; // STORAGE[0x0] bytes 0 to 19\nuint256 _unlock; // STORAGE[0x3b2ff02c0f36dba7cc1b20a669e540b974575f04ef71846d482983efb03bebb4]\nuint256 _upgrade; // STORAGE[0x90215db359d12011b32ff0c897114c39e26956599904ee846adb0dd49f782e97]\nuint256 stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6; // STORAGE[0xe89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6]\n\n// Events\nUpgraded(address);\nUpgradeAnnounced(address, uint256);\nOwnershipTransferred(address, address);\nDeactivated(address);\n\nfunction 0x1964(uint256 varg0) private { \n    if (!MEM[varg0]) {\n        return ;\n    } else {\n        require(MEM[varg0] >= 32);\n        v0 = MEM[32 + varg0];\n        if (!(v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) {\n            return ;\n        } else {\n            v1.word0 = 4;\n            v2 = v1.data;\n            v1.word1 = 0x3078303000000000000000000000000000000000000000000000000000000000;\n            if (v0 & 0xf00000000000000000000000000000000000000000000000000000000000000 >= 0xa00000000000000000000000000000000000000000000000000000000000000) {\n                assert(3 < v1.length);\n                assert(3 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000023] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 39 + ((0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & 0xf00000000000000000000000000000000000000000000000000000000000000) >> 248)) << 248, 0x0)) & 0xFF;\n            } else {\n                assert(3 < v1.length);\n                assert(3 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000023] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & 0xf00000000000000000000000000000000000000000000000000000000000000) >> 248) << 248, 0x0)) & 0xFF;\n            }\n            if ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff >= 0xa00000000000000000000000000000000000000000000000000000000000000) {\n                assert(2 < v1.length);\n                assert(2 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000022] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 39 + ((0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 >> 248)) << 248, 0x0)) & 0xFF;\n            } else {\n                assert(2 < v1.length);\n                assert(2 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000022] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 >> 248) << 248, 0x0)) & 0xFF;\n            }\n            v3 = new array[](v1.length);\n            v4 = v5 = 0;\n            while (v4 < v1.length) {\n                v3[v4] = v1[v4];\n                v4 += 32;\n            }\n            if (4) {\n                MEM[v3.data] = 0x3078303000000000000000000000000000000000000000000000000000000000;\n            }\n            revert(Error(v3));\n        }\n    }\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction upgradeAnnounced() public nonPayable { \n    0x93d();\n}\n\nfunction upgrade(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == address(_upgrade));\n    0x93d();\n}\n\nfunction withdrawByAdmin(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    MEM[64] = v0.data + (~0x1f & varg0.length + 31);\n    v1 = v2 = MEM[64] + 32;\n    MEM[v2] = 0x14e0c71f00000000000000000000000000000000000000000000000000000020;\n    v3 = v4 = MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + ~31;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v6, v7 = address(_unlock).delegatecall(MEM[(MEM[64]) len (v8 + v4 - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v6);\n    0x1964(v9);\n}\n\nfunction activateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0, Error('invalid address'));\n    require(_forceDeactivateAdmin < _setAdminLimit, Error('too many admins existed'));\n    require(!(0xff & _isAdmin[varg0]), Error('already admin'));\n    _isAdmin[varg0] = 0x1 | ~0xff & _isAdmin[varg0];\n    require(1 + _forceDeactivateAdmin >= _forceDeactivateAdmin);\n    _forceDeactivateAdmin += 1;\n    emit 0xcc43938d137e7efade6a531f663e78c1fc75257b0d65ffda2fdaf70cb49cdf9(varg0);\n}\n\nfunction updateTokenRank(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner);\n    MEM[64] = MEM[64] + 100;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, v6 = address(_unlock).updateTokenRank(0x2123cb7800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v7 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v7.data, 0, RETURNDATASIZE());\n    }\n    require(v5);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    MEM[64] = MEM[64] + 68;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, v6 = address(_unlock).withdraw(varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v7 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v7.data, 0, RETURNDATASIZE());\n    }\n    require(v5);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x338b5dea00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction register(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0.code.size, Error('Implementation address should be a contract address'));\n    _upgrade = varg0;\n    stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6 = 0x127500 + block.timestamp;\n    emit UpgradeAnnounced(varg0, stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6);\n}\n\nfunction tokenRanks(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokenRanks[varg0];\n}\n\nfunction userRanks(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userRanks[varg0];\n}\n\nfunction lockTimes(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _lockTimes[varg0];\n}\n\nfunction addToken(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x57016b0a00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction addUser(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x58d9fa0400000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction removeToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x5fa7b58400000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction userID_Address(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_userID_Address[varg0]);\n}\n\nfunction forceDeactivateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(0xff & _isAdmin[varg0], Error('not admin'));\n    _isAdmin[varg0] = ~0xff & _isAdmin[varg0];\n    require(1 <= _forceDeactivateAdmin);\n    _forceDeactivateAdmin = _forceDeactivateAdmin - 1;\n    emit Deactivated(varg0);\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner);\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction setAdminLimit(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(_setAdminLimit != varg0, Error('same limit'));\n    _setAdminLimit = varg0;\n}\n\nfunction removeUser(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x9857518800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x9e281a9800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction unlock() public nonPayable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    MEM[v2] = 0xa69df4b500000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2];\n    v3 = v4 = v4.data;\n    v5 = v6 = v0.length;\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + ~31;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v7, v8 = address(_unlock).unlock().gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v7);\n}\n\nfunction migrateByAdmin(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    if (v5 >= 32) {\n        v6 = v7 = v5 + ~31;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v6 >= 32) {\n            MEM[v3] = MEM[v1];\n            v6 = v6 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v6) - 1) | MEM[v3] & 256 ** (32 - v6) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xb19e43b400000000000000000000000000000000000000000000000000000020).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n    0x1964(v12);\n}\n\nfunction updateUserRank(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0xb46b791900000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction isAdmin() public nonPayable { \n    return 0xff & _isAdmin[msg.sender];\n}\n\nfunction balances(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _balances[varg1];\n}\n\nfunction settle(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    if (v5 >= 32) {\n        v6 = v7 = v5 + ~31;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v6 >= 32) {\n            MEM[v3] = MEM[v1];\n            v6 = v6 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v6) - 1) | MEM[v3] & 256 ** (32 - v6) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xd0322fbf00000000000000000000000000000000000000000000000000000020).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n    0x1964(v12);\n}\n\nfunction deposit() public payable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    v3 = v4 = MEM[64];\n    v5 = v6 = v0.length;\n    if (v6 >= 32) {\n        v5 = v7 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe4;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v5 >= 32) {\n            MEM[v3] = MEM[v1];\n            v5 = v5 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xd0e30db000000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2]).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n}\n\nfunction processTime() public nonPayable { \n    return _processTime;\n}\n\nfunction deactivateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(_forceDeactivateAdmin > 1, Error('admin should > 1'));\n    require(0xff & _isAdmin[varg0], Error('not admin'));\n    _isAdmin[varg0] = ~0xff & _isAdmin[varg0];\n    require(1 <= _forceDeactivateAdmin);\n    _forceDeactivateAdmin = _forceDeactivateAdmin - 1;\n    emit Deactivated(varg0);\n}\n\nfunction tokenID_Address(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_tokenID_Address[varg0]);\n}\n\nfunction changeProcessTime(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0xf1c5f1e200000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0);\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _orderFills[varg0];\n}\n\nfunction lock() public nonPayable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    v3 = v4 = MEM[64];\n    v5 = v6 = v0.length;\n    if (v6 >= 32) {\n        v5 = v7 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe4;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v5 >= 32) {\n            MEM[v3] = MEM[v1];\n            v5 = v5 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xf83d08ba00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2]).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n}\n\nfunction 0x93d() private { \n    require(msg.sender == _isOwner);\n    require(block.timestamp >= stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6);\n    require((address(_upgrade)).code.size, Error('Implementation address should be a contract address'));\n    _unlock = _upgrade;\n    emit Upgraded(address(_upgrade));\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8f32d59b > v0) {\n            if (0x4d5edd28 > v0) {\n                if (0x2123cb78 > v0) {\n                    if (0x56f9d6d == v0) {\n                        upgradeAnnounced();\n                    } else if (0x900f010 == v0) {\n                        upgrade(address);\n                    } else if (0x14e0c71f == v0) {\n                        withdrawByAdmin(bytes);\n                    } else {\n                        require(0x1af1a768 == v0);\n                        activateAdmin(address);\n                    }\n                } else if (0x2123cb78 == v0) {\n                    updateTokenRank(address,uint256);\n                } else if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x338b5dea == v0) {\n                    depositToken(address,uint256);\n                } else if (0x4420e486 == v0) {\n                    register(address);\n                } else {\n                    require(0x4a184239 == v0);\n                    tokenRanks(address);\n                }\n            } else if (0x5fa7b584 > v0) {\n                if (0x4d5edd28 == v0) {\n                    userRanks(address);\n                } else if (0x56c7c1b3 == v0) {\n                    lockTimes(address);\n                } else if (0x57016b0a == v0) {\n                    addToken(uint256,address);\n                } else {\n                    require(0x58d9fa04 == v0);\n                    addUser(uint256,address);\n                }\n            } else if (0x5fa7b584 == v0) {\n                removeToken(address);\n            } else if (0x61959f85 == v0) {\n                userID_Address(uint256);\n            } else if (0x6f9a5fb3 == v0) {\n                forceDeactivateAdmin(address);\n            } else if (0x715018a6 == v0) {\n                renounceOwnership();\n            } else {\n                require(0x8da5cb5b == v0);\n                owner();\n            }\n        } else if (0xd0322fbf > v0) {\n            if (0xa69df4b5 > v0) {\n                if (0x8f32d59b == v0) {\n                    isOwner();\n                } else if (0x91a8c4b8 == v0) {\n                    setAdminLimit(uint256);\n                } else if (0x98575188 == v0) {\n                    removeUser(address);\n                } else {\n                    require(0x9e281a98 == v0);\n                    withdrawToken(address,uint256);\n                }\n            } else if (0xa69df4b5 == v0) {\n                unlock();\n            } else if (0xb19e43b4 == v0) {\n                migrateByAdmin(bytes);\n            } else if (0xb46b7919 == v0) {\n                updateUserRank(address,uint256);\n            } else if (0xb6db75a0 == v0) {\n                isAdmin();\n            } else {\n                require(0xc23f001f == v0);\n                balances(address,address);\n            }\n        } else if (0xe8b93ad7 > v0) {\n            if (0xd0322fbf == v0) {\n                settle(bytes);\n            } else if (0xd0e30db0 == v0) {\n                deposit();\n            } else if (0xdd41250f == v0) {\n                processTime();\n            } else {\n                require(0xdf6fa20e == v0);\n                deactivateAdmin(address);\n            }\n        } else if (0xe8b93ad7 == v0) {\n            tokenID_Address(uint256);\n        } else if (0xf1c5f1e2 == v0) {\n            changeProcessTime(uint256);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else {\n            require(0xf83d08ba == v0);\n            lock();\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.28 12:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _isAdmin; // STORAGE[0x1]\nuint256 _forceDeactivateAdmin; // STORAGE[0x2]\nuint256 _setAdminLimit; // STORAGE[0x3]\nuint256 _processTime; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _userID_Address; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _tokenID_Address; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _userRanks; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokenRanks; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _lockTimes; // STORAGE[0xb]\nuint256 _isOwner; // STORAGE[0x0] bytes 0 to 19\nuint256 _unlock; // STORAGE[0x3b2ff02c0f36dba7cc1b20a669e540b974575f04ef71846d482983efb03bebb4]\nuint256 _upgrade; // STORAGE[0x90215db359d12011b32ff0c897114c39e26956599904ee846adb0dd49f782e97]\nuint256 stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6; // STORAGE[0xe89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6]\n\n// Events\nUpgraded(address);\nUpgradeAnnounced(address, uint256);\nOwnershipTransferred(address, address);\nDeactivated(address);\n\nfunction 0x1964(uint256 varg0) private { \n    if (!MEM[varg0]) {\n        return ;\n    } else {\n        require(MEM[varg0] >= 32);\n        v0 = MEM[32 + varg0];\n        if (!(v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) {\n            return ;\n        } else {\n            v1.word0 = 4;\n            v2 = v1.data;\n            v1.word1 = 0x3078303000000000000000000000000000000000000000000000000000000000;\n            if (v0 & 0xf00000000000000000000000000000000000000000000000000000000000000 >= 0xa00000000000000000000000000000000000000000000000000000000000000) {\n                assert(3 < v1.length);\n                assert(3 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000023] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 39 + ((0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & 0xf00000000000000000000000000000000000000000000000000000000000000) >> 248)) << 248, 0x0)) & 0xFF;\n            } else {\n                assert(3 < v1.length);\n                assert(3 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000023] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & 0xf00000000000000000000000000000000000000000000000000000000000000) >> 248) << 248, 0x0)) & 0xFF;\n            }\n            if ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff >= 0xa00000000000000000000000000000000000000000000000000000000000000) {\n                assert(2 < v1.length);\n                assert(2 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000022] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 39 + ((0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 >> 248)) << 248, 0x0)) & 0xFF;\n            } else {\n                assert(2 < v1.length);\n                assert(2 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000022] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 >> 248) << 248, 0x0)) & 0xFF;\n            }\n            v3 = new array[](v1.length);\n            v4 = v5 = 0;\n            while (v4 < v1.length) {\n                v3[v4] = v1[v4];\n                v4 += 32;\n            }\n            if (4) {\n                MEM[v3.data] = 0x3078303000000000000000000000000000000000000000000000000000000000;\n            }\n            revert(Error(v3));\n        }\n    }\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction upgradeAnnounced() public nonPayable { \n    0x93d();\n}\n\nfunction upgrade(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == address(_upgrade));\n    0x93d();\n}\n\nfunction withdrawByAdmin(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    MEM[64] = v0.data + (~0x1f & varg0.length + 31);\n    v1 = v2 = MEM[64] + 32;\n    MEM[v2] = 0x14e0c71f00000000000000000000000000000000000000000000000000000020;\n    v3 = v4 = MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + ~31;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v6, v7 = address(_unlock).delegatecall(MEM[(MEM[64]) len (v8 + v4 - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v6);\n    0x1964(v9);\n}\n\nfunction activateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0, Error('invalid address'));\n    require(_forceDeactivateAdmin < _setAdminLimit, Error('too many admins existed'));\n    require(!(0xff & _isAdmin[varg0]), Error('already admin'));\n    _isAdmin[varg0] = 0x1 | ~0xff & _isAdmin[varg0];\n    require(1 + _forceDeactivateAdmin >= _forceDeactivateAdmin);\n    _forceDeactivateAdmin += 1;\n    emit 0xcc43938d137e7efade6a531f663e78c1fc75257b0d65ffda2fdaf70cb49cdf9(varg0);\n}\n\nfunction updateTokenRank(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner);\n    MEM[64] = MEM[64] + 100;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, v6 = address(_unlock).updateTokenRank(0x2123cb7800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v7 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v7.data, 0, RETURNDATASIZE());\n    }\n    require(v5);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    MEM[64] = MEM[64] + 68;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, v6 = address(_unlock).withdraw(varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v7 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v7.data, 0, RETURNDATASIZE());\n    }\n    require(v5);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x338b5dea00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction register(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0.code.size, Error('Implementation address should be a contract address'));\n    _upgrade = varg0;\n    stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6 = 0x127500 + block.timestamp;\n    emit UpgradeAnnounced(varg0, stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6);\n}\n\nfunction tokenRanks(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokenRanks[varg0];\n}\n\nfunction userRanks(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userRanks[varg0];\n}\n\nfunction lockTimes(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _lockTimes[varg0];\n}\n\nfunction addToken(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x57016b0a00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction addUser(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x58d9fa0400000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction removeToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x5fa7b58400000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction userID_Address(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_userID_Address[varg0]);\n}\n\nfunction forceDeactivateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(0xff & _isAdmin[varg0], Error('not admin'));\n    _isAdmin[varg0] = ~0xff & _isAdmin[varg0];\n    require(1 <= _forceDeactivateAdmin);\n    _forceDeactivateAdmin = _forceDeactivateAdmin - 1;\n    emit Deactivated(varg0);\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner);\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction setAdminLimit(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(_setAdminLimit != varg0, Error('same limit'));\n    _setAdminLimit = varg0;\n}\n\nfunction removeUser(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x9857518800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x9e281a9800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction unlock() public nonPayable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    MEM[v2] = 0xa69df4b500000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2];\n    v3 = v4 = v4.data;\n    v5 = v6 = v0.length;\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + ~31;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v7, v8 = address(_unlock).unlock().gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v7);\n}\n\nfunction migrateByAdmin(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    if (v5 >= 32) {\n        v6 = v7 = v5 + ~31;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v6 >= 32) {\n            MEM[v3] = MEM[v1];\n            v6 = v6 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v6) - 1) | MEM[v3] & 256 ** (32 - v6) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xb19e43b400000000000000000000000000000000000000000000000000000020).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n    0x1964(v12);\n}\n\nfunction updateUserRank(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0xb46b791900000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction isAdmin() public nonPayable { \n    return 0xff & _isAdmin[msg.sender];\n}\n\nfunction balances(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _balances[varg1];\n}\n\nfunction settle(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    if (v5 >= 32) {\n        v6 = v7 = v5 + ~31;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v6 >= 32) {\n            MEM[v3] = MEM[v1];\n            v6 = v6 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v6) - 1) | MEM[v3] & 256 ** (32 - v6) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xd0322fbf00000000000000000000000000000000000000000000000000000020).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n    0x1964(v12);\n}\n\nfunction deposit() public payable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    v3 = v4 = MEM[64];\n    v5 = v6 = v0.length;\n    if (v6 >= 32) {\n        v5 = v7 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe4;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v5 >= 32) {\n            MEM[v3] = MEM[v1];\n            v5 = v5 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xd0e30db000000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2]).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n}\n\nfunction processTime() public nonPayable { \n    return _processTime;\n}\n\nfunction deactivateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(_forceDeactivateAdmin > 1, Error('admin should > 1'));\n    require(0xff & _isAdmin[varg0], Error('not admin'));\n    _isAdmin[varg0] = ~0xff & _isAdmin[varg0];\n    require(1 <= _forceDeactivateAdmin);\n    _forceDeactivateAdmin = _forceDeactivateAdmin - 1;\n    emit Deactivated(varg0);\n}\n\nfunction tokenID_Address(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_tokenID_Address[varg0]);\n}\n\nfunction changeProcessTime(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0xf1c5f1e200000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0);\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _orderFills[varg0];\n}\n\nfunction lock() public nonPayable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    v3 = v4 = MEM[64];\n    v5 = v6 = v0.length;\n    if (v6 >= 32) {\n        v5 = v7 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe4;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v5 >= 32) {\n            MEM[v3] = MEM[v1];\n            v5 = v5 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xf83d08ba00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2]).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n}\n\nfunction 0x93d() private { \n    require(msg.sender == _isOwner);\n    require(block.timestamp >= stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6);\n    require((address(_upgrade)).code.size, Error('Implementation address should be a contract address'));\n    _unlock = _upgrade;\n    emit Upgraded(address(_upgrade));\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8f32d59b > v0) {\n            if (0x4d5edd28 > v0) {\n                if (0x2123cb78 > v0) {\n                    if (0x56f9d6d == v0) {\n                        upgradeAnnounced();\n                    } else if (0x900f010 == v0) {\n                        upgrade(address);\n                    } else if (0x14e0c71f == v0) {\n                        withdrawByAdmin(bytes);\n                    } else {\n                        require(0x1af1a768 == v0);\n                        activateAdmin(address);\n                    }\n                } else if (0x2123cb78 == v0) {\n                    updateTokenRank(address,uint256);\n                } else if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x338b5dea == v0) {\n                    depositToken(address,uint256);\n                } else if (0x4420e486 == v0) {\n                    register(address);\n                } else {\n                    require(0x4a184239 == v0);\n                    tokenRanks(address);\n                }\n            } else if (0x5fa7b584 > v0) {\n                if (0x4d5edd28 == v0) {\n                    userRanks(address);\n                } else if (0x56c7c1b3 == v0) {\n                    lockTimes(address);\n                } else if (0x57016b0a == v0) {\n                    addToken(uint256,address);\n                } else {\n                    require(0x58d9fa04 == v0);\n                    addUser(uint256,address);\n                }\n            } else if (0x5fa7b584 == v0) {\n                removeToken(address);\n            } else if (0x61959f85 == v0) {\n                userID_Address(uint256);\n            } else if (0x6f9a5fb3 == v0) {\n                forceDeactivateAdmin(address);\n            } else if (0x715018a6 == v0) {\n                renounceOwnership();\n            } else {\n                require(0x8da5cb5b == v0);\n                owner();\n            }\n        } else if (0xd0322fbf > v0) {\n            if (0xa69df4b5 > v0) {\n                if (0x8f32d59b == v0) {\n                    isOwner();\n                } else if (0x91a8c4b8 == v0) {\n                    setAdminLimit(uint256);\n                } else if (0x98575188 == v0) {\n                    removeUser(address);\n                } else {\n                    require(0x9e281a98 == v0);\n                    withdrawToken(address,uint256);\n                }\n            } else if (0xa69df4b5 == v0) {\n                unlock();\n            } else if (0xb19e43b4 == v0) {\n                migrateByAdmin(bytes);\n            } else if (0xb46b7919 == v0) {\n                updateUserRank(address,uint256);\n            } else if (0xb6db75a0 == v0) {\n                isAdmin();\n            } else {\n                require(0xc23f001f == v0);\n                balances(address,address);\n            }\n        } else if (0xe8b93ad7 > v0) {\n            if (0xd0322fbf == v0) {\n                settle(bytes);\n            } else if (0xd0e30db0 == v0) {\n                deposit();\n            } else if (0xdd41250f == v0) {\n                processTime();\n            } else {\n                require(0xdf6fa20e == v0);\n                deactivateAdmin(address);\n            }\n        } else if (0xe8b93ad7 == v0) {\n            tokenID_Address(uint256);\n        } else if (0xf1c5f1e2 == v0) {\n            changeProcessTime(uint256);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else {\n            require(0xf83d08ba == v0);\n            lock();\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.28 12:10 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _isAdmin; // STORAGE[0x1]\nuint256 _forceDeactivateAdmin; // STORAGE[0x2]\nuint256 _setAdminLimit; // STORAGE[0x3]\nuint256 _processTime; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _orderFills; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _userID_Address; // STORAGE[0x7]\nmapping (uint256 => [uint256]) _tokenID_Address; // STORAGE[0x8]\nmapping (uint256 => [uint256]) _userRanks; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _tokenRanks; // STORAGE[0xa]\nmapping (uint256 => [uint256]) _lockTimes; // STORAGE[0xb]\nuint256 _isOwner; // STORAGE[0x0] bytes 0 to 19\nuint256 _unlock; // STORAGE[0x3b2ff02c0f36dba7cc1b20a669e540b974575f04ef71846d482983efb03bebb4]\nuint256 _upgrade; // STORAGE[0x90215db359d12011b32ff0c897114c39e26956599904ee846adb0dd49f782e97]\nuint256 stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6; // STORAGE[0xe89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6]\n\n// Events\nUpgraded(address);\nUpgradeAnnounced(address, uint256);\nOwnershipTransferred(address, address);\nDeactivated(address);\n\nfunction 0x1964(uint256 varg0) private { \n    if (!MEM[varg0]) {\n        return ;\n    } else {\n        require(MEM[varg0] >= 32);\n        v0 = MEM[32 + varg0];\n        if (!(v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) {\n            return ;\n        } else {\n            v1.word0 = 4;\n            v2 = v1.data;\n            v1.word1 = 0x3078303000000000000000000000000000000000000000000000000000000000;\n            if (v0 & 0xf00000000000000000000000000000000000000000000000000000000000000 >= 0xa00000000000000000000000000000000000000000000000000000000000000) {\n                assert(3 < v1.length);\n                assert(3 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000023] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 39 + ((0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & 0xf00000000000000000000000000000000000000000000000000000000000000) >> 248)) << 248, 0x0)) & 0xFF;\n            } else {\n                assert(3 < v1.length);\n                assert(3 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000023] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & 0xf00000000000000000000000000000000000000000000000000000000000000) >> 248) << 248, 0x0)) & 0xFF;\n            }\n            if ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff >= 0xa00000000000000000000000000000000000000000000000000000000000000) {\n                assert(2 < v1.length);\n                assert(2 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000022] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 39 + ((0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 >> 248)) << 248, 0x0)) & 0xFF;\n            } else {\n                assert(2 < v1.length);\n                assert(2 < v1.length);\n                MEM8[0x3078303000000000000000000000000000000000000000000000000000000022] = (byte(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x3000000000000000000000000000000000000000000000000000000000000000 >> 248) + ((v0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) >> 4 >> 248) << 248, 0x0)) & 0xFF;\n            }\n            v3 = new array[](v1.length);\n            v4 = v5 = 0;\n            while (v4 < v1.length) {\n                v3[v4] = v1[v4];\n                v4 += 32;\n            }\n            if (4) {\n                MEM[v3.data] = 0x3078303000000000000000000000000000000000000000000000000000000000;\n            }\n            revert(Error(v3));\n        }\n    }\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction upgradeAnnounced() public nonPayable { \n    0x93d();\n}\n\nfunction upgrade(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == address(_upgrade));\n    0x93d();\n}\n\nfunction withdrawByAdmin(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    MEM[64] = v0.data + (~0x1f & varg0.length + 31);\n    v1 = v2 = MEM[64] + 32;\n    MEM[v2] = 0x14e0c71f00000000000000000000000000000000000000000000000000000020;\n    v3 = v4 = MEM[64];\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + ~31;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v6, v7 = address(_unlock).delegatecall(MEM[(MEM[64]) len (v8 + v4 - MEM[64])], MEM[(MEM[64]) len 0]).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v6);\n    0x1964(v9);\n}\n\nfunction activateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0, Error('invalid address'));\n    require(_forceDeactivateAdmin < _setAdminLimit, Error('too many admins existed'));\n    require(!(0xff & _isAdmin[varg0]), Error('already admin'));\n    _isAdmin[varg0] = 0x1 | ~0xff & _isAdmin[varg0];\n    require(1 + _forceDeactivateAdmin >= _forceDeactivateAdmin);\n    _forceDeactivateAdmin += 1;\n    emit 0xcc43938d137e7efade6a531f663e78c1fc75257b0d65ffda2fdaf70cb49cdf9(varg0);\n}\n\nfunction updateTokenRank(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner);\n    MEM[64] = MEM[64] + 100;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, v6 = address(_unlock).updateTokenRank(0x2123cb7800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v7 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v7.data, 0, RETURNDATASIZE());\n    }\n    require(v5);\n}\n\nfunction withdraw(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    MEM[64] = MEM[64] + 68;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, v6 = address(_unlock).withdraw(varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v7 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v7.data, 0, RETURNDATASIZE());\n    }\n    require(v5);\n}\n\nfunction depositToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x338b5dea00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction register(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0.code.size, Error('Implementation address should be a contract address'));\n    _upgrade = varg0;\n    stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6 = 0x127500 + block.timestamp;\n    emit UpgradeAnnounced(varg0, stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6);\n}\n\nfunction tokenRanks(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _tokenRanks[varg0];\n}\n\nfunction userRanks(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _userRanks[varg0];\n}\n\nfunction lockTimes(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _lockTimes[varg0];\n}\n\nfunction addToken(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x57016b0a00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction addUser(uint256 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x58d9fa0400000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction removeToken(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x5fa7b58400000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction userID_Address(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_userID_Address[varg0]);\n}\n\nfunction forceDeactivateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(0xff & _isAdmin[varg0], Error('not admin'));\n    _isAdmin[varg0] = ~0xff & _isAdmin[varg0];\n    require(1 <= _forceDeactivateAdmin);\n    _forceDeactivateAdmin = _forceDeactivateAdmin - 1;\n    emit Deactivated(varg0);\n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _isOwner);\n    emit OwnershipTransferred(_isOwner, 0);\n    _isOwner = 0;\n}\n\nfunction owner() public nonPayable { \n    return _isOwner;\n}\n\nfunction isOwner() public nonPayable { \n    return msg.sender == _isOwner;\n}\n\nfunction setAdminLimit(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(_setAdminLimit != varg0, Error('same limit'));\n    _setAdminLimit = varg0;\n}\n\nfunction removeUser(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x9857518800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction withdrawToken(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0x9e281a9800000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction unlock() public nonPayable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    MEM[v2] = 0xa69df4b500000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2];\n    v3 = v4 = v4.data;\n    v5 = v6 = v0.length;\n    while (v5 >= 32) {\n        MEM[v3] = MEM[v1];\n        v5 = v5 + ~31;\n        v3 += 32;\n        v1 += 32;\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v7, v8 = address(_unlock).unlock().gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v9 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n    }\n    require(v7);\n}\n\nfunction migrateByAdmin(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    if (v5 >= 32) {\n        v6 = v7 = v5 + ~31;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v6 >= 32) {\n            MEM[v3] = MEM[v1];\n            v6 = v6 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v6) - 1) | MEM[v3] & 256 ** (32 - v6) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xb19e43b400000000000000000000000000000000000000000000000000000020).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n    0x1964(v12);\n}\n\nfunction updateUserRank(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 36;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0xb46b791900000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0, v11, varg1).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction isAdmin() public nonPayable { \n    return 0xff & _isAdmin[msg.sender];\n}\n\nfunction balances(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _balances[varg1];\n}\n\nfunction settle(bytes varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(4 + varg0 + 32 <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (36 + varg0 + varg0.length > 4 + (msg.data.length - 4))));\n    require(0xff & _isAdmin[msg.sender], Error('sender not admin'));\n    CALLDATACOPY(v0.data, 36 + varg0, varg0.length);\n    v0[varg0.length] = 0;\n    v1 = v2 = MEM[64] + 32;\n    v3 = v4 = MEM[64];\n    if (v5 >= 32) {\n        v6 = v7 = v5 + ~31;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v6 >= 32) {\n            MEM[v3] = MEM[v1];\n            v6 = v6 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v6) - 1) | MEM[v3] & 256 ** (32 - v6) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xd0322fbf00000000000000000000000000000000000000000000000000000020).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n    0x1964(v12);\n}\n\nfunction deposit() public payable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    v3 = v4 = MEM[64];\n    v5 = v6 = v0.length;\n    if (v6 >= 32) {\n        v5 = v7 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe4;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v5 >= 32) {\n            MEM[v3] = MEM[v1];\n            v5 = v5 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xd0e30db000000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2]).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n}\n\nfunction processTime() public nonPayable { \n    return _processTime;\n}\n\nfunction deactivateAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(_forceDeactivateAdmin > 1, Error('admin should > 1'));\n    require(0xff & _isAdmin[varg0], Error('not admin'));\n    _isAdmin[varg0] = ~0xff & _isAdmin[varg0];\n    require(1 <= _forceDeactivateAdmin);\n    _forceDeactivateAdmin = _forceDeactivateAdmin - 1;\n    emit Deactivated(varg0);\n}\n\nfunction tokenID_Address(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return address(_tokenID_Address[varg0]);\n}\n\nfunction changeProcessTime(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, v10 = address(_unlock).delegatecall(0xf1c5f1e200000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & varg0).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v11 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v11.data, 0, RETURNDATASIZE());\n    }\n    require(v9);\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _isOwner);\n    require(varg0);\n    emit OwnershipTransferred(_isOwner, varg0);\n    _isOwner = varg0;\n}\n\nfunction orderFills(bytes32 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _orderFills[varg0];\n}\n\nfunction lock() public nonPayable { \n    v0 = new bytes[](4);\n    v1 = v2 = v0.data;\n    v3 = v4 = MEM[64];\n    v5 = v6 = v0.length;\n    if (v6 >= 32) {\n        v5 = v7 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe4;\n        v3 = v8 = 32 + v4;\n        v1 = v9 = 32 + v2;\n        while (v5 >= 32) {\n            MEM[v3] = MEM[v1];\n            v5 = v5 + ~31;\n            v3 += 32;\n            v1 += 32;\n        }\n    }\n    MEM[v3] = MEM[v1] & ~(256 ** (32 - v5) - 1) | MEM[v3] & 256 ** (32 - v5) - 1;\n    v10, v11 = address(_unlock).delegatecall(0xf83d08ba00000000000000000000000000000000000000000000000000000000 | 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & MEM[v2]).gas(msg.gas);\n    if (RETURNDATASIZE() != 0) {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    require(v10);\n}\n\nfunction 0x93d() private { \n    require(msg.sender == _isOwner);\n    require(block.timestamp >= stor_e89d1a29650bdc8a918bc762afb8ef07e10f6180e461c3fc305f9f142e5591e6);\n    require((address(_upgrade)).code.size, Error('Implementation address should be a contract address'));\n    _unlock = _upgrade;\n    emit Upgraded(address(_upgrade));\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x8f32d59b > v0) {\n            if (0x4d5edd28 > v0) {\n                if (0x2123cb78 > v0) {\n                    if (0x56f9d6d == v0) {\n                        upgradeAnnounced();\n                    } else if (0x900f010 == v0) {\n                        upgrade(address);\n                    } else if (0x14e0c71f == v0) {\n                        withdrawByAdmin(bytes);\n                    } else {\n                        require(0x1af1a768 == v0);\n                        activateAdmin(address);\n                    }\n                } else if (0x2123cb78 == v0) {\n                    updateTokenRank(address,uint256);\n                } else if (0x2e1a7d4d == v0) {\n                    withdraw(uint256);\n                } else if (0x338b5dea == v0) {\n                    depositToken(address,uint256);\n                } else if (0x4420e486 == v0) {\n                    register(address);\n                } else {\n                    require(0x4a184239 == v0);\n                    tokenRanks(address);\n                }\n            } else if (0x5fa7b584 > v0) {\n                if (0x4d5edd28 == v0) {\n                    userRanks(address);\n                } else if (0x56c7c1b3 == v0) {\n                    lockTimes(address);\n                } else if (0x57016b0a == v0) {\n                    addToken(uint256,address);\n                } else {\n                    require(0x58d9fa04 == v0);\n                    addUser(uint256,address);\n                }\n            } else if (0x5fa7b584 == v0) {\n                removeToken(address);\n            } else if (0x61959f85 == v0) {\n                userID_Address(uint256);\n            } else if (0x6f9a5fb3 == v0) {\n                forceDeactivateAdmin(address);\n            } else if (0x715018a6 == v0) {\n                renounceOwnership();\n            } else {\n                require(0x8da5cb5b == v0);\n                owner();\n            }\n        } else if (0xd0322fbf > v0) {\n            if (0xa69df4b5 > v0) {\n                if (0x8f32d59b == v0) {\n                    isOwner();\n                } else if (0x91a8c4b8 == v0) {\n                    setAdminLimit(uint256);\n                } else if (0x98575188 == v0) {\n                    removeUser(address);\n                } else {\n                    require(0x9e281a98 == v0);\n                    withdrawToken(address,uint256);\n                }\n            } else if (0xa69df4b5 == v0) {\n                unlock();\n            } else if (0xb19e43b4 == v0) {\n                migrateByAdmin(bytes);\n            } else if (0xb46b7919 == v0) {\n                updateUserRank(address,uint256);\n            } else if (0xb6db75a0 == v0) {\n                isAdmin();\n            } else {\n                require(0xc23f001f == v0);\n                balances(address,address);\n            }\n        } else if (0xe8b93ad7 > v0) {\n            if (0xd0322fbf == v0) {\n                settle(bytes);\n            } else if (0xd0e30db0 == v0) {\n                deposit();\n            } else if (0xdd41250f == v0) {\n                processTime();\n            } else {\n                require(0xdf6fa20e == v0);\n                deactivateAdmin(address);\n            }\n        } else if (0xe8b93ad7 == v0) {\n            tokenID_Address(uint256);\n        } else if (0xf1c5f1e2 == v0) {\n            changeProcessTime(uint256);\n        } else if (0xf2fde38b == v0) {\n            transferOwnership(address);\n        } else if (0xf7213db6 == v0) {\n            orderFills(bytes32);\n        } else {\n            require(0xf83d08ba == v0);\n            lock();\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 112.77418971061707,
	"usage": {
		"completion_tokens": 413,
		"prompt_tokens": 9030,
		"total_tokens": 9443
	}
}