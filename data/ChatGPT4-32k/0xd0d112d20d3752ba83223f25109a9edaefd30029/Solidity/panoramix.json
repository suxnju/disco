{
	"address": "0xd0d112d20d3752ba83223f25109a9edaefd30029",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The Solidity equivalent of the EVM Bytecode could be something like:\n\n```solidity\npragma solidity ^0.7.0;\n\ncontract WaDaFuq {\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    uint256 private stor2;\n    uint256 private stor3;\n    uint8 private stor4;\n\n    address private owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() {\n        balanceOf[msg.sender] = 10**17;\n        owner = msg.sender;\n    }\n\n    function openTrading() public {\n        require(msg.sender == owner, \"Only owner can open trading\");\n        stor4 = 1;\n    }\n\n    function unknownef6d6e07(uint256 _param1, uint256 _param2) public {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        require(_param1 < 10, \"Parameter 1 has to be less than 10\");\n        stor2 = _param1;\n        stor3 = _param2;\n    }\n\n    function approve(address spender, uint256 amount) public returns(bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) public returns(bool) {\n        require(balanceOf[msg.sender] >= amount, 'Insufficient balance');\n\n        // more logic here...\n\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns(bool) {\n        require(allowance[sender][msg.sender] >= amount, 'Insufficient allowance');\n        require(balanceOf[sender] >= amount, 'Insufficient balance');\n\n        // more logic here...\n\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    fallback () external payable {\n        // default function\n    }\n}\n```\n\nPlease note that this code is just a simplified version of the decompiled code. The full implementation would require importing external contracts, calling other contracts, and handling more complex logic. Also, the code above does not handle exceptions and does not emit events in all functions. This would need to be added to create a complete and secure contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1700632234,
	"id": "chatcmpl-8NaQ6tMwBfAzycCo390BPAvfxjdDO",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst name = 'WaDaFuq', 0\nconst totalSupply = 10^17\nconst decimals = 9\nconst symbol = '', 0\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  allowance is mapping of uint256 at storage 1\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint8 at storage 4\n  stor4 is uint8 at storage 4 offset 8\n\ndef balanceOf(address account): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[account]\n\ndef allowance(address owner, address spender): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[owner][spender]\n\n#\n#  Regular functions\n#\n\ndef openTrading(): # not payable\n  require 0x98b284d61e45d83014b20432ea266155197452ec == caller\n  uint8(stor4.field_0) = 1\n\ndef unknownef6d6e07(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >=\u2032 64\n  if caller - 0x98b284d61e45d83014b20432ea266155197452ec:\n      require _param1 < 10\n      revert\n  stor2 = _param1\n  stor3 = _param2\n\ndef approve(address spender, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if balanceOf[caller] - amount > balanceOf[caller]:\n      revert with 0, 17\n  balanceOf[caller] -= amount\n  if caller != 0x98b284d61e45d83014b20432ea266155197452ec:\n      require uint8(stor4.field_0)\n  if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n      if not uint8(stor4.field_8):\n          if balanceOf[this.address] >= 10^14:\n              uint8(stor4.field_8) = 1\n              mem[128] = this.address\n              mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n              mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n              mem[196] = 10^14\n              idx = 0\n              s = 388\n              t = 128\n              while idx < 2:\n                  mem[s] = mem[t + 12 len 20]\n                  idx = idx + 1\n                  s = s + 32\n                  t = t + 32\n                  continue \n              require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n              call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                   gas gas_remaining wei\n                  args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                 value eth.balance(this.address) wei\n                   gas 2300 * is_zero(value) wei\n              uint8(stor4.field_8) = 0\n  else:\n      if recipient != 0x98b284d61e45d83014b20432ea266155197452ec:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          require amount + balanceOf[address(recipient)] <= 10^17\n      if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  mem[128] = this.address\n                  mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n                  mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n                  mem[196] = 10^14\n                  idx = 0\n                  s = 388\n                  t = 128\n                  while idx < 2:\n                      mem[s] = mem[t + 12 len 20]\n                      idx = idx + 1\n                      s = s + 32\n                      t = t + 32\n                      continue \n                  require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n                  call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                       gas gas_remaining wei\n                      args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                     value eth.balance(this.address) wei\n                       gas 2300 * is_zero(value) wei\n                  uint8(stor4.field_8) = 0\n  if this.address == caller:\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      log Transfer(\n            address from=amount,\n            address to=caller,\n            uint256 value=recipient)\n  else:\n      if 0x98b284d61e45d83014b20432ea266155197452ec == recipient:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          log Transfer(\n                address from=amount,\n                address to=caller,\n                uint256 value=recipient)\n      else:\n          if caller == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if stor2 != stor2 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor2 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor2 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor2 * amount / 100\n              log Transfer(\n                    address from=(stor2 * amount / 100),\n                    address to=caller,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor2 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor2 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor2 * amount / 100)),\n                    address to=caller,\n                    uint256 value=recipient)\n          else:\n              if stor3 != stor3 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor3 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor3 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor3 * amount / 100\n              log Transfer(\n                    address from=(stor3 * amount / 100),\n                    address to=caller,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor3 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor3 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor3 * amount / 100)),\n                    address to=caller,\n                    uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] - amount > allowance[address(sender)][caller]:\n      revert with 0, 17\n  allowance[address(sender)][caller] -= amount\n  if balanceOf[address(sender)] - amount > balanceOf[address(sender)]:\n      revert with 0, 17\n  balanceOf[address(sender)] -= amount\n  if sender != 0x98b284d61e45d83014b20432ea266155197452ec:\n      require uint8(stor4.field_0)\n  if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n      if not uint8(stor4.field_8):\n          if balanceOf[this.address] >= 10^14:\n              uint8(stor4.field_8) = 1\n              mem[128] = this.address\n              mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n              mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n              mem[196] = 10^14\n              idx = 0\n              s = 388\n              t = 128\n              while idx < 2:\n                  mem[s] = mem[t + 12 len 20]\n                  idx = idx + 1\n                  s = s + 32\n                  t = t + 32\n                  continue \n              require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n              call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                   gas gas_remaining wei\n                  args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                 value eth.balance(this.address) wei\n                   gas 2300 * is_zero(value) wei\n              uint8(stor4.field_8) = 0\n  else:\n      if recipient != 0x98b284d61e45d83014b20432ea266155197452ec:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          require amount + balanceOf[address(recipient)] <= 10^17\n      if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  mem[128] = this.address\n                  mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n                  mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n                  mem[196] = 10^14\n                  idx = 0\n                  s = 388\n                  t = 128\n                  while idx < 2:\n                      mem[s] = mem[t + 12 len 20]\n                      idx = idx + 1\n                      s = s + 32\n                      t = t + 32\n                      continue \n                  require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n                  call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                       gas gas_remaining wei\n                      args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                     value eth.balance(this.address) wei\n                       gas 2300 * is_zero(value) wei\n                  uint8(stor4.field_8) = 0\n  if this.address == sender:\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      log Transfer(\n            address from=amount,\n            address to=sender,\n            uint256 value=recipient)\n  else:\n      if 0x98b284d61e45d83014b20432ea266155197452ec == recipient:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          log Transfer(\n                address from=amount,\n                address to=sender,\n                uint256 value=recipient)\n      else:\n          if sender == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if stor2 != stor2 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor2 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor2 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor2 * amount / 100\n              log Transfer(\n                    address from=(stor2 * amount / 100),\n                    address to=sender,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor2 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor2 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor2 * amount / 100)),\n                    address to=sender,\n                    uint256 value=recipient)\n          else:\n              if stor3 != stor3 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor3 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor3 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor3 * amount / 100\n              log Transfer(\n                    address from=(stor3 * amount / 100),\n                    address to=sender,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor3 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor3 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor3 * amount / 100)),\n                    address to=sender,\n                    uint256 value=recipient)\n  return 1\n\ndef _fallback(?) payable: # default function\n  if calldata.size < 4:\n      require not calldata.size\n      stop\n  if balanceOf(address account) <= uint32(call.func_hash) >> 224:\n      if balanceOf(address account) == uint32(call.func_hash) >> 224:\n          require not call.value\n          require calldata.size - 4 >=\u2032 32\n          require _param1 == address(_param1)\n          return balanceOf[_param1]\n      if symbol() == uint32(call.func_hash) >> 224:\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if uint32(call.func_hash) >> 224 != transfer(address recipient, uint256 amount):\n          if openTrading() == uint32(call.func_hash) >> 224:\n              require not call.value\n              require 0x98b284d61e45d83014b20432ea266155197452ec == caller\n              uint8(stor4.field_0) = 1\n          else:\n              if allowance(address owner, address spender) == uint32(call.func_hash) >> 224:\n                  require not call.value\n                  require calldata.size - 4 >=\u2032 64\n                  require _param1 == address(_param1)\n                  require _param2 == address(_param2)\n                  return allowance[_param1][_param2]\n              require 4016926215 == uint32(call.func_hash) >> 224\n              require not call.value\n              require calldata.size - 4 >=\u2032 64\n              if caller - 0x98b284d61e45d83014b20432ea266155197452ec:\n                  require _param1 < 10\n                  revert\n              stor2 = _param1\n              stor3 = _param2\n          stop\n      require not call.value\n      require calldata.size - 4 >=\u2032 64\n      require _param1 == address(_param1)\n      if balanceOf[caller] - _param2 > balanceOf[caller]:\n          revert with 0, 17\n      balanceOf[caller] -= _param2\n      if caller != 0x98b284d61e45d83014b20432ea266155197452ec:\n          require uint8(stor4.field_0)\n      if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          if address(_param1) != 0x98b284d61e45d83014b20432ea266155197452ec:\n              if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n                  revert with 0, 17\n              require _param2 + balanceOf[address(_param1)] <= 10^17\n          if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if not uint8(stor4.field_8):\n                  if balanceOf[this.address] >= 10^14:\n                      uint8(stor4.field_8) = 1\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if this.address == caller:\n          if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n              revert with 0, 17\n          balanceOf[address(_param1)] += _param2\n          log Transfer(\n                address from=_param2,\n                address to=caller,\n                uint256 value=address(_param1))\n      else:\n          if 0x98b284d61e45d83014b20432ea266155197452ec == address(_param1):\n              if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n                  revert with 0, 17\n              balanceOf[address(_param1)] += _param2\n              log Transfer(\n                    address from=_param2,\n                    address to=caller,\n                    uint256 value=address(_param1))\n          else:\n              if caller == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                  if stor2 != stor2 * _param2 / _param2 and _param2:\n                      revert with 0, 17\n                  if _param2 - (stor2 * _param2 / 100) > _param2:\n                      revert with 0, 17\n                  if balanceOf[this.address] > (stor2 * _param2 / 100) + balanceOf[this.address]:\n                      revert with 0, 17\n                  balanceOf[this.address] += stor2 * _param2 / 100\n                  log Transfer(\n                        address from=(stor2 * _param2 / 100),\n                        address to=caller,\n                        uint256 value=this.address)\n                  if balanceOf[address(_param1)] > _param2 - (stor2 * _param2 / 100) + balanceOf[address(_param1)]:\n                      revert with 0, 17\n                  balanceOf[address(_param1)] = _param2 - (stor2 * _param2 / 100) + balanceOf[address(_param1)]\n                  log Transfer(\n                        address from=(_param2 - (stor2 * _param2 / 100)),\n                        address to=caller,\n                        uint256 value=address(_param1))\n              else:\n                  if stor3 != stor3 * _param2 / _param2 and _param2:\n                      revert with 0, 17\n                  if _param2 - (stor3 * _param2 / 100) > _param2:\n                      revert with 0, 17\n                  if balanceOf[this.address] > (stor3 * _param2 / 100) + balanceOf[this.address]:\n                      revert with 0, 17\n                  balanceOf[this.address] += stor3 * _param2 / 100\n                  log Transfer(\n                        address from=(stor3 * _param2 / 100),\n                        address to=caller,\n                        uint256 value=this.address)\n                  if balanceOf[address(_param1)] > _param2 - (stor3 * _param2 / 100) + balanceOf[address(_param1)]:\n                      revert with 0, 17\n                  balanceOf[address(_param1)] = _param2 - (stor3 * _param2 / 100) + balanceOf[address(_param1)]\n                  log Transfer(\n                        address from=(_param2 - (stor3 * _param2 / 100)),\n                        address to=caller,\n                        uint256 value=address(_param1))\n  else:\n      if name() == uint32(call.func_hash) >> 224:\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if approve(address spender, uint256 amount) == uint32(call.func_hash) >> 224:\n          require not call.value\n          require calldata.size - 4 >=\u2032 64\n          require _param1 == address(_param1)\n          allowance[caller][address(_param1)] = _param2\n          log Approval(\n                address owner=_param2,\n                address spender=caller,\n                uint256 value=address(_param1))\n      else:\n          if totalSupply() == uint32(call.func_hash) >> 224:\n              require not call.value\n              return 10^17\n          if uint32(call.func_hash) >> 224 != transferFrom(address sender, address recipient, uint256 amount):\n              require decimals() == uint32(call.func_hash) >> 224\n              require not call.value\n              return 9\n          require not call.value\n          require calldata.size - 4 >=\u2032 96\n          require _param1 == address(_param1)\n          require _param2 == address(_param2)\n          if allowance[address(_param1)][caller] - _param3 > allowance[address(_param1)][caller]:\n              revert with 0, 17\n          allowance[address(_param1)][caller] -= _param3\n          if balanceOf[address(_param1)] - _param3 > balanceOf[address(_param1)]:\n              revert with 0, 17\n          balanceOf[address(_param1)] -= _param3\n          if address(_param1) != 0x98b284d61e45d83014b20432ea266155197452ec:\n              require uint8(stor4.field_0)\n          if address(_param2) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if not uint8(stor4.field_8):\n                  if balanceOf[this.address] >= 10^14:\n                      uint8(stor4.field_8) = 1\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if address(_param2) != 0x98b284d61e45d83014b20432ea266155197452ec:\n                  if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                      revert with 0, 17\n                  require _param3 + balanceOf[address(_param2)] <= 10^17\n              if address(_param2) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                  if not uint8(stor4.field_8):\n                      if balanceOf[this.address] >= 10^14:\n                          uint8(stor4.field_8) = 1\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if this.address == address(_param1):\n              if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                  revert with 0, 17\n              balanceOf[address(_param2)] += _param3\n              log Transfer(\n                    address from=_param3,\n                    address to=address(_param1),\n                    uint256 value=address(_param2))\n          else:\n              if 0x98b284d61e45d83014b20432ea266155197452ec == address(_param2):\n                  if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                      revert with 0, 17\n                  balanceOf[address(_param2)] += _param3\n                  log Transfer(\n                        address from=_param3,\n                        address to=address(_param1),\n                        uint256 value=address(_param2))\n              else:\n                  if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                      if stor2 != stor2 * _param3 / _param3 and _param3:\n                          revert with 0, 17\n                      if _param3 - (stor2 * _param3 / 100) > _param3:\n                          revert with 0, 17\n                      if balanceOf[this.address] > (stor2 * _param3 / 100) + balanceOf[this.address]:\n                          revert with 0, 17\n                      balanceOf[this.address] += stor2 * _param3 / 100\n                      log Transfer(\n                            address from=(stor2 * _param3 / 100),\n                            address to=address(_param1),\n                            uint256 value=this.address)\n                      if balanceOf[address(_param2)] > _param3 - (stor2 * _param3 / 100) + balanceOf[address(_param2)]:\n                          revert with 0, 17\n                      balanceOf[address(_param2)] = _param3 - (stor2 * _param3 / 100) + balanceOf[address(_param2)]\n                      log Transfer(\n                            address from=(_param3 - (stor2 * _param3 / 100)),\n                            address to=address(_param1),\n                            uint256 value=address(_param2))\n                  else:\n                      if stor3 != stor3 * _param3 / _param3 and _param3:\n                          revert with 0, 17\n                      if _param3 - (stor3 * _param3 / 100) > _param3:\n                          revert with 0, 17\n                      if balanceOf[this.address] > (stor3 * _param3 / 100) + balanceOf[this.address]:\n                          revert with 0, 17\n                      balanceOf[this.address] += stor3 * _param3 / 100\n                      log Transfer(\n                            address from=(stor3 * _param3 / 100),\n                            address to=address(_param1),\n                            uint256 value=this.address)\n                      if balanceOf[address(_param2)] > _param3 - (stor3 * _param3 / 100) + balanceOf[address(_param2)]:\n                          revert with 0, 17\n                      balanceOf[address(_param2)] = _param3 - (stor3 * _param3 / 100) + balanceOf[address(_param2)]\n                      log Transfer(\n                            address from=(_param3 - (stor3 * _param3 / 100)),\n                            address to=address(_param1),\n                            uint256 value=address(_param2))\n  return 1\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst name = 'WaDaFuq', 0\nconst totalSupply = 10^17\nconst decimals = 9\nconst symbol = '', 0\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  allowance is mapping of uint256 at storage 1\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint8 at storage 4\n  stor4 is uint8 at storage 4 offset 8\n\ndef balanceOf(address account): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[account]\n\ndef allowance(address owner, address spender): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[owner][spender]\n\n#\n#  Regular functions\n#\n\ndef openTrading(): # not payable\n  require 0x98b284d61e45d83014b20432ea266155197452ec == caller\n  uint8(stor4.field_0) = 1\n\ndef unknownef6d6e07(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >=\u2032 64\n  if caller - 0x98b284d61e45d83014b20432ea266155197452ec:\n      require _param1 < 10\n      revert\n  stor2 = _param1\n  stor3 = _param2\n\ndef approve(address spender, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if balanceOf[caller] - amount > balanceOf[caller]:\n      revert with 0, 17\n  balanceOf[caller] -= amount\n  if caller != 0x98b284d61e45d83014b20432ea266155197452ec:\n      require uint8(stor4.field_0)\n  if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n      if not uint8(stor4.field_8):\n          if balanceOf[this.address] >= 10^14:\n              uint8(stor4.field_8) = 1\n              mem[128] = this.address\n              mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n              mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n              mem[196] = 10^14\n              idx = 0\n              s = 388\n              t = 128\n              while idx < 2:\n                  mem[s] = mem[t + 12 len 20]\n                  idx = idx + 1\n                  s = s + 32\n                  t = t + 32\n                  continue \n              require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n              call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                   gas gas_remaining wei\n                  args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                 value eth.balance(this.address) wei\n                   gas 2300 * is_zero(value) wei\n              uint8(stor4.field_8) = 0\n  else:\n      if recipient != 0x98b284d61e45d83014b20432ea266155197452ec:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          require amount + balanceOf[address(recipient)] <= 10^17\n      if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  mem[128] = this.address\n                  mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n                  mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n                  mem[196] = 10^14\n                  idx = 0\n                  s = 388\n                  t = 128\n                  while idx < 2:\n                      mem[s] = mem[t + 12 len 20]\n                      idx = idx + 1\n                      s = s + 32\n                      t = t + 32\n                      continue \n                  require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n                  call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                       gas gas_remaining wei\n                      args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                     value eth.balance(this.address) wei\n                       gas 2300 * is_zero(value) wei\n                  uint8(stor4.field_8) = 0\n  if this.address == caller:\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      log Transfer(\n            address from=amount,\n            address to=caller,\n            uint256 value=recipient)\n  else:\n      if 0x98b284d61e45d83014b20432ea266155197452ec == recipient:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          log Transfer(\n                address from=amount,\n                address to=caller,\n                uint256 value=recipient)\n      else:\n          if caller == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if stor2 != stor2 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor2 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor2 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor2 * amount / 100\n              log Transfer(\n                    address from=(stor2 * amount / 100),\n                    address to=caller,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor2 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor2 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor2 * amount / 100)),\n                    address to=caller,\n                    uint256 value=recipient)\n          else:\n              if stor3 != stor3 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor3 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor3 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor3 * amount / 100\n              log Transfer(\n                    address from=(stor3 * amount / 100),\n                    address to=caller,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor3 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor3 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor3 * amount / 100)),\n                    address to=caller,\n                    uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] - amount > allowance[address(sender)][caller]:\n      revert with 0, 17\n  allowance[address(sender)][caller] -= amount\n  if balanceOf[address(sender)] - amount > balanceOf[address(sender)]:\n      revert with 0, 17\n  balanceOf[address(sender)] -= amount\n  if sender != 0x98b284d61e45d83014b20432ea266155197452ec:\n      require uint8(stor4.field_0)\n  if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n      if not uint8(stor4.field_8):\n          if balanceOf[this.address] >= 10^14:\n              uint8(stor4.field_8) = 1\n              mem[128] = this.address\n              mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n              mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n              mem[196] = 10^14\n              idx = 0\n              s = 388\n              t = 128\n              while idx < 2:\n                  mem[s] = mem[t + 12 len 20]\n                  idx = idx + 1\n                  s = s + 32\n                  t = t + 32\n                  continue \n              require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n              call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                   gas gas_remaining wei\n                  args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                 value eth.balance(this.address) wei\n                   gas 2300 * is_zero(value) wei\n              uint8(stor4.field_8) = 0\n  else:\n      if recipient != 0x98b284d61e45d83014b20432ea266155197452ec:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          require amount + balanceOf[address(recipient)] <= 10^17\n      if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  mem[128] = this.address\n                  mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n                  mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n                  mem[196] = 10^14\n                  idx = 0\n                  s = 388\n                  t = 128\n                  while idx < 2:\n                      mem[s] = mem[t + 12 len 20]\n                      idx = idx + 1\n                      s = s + 32\n                      t = t + 32\n                      continue \n                  require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n                  call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                       gas gas_remaining wei\n                      args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                     value eth.balance(this.address) wei\n                       gas 2300 * is_zero(value) wei\n                  uint8(stor4.field_8) = 0\n  if this.address == sender:\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      log Transfer(\n            address from=amount,\n            address to=sender,\n            uint256 value=recipient)\n  else:\n      if 0x98b284d61e45d83014b20432ea266155197452ec == recipient:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          log Transfer(\n                address from=amount,\n                address to=sender,\n                uint256 value=recipient)\n      else:\n          if sender == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if stor2 != stor2 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor2 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor2 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor2 * amount / 100\n              log Transfer(\n                    address from=(stor2 * amount / 100),\n                    address to=sender,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor2 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor2 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor2 * amount / 100)),\n                    address to=sender,\n                    uint256 value=recipient)\n          else:\n              if stor3 != stor3 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor3 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor3 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor3 * amount / 100\n              log Transfer(\n                    address from=(stor3 * amount / 100),\n                    address to=sender,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor3 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor3 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor3 * amount / 100)),\n                    address to=sender,\n                    uint256 value=recipient)\n  return 1\n\ndef _fallback(?) payable: # default function\n  if calldata.size < 4:\n      require not calldata.size\n      stop\n  if balanceOf(address account) <= uint32(call.func_hash) >> 224:\n      if balanceOf(address account) == uint32(call.func_hash) >> 224:\n          require not call.value\n          require calldata.size - 4 >=\u2032 32\n          require _param1 == address(_param1)\n          return balanceOf[_param1]\n      if symbol() == uint32(call.func_hash) >> 224:\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if uint32(call.func_hash) >> 224 != transfer(address recipient, uint256 amount):\n          if openTrading() == uint32(call.func_hash) >> 224:\n              require not call.value\n              require 0x98b284d61e45d83014b20432ea266155197452ec == caller\n              uint8(stor4.field_0) = 1\n          else:\n              if allowance(address owner, address spender) == uint32(call.func_hash) >> 224:\n                  require not call.value\n                  require calldata.size - 4 >=\u2032 64\n                  require _param1 == address(_param1)\n                  require _param2 == address(_param2)\n                  return allowance[_param1][_param2]\n              require 4016926215 == uint32(call.func_hash) >> 224\n              require not call.value\n              require calldata.size - 4 >=\u2032 64\n              if caller - 0x98b284d61e45d83014b20432ea266155197452ec:\n                  require _param1 < 10\n                  revert\n              stor2 = _param1\n              stor3 = _param2\n          stop\n      require not call.value\n      require calldata.size - 4 >=\u2032 64\n      require _param1 == address(_param1)\n      if balanceOf[caller] - _param2 > balanceOf[caller]:\n          revert with 0, 17\n      balanceOf[caller] -= _param2\n      if caller != 0x98b284d61e45d83014b20432ea266155197452ec:\n          require uint8(stor4.field_0)\n      if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          if address(_param1) != 0x98b284d61e45d83014b20432ea266155197452ec:\n              if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n                  revert with 0, 17\n              require _param2 + balanceOf[address(_param1)] <= 10^17\n          if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if not uint8(stor4.field_8):\n                  if balanceOf[this.address] >= 10^14:\n                      uint8(stor4.field_8) = 1\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if this.address == caller:\n          if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n              revert with 0, 17\n          balanceOf[address(_param1)] += _param2\n          log Transfer(\n                address from=_param2,\n                address to=caller,\n                uint256 value=address(_param1))\n      else:\n          if 0x98b284d61e45d83014b20432ea266155197452ec == address(_param1):\n              if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n                  revert with 0, 17\n              balanceOf[address(_param1)] += _param2\n              log Transfer(\n                    address from=_param2,\n                    address to=caller,\n                    uint256 value=address(_param1))\n          else:\n              if caller == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                  if stor2 != stor2 * _param2 / _param2 and _param2:\n                      revert with 0, 17\n                  if _param2 - (stor2 * _param2 / 100) > _param2:\n                      revert with 0, 17\n                  if balanceOf[this.address] > (stor2 * _param2 / 100) + balanceOf[this.address]:\n                      revert with 0, 17\n                  balanceOf[this.address] += stor2 * _param2 / 100\n                  log Transfer(\n                        address from=(stor2 * _param2 / 100),\n                        address to=caller,\n                        uint256 value=this.address)\n                  if balanceOf[address(_param1)] > _param2 - (stor2 * _param2 / 100) + balanceOf[address(_param1)]:\n                      revert with 0, 17\n                  balanceOf[address(_param1)] = _param2 - (stor2 * _param2 / 100) + balanceOf[address(_param1)]\n                  log Transfer(\n                        address from=(_param2 - (stor2 * _param2 / 100)),\n                        address to=caller,\n                        uint256 value=address(_param1))\n              else:\n                  if stor3 != stor3 * _param2 / _param2 and _param2:\n                      revert with 0, 17\n                  if _param2 - (stor3 * _param2 / 100) > _param2:\n                      revert with 0, 17\n                  if balanceOf[this.address] > (stor3 * _param2 / 100) + balanceOf[this.address]:\n                      revert with 0, 17\n                  balanceOf[this.address] += stor3 * _param2 / 100\n                  log Transfer(\n                        address from=(stor3 * _param2 / 100),\n                        address to=caller,\n                        uint256 value=this.address)\n                  if balanceOf[address(_param1)] > _param2 - (stor3 * _param2 / 100) + balanceOf[address(_param1)]:\n                      revert with 0, 17\n                  balanceOf[address(_param1)] = _param2 - (stor3 * _param2 / 100) + balanceOf[address(_param1)]\n                  log Transfer(\n                        address from=(_param2 - (stor3 * _param2 / 100)),\n                        address to=caller,\n                        uint256 value=address(_param1))\n  else:\n      if name() == uint32(call.func_hash) >> 224:\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if approve(address spender, uint256 amount) == uint32(call.func_hash) >> 224:\n          require not call.value\n          require calldata.size - 4 >=\u2032 64\n          require _param1 == address(_param1)\n          allowance[caller][address(_param1)] = _param2\n          log Approval(\n                address owner=_param2,\n                address spender=caller,\n                uint256 value=address(_param1))\n      else:\n          if totalSupply() == uint32(call.func_hash) >> 224:\n              require not call.value\n              return 10^17\n          if uint32(call.func_hash) >> 224 != transferFrom(address sender, address recipient, uint256 amount):\n              require decimals() == uint32(call.func_hash) >> 224\n              require not call.value\n              return 9\n          require not call.value\n          require calldata.size - 4 >=\u2032 96\n          require _param1 == address(_param1)\n          require _param2 == address(_param2)\n          if allowance[address(_param1)][caller] - _param3 > allowance[address(_param1)][caller]:\n              revert with 0, 17\n          allowance[address(_param1)][caller] -= _param3\n          if balanceOf[address(_param1)] - _param3 > balanceOf[address(_param1)]:\n              revert with 0, 17\n          balanceOf[address(_param1)] -= _param3\n          if address(_param1) != 0x98b284d61e45d83014b20432ea266155197452ec:\n              require uint8(stor4.field_0)\n          if address(_param2) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if not uint8(stor4.field_8):\n                  if balanceOf[this.address] >= 10^14:\n                      uint8(stor4.field_8) = 1\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if address(_param2) != 0x98b284d61e45d83014b20432ea266155197452ec:\n                  if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                      revert with 0, 17\n                  require _param3 + balanceOf[address(_param2)] <= 10^17\n              if address(_param2) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                  if not uint8(stor4.field_8):\n                      if balanceOf[this.address] >= 10^14:\n                          uint8(stor4.field_8) = 1\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if this.address == address(_param1):\n              if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                  revert with 0, 17\n              balanceOf[address(_param2)] += _param3\n              log Transfer(\n                    address from=_param3,\n                    address to=address(_param1),\n                    uint256 value=address(_param2))\n          else:\n              if 0x98b284d61e45d83014b20432ea266155197452ec == address(_param2):\n                  if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                      revert with 0, 17\n                  balanceOf[address(_param2)] += _param3\n                  log Transfer(\n                        address from=_param3,\n                        address to=address(_param1),\n                        uint256 value=address(_param2))\n              else:\n                  if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                      if stor2 != stor2 * _param3 / _param3 and _param3:\n                          revert with 0, 17\n                      if _param3 - (stor2 * _param3 / 100) > _param3:\n                          revert with 0, 17\n                      if balanceOf[this.address] > (stor2 * _param3 / 100) + balanceOf[this.address]:\n                          revert with 0, 17\n                      balanceOf[this.address] += stor2 * _param3 / 100\n                      log Transfer(\n                            address from=(stor2 * _param3 / 100),\n                            address to=address(_param1),\n                            uint256 value=this.address)\n                      if balanceOf[address(_param2)] > _param3 - (stor2 * _param3 / 100) + balanceOf[address(_param2)]:\n                          revert with 0, 17\n                      balanceOf[address(_param2)] = _param3 - (stor2 * _param3 / 100) + balanceOf[address(_param2)]\n                      log Transfer(\n                            address from=(_param3 - (stor2 * _param3 / 100)),\n                            address to=address(_param1),\n                            uint256 value=address(_param2))\n                  else:\n                      if stor3 != stor3 * _param3 / _param3 and _param3:\n                          revert with 0, 17\n                      if _param3 - (stor3 * _param3 / 100) > _param3:\n                          revert with 0, 17\n                      if balanceOf[this.address] > (stor3 * _param3 / 100) + balanceOf[this.address]:\n                          revert with 0, 17\n                      balanceOf[this.address] += stor3 * _param3 / 100\n                      log Transfer(\n                            address from=(stor3 * _param3 / 100),\n                            address to=address(_param1),\n                            uint256 value=this.address)\n                      if balanceOf[address(_param2)] > _param3 - (stor3 * _param3 / 100) + balanceOf[address(_param2)]:\n                          revert with 0, 17\n                      balanceOf[address(_param2)] = _param3 - (stor3 * _param3 / 100) + balanceOf[address(_param2)]\n                      log Transfer(\n                            address from=(_param3 - (stor3 * _param3 / 100)),\n                            address to=address(_param1),\n                            uint256 value=address(_param2))\n  return 1\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst name = 'WaDaFuq', 0\nconst totalSupply = 10^17\nconst decimals = 9\nconst symbol = '', 0\n\ndef storage:\n  balanceOf is mapping of uint256 at storage 0\n  allowance is mapping of uint256 at storage 1\n  stor2 is uint256 at storage 2\n  stor3 is uint256 at storage 3\n  stor4 is uint8 at storage 4\n  stor4 is uint8 at storage 4 offset 8\n\ndef balanceOf(address account): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require account == account\n  return balanceOf[account]\n\ndef allowance(address owner, address spender): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require owner == owner\n  require spender == spender\n  return allowance[owner][spender]\n\n#\n#  Regular functions\n#\n\ndef openTrading(): # not payable\n  require 0x98b284d61e45d83014b20432ea266155197452ec == caller\n  uint8(stor4.field_0) = 1\n\ndef unknownef6d6e07(uint256 _param1, uint256 _param2): # not payable\n  require calldata.size - 4 >=\u2032 64\n  if caller - 0x98b284d61e45d83014b20432ea266155197452ec:\n      require _param1 < 10\n      revert\n  stor2 = _param1\n  stor3 = _param2\n\ndef approve(address spender, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require spender == spender\n  allowance[caller][address(spender)] = amount\n  log Approval(\n        address owner=amount,\n        address spender=caller,\n        uint256 value=spender)\n  return 1\n\ndef transfer(address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 64\n  require recipient == recipient\n  if balanceOf[caller] - amount > balanceOf[caller]:\n      revert with 0, 17\n  balanceOf[caller] -= amount\n  if caller != 0x98b284d61e45d83014b20432ea266155197452ec:\n      require uint8(stor4.field_0)\n  if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n      if not uint8(stor4.field_8):\n          if balanceOf[this.address] >= 10^14:\n              uint8(stor4.field_8) = 1\n              mem[128] = this.address\n              mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n              mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n              mem[196] = 10^14\n              idx = 0\n              s = 388\n              t = 128\n              while idx < 2:\n                  mem[s] = mem[t + 12 len 20]\n                  idx = idx + 1\n                  s = s + 32\n                  t = t + 32\n                  continue \n              require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n              call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                   gas gas_remaining wei\n                  args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                 value eth.balance(this.address) wei\n                   gas 2300 * is_zero(value) wei\n              uint8(stor4.field_8) = 0\n  else:\n      if recipient != 0x98b284d61e45d83014b20432ea266155197452ec:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          require amount + balanceOf[address(recipient)] <= 10^17\n      if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  mem[128] = this.address\n                  mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n                  mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n                  mem[196] = 10^14\n                  idx = 0\n                  s = 388\n                  t = 128\n                  while idx < 2:\n                      mem[s] = mem[t + 12 len 20]\n                      idx = idx + 1\n                      s = s + 32\n                      t = t + 32\n                      continue \n                  require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n                  call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                       gas gas_remaining wei\n                      args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                     value eth.balance(this.address) wei\n                       gas 2300 * is_zero(value) wei\n                  uint8(stor4.field_8) = 0\n  if this.address == caller:\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      log Transfer(\n            address from=amount,\n            address to=caller,\n            uint256 value=recipient)\n  else:\n      if 0x98b284d61e45d83014b20432ea266155197452ec == recipient:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          log Transfer(\n                address from=amount,\n                address to=caller,\n                uint256 value=recipient)\n      else:\n          if caller == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if stor2 != stor2 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor2 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor2 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor2 * amount / 100\n              log Transfer(\n                    address from=(stor2 * amount / 100),\n                    address to=caller,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor2 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor2 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor2 * amount / 100)),\n                    address to=caller,\n                    uint256 value=recipient)\n          else:\n              if stor3 != stor3 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor3 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor3 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor3 * amount / 100\n              log Transfer(\n                    address from=(stor3 * amount / 100),\n                    address to=caller,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor3 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor3 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor3 * amount / 100)),\n                    address to=caller,\n                    uint256 value=recipient)\n  return 1\n\ndef transferFrom(address sender, address recipient, uint256 amount): # not payable\n  require calldata.size - 4 >=\u2032 96\n  require sender == sender\n  require recipient == recipient\n  if allowance[address(sender)][caller] - amount > allowance[address(sender)][caller]:\n      revert with 0, 17\n  allowance[address(sender)][caller] -= amount\n  if balanceOf[address(sender)] - amount > balanceOf[address(sender)]:\n      revert with 0, 17\n  balanceOf[address(sender)] -= amount\n  if sender != 0x98b284d61e45d83014b20432ea266155197452ec:\n      require uint8(stor4.field_0)\n  if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n      if not uint8(stor4.field_8):\n          if balanceOf[this.address] >= 10^14:\n              uint8(stor4.field_8) = 1\n              mem[128] = this.address\n              mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n              mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n              mem[196] = 10^14\n              idx = 0\n              s = 388\n              t = 128\n              while idx < 2:\n                  mem[s] = mem[t + 12 len 20]\n                  idx = idx + 1\n                  s = s + 32\n                  t = t + 32\n                  continue \n              require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n              call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                   gas gas_remaining wei\n                  args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n              if not ext_call.success:\n                  revert with ext_call.return_data[0 len return_data.size]\n              call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                 value eth.balance(this.address) wei\n                   gas 2300 * is_zero(value) wei\n              uint8(stor4.field_8) = 0\n  else:\n      if recipient != 0x98b284d61e45d83014b20432ea266155197452ec:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          require amount + balanceOf[address(recipient)] <= 10^17\n      if recipient == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  mem[128] = this.address\n                  mem[160] = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\n                  mem[192] = 0x791ac94700000000000000000000000000000000000000000000000000000000\n                  mem[196] = 10^14\n                  idx = 0\n                  s = 388\n                  t = 128\n                  while idx < 2:\n                      mem[s] = mem[t + 12 len 20]\n                      idx = idx + 1\n                      s = s + 32\n                      t = t + 32\n                      continue \n                  require ext_code.size(0x7a250d5630b4cf539739df2c5dacb4c659f2488d)\n                  call 0x7a250d5630b4cf539739df2c5dacb4c659f2488d.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) with:\n                       gas gas_remaining wei\n                      args 10^14, 0, 160, address(this.address), block.timestamp, 2, mem[388 len 64]\n                  if not ext_call.success:\n                      revert with ext_call.return_data[0 len return_data.size]\n                  call 0x98b284d61e45d83014b20432ea266155197452ec with:\n                     value eth.balance(this.address) wei\n                       gas 2300 * is_zero(value) wei\n                  uint8(stor4.field_8) = 0\n  if this.address == sender:\n      if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n          revert with 0, 17\n      balanceOf[address(recipient)] += amount\n      log Transfer(\n            address from=amount,\n            address to=sender,\n            uint256 value=recipient)\n  else:\n      if 0x98b284d61e45d83014b20432ea266155197452ec == recipient:\n          if balanceOf[address(recipient)] > amount + balanceOf[address(recipient)]:\n              revert with 0, 17\n          balanceOf[address(recipient)] += amount\n          log Transfer(\n                address from=amount,\n                address to=sender,\n                uint256 value=recipient)\n      else:\n          if sender == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if stor2 != stor2 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor2 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor2 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor2 * amount / 100\n              log Transfer(\n                    address from=(stor2 * amount / 100),\n                    address to=sender,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor2 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor2 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor2 * amount / 100)),\n                    address to=sender,\n                    uint256 value=recipient)\n          else:\n              if stor3 != stor3 * amount / amount and amount:\n                  revert with 0, 17\n              if amount - (stor3 * amount / 100) > amount:\n                  revert with 0, 17\n              if balanceOf[this.address] > (stor3 * amount / 100) + balanceOf[this.address]:\n                  revert with 0, 17\n              balanceOf[this.address] += stor3 * amount / 100\n              log Transfer(\n                    address from=(stor3 * amount / 100),\n                    address to=sender,\n                    uint256 value=this.address)\n              if balanceOf[address(recipient)] > amount - (stor3 * amount / 100) + balanceOf[address(recipient)]:\n                  revert with 0, 17\n              balanceOf[address(recipient)] = amount - (stor3 * amount / 100) + balanceOf[address(recipient)]\n              log Transfer(\n                    address from=(amount - (stor3 * amount / 100)),\n                    address to=sender,\n                    uint256 value=recipient)\n  return 1\n\ndef _fallback(?) payable: # default function\n  if calldata.size < 4:\n      require not calldata.size\n      stop\n  if balanceOf(address account) <= uint32(call.func_hash) >> 224:\n      if balanceOf(address account) == uint32(call.func_hash) >> 224:\n          require not call.value\n          require calldata.size - 4 >=\u2032 32\n          require _param1 == address(_param1)\n          return balanceOf[_param1]\n      if symbol() == uint32(call.func_hash) >> 224:\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if uint32(call.func_hash) >> 224 != transfer(address recipient, uint256 amount):\n          if openTrading() == uint32(call.func_hash) >> 224:\n              require not call.value\n              require 0x98b284d61e45d83014b20432ea266155197452ec == caller\n              uint8(stor4.field_0) = 1\n          else:\n              if allowance(address owner, address spender) == uint32(call.func_hash) >> 224:\n                  require not call.value\n                  require calldata.size - 4 >=\u2032 64\n                  require _param1 == address(_param1)\n                  require _param2 == address(_param2)\n                  return allowance[_param1][_param2]\n              require 4016926215 == uint32(call.func_hash) >> 224\n              require not call.value\n              require calldata.size - 4 >=\u2032 64\n              if caller - 0x98b284d61e45d83014b20432ea266155197452ec:\n                  require _param1 < 10\n                  revert\n              stor2 = _param1\n              stor3 = _param2\n          stop\n      require not call.value\n      require calldata.size - 4 >=\u2032 64\n      require _param1 == address(_param1)\n      if balanceOf[caller] - _param2 > balanceOf[caller]:\n          revert with 0, 17\n      balanceOf[caller] -= _param2\n      if caller != 0x98b284d61e45d83014b20432ea266155197452ec:\n          require uint8(stor4.field_0)\n      if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n          if not uint8(stor4.field_8):\n              if balanceOf[this.address] >= 10^14:\n                  uint8(stor4.field_8) = 1\n                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      else:\n          if address(_param1) != 0x98b284d61e45d83014b20432ea266155197452ec:\n              if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n                  revert with 0, 17\n              require _param2 + balanceOf[address(_param1)] <= 10^17\n          if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if not uint8(stor4.field_8):\n                  if balanceOf[this.address] >= 10^14:\n                      uint8(stor4.field_8) = 1\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if this.address == caller:\n          if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n              revert with 0, 17\n          balanceOf[address(_param1)] += _param2\n          log Transfer(\n                address from=_param2,\n                address to=caller,\n                uint256 value=address(_param1))\n      else:\n          if 0x98b284d61e45d83014b20432ea266155197452ec == address(_param1):\n              if balanceOf[address(_param1)] > _param2 + balanceOf[address(_param1)]:\n                  revert with 0, 17\n              balanceOf[address(_param1)] += _param2\n              log Transfer(\n                    address from=_param2,\n                    address to=caller,\n                    uint256 value=address(_param1))\n          else:\n              if caller == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                  if stor2 != stor2 * _param2 / _param2 and _param2:\n                      revert with 0, 17\n                  if _param2 - (stor2 * _param2 / 100) > _param2:\n                      revert with 0, 17\n                  if balanceOf[this.address] > (stor2 * _param2 / 100) + balanceOf[this.address]:\n                      revert with 0, 17\n                  balanceOf[this.address] += stor2 * _param2 / 100\n                  log Transfer(\n                        address from=(stor2 * _param2 / 100),\n                        address to=caller,\n                        uint256 value=this.address)\n                  if balanceOf[address(_param1)] > _param2 - (stor2 * _param2 / 100) + balanceOf[address(_param1)]:\n                      revert with 0, 17\n                  balanceOf[address(_param1)] = _param2 - (stor2 * _param2 / 100) + balanceOf[address(_param1)]\n                  log Transfer(\n                        address from=(_param2 - (stor2 * _param2 / 100)),\n                        address to=caller,\n                        uint256 value=address(_param1))\n              else:\n                  if stor3 != stor3 * _param2 / _param2 and _param2:\n                      revert with 0, 17\n                  if _param2 - (stor3 * _param2 / 100) > _param2:\n                      revert with 0, 17\n                  if balanceOf[this.address] > (stor3 * _param2 / 100) + balanceOf[this.address]:\n                      revert with 0, 17\n                  balanceOf[this.address] += stor3 * _param2 / 100\n                  log Transfer(\n                        address from=(stor3 * _param2 / 100),\n                        address to=caller,\n                        uint256 value=this.address)\n                  if balanceOf[address(_param1)] > _param2 - (stor3 * _param2 / 100) + balanceOf[address(_param1)]:\n                      revert with 0, 17\n                  balanceOf[address(_param1)] = _param2 - (stor3 * _param2 / 100) + balanceOf[address(_param1)]\n                  log Transfer(\n                        address from=(_param2 - (stor3 * _param2 / 100)),\n                        address to=caller,\n                        uint256 value=address(_param1))\n  else:\n      if name() == uint32(call.func_hash) >> 224:\n          require not call.value\n          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n      if approve(address spender, uint256 amount) == uint32(call.func_hash) >> 224:\n          require not call.value\n          require calldata.size - 4 >=\u2032 64\n          require _param1 == address(_param1)\n          allowance[caller][address(_param1)] = _param2\n          log Approval(\n                address owner=_param2,\n                address spender=caller,\n                uint256 value=address(_param1))\n      else:\n          if totalSupply() == uint32(call.func_hash) >> 224:\n              require not call.value\n              return 10^17\n          if uint32(call.func_hash) >> 224 != transferFrom(address sender, address recipient, uint256 amount):\n              require decimals() == uint32(call.func_hash) >> 224\n              require not call.value\n              return 9\n          require not call.value\n          require calldata.size - 4 >=\u2032 96\n          require _param1 == address(_param1)\n          require _param2 == address(_param2)\n          if allowance[address(_param1)][caller] - _param3 > allowance[address(_param1)][caller]:\n              revert with 0, 17\n          allowance[address(_param1)][caller] -= _param3\n          if balanceOf[address(_param1)] - _param3 > balanceOf[address(_param1)]:\n              revert with 0, 17\n          balanceOf[address(_param1)] -= _param3\n          if address(_param1) != 0x98b284d61e45d83014b20432ea266155197452ec:\n              require uint8(stor4.field_0)\n          if address(_param2) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n              if not uint8(stor4.field_8):\n                  if balanceOf[this.address] >= 10^14:\n                      uint8(stor4.field_8) = 1\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          else:\n              if address(_param2) != 0x98b284d61e45d83014b20432ea266155197452ec:\n                  if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                      revert with 0, 17\n                  require _param3 + balanceOf[address(_param2)] <= 10^17\n              if address(_param2) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                  if not uint8(stor4.field_8):\n                      if balanceOf[this.address] >= 10^14:\n                          uint8(stor4.field_8) = 1\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n          if this.address == address(_param1):\n              if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                  revert with 0, 17\n              balanceOf[address(_param2)] += _param3\n              log Transfer(\n                    address from=_param3,\n                    address to=address(_param1),\n                    uint256 value=address(_param2))\n          else:\n              if 0x98b284d61e45d83014b20432ea266155197452ec == address(_param2):\n                  if balanceOf[address(_param2)] > _param3 + balanceOf[address(_param2)]:\n                      revert with 0, 17\n                  balanceOf[address(_param2)] += _param3\n                  log Transfer(\n                        address from=_param3,\n                        address to=address(_param1),\n                        uint256 value=address(_param2))\n              else:\n                  if address(_param1) == 0x30b1e0e276ed8db10ffd01e4f26db9c9faddf959:\n                      if stor2 != stor2 * _param3 / _param3 and _param3:\n                          revert with 0, 17\n                      if _param3 - (stor2 * _param3 / 100) > _param3:\n                          revert with 0, 17\n                      if balanceOf[this.address] > (stor2 * _param3 / 100) + balanceOf[this.address]:\n                          revert with 0, 17\n                      balanceOf[this.address] += stor2 * _param3 / 100\n                      log Transfer(\n                            address from=(stor2 * _param3 / 100),\n                            address to=address(_param1),\n                            uint256 value=this.address)\n                      if balanceOf[address(_param2)] > _param3 - (stor2 * _param3 / 100) + balanceOf[address(_param2)]:\n                          revert with 0, 17\n                      balanceOf[address(_param2)] = _param3 - (stor2 * _param3 / 100) + balanceOf[address(_param2)]\n                      log Transfer(\n                            address from=(_param3 - (stor2 * _param3 / 100)),\n                            address to=address(_param1),\n                            uint256 value=address(_param2))\n                  else:\n                      if stor3 != stor3 * _param3 / _param3 and _param3:\n                          revert with 0, 17\n                      if _param3 - (stor3 * _param3 / 100) > _param3:\n                          revert with 0, 17\n                      if balanceOf[this.address] > (stor3 * _param3 / 100) + balanceOf[this.address]:\n                          revert with 0, 17\n                      balanceOf[this.address] += stor3 * _param3 / 100\n                      log Transfer(\n                            address from=(stor3 * _param3 / 100),\n                            address to=address(_param1),\n                            uint256 value=this.address)\n                      if balanceOf[address(_param2)] > _param3 - (stor3 * _param3 / 100) + balanceOf[address(_param2)]:\n                          revert with 0, 17\n                      balanceOf[address(_param2)] = _param3 - (stor3 * _param3 / 100) + balanceOf[address(_param2)]\n                      log Transfer(\n                            address from=(_param3 - (stor3 * _param3 / 100)),\n                            address to=address(_param1),\n                            uint256 value=address(_param2))\n  return 1\n\n.",
	"status": "1",
	"time_cost": 20.744487524032593,
	"usage": {
		"completion_tokens": 498,
		"prompt_tokens": 6922,
		"total_tokens": 7420
	}
}