{
	"address": "0xf1adc3c1cfd4181312185d9ef3fbe3ce1a7cde4e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code for the decompiled EVM bytecode given:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity 0.5.11;\n\ncontract MyToken {\n    uint256[] private _name;\n    uint256[] private _symbol;\n    mapping (uint256 => uint256[]) private _balanceOf;\n    mapping (uint256 => uint256[]) private _allowance;\n    uint256 private _totalSupply;\n    uint256 private _totalDead;\n    uint256 private stor_7;\n    uint8 private _decimals;\n    address private _withdrawSparkle;\n    address private _buySparkle;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function _SafeSub(uint256 varg0, uint256 varg1) private pure returns (uint256) { ... }\n    function _0x175f(uint256 varg0, uint256 varg1) private pure returns (uint256) { ... }\n    function _SafeDiv(uint256 varg0, uint256 varg1) private pure returns (uint256) { ... }\n    function _0x18b7() private { ... }\n    function approve(address varg0, uint256 varg1) public returns (bool) { ... }\n    function _0x18e7(uint256 varg0, uint256 varg1, uint256 varg2) private { ... }\n    function _0x1ade(uint256 varg0, uint256 varg1, uint256 varg2) private { ... }\n    function totalSupply() public view returns (uint256) { ... }\n    function transferFrom(address varg0, address varg1, uint256 varg2) public returns (bool) { ... }\n    function decimals() public view returns (uint8) { ... }\n    function increaseAllowance(address varg0, uint256 varg1) public returns (bool) { ... }\n    function mintDeth() public payable { ... }\n    function balanceOf(address varg0) public view returns (uint256) { ... }\n    function withdrawSparkle(uint256 varg0) public { ... }\n    function symbol() public view returns (string memory) { ... }\n    function decreaseAllowance(address varg0, uint256 varg1) public returns (bool) { ... }\n    function transfer(address varg0, uint256 varg1) public returns (bool) { ... }\n    function allowance(address varg0, address varg1) public view returns (uint256) { ... }\n    function sellSparkle(uint256 varg0) public { ... }\n    function totalDead() public view returns (uint256) { ... }\n    function buySparkle() public { ... }\n    function _0x6e5() private { ... }\n    function fallback() public payable { ... }\n    function name() public view returns (string memory) { ... }\n}\n```\nThis is just a template and the body of the functions needs to be filled based on the logic in the decompiled code. Also, please note that the visibility and return type of functions might need to be adjusted according to the actual implementation.",
				"role": "assistant"
			}
		}
	],
	"created": 1701463335,
	"id": "chatcmpl-8R4cxKh85RGkNvan4Xu0Cx07IN1yA",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 05:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalDead; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _withdrawSparkle; // STORAGE[0x8] bytes 0 to 19\naddress _buySparkle; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x175f(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (26) {\n            MEM[v0.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x18b7() private { \n    MEM[(MEM[64]) len 111] = 0x6080604052348015600f57600080fd5b50605280601d6000396000f3fe60806040523073ffffffffffffffffffffffffffffffffffffffff16fffea265627a7a72315820607e50910aa817fcbb2f830a5681d6208e6c1542b6b6dd4928096230f0d7551564736f6c634300050b0032;\n    v0 = create.code(MEM[64], 111).value(0);\n    require(v0); // checks call status, propagates error data on error\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x18e7(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction 0x18e7(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, 'ERC20: approve from the zero address');\n    require(address(varg1) != 0, 'ERC20: approve to the zero address');\n    v0 = address(varg2);\n    v1 = address(varg1);\n    _allowance[v1] = varg0;\n    emit Approval(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction 0x1ade(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, 'ERC20: transfer from the zero address');\n    require(address(varg1) != 0, 'ERC20: transfer to the zero address');\n    v0 = address(varg2);\n    v1 = _SafeSub(varg0, _balanceOf[v0]);\n    v2 = address(varg2);\n    _balanceOf[v2] = v1;\n    v3 = address(varg1);\n    v4 = _balanceOf[v3] + varg0;\n    require(v4 >= _balanceOf[v3], 'SafeMath: addition overflow');\n    v5 = address(varg1);\n    _balanceOf[v5] = v4;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    0x1ade(varg2, varg1, varg0);\n    v0 = _SafeSub(varg2, _allowance[msg.sender]);\n    0x18e7(v0, msg.sender, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_allowance[varg0] + varg1 >= _allowance[varg0], 'SafeMath: addition overflow');\n    0x18e7(_allowance[varg0] + varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction mintDeth() public payable { \n    v0 = 0x6e5();\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction withdrawSparkle(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    require(_buySparkle.code.size);\n    v0, v1 = _buySparkle.transfer(_withdrawSparkle, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return 1;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = _SafeSub(varg1, _allowance[varg0]);\n    0x18e7(v0, varg0, msg.sender);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x1ade(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sellSparkle(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    require(_buySparkle.code.size);\n    v0, v1 = _buySparkle.sellSparkle(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _withdrawSparkle.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction totalDead() public nonPayable { \n    return _totalDead;\n}\n\nfunction buySparkle() public nonPayable { \n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    v0 = _SafeDiv(0x5af3107a4000, (address(this)).balance);\n    require(_buySparkle.code.size);\n    v1, v2 = _buySparkle.totalSupply().gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2 + v0 >= v2, 'SafeMath: addition overflow');\n    if (0x14adf4b7320334b90000000 < v2 + v0) {\n        v3 = _withdrawSparkle.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v3); // checks call status, propagates error data on error\n        v4 = 1;\n    } else {\n        v5, v6 = _buySparkle.call().value((address(this)).balance).gas(0x1d4c0);\n        if (RETURNDATASIZE() != 0) {\n            v7 = new bytes[](RETURNDATASIZE());\n            v6 = v7.data;\n            RETURNDATACOPY(v6, 0, RETURNDATASIZE());\n        }\n        v4 = v8 = 1;\n    }\n    return v4;\n}\n\nfunction 0x6e5() private { \n    require(msg.value > 0x2386f26fc10000, 'Insufficient deposit. Minimum mint is .01 eth');\n    if (msg.value < 0x29a2241af62c0000) {\n        v0 = _SafeSub(0x2386f26fc10000, msg.value);\n        require(stor_7 + 1000 >= stor_7, 'SafeMath: addition overflow');\n        v1 = _SafeDiv(stor_7 + 1000, v0);\n        v2 = 0x175f(1000, v1);\n        require(stor_7 + 1 >= stor_7, 'SafeMath: addition overflow');\n        stor_7 = stor_7 + 1;\n        v3 = 0x18b7();\n        v4, v5 = address(v3).call().value(v2).gas(25000);\n        if (RETURNDATASIZE() != 0) {\n            v6 = new bytes[](RETURNDATASIZE());\n            v5 = v6.data;\n            RETURNDATACOPY(v5, 0, RETURNDATASIZE());\n        }\n        require(_balanceOf[msg.sender] + v2 >= _balanceOf[msg.sender], 'SafeMath: addition overflow');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + v2;\n        require(_totalSupply + v2 >= _totalSupply, 'SafeMath: addition overflow');\n        _totalSupply = _totalSupply + v2;\n        require(_totalDead + v0 >= _totalDead, 'SafeMath: addition overflow');\n        _totalDead = _totalDead + v0;\n        emit Transfer(0, msg.sender, v2);\n        v7 = v8 = 1;\n    } else {\n        v9 = _SafeSub(0x2386f26fc10000, msg.value);\n        v10 = 0x175f(13, v9);\n        v11 = _SafeDiv(10, v10);\n        require(stor_7 + 1000 >= stor_7, 'SafeMath: addition overflow');\n        v12 = _SafeDiv(stor_7 + 1000, v11);\n        v13 = 0x175f(1000, v12);\n        require(stor_7 + 1 >= stor_7, 'SafeMath: addition overflow');\n        stor_7 = stor_7 + 1;\n        v14 = 0x18b7();\n        v15, v16 = address(v14).call().value(v13).gas(25000);\n        if (RETURNDATASIZE() != 0) {\n            v17 = new bytes[](RETURNDATASIZE());\n            v16 = v17.data;\n            RETURNDATACOPY(v16, 0, RETURNDATASIZE());\n        }\n        require(_balanceOf[msg.sender] + v13 >= _balanceOf[msg.sender], 'SafeMath: addition overflow');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + v13;\n        require(_totalSupply + v13 >= _totalSupply, 'SafeMath: addition overflow');\n        _totalSupply = _totalSupply + v13;\n        require(_totalDead + v9 >= _totalDead, 'SafeMath: addition overflow');\n        _totalDead = _totalDead + v9;\n        emit Transfer(0, msg.sender, v13);\n        v7 = v18 = 1;\n    }\n    return v7;\n}\n\nfunction fallback() public payable { \n    v0 = 0x6e5();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x77370a46 > function_selector >> 224) {\n            if (0x313ce567 > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector >> 224) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x39509351 == function_selector >> 224) {\n                increaseAllowance(address,uint256);\n            } else if (0x61555a77 == function_selector >> 224) {\n                mintDeth();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xdd62ed3e > function_selector >> 224) {\n            if (0x77370a46 == function_selector >> 224) {\n                withdrawSparkle(uint256);\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa457c2d7 == function_selector >> 224) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa9059cbb == function_selector >> 224) {\n                transfer(address,uint256);\n            }\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe1ee4e4e == function_selector >> 224) {\n            sellSparkle(uint256);\n        } else if (0xf2167f41 == function_selector >> 224) {\n            totalDead();\n        } else if (0xfebd7358 == function_selector >> 224) {\n            buySparkle();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 05:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalDead; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _withdrawSparkle; // STORAGE[0x8] bytes 0 to 19\naddress _buySparkle; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x175f(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (26) {\n            MEM[v0.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x18b7() private { \n    MEM[(MEM[64]) len 111] = 0x6080604052348015600f57600080fd5b50605280601d6000396000f3fe60806040523073ffffffffffffffffffffffffffffffffffffffff16fffea265627a7a72315820607e50910aa817fcbb2f830a5681d6208e6c1542b6b6dd4928096230f0d7551564736f6c634300050b0032;\n    v0 = create.code(MEM[64], 111).value(0);\n    require(v0); // checks call status, propagates error data on error\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x18e7(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction 0x18e7(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, 'ERC20: approve from the zero address');\n    require(address(varg1) != 0, 'ERC20: approve to the zero address');\n    v0 = address(varg2);\n    v1 = address(varg1);\n    _allowance[v1] = varg0;\n    emit Approval(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction 0x1ade(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, 'ERC20: transfer from the zero address');\n    require(address(varg1) != 0, 'ERC20: transfer to the zero address');\n    v0 = address(varg2);\n    v1 = _SafeSub(varg0, _balanceOf[v0]);\n    v2 = address(varg2);\n    _balanceOf[v2] = v1;\n    v3 = address(varg1);\n    v4 = _balanceOf[v3] + varg0;\n    require(v4 >= _balanceOf[v3], 'SafeMath: addition overflow');\n    v5 = address(varg1);\n    _balanceOf[v5] = v4;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    0x1ade(varg2, varg1, varg0);\n    v0 = _SafeSub(varg2, _allowance[msg.sender]);\n    0x18e7(v0, msg.sender, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_allowance[varg0] + varg1 >= _allowance[varg0], 'SafeMath: addition overflow');\n    0x18e7(_allowance[varg0] + varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction mintDeth() public payable { \n    v0 = 0x6e5();\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction withdrawSparkle(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    require(_buySparkle.code.size);\n    v0, v1 = _buySparkle.transfer(_withdrawSparkle, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return 1;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = _SafeSub(varg1, _allowance[varg0]);\n    0x18e7(v0, varg0, msg.sender);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x1ade(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sellSparkle(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    require(_buySparkle.code.size);\n    v0, v1 = _buySparkle.sellSparkle(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _withdrawSparkle.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction totalDead() public nonPayable { \n    return _totalDead;\n}\n\nfunction buySparkle() public nonPayable { \n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    v0 = _SafeDiv(0x5af3107a4000, (address(this)).balance);\n    require(_buySparkle.code.size);\n    v1, v2 = _buySparkle.totalSupply().gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2 + v0 >= v2, 'SafeMath: addition overflow');\n    if (0x14adf4b7320334b90000000 < v2 + v0) {\n        v3 = _withdrawSparkle.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v3); // checks call status, propagates error data on error\n        v4 = 1;\n    } else {\n        v5, v6 = _buySparkle.call().value((address(this)).balance).gas(0x1d4c0);\n        if (RETURNDATASIZE() != 0) {\n            v7 = new bytes[](RETURNDATASIZE());\n            v6 = v7.data;\n            RETURNDATACOPY(v6, 0, RETURNDATASIZE());\n        }\n        v4 = v8 = 1;\n    }\n    return v4;\n}\n\nfunction 0x6e5() private { \n    require(msg.value > 0x2386f26fc10000, 'Insufficient deposit. Minimum mint is .01 eth');\n    if (msg.value < 0x29a2241af62c0000) {\n        v0 = _SafeSub(0x2386f26fc10000, msg.value);\n        require(stor_7 + 1000 >= stor_7, 'SafeMath: addition overflow');\n        v1 = _SafeDiv(stor_7 + 1000, v0);\n        v2 = 0x175f(1000, v1);\n        require(stor_7 + 1 >= stor_7, 'SafeMath: addition overflow');\n        stor_7 = stor_7 + 1;\n        v3 = 0x18b7();\n        v4, v5 = address(v3).call().value(v2).gas(25000);\n        if (RETURNDATASIZE() != 0) {\n            v6 = new bytes[](RETURNDATASIZE());\n            v5 = v6.data;\n            RETURNDATACOPY(v5, 0, RETURNDATASIZE());\n        }\n        require(_balanceOf[msg.sender] + v2 >= _balanceOf[msg.sender], 'SafeMath: addition overflow');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + v2;\n        require(_totalSupply + v2 >= _totalSupply, 'SafeMath: addition overflow');\n        _totalSupply = _totalSupply + v2;\n        require(_totalDead + v0 >= _totalDead, 'SafeMath: addition overflow');\n        _totalDead = _totalDead + v0;\n        emit Transfer(0, msg.sender, v2);\n        v7 = v8 = 1;\n    } else {\n        v9 = _SafeSub(0x2386f26fc10000, msg.value);\n        v10 = 0x175f(13, v9);\n        v11 = _SafeDiv(10, v10);\n        require(stor_7 + 1000 >= stor_7, 'SafeMath: addition overflow');\n        v12 = _SafeDiv(stor_7 + 1000, v11);\n        v13 = 0x175f(1000, v12);\n        require(stor_7 + 1 >= stor_7, 'SafeMath: addition overflow');\n        stor_7 = stor_7 + 1;\n        v14 = 0x18b7();\n        v15, v16 = address(v14).call().value(v13).gas(25000);\n        if (RETURNDATASIZE() != 0) {\n            v17 = new bytes[](RETURNDATASIZE());\n            v16 = v17.data;\n            RETURNDATACOPY(v16, 0, RETURNDATASIZE());\n        }\n        require(_balanceOf[msg.sender] + v13 >= _balanceOf[msg.sender], 'SafeMath: addition overflow');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + v13;\n        require(_totalSupply + v13 >= _totalSupply, 'SafeMath: addition overflow');\n        _totalSupply = _totalSupply + v13;\n        require(_totalDead + v9 >= _totalDead, 'SafeMath: addition overflow');\n        _totalDead = _totalDead + v9;\n        emit Transfer(0, msg.sender, v13);\n        v7 = v18 = 1;\n    }\n    return v7;\n}\n\nfunction fallback() public payable { \n    v0 = 0x6e5();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x77370a46 > function_selector >> 224) {\n            if (0x313ce567 > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector >> 224) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x39509351 == function_selector >> 224) {\n                increaseAllowance(address,uint256);\n            } else if (0x61555a77 == function_selector >> 224) {\n                mintDeth();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xdd62ed3e > function_selector >> 224) {\n            if (0x77370a46 == function_selector >> 224) {\n                withdrawSparkle(uint256);\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa457c2d7 == function_selector >> 224) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa9059cbb == function_selector >> 224) {\n                transfer(address,uint256);\n            }\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe1ee4e4e == function_selector >> 224) {\n            sellSparkle(uint256);\n        } else if (0xf2167f41 == function_selector >> 224) {\n            totalDead();\n        } else if (0xfebd7358 == function_selector >> 224) {\n            buySparkle();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 05:55 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x4]\nuint256 _totalSupply; // STORAGE[0x5]\nuint256 _totalDead; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _withdrawSparkle; // STORAGE[0x8] bytes 0 to 19\naddress _buySparkle; // STORAGE[0x9] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nApproval(address, address, uint256);\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    if (varg0 <= varg1) {\n        return varg1 - varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (30) {\n            MEM[v0.data] = ~0xffff & 'SafeMath: subtraction overflow';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x175f(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        require(v1 / varg1 == varg0, 'SafeMath: multiplication overflow');\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    if (varg0 > 0) {\n        assert(varg0);\n        return varg1 / varg0;\n    } else {\n        v0 = new array[](v1.length);\n        v2 = v3 = 0;\n        while (v2 < v1.length) {\n            MEM[v0.data + v2] = MEM[v1.data + v2];\n            v2 = v2 + 32;\n        }\n        if (26) {\n            MEM[v0.data] = ~0xffffffffffff & 'SafeMath: division by zero';\n        }\n        revert(v0);\n    }\n}\n\nfunction 0x18b7() private { \n    MEM[(MEM[64]) len 111] = 0x6080604052348015600f57600080fd5b50605280601d6000396000f3fe60806040523073ffffffffffffffffffffffffffffffffffffffff16fffea265627a7a72315820607e50910aa817fcbb2f830a5681d6208e6c1542b6b6dd4928096230f0d7551564736f6c634300050b0032;\n    v0 = create.code(MEM[64], 111).value(0);\n    require(v0); // checks call status, propagates error data on error\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x18e7(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction 0x18e7(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, 'ERC20: approve from the zero address');\n    require(address(varg1) != 0, 'ERC20: approve to the zero address');\n    v0 = address(varg2);\n    v1 = address(varg1);\n    _allowance[v1] = varg0;\n    emit Approval(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction 0x1ade(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg2) != 0, 'ERC20: transfer from the zero address');\n    require(address(varg1) != 0, 'ERC20: transfer to the zero address');\n    v0 = address(varg2);\n    v1 = _SafeSub(varg0, _balanceOf[v0]);\n    v2 = address(varg2);\n    _balanceOf[v2] = v1;\n    v3 = address(varg1);\n    v4 = _balanceOf[v3] + varg0;\n    require(v4 >= _balanceOf[v3], 'SafeMath: addition overflow');\n    v5 = address(varg1);\n    _balanceOf[v5] = v4;\n    emit Transfer(address(varg2), address(varg1), varg0);\n    return ;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    0x1ade(varg2, varg1, varg0);\n    v0 = _SafeSub(varg2, _allowance[msg.sender]);\n    0x18e7(v0, msg.sender, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction increaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_allowance[varg0] + varg1 >= _allowance[varg0], 'SafeMath: addition overflow');\n    0x18e7(_allowance[varg0] + varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction mintDeth() public payable { \n    v0 = 0x6e5();\n    return v0;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    return _balanceOf[varg0];\n}\n\nfunction withdrawSparkle(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    require(_buySparkle.code.size);\n    v0, v1 = _buySparkle.transfer(_withdrawSparkle, varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return 1;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction decreaseAllowance(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    v0 = _SafeSub(varg1, _allowance[varg0]);\n    0x18e7(v0, varg0, msg.sender);\n    return 1;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    0x1ade(varg1, varg0, msg.sender);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    return _allowance[varg1];\n}\n\nfunction sellSparkle(uint256 varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    require(_buySparkle.code.size);\n    v0, v1 = _buySparkle.sellSparkle(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    v2 = _withdrawSparkle.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v2); // checks call status, propagates error data on error\n    return 1;\n}\n\nfunction totalDead() public nonPayable { \n    return _totalDead;\n}\n\nfunction buySparkle() public nonPayable { \n    require(msg.sender == _withdrawSparkle, 'Access denied.');\n    v0 = _SafeDiv(0x5af3107a4000, (address(this)).balance);\n    require(_buySparkle.code.size);\n    v1, v2 = _buySparkle.totalSupply().gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(v2 + v0 >= v2, 'SafeMath: addition overflow');\n    if (0x14adf4b7320334b90000000 < v2 + v0) {\n        v3 = _withdrawSparkle.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n        require(v3); // checks call status, propagates error data on error\n        v4 = 1;\n    } else {\n        v5, v6 = _buySparkle.call().value((address(this)).balance).gas(0x1d4c0);\n        if (RETURNDATASIZE() != 0) {\n            v7 = new bytes[](RETURNDATASIZE());\n            v6 = v7.data;\n            RETURNDATACOPY(v6, 0, RETURNDATASIZE());\n        }\n        v4 = v8 = 1;\n    }\n    return v4;\n}\n\nfunction 0x6e5() private { \n    require(msg.value > 0x2386f26fc10000, 'Insufficient deposit. Minimum mint is .01 eth');\n    if (msg.value < 0x29a2241af62c0000) {\n        v0 = _SafeSub(0x2386f26fc10000, msg.value);\n        require(stor_7 + 1000 >= stor_7, 'SafeMath: addition overflow');\n        v1 = _SafeDiv(stor_7 + 1000, v0);\n        v2 = 0x175f(1000, v1);\n        require(stor_7 + 1 >= stor_7, 'SafeMath: addition overflow');\n        stor_7 = stor_7 + 1;\n        v3 = 0x18b7();\n        v4, v5 = address(v3).call().value(v2).gas(25000);\n        if (RETURNDATASIZE() != 0) {\n            v6 = new bytes[](RETURNDATASIZE());\n            v5 = v6.data;\n            RETURNDATACOPY(v5, 0, RETURNDATASIZE());\n        }\n        require(_balanceOf[msg.sender] + v2 >= _balanceOf[msg.sender], 'SafeMath: addition overflow');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + v2;\n        require(_totalSupply + v2 >= _totalSupply, 'SafeMath: addition overflow');\n        _totalSupply = _totalSupply + v2;\n        require(_totalDead + v0 >= _totalDead, 'SafeMath: addition overflow');\n        _totalDead = _totalDead + v0;\n        emit Transfer(0, msg.sender, v2);\n        v7 = v8 = 1;\n    } else {\n        v9 = _SafeSub(0x2386f26fc10000, msg.value);\n        v10 = 0x175f(13, v9);\n        v11 = _SafeDiv(10, v10);\n        require(stor_7 + 1000 >= stor_7, 'SafeMath: addition overflow');\n        v12 = _SafeDiv(stor_7 + 1000, v11);\n        v13 = 0x175f(1000, v12);\n        require(stor_7 + 1 >= stor_7, 'SafeMath: addition overflow');\n        stor_7 = stor_7 + 1;\n        v14 = 0x18b7();\n        v15, v16 = address(v14).call().value(v13).gas(25000);\n        if (RETURNDATASIZE() != 0) {\n            v17 = new bytes[](RETURNDATASIZE());\n            v16 = v17.data;\n            RETURNDATACOPY(v16, 0, RETURNDATASIZE());\n        }\n        require(_balanceOf[msg.sender] + v13 >= _balanceOf[msg.sender], 'SafeMath: addition overflow');\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] + v13;\n        require(_totalSupply + v13 >= _totalSupply, 'SafeMath: addition overflow');\n        _totalSupply = _totalSupply + v13;\n        require(_totalDead + v9 >= _totalDead, 'SafeMath: addition overflow');\n        _totalDead = _totalDead + v9;\n        emit Transfer(0, msg.sender, v13);\n        v7 = v18 = 1;\n    }\n    return v7;\n}\n\nfunction fallback() public payable { \n    v0 = 0x6e5();\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x77370a46 > function_selector >> 224) {\n            if (0x313ce567 > function_selector >> 224) {\n                if (0x6fdde03 == function_selector >> 224) {\n                    name();\n                } else if (0x95ea7b3 == function_selector >> 224) {\n                    approve(address,uint256);\n                } else if (0x18160ddd == function_selector >> 224) {\n                    totalSupply();\n                } else if (0x23b872dd == function_selector >> 224) {\n                    transferFrom(address,address,uint256);\n                }\n            } else if (0x313ce567 == function_selector >> 224) {\n                decimals();\n            } else if (0x39509351 == function_selector >> 224) {\n                increaseAllowance(address,uint256);\n            } else if (0x61555a77 == function_selector >> 224) {\n                mintDeth();\n            } else if (0x70a08231 == function_selector >> 224) {\n                balanceOf(address);\n            }\n        } else if (0xdd62ed3e > function_selector >> 224) {\n            if (0x77370a46 == function_selector >> 224) {\n                withdrawSparkle(uint256);\n            } else if (0x95d89b41 == function_selector >> 224) {\n                symbol();\n            } else if (0xa457c2d7 == function_selector >> 224) {\n                decreaseAllowance(address,uint256);\n            } else if (0xa9059cbb == function_selector >> 224) {\n                transfer(address,uint256);\n            }\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        } else if (0xe1ee4e4e == function_selector >> 224) {\n            sellSparkle(uint256);\n        } else if (0xf2167f41 == function_selector >> 224) {\n            totalDead();\n        } else if (0xfebd7358 == function_selector >> 224) {\n            buySparkle();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 28.408448457717896,
	"usage": {
		"completion_tokens": 675,
		"prompt_tokens": 4065,
		"total_tokens": 4740
	}
}