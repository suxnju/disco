{
	"address": "0x4c854e15c2acbe3a505dc33eb6b72b8fc8a0ff00",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Sure, here's a rough approximation in Solidity based on the decompiled code you provided:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract RecoveryAddress {\n    struct RecoveryInfo {\n        uint256 recoveryDelayInDays;\n        address recoveryAddress;\n    }\n\n    mapping (address => RecoveryInfo) public recoveryMap;\n    address public owner;\n    address public activeRecoveryAddress;\n    uint256 public activeRecoveryEndTime;\n\n    event RecoveryAddressAdded(address newRecoveryAddress, uint16 recoveryDelayInDays);\n    event RecoveryAddressRemoved(address oldRecoveryAddress);\n    event RecoveryStarted(address recoveryAddress);\n    event RecoveryCancelled(address recoveryAddress);\n    event RecoveryFinished(address oldOwner, address newOwner);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function addRecoveryAddress(address _newRecoveryAddress, uint16 _recoveryDelayInDays) public onlyOwner {\n        recoveryMap[_newRecoveryAddress] = RecoveryInfo(_recoveryDelayInDays, _newRecoveryAddress);\n        emit RecoveryAddressAdded(_newRecoveryAddress, _recoveryDelayInDays);\n    }\n\n    function removeRecoveryAddress(address _oldRecoveryAddress) public onlyOwner {\n        delete recoveryMap[_oldRecoveryAddress];\n        emit RecoveryAddressRemoved(_oldRecoveryAddress);\n    }\n\n    function startRecovery(address recoverer) public {\n        require(recoveryMap[recoverer].recoveryAddress == recoverer, \"Invalid recovery address\");\n        activeRecoveryAddress = recoverer;\n        activeRecoveryEndTime = block.timestamp + recoveryMap[recoverer].recoveryDelayInDays * 1 days;\n        emit RecoveryStarted(recoverer);\n    }\n\n    function cancelRecovery() public onlyOwner {\n        emit RecoveryCancelled(activeRecoveryAddress);\n        activeRecoveryAddress = address(0);\n        activeRecoveryEndTime = 0;\n    }\n\n    function finishRecovery() public {\n        require(block.timestamp >= activeRecoveryEndTime, \"Recovery period not yet ended\");\n        address oldOwner = owner;\n        owner = activeRecoveryAddress;\n        activeRecoveryAddress = address(0);\n        activeRecoveryEndTime = 0;\n        emit RecoveryFinished(oldOwner, owner);\n    }\n}\n```\nPlease note that the decompiled code you provided is hard to translate directly to Solidity as there are some parts that are not clear (like the use of `v0`, `v1`, `v2` etc variables). The Solidity code I provided is a rough approximation and may not cover all cases or mimic the exact behavior of your decompiled EVM bytecode.",
				"role": "assistant"
			}
		}
	],
	"created": 1698038611,
	"id": "chatcmpl-8ChhTNJ3hcmCV4zQcsC0k0uamlQUF",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.14 11:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nuint256[] array_2; // STORAGE[0x2]\nuint256 stor_4; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress stor_3_0_19; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction cancelRecovery() public nonPayable { \n    0x2bb();\n}\n\nfunction canImplementInterfaceForAddress(bytes32 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 == varg1);\n    v0 = v1 = this == varg1;\n    if (v1) {\n        v0 = varg0 == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        v2 = v4 = 0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4;\n    }\n    return v2;\n}\n\nfunction getRecoveryDelayInDays(address recoverer) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(recoverer == recoverer);\n    require(owner_1[recoverer], 'Provided key was not in the map.', 'Provided key was not in the map.');\n    assert(owner_1[recoverer] < array_2.length);\n    return uint16(array_2[owner_1[recoverer]] >> 160);\n}\n\nfunction fallback() public payable { \n}\n\nfunction addRecoveryAddress(address _newRecoveryAddress, uint16 _recoveryDelayInDays) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_newRecoveryAddress == _newRecoveryAddress);\n    require(_recoveryDelayInDays == _recoveryDelayInDays);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (_newRecoveryAddress) {\n                if (owner_1[_newRecoveryAddress]) {\n                    assert(owner_1[_newRecoveryAddress] < array_2.length);\n                    STORAGE[0 + (keccak256(2) + owner_1[_newRecoveryAddress])] = _recoveryDelayInDays << 160 | ~0xffff0000000000000000000000000000000000000000 & STORAGE[0 + (keccak256(2) + owner_1[_newRecoveryAddress])];\n                } else {\n                    MEM[MEM[64]] = 0;\n                    MEM[MEM[64] + 32] = 0;\n                    array_2.length = array_2.length + 1;\n                    array_2[array_2.length] = (array_2[array_2.length] & ~0xffffffffffffffffffffffffffffffffffffffff | _newRecoveryAddress) & ~0xffff0000000000000000000000000000000000000000 | _recoveryDelayInDays << 160;\n                    owner_1[2] = ~0 + array_2.length;\n                }\n                assert(owner_1[_newRecoveryAddress] < array_2.length);\n                if (address(array_2[owner_1[_newRecoveryAddress]]) == _newRecoveryAddress) {\n                    assert(owner_1[_newRecoveryAddress] < array_2.length);\n                    if (uint16(array_2[owner_1[_newRecoveryAddress]] >> 160) == _recoveryDelayInDays) {\n                        emit 0xca4ba7fe9344a8a1e34b14f051473d2b4b02dd480025f14df8f6fa70c7950cab(_newRecoveryAddress, _recoveryDelayInDays);\n                        exit;\n                    }\n                }\n                revert('Value at inserted location does not match inserted value.');\n            } else {\n                goto 0x2e50x191;\n            }\n        } else {\n            goto 0x2e50x191;\n        }\n    }\n    revert('Recovery address must be supplied.');\n}\n\nfunction removeRecoveryAddress(address _oldRecoveryAddress) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_oldRecoveryAddress == _oldRecoveryAddress);\n    0x4b3(_oldRecoveryAddress);\n}\n\nfunction activeRecoveryEndTime() public nonPayable { \n    return stor_4;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction startRecovery() public nonPayable { \n    if (owner_1[msg.sender]) {\n        require(owner_1[msg.sender], 'Provided key was not in the map.', 'Provided key was not in the map.');\n        assert(owner_1[msg.sender] < array_2.length);\n        if (stor_3_0_19) {\n            require(owner_1[stor_3_0_19], 'Provided key was not in the map.', 'Provided key was not in the map.');\n            assert(owner_1[stor_3_0_19] < array_2.length);\n            if (uint16(array_2[owner_1[msg.sender]] >> 160) < uint16(array_2[owner_1[stor_3_0_19]] >> 160)) {\n                emit 0x8154b6c5e1fc90d44b49808ef93f9739148d0821411890f8cd684385e24b9f1e(stor_3_0_19);\n            }\n        }\n        stor_3_0_19 = msg.sender;\n        stor_4 = (uint16(array_2[owner_1[msg.sender]] >> 160) * 0x15180 & 0xffffff) + block.timestamp;\n        emit 0xcd4e9df2b0a742bc5628c20baf55859f839c034aa76a32f600d6b085c4de4829(msg.sender);\n        exit;\n    }\n    revert(\"Recovery is already under way and new recoverer doesn't have a higher priority.\");\n}\n\nfunction listRecoverers() public nonPayable { \n    v0 = v1 = array_2.length - 1;\n    v2 = new uint256[](v1);\n    if (v1) {\n        v3 = v2.data;\n        do {\n            MEM[MEM[64]] = 0;\n            MEM[MEM[64] + 32] = 0;\n            MEM[v3] = MEM[64];\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v4 = v5 = 1;\n    while (v4 < array_2.length) {\n        assert(v4 < array_2.length);\n        MEM[MEM[64]] = address(array_2[v4]);\n        MEM[MEM[64] + 32] = uint16(array_2[v4] >> 160);\n        assert(v4 + ~0 < v2.length);\n        v2[v4 + ~0] = MEM[64];\n        v4 += 1;\n    }\n    v6 = new array[](v2.length);\n    v7 = v8 = 0;\n    v9 = v10 = v6.data;\n    v11 = v12 = v2.data;\n    while (v7 < v2.length) {\n        MEM[v9] = address(MEM[MEM[v11]]);\n        MEM[v9 + 32] = uint16(MEM[32 + MEM[v11]]);\n        v9 += 64;\n        v11 += 32;\n        v7 += 1;\n    }\n    return v6;\n}\n\nfunction activeRecoveryAddress() public nonPayable { \n    return stor_3_0_19;\n}\n\nfunction execute(address varg0, uint256 varg1, bytes varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg2 <= 0xffffffffffffffff);\n    require(4 + varg2 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg2 + (?).length + 32 <= msg.data.length);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (varg0) {\n                if (this.balance >= varg1) {\n                    MEM[(?).length + MEM[64]] = 0;\n                    v0, v1 = varg0.call(MEM[(MEM[64]) len ((?).length + MEM[64] - MEM[64])], MEM[(MEM[64]) len 0]).value(varg1).gas(msg.gas);\n                    if (RETURNDATASIZE() == 0) {\n                        v2 = v3 = 96;\n                    } else {\n                        v2 = v4 = new bytes[](RETURNDATASIZE());\n                        RETURNDATACOPY(v4.data, 0, RETURNDATASIZE());\n                    }\n                    if (v0) {\n                        v5 = v6 = 0;\n                        while (v5 < MEM[v2]) {\n                            MEM[64 + (v5 + MEM[64])] = MEM[32 + (v5 + v2)];\n                            v5 += 32;\n                        }\n                        if (v5 > MEM[v2]) {\n                            MEM[MEM[64] + MEM[v2] + 64] = v6;\n                        }\n                        return 32, MEM[v2];\n                    }\n                }\n            } else {\n                v7 = new array[](105);\n                MEM[v7.data] = 'Transaction execution must conta';\n                MEM[4 + MEM[64] + 96] = 'in a destination.  If you meant ';\n                MEM[4 + MEM[64] + 128] = 'to deploy a contract, use deploy';\n                MEM[4 + MEM[64] + 160] = ' instead.';\n            }\n        } else {\n            goto 0x2e50x6daB0x262;\n        }\n    }\n    revert('This method cannot be called during a recovery.');\n}\n\nfunction finishRecovery() public nonPayable { \n    if (stor_3_0_19) {\n        if (block.timestamp >= stor_4) {\n            _owner = stor_3_0_19;\n            stor_3_0_19 = 0;\n            stor_4 = ~0;\n            emit 0x18fd514351dc50d192b7e41b5a6478575c793d38f756ec15acc7b1796597ef19(_owner, _owner);\n            exit;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction cancelRecoveryAndRemoveRecoveryAddress() public nonPayable { \n    if (msg.sender == _owner) {\n        if (stor_3_0_19) {\n            0x2bb();\n            0x4b3(stor_3_0_19);\n            exit;\n        } else {\n            goto 0x2e50x8b4B0x295;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction deploy(uint256 _value, bytes _data, uint256 _salt) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(_data <= 0xffffffffffffffff);\n    require(4 + _data + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + _data + (?).length + 32 <= msg.data.length);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (this.balance >= _value) {\n                if ((?).length) {\n                    v0 = new bytes[]((?).length);\n                    CALLDATACOPY(v0.data, 4 + _data + 32, (?).length);\n                    MEM[v0.data + (?).length] = 0;\n                    if (address(CREATE2(_value, v0.data, v0.length, _salt))) {\n                        return address(CREATE2(_value, v0.data, v0.length, _salt));\n                    }\n                }\n            }\n        } else {\n            goto 0x2e50x926B0x2ac;\n        }\n    }\n    revert('This method cannot be called during a recovery.');\n}\n\nfunction 0x2bb() private { \n    if (msg.sender == _owner) {\n        if (stor_3_0_19) {\n            stor_3_0_19 = 0;\n            stor_4 = ~0;\n            emit 0x8154b6c5e1fc90d44b49808ef93f9739148d0821411890f8cd684385e24b9f1e(stor_3_0_19);\n            return ;\n        } else {\n            goto 0x2e50x2bb;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction 0x4b3(uint256 varg0) private { \n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (address(varg0)) {\n                v0 = address(varg0);\n                if (owner_1[v0]) {\n                    if (~0 + array_2.length != owner_1[v0]) {\n                        assert(~0 + array_2.length < array_2.length);\n                        assert(owner_1[v0] < array_2.length);\n                        array_2[owner_1[v0]] = address(array_2[~0 + array_2.length]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[owner_1[v0]];\n                        array_2[owner_1[v0]] = (address(array_2[~0 + array_2.length]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[owner_1[v0]]) & ~0xffff0000000000000000000000000000000000000000 | uint16(array_2[~0 + array_2.length] >> 160) << 160;\n                        owner_1[address(array_2[~0 + array_2.length])] = owner_1[v0];\n                    }\n                    assert(array_2.length);\n                    STORAGE[~0 + (array_2.length + keccak256(2))] = ~0xffffffffffffffffffffffffffffffffffffffffffff & STORAGE[~0 + (array_2.length + keccak256(2))];\n                    array_2.length = array_2.length + ~0;\n                    v1 = address(varg0);\n                    owner_1[v1] = 0;\n                    v2 = v3 = owner_1[v0] == ~0 + array_2.length;\n                    if (owner_1[v0] != ~0 + array_2.length) {\n                        assert(owner_1[v0] < array_2.length);\n                        v2 = address(array_2[owner_1[v0]]) != address(varg0);\n                    }\n                    require(v2, 'Removed key still exists in the array at original index.');\n                    goto 0x53d;\n                }\n                emit 0x250546491931526473f4670f0964714a4f7272548fa2040f447d653f5cffbbb7(address(varg0));\n                return ;\n            } else {\n                goto 0x2e50x4b3;\n            }\n        } else {\n            goto 0x2e50x4b3;\n        }\n    }\n    revert('Recovery address must be supplied.');\n}\n\nfunction tokensReceived(address varg0, address varg1, address varg2, uint256 varg3, bytes varg4, bytes varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg2 == varg2);\n    require(varg4 <= 0xffffffffffffffff);\n    require(4 + varg4 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg4 + (?).length + 32 <= msg.data.length);\n    require(varg5 <= 0xffffffffffffffff);\n    require(4 + varg5 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg5 + (?).length + 32 <= msg.data.length);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        if (!msg.data.length) {\n            fallback();\n        }\n    } else if (0x8da5cb5b > function_selector >> 224) {\n        if (0x432b357c > function_selector >> 224) {\n            if (0x23de29 == function_selector >> 224) {\n                tokensReceived(address,address,address,uint256,bytes,bytes);\n            } else if (0xba234d6 == function_selector >> 224) {\n                0x0ba234d6();\n            } else if (0x249cb3fa == function_selector >> 224) {\n                canImplementInterfaceForAddress(bytes32,address);\n            }\n        } else if (0x432b357c == function_selector >> 224) {\n            0x432b357c();\n        } else if (0x6d6a5349 == function_selector >> 224) {\n            0x6d6a5349();\n        } else if (0x7e3bfa1d == function_selector >> 224) {\n            0x7e3bfa1d();\n        } else if (0x8a295c37 == function_selector >> 224) {\n            0x8a295c37();\n        }\n    } else if (0xb61d27f6 > function_selector >> 224) {\n        if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x923689e4 == function_selector >> 224) {\n            0x923689e4();\n        } else if (0x994b68b5 == function_selector >> 224) {\n            0x994b68b5();\n        } else if (0xb52f65e7 == function_selector >> 224) {\n            0xb52f65e7();\n        }\n    } else if (0xb61d27f6 == function_selector >> 224) {\n        execute(address,uint256,bytes);\n    } else if (0xc7423803 == function_selector >> 224) {\n        0xc7423803();\n    } else if (0xf1f3c7f8 == function_selector >> 224) {\n        0xf1f3c7f8();\n    } else if (0xf9899326 == function_selector >> 224) {\n        0xf9899326();\n    }\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 11:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nuint256[] array_2; // STORAGE[0x2]\nuint256 stor_4; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress stor_3_0_19; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction cancelRecovery() public nonPayable { \n    0x2bb();\n}\n\nfunction canImplementInterfaceForAddress(bytes32 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 == varg1);\n    v0 = v1 = this == varg1;\n    if (v1) {\n        v0 = varg0 == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        v2 = v4 = 0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4;\n    }\n    return v2;\n}\n\nfunction getRecoveryDelayInDays(address recoverer) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(recoverer == recoverer);\n    require(owner_1[recoverer], 'Provided key was not in the map.', 'Provided key was not in the map.');\n    assert(owner_1[recoverer] < array_2.length);\n    return uint16(array_2[owner_1[recoverer]] >> 160);\n}\n\nfunction fallback() public payable { \n}\n\nfunction addRecoveryAddress(address _newRecoveryAddress, uint16 _recoveryDelayInDays) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_newRecoveryAddress == _newRecoveryAddress);\n    require(_recoveryDelayInDays == _recoveryDelayInDays);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (_newRecoveryAddress) {\n                if (owner_1[_newRecoveryAddress]) {\n                    assert(owner_1[_newRecoveryAddress] < array_2.length);\n                    STORAGE[0 + (keccak256(2) + owner_1[_newRecoveryAddress])] = _recoveryDelayInDays << 160 | ~0xffff0000000000000000000000000000000000000000 & STORAGE[0 + (keccak256(2) + owner_1[_newRecoveryAddress])];\n                } else {\n                    MEM[MEM[64]] = 0;\n                    MEM[MEM[64] + 32] = 0;\n                    array_2.length = array_2.length + 1;\n                    array_2[array_2.length] = (array_2[array_2.length] & ~0xffffffffffffffffffffffffffffffffffffffff | _newRecoveryAddress) & ~0xffff0000000000000000000000000000000000000000 | _recoveryDelayInDays << 160;\n                    owner_1[2] = ~0 + array_2.length;\n                }\n                assert(owner_1[_newRecoveryAddress] < array_2.length);\n                if (address(array_2[owner_1[_newRecoveryAddress]]) == _newRecoveryAddress) {\n                    assert(owner_1[_newRecoveryAddress] < array_2.length);\n                    if (uint16(array_2[owner_1[_newRecoveryAddress]] >> 160) == _recoveryDelayInDays) {\n                        emit 0xca4ba7fe9344a8a1e34b14f051473d2b4b02dd480025f14df8f6fa70c7950cab(_newRecoveryAddress, _recoveryDelayInDays);\n                        exit;\n                    }\n                }\n                revert('Value at inserted location does not match inserted value.');\n            } else {\n                goto 0x2e50x191;\n            }\n        } else {\n            goto 0x2e50x191;\n        }\n    }\n    revert('Recovery address must be supplied.');\n}\n\nfunction removeRecoveryAddress(address _oldRecoveryAddress) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_oldRecoveryAddress == _oldRecoveryAddress);\n    0x4b3(_oldRecoveryAddress);\n}\n\nfunction activeRecoveryEndTime() public nonPayable { \n    return stor_4;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction startRecovery() public nonPayable { \n    if (owner_1[msg.sender]) {\n        require(owner_1[msg.sender], 'Provided key was not in the map.', 'Provided key was not in the map.');\n        assert(owner_1[msg.sender] < array_2.length);\n        if (stor_3_0_19) {\n            require(owner_1[stor_3_0_19], 'Provided key was not in the map.', 'Provided key was not in the map.');\n            assert(owner_1[stor_3_0_19] < array_2.length);\n            if (uint16(array_2[owner_1[msg.sender]] >> 160) < uint16(array_2[owner_1[stor_3_0_19]] >> 160)) {\n                emit 0x8154b6c5e1fc90d44b49808ef93f9739148d0821411890f8cd684385e24b9f1e(stor_3_0_19);\n            }\n        }\n        stor_3_0_19 = msg.sender;\n        stor_4 = (uint16(array_2[owner_1[msg.sender]] >> 160) * 0x15180 & 0xffffff) + block.timestamp;\n        emit 0xcd4e9df2b0a742bc5628c20baf55859f839c034aa76a32f600d6b085c4de4829(msg.sender);\n        exit;\n    }\n    revert(\"Recovery is already under way and new recoverer doesn't have a higher priority.\");\n}\n\nfunction listRecoverers() public nonPayable { \n    v0 = v1 = array_2.length - 1;\n    v2 = new uint256[](v1);\n    if (v1) {\n        v3 = v2.data;\n        do {\n            MEM[MEM[64]] = 0;\n            MEM[MEM[64] + 32] = 0;\n            MEM[v3] = MEM[64];\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v4 = v5 = 1;\n    while (v4 < array_2.length) {\n        assert(v4 < array_2.length);\n        MEM[MEM[64]] = address(array_2[v4]);\n        MEM[MEM[64] + 32] = uint16(array_2[v4] >> 160);\n        assert(v4 + ~0 < v2.length);\n        v2[v4 + ~0] = MEM[64];\n        v4 += 1;\n    }\n    v6 = new array[](v2.length);\n    v7 = v8 = 0;\n    v9 = v10 = v6.data;\n    v11 = v12 = v2.data;\n    while (v7 < v2.length) {\n        MEM[v9] = address(MEM[MEM[v11]]);\n        MEM[v9 + 32] = uint16(MEM[32 + MEM[v11]]);\n        v9 += 64;\n        v11 += 32;\n        v7 += 1;\n    }\n    return v6;\n}\n\nfunction activeRecoveryAddress() public nonPayable { \n    return stor_3_0_19;\n}\n\nfunction execute(address varg0, uint256 varg1, bytes varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg2 <= 0xffffffffffffffff);\n    require(4 + varg2 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg2 + (?).length + 32 <= msg.data.length);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (varg0) {\n                if (this.balance >= varg1) {\n                    MEM[(?).length + MEM[64]] = 0;\n                    v0, v1 = varg0.call(MEM[(MEM[64]) len ((?).length + MEM[64] - MEM[64])], MEM[(MEM[64]) len 0]).value(varg1).gas(msg.gas);\n                    if (RETURNDATASIZE() == 0) {\n                        v2 = v3 = 96;\n                    } else {\n                        v2 = v4 = new bytes[](RETURNDATASIZE());\n                        RETURNDATACOPY(v4.data, 0, RETURNDATASIZE());\n                    }\n                    if (v0) {\n                        v5 = v6 = 0;\n                        while (v5 < MEM[v2]) {\n                            MEM[64 + (v5 + MEM[64])] = MEM[32 + (v5 + v2)];\n                            v5 += 32;\n                        }\n                        if (v5 > MEM[v2]) {\n                            MEM[MEM[64] + MEM[v2] + 64] = v6;\n                        }\n                        return 32, MEM[v2];\n                    }\n                }\n            } else {\n                v7 = new array[](105);\n                MEM[v7.data] = 'Transaction execution must conta';\n                MEM[4 + MEM[64] + 96] = 'in a destination.  If you meant ';\n                MEM[4 + MEM[64] + 128] = 'to deploy a contract, use deploy';\n                MEM[4 + MEM[64] + 160] = ' instead.';\n            }\n        } else {\n            goto 0x2e50x6daB0x262;\n        }\n    }\n    revert('This method cannot be called during a recovery.');\n}\n\nfunction finishRecovery() public nonPayable { \n    if (stor_3_0_19) {\n        if (block.timestamp >= stor_4) {\n            _owner = stor_3_0_19;\n            stor_3_0_19 = 0;\n            stor_4 = ~0;\n            emit 0x18fd514351dc50d192b7e41b5a6478575c793d38f756ec15acc7b1796597ef19(_owner, _owner);\n            exit;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction cancelRecoveryAndRemoveRecoveryAddress() public nonPayable { \n    if (msg.sender == _owner) {\n        if (stor_3_0_19) {\n            0x2bb();\n            0x4b3(stor_3_0_19);\n            exit;\n        } else {\n            goto 0x2e50x8b4B0x295;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction deploy(uint256 _value, bytes _data, uint256 _salt) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(_data <= 0xffffffffffffffff);\n    require(4 + _data + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + _data + (?).length + 32 <= msg.data.length);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (this.balance >= _value) {\n                if ((?).length) {\n                    v0 = new bytes[]((?).length);\n                    CALLDATACOPY(v0.data, 4 + _data + 32, (?).length);\n                    MEM[v0.data + (?).length] = 0;\n                    if (address(CREATE2(_value, v0.data, v0.length, _salt))) {\n                        return address(CREATE2(_value, v0.data, v0.length, _salt));\n                    }\n                }\n            }\n        } else {\n            goto 0x2e50x926B0x2ac;\n        }\n    }\n    revert('This method cannot be called during a recovery.');\n}\n\nfunction 0x2bb() private { \n    if (msg.sender == _owner) {\n        if (stor_3_0_19) {\n            stor_3_0_19 = 0;\n            stor_4 = ~0;\n            emit 0x8154b6c5e1fc90d44b49808ef93f9739148d0821411890f8cd684385e24b9f1e(stor_3_0_19);\n            return ;\n        } else {\n            goto 0x2e50x2bb;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction 0x4b3(uint256 varg0) private { \n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (address(varg0)) {\n                v0 = address(varg0);\n                if (owner_1[v0]) {\n                    if (~0 + array_2.length != owner_1[v0]) {\n                        assert(~0 + array_2.length < array_2.length);\n                        assert(owner_1[v0] < array_2.length);\n                        array_2[owner_1[v0]] = address(array_2[~0 + array_2.length]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[owner_1[v0]];\n                        array_2[owner_1[v0]] = (address(array_2[~0 + array_2.length]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[owner_1[v0]]) & ~0xffff0000000000000000000000000000000000000000 | uint16(array_2[~0 + array_2.length] >> 160) << 160;\n                        owner_1[address(array_2[~0 + array_2.length])] = owner_1[v0];\n                    }\n                    assert(array_2.length);\n                    STORAGE[~0 + (array_2.length + keccak256(2))] = ~0xffffffffffffffffffffffffffffffffffffffffffff & STORAGE[~0 + (array_2.length + keccak256(2))];\n                    array_2.length = array_2.length + ~0;\n                    v1 = address(varg0);\n                    owner_1[v1] = 0;\n                    v2 = v3 = owner_1[v0] == ~0 + array_2.length;\n                    if (owner_1[v0] != ~0 + array_2.length) {\n                        assert(owner_1[v0] < array_2.length);\n                        v2 = address(array_2[owner_1[v0]]) != address(varg0);\n                    }\n                    require(v2, 'Removed key still exists in the array at original index.');\n                    goto 0x53d;\n                }\n                emit 0x250546491931526473f4670f0964714a4f7272548fa2040f447d653f5cffbbb7(address(varg0));\n                return ;\n            } else {\n                goto 0x2e50x4b3;\n            }\n        } else {\n            goto 0x2e50x4b3;\n        }\n    }\n    revert('Recovery address must be supplied.');\n}\n\nfunction tokensReceived(address varg0, address varg1, address varg2, uint256 varg3, bytes varg4, bytes varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg2 == varg2);\n    require(varg4 <= 0xffffffffffffffff);\n    require(4 + varg4 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg4 + (?).length + 32 <= msg.data.length);\n    require(varg5 <= 0xffffffffffffffff);\n    require(4 + varg5 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg5 + (?).length + 32 <= msg.data.length);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        if (!msg.data.length) {\n            fallback();\n        }\n    } else if (0x8da5cb5b > function_selector >> 224) {\n        if (0x432b357c > function_selector >> 224) {\n            if (0x23de29 == function_selector >> 224) {\n                tokensReceived(address,address,address,uint256,bytes,bytes);\n            } else if (0xba234d6 == function_selector >> 224) {\n                0x0ba234d6();\n            } else if (0x249cb3fa == function_selector >> 224) {\n                canImplementInterfaceForAddress(bytes32,address);\n            }\n        } else if (0x432b357c == function_selector >> 224) {\n            0x432b357c();\n        } else if (0x6d6a5349 == function_selector >> 224) {\n            0x6d6a5349();\n        } else if (0x7e3bfa1d == function_selector >> 224) {\n            0x7e3bfa1d();\n        } else if (0x8a295c37 == function_selector >> 224) {\n            0x8a295c37();\n        }\n    } else if (0xb61d27f6 > function_selector >> 224) {\n        if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x923689e4 == function_selector >> 224) {\n            0x923689e4();\n        } else if (0x994b68b5 == function_selector >> 224) {\n            0x994b68b5();\n        } else if (0xb52f65e7 == function_selector >> 224) {\n            0xb52f65e7();\n        }\n    } else if (0xb61d27f6 == function_selector >> 224) {\n        execute(address,uint256,bytes);\n    } else if (0xc7423803 == function_selector >> 224) {\n        0xc7423803();\n    } else if (0xf1f3c7f8 == function_selector >> 224) {\n        0xf1f3c7f8();\n    } else if (0xf9899326 == function_selector >> 224) {\n        0xf9899326();\n    }\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.14 11:53 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) owner_1; // STORAGE[0x1]\nuint256[] array_2; // STORAGE[0x2]\nuint256 stor_4; // STORAGE[0x4]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_3_0_0; // STORAGE[0x3] bytes 0 to 0\naddress stor_3_0_19; // STORAGE[0x3] bytes 0 to 19\n\n\nfunction cancelRecovery() public nonPayable { \n    0x2bb();\n}\n\nfunction canImplementInterfaceForAddress(bytes32 varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg1 == varg1);\n    v0 = v1 = this == varg1;\n    if (v1) {\n        v0 = varg0 == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n    } else {\n        v2 = v4 = 0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4;\n    }\n    return v2;\n}\n\nfunction getRecoveryDelayInDays(address recoverer) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(recoverer == recoverer);\n    require(owner_1[recoverer], 'Provided key was not in the map.', 'Provided key was not in the map.');\n    assert(owner_1[recoverer] < array_2.length);\n    return uint16(array_2[owner_1[recoverer]] >> 160);\n}\n\nfunction fallback() public payable { \n}\n\nfunction addRecoveryAddress(address _newRecoveryAddress, uint16 _recoveryDelayInDays) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(_newRecoveryAddress == _newRecoveryAddress);\n    require(_recoveryDelayInDays == _recoveryDelayInDays);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (_newRecoveryAddress) {\n                if (owner_1[_newRecoveryAddress]) {\n                    assert(owner_1[_newRecoveryAddress] < array_2.length);\n                    STORAGE[0 + (keccak256(2) + owner_1[_newRecoveryAddress])] = _recoveryDelayInDays << 160 | ~0xffff0000000000000000000000000000000000000000 & STORAGE[0 + (keccak256(2) + owner_1[_newRecoveryAddress])];\n                } else {\n                    MEM[MEM[64]] = 0;\n                    MEM[MEM[64] + 32] = 0;\n                    array_2.length = array_2.length + 1;\n                    array_2[array_2.length] = (array_2[array_2.length] & ~0xffffffffffffffffffffffffffffffffffffffff | _newRecoveryAddress) & ~0xffff0000000000000000000000000000000000000000 | _recoveryDelayInDays << 160;\n                    owner_1[2] = ~0 + array_2.length;\n                }\n                assert(owner_1[_newRecoveryAddress] < array_2.length);\n                if (address(array_2[owner_1[_newRecoveryAddress]]) == _newRecoveryAddress) {\n                    assert(owner_1[_newRecoveryAddress] < array_2.length);\n                    if (uint16(array_2[owner_1[_newRecoveryAddress]] >> 160) == _recoveryDelayInDays) {\n                        emit 0xca4ba7fe9344a8a1e34b14f051473d2b4b02dd480025f14df8f6fa70c7950cab(_newRecoveryAddress, _recoveryDelayInDays);\n                        exit;\n                    }\n                }\n                revert('Value at inserted location does not match inserted value.');\n            } else {\n                goto 0x2e50x191;\n            }\n        } else {\n            goto 0x2e50x191;\n        }\n    }\n    revert('Recovery address must be supplied.');\n}\n\nfunction removeRecoveryAddress(address _oldRecoveryAddress) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(_oldRecoveryAddress == _oldRecoveryAddress);\n    0x4b3(_oldRecoveryAddress);\n}\n\nfunction activeRecoveryEndTime() public nonPayable { \n    return stor_4;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction startRecovery() public nonPayable { \n    if (owner_1[msg.sender]) {\n        require(owner_1[msg.sender], 'Provided key was not in the map.', 'Provided key was not in the map.');\n        assert(owner_1[msg.sender] < array_2.length);\n        if (stor_3_0_19) {\n            require(owner_1[stor_3_0_19], 'Provided key was not in the map.', 'Provided key was not in the map.');\n            assert(owner_1[stor_3_0_19] < array_2.length);\n            if (uint16(array_2[owner_1[msg.sender]] >> 160) < uint16(array_2[owner_1[stor_3_0_19]] >> 160)) {\n                emit 0x8154b6c5e1fc90d44b49808ef93f9739148d0821411890f8cd684385e24b9f1e(stor_3_0_19);\n            }\n        }\n        stor_3_0_19 = msg.sender;\n        stor_4 = (uint16(array_2[owner_1[msg.sender]] >> 160) * 0x15180 & 0xffffff) + block.timestamp;\n        emit 0xcd4e9df2b0a742bc5628c20baf55859f839c034aa76a32f600d6b085c4de4829(msg.sender);\n        exit;\n    }\n    revert(\"Recovery is already under way and new recoverer doesn't have a higher priority.\");\n}\n\nfunction listRecoverers() public nonPayable { \n    v0 = v1 = array_2.length - 1;\n    v2 = new uint256[](v1);\n    if (v1) {\n        v3 = v2.data;\n        do {\n            MEM[MEM[64]] = 0;\n            MEM[MEM[64] + 32] = 0;\n            MEM[v3] = MEM[64];\n            v3 += 32;\n            v0 = v0 - 1;\n        } while (!v0);\n    }\n    v4 = v5 = 1;\n    while (v4 < array_2.length) {\n        assert(v4 < array_2.length);\n        MEM[MEM[64]] = address(array_2[v4]);\n        MEM[MEM[64] + 32] = uint16(array_2[v4] >> 160);\n        assert(v4 + ~0 < v2.length);\n        v2[v4 + ~0] = MEM[64];\n        v4 += 1;\n    }\n    v6 = new array[](v2.length);\n    v7 = v8 = 0;\n    v9 = v10 = v6.data;\n    v11 = v12 = v2.data;\n    while (v7 < v2.length) {\n        MEM[v9] = address(MEM[MEM[v11]]);\n        MEM[v9 + 32] = uint16(MEM[32 + MEM[v11]]);\n        v9 += 64;\n        v11 += 32;\n        v7 += 1;\n    }\n    return v6;\n}\n\nfunction activeRecoveryAddress() public nonPayable { \n    return stor_3_0_19;\n}\n\nfunction execute(address varg0, uint256 varg1, bytes varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg2 <= 0xffffffffffffffff);\n    require(4 + varg2 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg2 + (?).length + 32 <= msg.data.length);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (varg0) {\n                if (this.balance >= varg1) {\n                    MEM[(?).length + MEM[64]] = 0;\n                    v0, v1 = varg0.call(MEM[(MEM[64]) len ((?).length + MEM[64] - MEM[64])], MEM[(MEM[64]) len 0]).value(varg1).gas(msg.gas);\n                    if (RETURNDATASIZE() == 0) {\n                        v2 = v3 = 96;\n                    } else {\n                        v2 = v4 = new bytes[](RETURNDATASIZE());\n                        RETURNDATACOPY(v4.data, 0, RETURNDATASIZE());\n                    }\n                    if (v0) {\n                        v5 = v6 = 0;\n                        while (v5 < MEM[v2]) {\n                            MEM[64 + (v5 + MEM[64])] = MEM[32 + (v5 + v2)];\n                            v5 += 32;\n                        }\n                        if (v5 > MEM[v2]) {\n                            MEM[MEM[64] + MEM[v2] + 64] = v6;\n                        }\n                        return 32, MEM[v2];\n                    }\n                }\n            } else {\n                v7 = new array[](105);\n                MEM[v7.data] = 'Transaction execution must conta';\n                MEM[4 + MEM[64] + 96] = 'in a destination.  If you meant ';\n                MEM[4 + MEM[64] + 128] = 'to deploy a contract, use deploy';\n                MEM[4 + MEM[64] + 160] = ' instead.';\n            }\n        } else {\n            goto 0x2e50x6daB0x262;\n        }\n    }\n    revert('This method cannot be called during a recovery.');\n}\n\nfunction finishRecovery() public nonPayable { \n    if (stor_3_0_19) {\n        if (block.timestamp >= stor_4) {\n            _owner = stor_3_0_19;\n            stor_3_0_19 = 0;\n            stor_4 = ~0;\n            emit 0x18fd514351dc50d192b7e41b5a6478575c793d38f756ec15acc7b1796597ef19(_owner, _owner);\n            exit;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction cancelRecoveryAndRemoveRecoveryAddress() public nonPayable { \n    if (msg.sender == _owner) {\n        if (stor_3_0_19) {\n            0x2bb();\n            0x4b3(stor_3_0_19);\n            exit;\n        } else {\n            goto 0x2e50x8b4B0x295;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction deploy(uint256 _value, bytes _data, uint256 _salt) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(_data <= 0xffffffffffffffff);\n    require(4 + _data + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + _data + (?).length + 32 <= msg.data.length);\n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (this.balance >= _value) {\n                if ((?).length) {\n                    v0 = new bytes[]((?).length);\n                    CALLDATACOPY(v0.data, 4 + _data + 32, (?).length);\n                    MEM[v0.data + (?).length] = 0;\n                    if (address(CREATE2(_value, v0.data, v0.length, _salt))) {\n                        return address(CREATE2(_value, v0.data, v0.length, _salt));\n                    }\n                }\n            }\n        } else {\n            goto 0x2e50x926B0x2ac;\n        }\n    }\n    revert('This method cannot be called during a recovery.');\n}\n\nfunction 0x2bb() private { \n    if (msg.sender == _owner) {\n        if (stor_3_0_19) {\n            stor_3_0_19 = 0;\n            stor_4 = ~0;\n            emit 0x8154b6c5e1fc90d44b49808ef93f9739148d0821411890f8cd684385e24b9f1e(stor_3_0_19);\n            return ;\n        } else {\n            goto 0x2e50x2bb;\n        }\n    }\n    revert('This method can only be called during a recovery.');\n}\n\nfunction 0x4b3(uint256 varg0) private { \n    if (msg.sender == _owner) {\n        if (!stor_3_0_19) {\n            if (address(varg0)) {\n                v0 = address(varg0);\n                if (owner_1[v0]) {\n                    if (~0 + array_2.length != owner_1[v0]) {\n                        assert(~0 + array_2.length < array_2.length);\n                        assert(owner_1[v0] < array_2.length);\n                        array_2[owner_1[v0]] = address(array_2[~0 + array_2.length]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[owner_1[v0]];\n                        array_2[owner_1[v0]] = (address(array_2[~0 + array_2.length]) | ~0xffffffffffffffffffffffffffffffffffffffff & array_2[owner_1[v0]]) & ~0xffff0000000000000000000000000000000000000000 | uint16(array_2[~0 + array_2.length] >> 160) << 160;\n                        owner_1[address(array_2[~0 + array_2.length])] = owner_1[v0];\n                    }\n                    assert(array_2.length);\n                    STORAGE[~0 + (array_2.length + keccak256(2))] = ~0xffffffffffffffffffffffffffffffffffffffffffff & STORAGE[~0 + (array_2.length + keccak256(2))];\n                    array_2.length = array_2.length + ~0;\n                    v1 = address(varg0);\n                    owner_1[v1] = 0;\n                    v2 = v3 = owner_1[v0] == ~0 + array_2.length;\n                    if (owner_1[v0] != ~0 + array_2.length) {\n                        assert(owner_1[v0] < array_2.length);\n                        v2 = address(array_2[owner_1[v0]]) != address(varg0);\n                    }\n                    require(v2, 'Removed key still exists in the array at original index.');\n                    goto 0x53d;\n                }\n                emit 0x250546491931526473f4670f0964714a4f7272548fa2040f447d653f5cffbbb7(address(varg0));\n                return ;\n            } else {\n                goto 0x2e50x4b3;\n            }\n        } else {\n            goto 0x2e50x4b3;\n        }\n    }\n    revert('Recovery address must be supplied.');\n}\n\nfunction tokensReceived(address varg0, address varg1, address varg2, uint256 varg3, bytes varg4, bytes varg5) public nonPayable { \n    require(msg.data.length - 4 >= 192);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    require(varg2 == varg2);\n    require(varg4 <= 0xffffffffffffffff);\n    require(4 + varg4 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg4 + (?).length + 32 <= msg.data.length);\n    require(varg5 <= 0xffffffffffffffff);\n    require(4 + varg5 + 31 < msg.data.length);\n    require((?).length <= 0xffffffffffffffff);\n    require(4 + varg5 + (?).length + 32 <= msg.data.length);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        if (!msg.data.length) {\n            fallback();\n        }\n    } else if (0x8da5cb5b > function_selector >> 224) {\n        if (0x432b357c > function_selector >> 224) {\n            if (0x23de29 == function_selector >> 224) {\n                tokensReceived(address,address,address,uint256,bytes,bytes);\n            } else if (0xba234d6 == function_selector >> 224) {\n                0x0ba234d6();\n            } else if (0x249cb3fa == function_selector >> 224) {\n                canImplementInterfaceForAddress(bytes32,address);\n            }\n        } else if (0x432b357c == function_selector >> 224) {\n            0x432b357c();\n        } else if (0x6d6a5349 == function_selector >> 224) {\n            0x6d6a5349();\n        } else if (0x7e3bfa1d == function_selector >> 224) {\n            0x7e3bfa1d();\n        } else if (0x8a295c37 == function_selector >> 224) {\n            0x8a295c37();\n        }\n    } else if (0xb61d27f6 > function_selector >> 224) {\n        if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x923689e4 == function_selector >> 224) {\n            0x923689e4();\n        } else if (0x994b68b5 == function_selector >> 224) {\n            0x994b68b5();\n        } else if (0xb52f65e7 == function_selector >> 224) {\n            0xb52f65e7();\n        }\n    } else if (0xb61d27f6 == function_selector >> 224) {\n        execute(address,uint256,bytes);\n    } else if (0xc7423803 == function_selector >> 224) {\n        0xc7423803();\n    } else if (0xf1f3c7f8 == function_selector >> 224) {\n        0xf1f3c7f8();\n    } else if (0xf9899326 == function_selector >> 224) {\n        0xf9899326();\n    }\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 26.713157653808594,
	"usage": {
		"completion_tokens": 568,
		"prompt_tokens": 4343,
		"total_tokens": 4911
	}
}