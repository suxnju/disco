{
	"address": "0xc6e5e9c6f4f3d1667df6086e91637cc7c64a13eb",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Apologies for misunderstanding, but it's very difficult and time-consuming to reverse engineer EVM bytecode to Solidity. The decompiled code you provided seems to be a contract for an ERC20 token with additional features such as staking, dividend distribution, and selling tokens. However, the pseudocode is quite complex and lacks clarity. \n\nHere's a simplified version of a Solidity contract that includes some of the features found in the pseudocode like staking and dividends. It doesn't cover everything but gives a rough idea. The contract assumes an ERC20 token:\n\n```Solidity\npragma solidity ^0.5.0;\n\ncontract ERC20Token {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public stakeOf;\n    mapping (address => uint256) public dividendOf;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Stake(address indexed from, uint256 value);\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function stake(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        stakeOf[msg.sender] += _value;\n        emit Stake(msg.sender, _value);\n        return true;\n    }\n\n    function dividend() public returns (uint256 _value) {\n        require(stakeOf[msg.sender] > 0);\n        _value = stakeOf[msg.sender] / 100; // 1% dividend\n        balanceOf[msg.sender] += _value;\n        stakeOf[msg.sender] -= _value;\n        return _value;\n    }\n}\n```\n\nThis contract creates an ERC20 token and allows users to transfer tokens, stake tokens and claim a dividend from their stake.\n\nHowever, please note that this is a very basic example and lacks many features and security measures that you would want in a production-level contract. You should consider factors like overflows/underflows, access controls, testing, and other security practices if you want to use this for anything beyond learning or testing.",
				"role": "assistant"
			}
		}
	],
	"created": 1701455954,
	"id": "chatcmpl-8R2huNtZFPTk6FG1XFuJDUX5CzL6r",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.14 19:56 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _stakingRequirement; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0xa]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nuint256 stor_f; // STORAGE[0xf]\nuint256 _totalSupply; // STORAGE[0x10]\nuint256 owner_11; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _canAcceptTokens_; // STORAGE[0x13]\naddress _setStakingRequirement; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _onlyAmbassadors; // STORAGE[0xe] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x1007() private { \n    v0 = 0x1297(1);\n    require(v0 > 0);\n    v1 = 0x1297(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0x1297(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * owner_11 - _dividendsOf[msg.sender] >> 64) + owner_b[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * owner_11 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x13bf() private { \n    return _exit[msg.sender];\n}\n\nfunction 0x1466(uint256 varg0, uint256 varg1) private { \n    v0 = 0x13bf();\n    require(v0 > 0);\n    v1 = v2 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v1 = v3 = varg0 <= _exit[msg.sender];\n    }\n    require(v1);\n    v4 = 0x197b(5, varg0);\n    assert(100);\n    assert(v4 / 100 <= varg0);\n    v5 = varg0 - v4 / 100;\n    assert(v4 / 100 <= _totalSupply);\n    _totalSupply = _totalSupply - v4 / 100;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v6 = address(varg1);\n    v7 = _SafeAdd(v5, _exit[v6]);\n    v8 = address(varg1);\n    _exit[v8] = v7;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg0 * owner_11;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + v5 * owner_11;\n    assert(_totalSupply);\n    assert((v4 / 100 / 20000 << 64) / _totalSupply + owner_11 >= owner_11);\n    owner_11 += (v4 / 100 / 20000 << 64) / _totalSupply;\n    emit Transfer(msg.sender, address(varg1), v5);\n    return 1;\n}\n\nfunction 0x170f(uint256 varg0) private { \n    v0 = 0x13bf();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = varg0 / 20000;\n    v2 = 0x197b(10, v1);\n    assert(100);\n    assert(v2 / 100 <= v1);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v1 - v2 / 100 << 64) + varg0 * owner_11);\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert((v2 / 100 << 64) / _totalSupply + owner_11 >= owner_11);\n        owner_11 += (v2 / 100 << 64) / _totalSupply;\n    }\n    emit onTokenSell(msg.sender, varg0, v1 - v2 / 100);\n    return ;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x197b(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x656(0, msg.value, msg.sender, 449, v1);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * owner_11 - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction canAcceptTokens_(address varg0) public nonPayable { \n    return 0xff & _canAcceptTokens_[varg0];\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x197b(10, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    return 20000 * (varg0 - v0 / 100);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x197b(10, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    return varg0 - v0 / 100;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction setCanAcceptTokens(address varg0, bool varg1) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _canAcceptTokens_[varg0] = varg1 | ~0xff & _canAcceptTokens_[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0x1007();\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(varg0);\n    require(1 == 0xff & _canAcceptTokens_[varg0]);\n    v0 = 0x1466(varg1, varg0);\n    require(v0);\n    if (varg0.code.size > 0) {\n        MEM[32 + MEM[64]] = 0;\n        v1 = new array[](varg2.length);\n        require(varg0.code.size);\n        v2, v3 = varg0.tokenFallback(msg.sender, varg1, v1).gas(msg.gas - 710);\n        require(v2);\n        require(v3);\n    }\n    return 1;\n}\n\nfunction changePromoter(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_7_0_19 = varg0;\n}\n\nfunction sellPrice() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (7) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & '0.00005';\n    }\n    return v0;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x1297(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & '0.00005556';\n    }\n    return v0;\n}\n\nfunction changeDev(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_8_0_19 = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _setStakingRequirement;\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0x13bf();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1466(varg1, varg0);\n    return v0;\n}\n\nfunction changePartner(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_6_0_19 = varg0;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(_setStakingRequirement == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(_setStakingRequirement == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction buyFor(address varg0, address varg1) public payable { \n    v0 = 0x656(varg1, msg.value, varg0, 5820, 0);\n    return v0;\n}\n\nfunction setAdministrator(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _setStakingRequirement = varg0;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x170f(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x170f(_exit[msg.sender]);\n    }\n    0x1007();\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x656(varg0, msg.value, msg.sender, 4820, 0);\n    return 483;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x1297(1);\n    require(v0 > 0);\n    v1 = 0x1297(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x656(0, v1 + _dividendsOf[msg.sender], msg.sender, 6422, 0);\n    emit onReinvestment(808, v3, v2);\n}\n\nfunction 0x656(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v2 = v4 = 0;\n    v2 = v5 = 0;\n    if (block.timestamp >= stor_f) {\n        _onlyAmbassadors = 0;\n    }\n    if (!_onlyAmbassadors) {\n        _onlyAmbassadors = 0;\n        v6 = v7 = 2752;\n        v8 = v9 = 0x197b(10, varg1);\n    } else {\n        v10 = v11 = 1 == 0xff & owner_9[msg.sender];\n        if (v11) {\n            v10 = v12 = varg1 + owner_d[msg.sender] <= 0xde0b6b3a7640000;\n        }\n        require(v10);\n        v13 = _SafeAdd(varg1, owner_d[msg.sender]);\n        owner_d[msg.sender] = v13;\n        v6 = v14 = 1840;\n        v8 = v15 = 0x197b(10, varg1);\n    }\n    while (!100) {\n        assert(100);\n        v0 = v8 / 100;\n        goto {'0x76c', '0x9b5', '0x9f7', '0xac0', '0xad0', '0xd39', '0x740', '0x730', '0xd7b'};\n        v6 = v16 = 1856;\n        v8 = 0x197b(33, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        assert(v0 <= v0);\n        v0 = v17 = v0 - v0;\n        v2 = v18 = 1905;\n        v6 = v19 = 1900;\n        v8 = 0x197b(1, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        goto {'0xafc', '0x7a0', '0xb10', '0x785', '0xb38', '0x771', '0xb24', '0x7b4'};\n        v2 = v20 = 1925;\n        v6 = v21 = 1900;\n        v8 = 0x197b(1, v0);\n        v2 = v22 = 1952;\n        v23 = v24 = 1900;\n        v25 = v26 = 0x197b(1, v0);\n        v2 = v27 = 1972;\n        v23 = v28 = 1900;\n        v25 = v29 = 0x197b(1, v0);\n        v2 = v30 = 20000 * v0;\n        v31 = v32 = v0 << 64;\n        v33 = v34 = v30 > 0;\n        if (v34) {\n            v35 = _SafeAdd(_totalSupply, v30);\n            v33 = v36 = v35 > _totalSupply;\n        }\n        require(v33);\n        v37 = !address(v0);\n        v38 = v39 = address(v0);\n        if (address(v0)) {\n            v38 = v40 = address(v0) != address(v0);\n        }\n        if (v38) {\n            v41 = address(v0);\n            v38 = v42 = _exit[v41] >= _stakingRequirement;\n        }\n        if (!v38) {\n            v0 = _SafeAdd(v0, v0);\n            v31 = v43 = v0 << 64;\n        } else {\n            v44 = address(v0);\n            v45 = _SafeAdd(v0, owner_b[v44]);\n            v46 = address(v0);\n            owner_b[v46] = v45;\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v30;\n        } else {\n            v47 = _SafeAdd(v30, _totalSupply);\n            _totalSupply = v47;\n            assert(v47);\n            owner_11 = owner_11 + (v0 << 64) / v47;\n            assert(_totalSupply);\n            v31 = v48 = v31 - (v31 - v30 * ((v0 << 64) / _totalSupply));\n        }\n        v49 = address(v0);\n        v50 = _SafeAdd(v30, _exit[v49]);\n        v51 = address(v0);\n        _exit[v51] = v50;\n        v2 = v52 = v30 * owner_11 - v31;\n        _dividendsOf[v51] += v52;\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(v51, address(v0), v0, v30);\n        v2 = v53 = stor_5_0_19;\n        v0 = v54 = 2300;\n        v6 = v55 = 2485;\n        v8 = 0x197b(1, v0);\n        v2 = v56 = 2832;\n        v6 = v57 = 1900;\n        v8 = 0x197b(1, v0);\n        v2 = v58 = 2852;\n        v23 = v59 = 1900;\n        v25 = v60 = 0x197b(1, v0);\n        v2 = v61 = 2872;\n        v23 = v62 = 1900;\n        v25 = v63 = 0x197b(1, v0);\n        v2 = 20000 * v0;\n        v64 = v65 = v0 << 64;\n        v66 = v67 = v2 > 0;\n        if (v67) {\n            v68 = _SafeAdd(_totalSupply, v2);\n            v66 = v69 = v68 > _totalSupply;\n        }\n        require(v66);\n        v70 = !address(v0);\n        v71 = v72 = address(v0);\n        if (address(v0)) {\n            v71 = v73 = address(v0) != address(v0);\n        }\n        if (v71) {\n            v74 = address(v0);\n            v71 = v75 = _exit[v74] >= _stakingRequirement;\n        }\n        if (!v71) {\n            v0 = _SafeAdd(v0, v0);\n            v64 = v76 = v0 << 64;\n        } else {\n            v77 = address(v0);\n            v78 = _SafeAdd(v0, owner_b[v77]);\n            v79 = address(v0);\n            owner_b[v79] = v78;\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v2;\n        } else {\n            v80 = _SafeAdd(v2, _totalSupply);\n            _totalSupply = v80;\n            assert(v80);\n            owner_11 = owner_11 + (v0 << 64) / v80;\n            assert(_totalSupply);\n            v64 = v81 = v64 - (v64 - v2 * ((v0 << 64) / _totalSupply));\n        }\n        v82 = address(v0);\n        v83 = _SafeAdd(v2, _exit[v82]);\n        v84 = address(v0);\n        _exit[v84] = v83;\n        v2 = v85 = v2 * owner_11 - v64;\n        _dividendsOf[v84] += v85;\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(v84, address(v0), v0, v2);\n        v2 = v86 = stor_5_0_19;\n        v0 = v87 = 2300;\n        v6 = v88 = 3385;\n        v8 = 0x197b(1, v0);\n        v89 = v2.call().value(v0).gas(!v0 * v0);\n        require(v89);\n        v2 = v90 = stor_6_0_19;\n        v0 = v91 = 2300;\n        v6 = v92 = 2551;\n        v8 = 0x197b(1, v0);\n        v93 = v2.call().value(v0).gas(!v0 * v0);\n        require(v93);\n        v2 = v94 = stor_7_0_19;\n        v0 = v95 = 2300;\n        v23 = v96 = 2617;\n        v25 = v97 = 0x197b(1, v0);\n        while (!200) {\n            assert(200);\n            v98 = v2.call().value(v99).gas(!v99 * v0);\n            require(v98);\n            return v2;\n            v100 = v2.call().value(v99).gas(!v99 * v0);\n            require(v100);\n            v0 = v99 = v25 / 200;\n            goto {'0x76c', '0xdbd', '0xa7b', '0xa39', '0xdff'};\n            v101 = v2.call().value(v99).gas(!v99 * v0);\n            require(v101);\n            v2 = v102 = stor_8_0_19;\n            v0 = v103 = 2300;\n            v23 = v104 = 2683;\n            v25 = v105 = 0x197b(1, v0);\n            v106 = v2.call().value(v99).gas(!v99 * v0);\n            require(v106);\n            v2 = v107 = stor_8_0_19;\n            v0 = v108 = 2300;\n            v23 = v109 = 3583;\n            v25 = v110 = 0x197b(1, v0);\n        }\n        v6 = v111 = 2768;\n        v8 = 0x197b(33, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        assert(v0 <= v0);\n        v0 = v112 = v0 - v0;\n        v2 = v113 = 2812;\n        v6 = v114 = 1900;\n        v8 = 0x197b(1, v0);\n        v115 = v2.call().value(v0).gas(!v0 * v0);\n        require(v115);\n        v2 = v116 = stor_6_0_19;\n        v0 = v117 = 2300;\n        v6 = v118 = 3451;\n        v8 = 0x197b(1, v0);\n        v119 = v2.call().value(v0).gas(!v0 * v0);\n        require(v119);\n        v2 = v120 = stor_7_0_19;\n        v0 = v121 = 2300;\n        v23 = v122 = 3517;\n        v25 = v123 = 0x197b(1, v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0xf34dc16 == function_selector) {\n            canAcceptTokens_(address);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x294205b4 == function_selector) {\n            setCanAcceptTokens(address,bool);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x4411b711 == function_selector) {\n            changePromoter(address);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x88a8c95c == function_selector) {\n            changeDev(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab1eedb2 == function_selector) {\n            changePartner(address);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xcaa877e7 == function_selector) {\n            buyFor(address,address);\n        } else if (0xdf8089ef == function_selector) {\n            setAdministrator(address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 19:56 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _stakingRequirement; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0xa]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nuint256 stor_f; // STORAGE[0xf]\nuint256 _totalSupply; // STORAGE[0x10]\nuint256 owner_11; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _canAcceptTokens_; // STORAGE[0x13]\naddress _setStakingRequirement; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _onlyAmbassadors; // STORAGE[0xe] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x1007() private { \n    v0 = 0x1297(1);\n    require(v0 > 0);\n    v1 = 0x1297(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0x1297(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * owner_11 - _dividendsOf[msg.sender] >> 64) + owner_b[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * owner_11 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x13bf() private { \n    return _exit[msg.sender];\n}\n\nfunction 0x1466(uint256 varg0, uint256 varg1) private { \n    v0 = 0x13bf();\n    require(v0 > 0);\n    v1 = v2 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v1 = v3 = varg0 <= _exit[msg.sender];\n    }\n    require(v1);\n    v4 = 0x197b(5, varg0);\n    assert(100);\n    assert(v4 / 100 <= varg0);\n    v5 = varg0 - v4 / 100;\n    assert(v4 / 100 <= _totalSupply);\n    _totalSupply = _totalSupply - v4 / 100;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v6 = address(varg1);\n    v7 = _SafeAdd(v5, _exit[v6]);\n    v8 = address(varg1);\n    _exit[v8] = v7;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg0 * owner_11;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + v5 * owner_11;\n    assert(_totalSupply);\n    assert((v4 / 100 / 20000 << 64) / _totalSupply + owner_11 >= owner_11);\n    owner_11 += (v4 / 100 / 20000 << 64) / _totalSupply;\n    emit Transfer(msg.sender, address(varg1), v5);\n    return 1;\n}\n\nfunction 0x170f(uint256 varg0) private { \n    v0 = 0x13bf();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = varg0 / 20000;\n    v2 = 0x197b(10, v1);\n    assert(100);\n    assert(v2 / 100 <= v1);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v1 - v2 / 100 << 64) + varg0 * owner_11);\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert((v2 / 100 << 64) / _totalSupply + owner_11 >= owner_11);\n        owner_11 += (v2 / 100 << 64) / _totalSupply;\n    }\n    emit onTokenSell(msg.sender, varg0, v1 - v2 / 100);\n    return ;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x197b(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x656(0, msg.value, msg.sender, 449, v1);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * owner_11 - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction canAcceptTokens_(address varg0) public nonPayable { \n    return 0xff & _canAcceptTokens_[varg0];\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x197b(10, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    return 20000 * (varg0 - v0 / 100);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x197b(10, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    return varg0 - v0 / 100;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction setCanAcceptTokens(address varg0, bool varg1) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _canAcceptTokens_[varg0] = varg1 | ~0xff & _canAcceptTokens_[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0x1007();\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(varg0);\n    require(1 == 0xff & _canAcceptTokens_[varg0]);\n    v0 = 0x1466(varg1, varg0);\n    require(v0);\n    if (varg0.code.size > 0) {\n        MEM[32 + MEM[64]] = 0;\n        v1 = new array[](varg2.length);\n        require(varg0.code.size);\n        v2, v3 = varg0.tokenFallback(msg.sender, varg1, v1).gas(msg.gas - 710);\n        require(v2);\n        require(v3);\n    }\n    return 1;\n}\n\nfunction changePromoter(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_7_0_19 = varg0;\n}\n\nfunction sellPrice() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (7) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & '0.00005';\n    }\n    return v0;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x1297(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & '0.00005556';\n    }\n    return v0;\n}\n\nfunction changeDev(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_8_0_19 = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _setStakingRequirement;\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0x13bf();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1466(varg1, varg0);\n    return v0;\n}\n\nfunction changePartner(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_6_0_19 = varg0;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(_setStakingRequirement == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(_setStakingRequirement == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction buyFor(address varg0, address varg1) public payable { \n    v0 = 0x656(varg1, msg.value, varg0, 5820, 0);\n    return v0;\n}\n\nfunction setAdministrator(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _setStakingRequirement = varg0;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x170f(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x170f(_exit[msg.sender]);\n    }\n    0x1007();\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x656(varg0, msg.value, msg.sender, 4820, 0);\n    return 483;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x1297(1);\n    require(v0 > 0);\n    v1 = 0x1297(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x656(0, v1 + _dividendsOf[msg.sender], msg.sender, 6422, 0);\n    emit onReinvestment(808, v3, v2);\n}\n\nfunction 0x656(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v2 = v4 = 0;\n    v2 = v5 = 0;\n    if (block.timestamp >= stor_f) {\n        _onlyAmbassadors = 0;\n    }\n    if (!_onlyAmbassadors) {\n        _onlyAmbassadors = 0;\n        v6 = v7 = 2752;\n        v8 = v9 = 0x197b(10, varg1);\n    } else {\n        v10 = v11 = 1 == 0xff & owner_9[msg.sender];\n        if (v11) {\n            v10 = v12 = varg1 + owner_d[msg.sender] <= 0xde0b6b3a7640000;\n        }\n        require(v10);\n        v13 = _SafeAdd(varg1, owner_d[msg.sender]);\n        owner_d[msg.sender] = v13;\n        v6 = v14 = 1840;\n        v8 = v15 = 0x197b(10, varg1);\n    }\n    while (!100) {\n        assert(100);\n        v0 = v8 / 100;\n        goto {'0x76c', '0x9b5', '0x9f7', '0xac0', '0xad0', '0xd39', '0x740', '0x730', '0xd7b'};\n        v6 = v16 = 1856;\n        v8 = 0x197b(33, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        assert(v0 <= v0);\n        v0 = v17 = v0 - v0;\n        v2 = v18 = 1905;\n        v6 = v19 = 1900;\n        v8 = 0x197b(1, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        goto {'0xafc', '0x7a0', '0xb10', '0x785', '0xb38', '0x771', '0xb24', '0x7b4'};\n        v2 = v20 = 1925;\n        v6 = v21 = 1900;\n        v8 = 0x197b(1, v0);\n        v2 = v22 = 1952;\n        v23 = v24 = 1900;\n        v25 = v26 = 0x197b(1, v0);\n        v2 = v27 = 1972;\n        v23 = v28 = 1900;\n        v25 = v29 = 0x197b(1, v0);\n        v2 = v30 = 20000 * v0;\n        v31 = v32 = v0 << 64;\n        v33 = v34 = v30 > 0;\n        if (v34) {\n            v35 = _SafeAdd(_totalSupply, v30);\n            v33 = v36 = v35 > _totalSupply;\n        }\n        require(v33);\n        v37 = !address(v0);\n        v38 = v39 = address(v0);\n        if (address(v0)) {\n            v38 = v40 = address(v0) != address(v0);\n        }\n        if (v38) {\n            v41 = address(v0);\n            v38 = v42 = _exit[v41] >= _stakingRequirement;\n        }\n        if (!v38) {\n            v0 = _SafeAdd(v0, v0);\n            v31 = v43 = v0 << 64;\n        } else {\n            v44 = address(v0);\n            v45 = _SafeAdd(v0, owner_b[v44]);\n            v46 = address(v0);\n            owner_b[v46] = v45;\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v30;\n        } else {\n            v47 = _SafeAdd(v30, _totalSupply);\n            _totalSupply = v47;\n            assert(v47);\n            owner_11 = owner_11 + (v0 << 64) / v47;\n            assert(_totalSupply);\n            v31 = v48 = v31 - (v31 - v30 * ((v0 << 64) / _totalSupply));\n        }\n        v49 = address(v0);\n        v50 = _SafeAdd(v30, _exit[v49]);\n        v51 = address(v0);\n        _exit[v51] = v50;\n        v2 = v52 = v30 * owner_11 - v31;\n        _dividendsOf[v51] += v52;\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(v51, address(v0), v0, v30);\n        v2 = v53 = stor_5_0_19;\n        v0 = v54 = 2300;\n        v6 = v55 = 2485;\n        v8 = 0x197b(1, v0);\n        v2 = v56 = 2832;\n        v6 = v57 = 1900;\n        v8 = 0x197b(1, v0);\n        v2 = v58 = 2852;\n        v23 = v59 = 1900;\n        v25 = v60 = 0x197b(1, v0);\n        v2 = v61 = 2872;\n        v23 = v62 = 1900;\n        v25 = v63 = 0x197b(1, v0);\n        v2 = 20000 * v0;\n        v64 = v65 = v0 << 64;\n        v66 = v67 = v2 > 0;\n        if (v67) {\n            v68 = _SafeAdd(_totalSupply, v2);\n            v66 = v69 = v68 > _totalSupply;\n        }\n        require(v66);\n        v70 = !address(v0);\n        v71 = v72 = address(v0);\n        if (address(v0)) {\n            v71 = v73 = address(v0) != address(v0);\n        }\n        if (v71) {\n            v74 = address(v0);\n            v71 = v75 = _exit[v74] >= _stakingRequirement;\n        }\n        if (!v71) {\n            v0 = _SafeAdd(v0, v0);\n            v64 = v76 = v0 << 64;\n        } else {\n            v77 = address(v0);\n            v78 = _SafeAdd(v0, owner_b[v77]);\n            v79 = address(v0);\n            owner_b[v79] = v78;\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v2;\n        } else {\n            v80 = _SafeAdd(v2, _totalSupply);\n            _totalSupply = v80;\n            assert(v80);\n            owner_11 = owner_11 + (v0 << 64) / v80;\n            assert(_totalSupply);\n            v64 = v81 = v64 - (v64 - v2 * ((v0 << 64) / _totalSupply));\n        }\n        v82 = address(v0);\n        v83 = _SafeAdd(v2, _exit[v82]);\n        v84 = address(v0);\n        _exit[v84] = v83;\n        v2 = v85 = v2 * owner_11 - v64;\n        _dividendsOf[v84] += v85;\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(v84, address(v0), v0, v2);\n        v2 = v86 = stor_5_0_19;\n        v0 = v87 = 2300;\n        v6 = v88 = 3385;\n        v8 = 0x197b(1, v0);\n        v89 = v2.call().value(v0).gas(!v0 * v0);\n        require(v89);\n        v2 = v90 = stor_6_0_19;\n        v0 = v91 = 2300;\n        v6 = v92 = 2551;\n        v8 = 0x197b(1, v0);\n        v93 = v2.call().value(v0).gas(!v0 * v0);\n        require(v93);\n        v2 = v94 = stor_7_0_19;\n        v0 = v95 = 2300;\n        v23 = v96 = 2617;\n        v25 = v97 = 0x197b(1, v0);\n        while (!200) {\n            assert(200);\n            v98 = v2.call().value(v99).gas(!v99 * v0);\n            require(v98);\n            return v2;\n            v100 = v2.call().value(v99).gas(!v99 * v0);\n            require(v100);\n            v0 = v99 = v25 / 200;\n            goto {'0x76c', '0xdbd', '0xa7b', '0xa39', '0xdff'};\n            v101 = v2.call().value(v99).gas(!v99 * v0);\n            require(v101);\n            v2 = v102 = stor_8_0_19;\n            v0 = v103 = 2300;\n            v23 = v104 = 2683;\n            v25 = v105 = 0x197b(1, v0);\n            v106 = v2.call().value(v99).gas(!v99 * v0);\n            require(v106);\n            v2 = v107 = stor_8_0_19;\n            v0 = v108 = 2300;\n            v23 = v109 = 3583;\n            v25 = v110 = 0x197b(1, v0);\n        }\n        v6 = v111 = 2768;\n        v8 = 0x197b(33, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        assert(v0 <= v0);\n        v0 = v112 = v0 - v0;\n        v2 = v113 = 2812;\n        v6 = v114 = 1900;\n        v8 = 0x197b(1, v0);\n        v115 = v2.call().value(v0).gas(!v0 * v0);\n        require(v115);\n        v2 = v116 = stor_6_0_19;\n        v0 = v117 = 2300;\n        v6 = v118 = 3451;\n        v8 = 0x197b(1, v0);\n        v119 = v2.call().value(v0).gas(!v0 * v0);\n        require(v119);\n        v2 = v120 = stor_7_0_19;\n        v0 = v121 = 2300;\n        v23 = v122 = 3517;\n        v25 = v123 = 0x197b(1, v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0xf34dc16 == function_selector) {\n            canAcceptTokens_(address);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x294205b4 == function_selector) {\n            setCanAcceptTokens(address,bool);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x4411b711 == function_selector) {\n            changePromoter(address);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x88a8c95c == function_selector) {\n            changeDev(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab1eedb2 == function_selector) {\n            changePartner(address);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xcaa877e7 == function_selector) {\n            buyFor(address,address);\n        } else if (0xdf8089ef == function_selector) {\n            setAdministrator(address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.14 19:56 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _stakingRequirement; // STORAGE[0x4]\nmapping (uint256 => [uint256]) owner_9; // STORAGE[0x9]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0xa]\nmapping (uint256 => [uint256]) owner_b; // STORAGE[0xb]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0xc]\nmapping (uint256 => [uint256]) owner_d; // STORAGE[0xd]\nuint256 stor_f; // STORAGE[0xf]\nuint256 _totalSupply; // STORAGE[0x10]\nuint256 owner_11; // STORAGE[0x11]\nmapping (uint256 => [uint256]) _administrators; // STORAGE[0x12]\nmapping (uint256 => [uint256]) _canAcceptTokens_; // STORAGE[0x13]\naddress _setStakingRequirement; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\nuint8 _onlyAmbassadors; // STORAGE[0xe] bytes 0 to 0\naddress stor_5_0_19; // STORAGE[0x5] bytes 0 to 19\naddress stor_6_0_19; // STORAGE[0x6] bytes 0 to 19\naddress stor_7_0_19; // STORAGE[0x7] bytes 0 to 19\naddress stor_8_0_19; // STORAGE[0x8] bytes 0 to 19\n\n// Events\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x1007() private { \n    v0 = 0x1297(1);\n    require(v0 > 0);\n    v1 = 0x1297(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + _dividendsOf[msg.sender]).gas(2300 * !(v1 + _dividendsOf[msg.sender]));\n    require(v2);\n    emit onWithdraw(msg.sender, v1 + _dividendsOf[msg.sender]);\n    return ;\n}\n\nfunction 0x1297(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (_dividendsOf[msg.sender] * owner_11 - _dividendsOf[msg.sender] >> 64) + owner_b[msg.sender];\n    } else {\n        v0 = _dividendsOf[msg.sender] * owner_11 - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x13bf() private { \n    return _exit[msg.sender];\n}\n\nfunction 0x1466(uint256 varg0, uint256 varg1) private { \n    v0 = 0x13bf();\n    require(v0 > 0);\n    v1 = v2 = !_onlyAmbassadors;\n    if (!_onlyAmbassadors) {\n        v1 = v3 = varg0 <= _exit[msg.sender];\n    }\n    require(v1);\n    v4 = 0x197b(5, varg0);\n    assert(100);\n    assert(v4 / 100 <= varg0);\n    v5 = varg0 - v4 / 100;\n    assert(v4 / 100 <= _totalSupply);\n    _totalSupply = _totalSupply - v4 / 100;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v6 = address(varg1);\n    v7 = _SafeAdd(v5, _exit[v6]);\n    v8 = address(varg1);\n    _exit[v8] = v7;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - varg0 * owner_11;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + v5 * owner_11;\n    assert(_totalSupply);\n    assert((v4 / 100 / 20000 << 64) / _totalSupply + owner_11 >= owner_11);\n    owner_11 += (v4 / 100 / 20000 << 64) / _totalSupply;\n    emit Transfer(msg.sender, address(varg1), v5);\n    return 1;\n}\n\nfunction 0x170f(uint256 varg0) private { \n    v0 = 0x13bf();\n    require(v0 > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v1 = varg0 / 20000;\n    v2 = 0x197b(10, v1);\n    assert(100);\n    assert(v2 / 100 <= v1);\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - ((v1 - v2 / 100 << 64) + varg0 * owner_11);\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert((v2 / 100 << 64) / _totalSupply + owner_11 >= owner_11);\n        owner_11 += (v2 / 100 << 64) / _totalSupply;\n    }\n    emit onTokenSell(msg.sender, varg0, v1 - v2 / 100);\n    return ;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction 0x197b(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x656(0, msg.value, msg.sender, 449, v1);\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return _dividendsOf[varg0] * owner_11 - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction canAcceptTokens_(address varg0) public nonPayable { \n    return 0xff & _canAcceptTokens_[varg0];\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x197b(10, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    return 20000 * (varg0 - v0 / 100);\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x197b(10, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    return varg0 - v0 / 100;\n}\n\nfunction onlyAmbassadors() public nonPayable { \n    return _onlyAmbassadors;\n}\n\nfunction setCanAcceptTokens(address varg0, bool varg1) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _canAcceptTokens_[varg0] = varg1 | ~0xff & _canAcceptTokens_[varg0];\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction administrators(bytes32 varg0) public nonPayable { \n    return 0xff & _administrators[varg0];\n}\n\nfunction withdraw() public nonPayable { \n    0x1007();\n}\n\nfunction transferAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    require(varg0);\n    require(1 == 0xff & _canAcceptTokens_[varg0]);\n    v0 = 0x1466(varg1, varg0);\n    require(v0);\n    if (varg0.code.size > 0) {\n        MEM[32 + MEM[64]] = 0;\n        v1 = new array[](varg2.length);\n        require(varg0.code.size);\n        v2, v3 = varg0.tokenFallback(msg.sender, varg1, v1).gas(msg.gas - 710);\n        require(v2);\n        require(v3);\n    }\n    return 1;\n}\n\nfunction changePromoter(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_7_0_19 = varg0;\n}\n\nfunction sellPrice() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (7) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffffff & '0.00005';\n    }\n    return v0;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x1297(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction setStakingRequirement(uint256 varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _stakingRequirement = varg0;\n}\n\nfunction buyPrice() public nonPayable { \n    MEM[MEM[64]] = 0;\n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v1.data + v2];\n        v2 += 32;\n    }\n    if (10) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffff & '0.00005556';\n    }\n    return v0;\n}\n\nfunction changeDev(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_8_0_19 = varg0;\n}\n\nfunction owner() public nonPayable { \n    return _setStakingRequirement;\n}\n\nfunction myTokens() public nonPayable { \n    v0 = 0x13bf();\n    return v0;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction disableInitialStage() public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _onlyAmbassadors = 0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = 0x1466(varg1, varg0);\n    return v0;\n}\n\nfunction changePartner(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    stor_6_0_19 = varg0;\n}\n\nfunction setSymbol(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(_setStakingRequirement == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _symbol.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _symbol.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _symbol.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction setName(string varg0) public nonPayable { \n    v0 = new bytes[](varg0.length);\n    CALLDATACOPY(v0.data, varg0 + 36, varg0.length);\n    require(_setStakingRequirement == msg.sender);\n    v1 = v2 = v0.data;\n    if (31 < v0.length) {\n        _name.length = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v2 + v0.length > v1) {\n                STORAGE[v3] = MEM[v1];\n                v1 += 32;\n                v3 += 1;\n            }\n        }\n    } else {\n        _name.length = v0.length + v0.length | ~0xff & MEM[v2];\n    }\n    while (v4 + (31 + _name.length >> 5) > v3) {\n        STORAGE[v3] = 0;\n        v3 += 1;\n    }\n}\n\nfunction buyFor(address varg0, address varg1) public payable { \n    v0 = 0x656(varg1, msg.value, varg0, 5820, 0);\n    return v0;\n}\n\nfunction setAdministrator(address varg0) public nonPayable { \n    require(_setStakingRequirement == msg.sender);\n    _setStakingRequirement = varg0;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x170f(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x170f(_exit[msg.sender]);\n    }\n    0x1007();\n}\n\nfunction buy(address varg0) public payable { \n    v0 = 0x656(varg0, msg.value, msg.sender, 4820, 0);\n    return 483;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x1297(1);\n    require(v0 > 0);\n    v1 = 0x1297(0);\n    _dividendsOf[msg.sender] += v1 << 64;\n    _dividendsOf[msg.sender] = 0;\n    v2 = 0x656(0, v1 + _dividendsOf[msg.sender], msg.sender, 6422, 0);\n    emit onReinvestment(808, v3, v2);\n}\n\nfunction 0x656(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v2 = v4 = 0;\n    v2 = v5 = 0;\n    if (block.timestamp >= stor_f) {\n        _onlyAmbassadors = 0;\n    }\n    if (!_onlyAmbassadors) {\n        _onlyAmbassadors = 0;\n        v6 = v7 = 2752;\n        v8 = v9 = 0x197b(10, varg1);\n    } else {\n        v10 = v11 = 1 == 0xff & owner_9[msg.sender];\n        if (v11) {\n            v10 = v12 = varg1 + owner_d[msg.sender] <= 0xde0b6b3a7640000;\n        }\n        require(v10);\n        v13 = _SafeAdd(varg1, owner_d[msg.sender]);\n        owner_d[msg.sender] = v13;\n        v6 = v14 = 1840;\n        v8 = v15 = 0x197b(10, varg1);\n    }\n    while (!100) {\n        assert(100);\n        v0 = v8 / 100;\n        goto {'0x76c', '0x9b5', '0x9f7', '0xac0', '0xad0', '0xd39', '0x740', '0x730', '0xd7b'};\n        v6 = v16 = 1856;\n        v8 = 0x197b(33, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        assert(v0 <= v0);\n        v0 = v17 = v0 - v0;\n        v2 = v18 = 1905;\n        v6 = v19 = 1900;\n        v8 = 0x197b(1, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        goto {'0xafc', '0x7a0', '0xb10', '0x785', '0xb38', '0x771', '0xb24', '0x7b4'};\n        v2 = v20 = 1925;\n        v6 = v21 = 1900;\n        v8 = 0x197b(1, v0);\n        v2 = v22 = 1952;\n        v23 = v24 = 1900;\n        v25 = v26 = 0x197b(1, v0);\n        v2 = v27 = 1972;\n        v23 = v28 = 1900;\n        v25 = v29 = 0x197b(1, v0);\n        v2 = v30 = 20000 * v0;\n        v31 = v32 = v0 << 64;\n        v33 = v34 = v30 > 0;\n        if (v34) {\n            v35 = _SafeAdd(_totalSupply, v30);\n            v33 = v36 = v35 > _totalSupply;\n        }\n        require(v33);\n        v37 = !address(v0);\n        v38 = v39 = address(v0);\n        if (address(v0)) {\n            v38 = v40 = address(v0) != address(v0);\n        }\n        if (v38) {\n            v41 = address(v0);\n            v38 = v42 = _exit[v41] >= _stakingRequirement;\n        }\n        if (!v38) {\n            v0 = _SafeAdd(v0, v0);\n            v31 = v43 = v0 << 64;\n        } else {\n            v44 = address(v0);\n            v45 = _SafeAdd(v0, owner_b[v44]);\n            v46 = address(v0);\n            owner_b[v46] = v45;\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v30;\n        } else {\n            v47 = _SafeAdd(v30, _totalSupply);\n            _totalSupply = v47;\n            assert(v47);\n            owner_11 = owner_11 + (v0 << 64) / v47;\n            assert(_totalSupply);\n            v31 = v48 = v31 - (v31 - v30 * ((v0 << 64) / _totalSupply));\n        }\n        v49 = address(v0);\n        v50 = _SafeAdd(v30, _exit[v49]);\n        v51 = address(v0);\n        _exit[v51] = v50;\n        v2 = v52 = v30 * owner_11 - v31;\n        _dividendsOf[v51] += v52;\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(v51, address(v0), v0, v30);\n        v2 = v53 = stor_5_0_19;\n        v0 = v54 = 2300;\n        v6 = v55 = 2485;\n        v8 = 0x197b(1, v0);\n        v2 = v56 = 2832;\n        v6 = v57 = 1900;\n        v8 = 0x197b(1, v0);\n        v2 = v58 = 2852;\n        v23 = v59 = 1900;\n        v25 = v60 = 0x197b(1, v0);\n        v2 = v61 = 2872;\n        v23 = v62 = 1900;\n        v25 = v63 = 0x197b(1, v0);\n        v2 = 20000 * v0;\n        v64 = v65 = v0 << 64;\n        v66 = v67 = v2 > 0;\n        if (v67) {\n            v68 = _SafeAdd(_totalSupply, v2);\n            v66 = v69 = v68 > _totalSupply;\n        }\n        require(v66);\n        v70 = !address(v0);\n        v71 = v72 = address(v0);\n        if (address(v0)) {\n            v71 = v73 = address(v0) != address(v0);\n        }\n        if (v71) {\n            v74 = address(v0);\n            v71 = v75 = _exit[v74] >= _stakingRequirement;\n        }\n        if (!v71) {\n            v0 = _SafeAdd(v0, v0);\n            v64 = v76 = v0 << 64;\n        } else {\n            v77 = address(v0);\n            v78 = _SafeAdd(v0, owner_b[v77]);\n            v79 = address(v0);\n            owner_b[v79] = v78;\n        }\n        if (_totalSupply <= 0) {\n            _totalSupply = v2;\n        } else {\n            v80 = _SafeAdd(v2, _totalSupply);\n            _totalSupply = v80;\n            assert(v80);\n            owner_11 = owner_11 + (v0 << 64) / v80;\n            assert(_totalSupply);\n            v64 = v81 = v64 - (v64 - v2 * ((v0 << 64) / _totalSupply));\n        }\n        v82 = address(v0);\n        v83 = _SafeAdd(v2, _exit[v82]);\n        v84 = address(v0);\n        _exit[v84] = v83;\n        v2 = v85 = v2 * owner_11 - v64;\n        _dividendsOf[v84] += v85;\n        emit 0x22c0d992e4d873a3748436d960d5140c1f9721cf73f7ca5ec679d3d9f4fe2d5(v84, address(v0), v0, v2);\n        v2 = v86 = stor_5_0_19;\n        v0 = v87 = 2300;\n        v6 = v88 = 3385;\n        v8 = 0x197b(1, v0);\n        v89 = v2.call().value(v0).gas(!v0 * v0);\n        require(v89);\n        v2 = v90 = stor_6_0_19;\n        v0 = v91 = 2300;\n        v6 = v92 = 2551;\n        v8 = 0x197b(1, v0);\n        v93 = v2.call().value(v0).gas(!v0 * v0);\n        require(v93);\n        v2 = v94 = stor_7_0_19;\n        v0 = v95 = 2300;\n        v23 = v96 = 2617;\n        v25 = v97 = 0x197b(1, v0);\n        while (!200) {\n            assert(200);\n            v98 = v2.call().value(v99).gas(!v99 * v0);\n            require(v98);\n            return v2;\n            v100 = v2.call().value(v99).gas(!v99 * v0);\n            require(v100);\n            v0 = v99 = v25 / 200;\n            goto {'0x76c', '0xdbd', '0xa7b', '0xa39', '0xdff'};\n            v101 = v2.call().value(v99).gas(!v99 * v0);\n            require(v101);\n            v2 = v102 = stor_8_0_19;\n            v0 = v103 = 2300;\n            v23 = v104 = 2683;\n            v25 = v105 = 0x197b(1, v0);\n            v106 = v2.call().value(v99).gas(!v99 * v0);\n            require(v106);\n            v2 = v107 = stor_8_0_19;\n            v0 = v108 = 2300;\n            v23 = v109 = 3583;\n            v25 = v110 = 0x197b(1, v0);\n        }\n        v6 = v111 = 2768;\n        v8 = 0x197b(33, v0);\n        assert(v0 <= v0);\n        v0 = v0 - v0;\n        assert(v0 <= v0);\n        v0 = v112 = v0 - v0;\n        v2 = v113 = 2812;\n        v6 = v114 = 1900;\n        v8 = 0x197b(1, v0);\n        v115 = v2.call().value(v0).gas(!v0 * v0);\n        require(v115);\n        v2 = v116 = stor_6_0_19;\n        v0 = v117 = 2300;\n        v6 = v118 = 3451;\n        v8 = 0x197b(1, v0);\n        v119 = v2.call().value(v0).gas(!v0 * v0);\n        require(v119);\n        v2 = v120 = stor_7_0_19;\n        v0 = v121 = 2300;\n        v23 = v122 = 3517;\n        v25 = v123 = 0x197b(1, v0);\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x65318b) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0xf34dc16 == function_selector) {\n            canAcceptTokens_(address);\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x27defa1f == function_selector) {\n            onlyAmbassadors();\n        } else if (0x294205b4 == function_selector) {\n            setCanAcceptTokens(address,bool);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x392efb52 == function_selector) {\n            administrators(bytes32);\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4000aea0 == function_selector) {\n            transferAndCall(address,uint256,bytes);\n        } else if (0x4411b711 == function_selector) {\n            changePromoter(address);\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8328b610 == function_selector) {\n            setStakingRequirement(uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x88a8c95c == function_selector) {\n            changeDev(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa8e04f34 == function_selector) {\n            disableInitialStage();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xab1eedb2 == function_selector) {\n            changePartner(address);\n        } else if (0xb84c8246 == function_selector) {\n            setSymbol(string);\n        } else if (0xc47f0027 == function_selector) {\n            setName(string);\n        } else if (0xcaa877e7 == function_selector) {\n            buyFor(address,address);\n        } else if (0xdf8089ef == function_selector) {\n            setAdministrator(address);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 31.2499361038208,
	"usage": {
		"completion_tokens": 571,
		"prompt_tokens": 7248,
		"total_tokens": 7819
	}
}