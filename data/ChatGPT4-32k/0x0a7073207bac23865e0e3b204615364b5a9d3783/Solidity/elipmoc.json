{
	"address": "0x0a7073207bac23865e0e3b204615364b5a9d3783",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code corresponding to the given decompiled code:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract InvestmentContract {\n    mapping (address => uint256) private _getInvested;\n    mapping (address => uint256) private _lastInvest;\n    mapping (address => uint256) private _getAffiliateCommision;\n    address private _investETH;\n    address private stor_4_0_19;\n    \n    function affiliateCommision(address varg0) public view returns(uint256) { \n        return _getAffiliateCommision[varg0];\n    }\n\n    function getProfitFromSender() public view returns(uint256) { \n        return calculateProfit(msg.sender);\n    }\n\n    function investETH(address varg0) public payable { \n        require(msg.value >= 1 ether);\n        uint256 profit = calculateProfit(msg.sender);\n        if (profit > 0) {\n            _lastInvest[msg.sender] = now;\n            msg.sender.transfer(profit);\n        }\n        uint256 commission = msg.value / 20;\n        if (varg0 != msg.sender && varg0 != _investETH && varg0 != stor_4_0_19 && varg0 != 0x0000000000000000000000000000000000000001) {\n            _getAffiliateCommision[varg0] += commission;\n        }\n        _getAffiliateCommision[_investETH] += commission;\n        _getAffiliateCommision[stor_4_0_19] += commission;\n        _getInvested[msg.sender] += msg.value;\n        _lastInvest[msg.sender] = now;\n    }\n\n    function lastInvest(address varg0) public view returns(uint256) { \n        return _lastInvest[varg0];\n    }\n\n    function getInvested() public view returns(uint256) { \n        return _getInvested[msg.sender];\n    }\n\n    function getProfit(address varg0) public view returns(uint256) { \n        return calculateProfit(varg0);\n    }\n\n    function investedETH(address varg0) public view returns(uint256) {\n        return _getInvested[varg0];\n    }\n\n    function reinvestProfit() public { \n        uint256 profit = calculateProfit(msg.sender);\n        require(profit > 0);\n        _lastInvest[msg.sender] = now;\n        _getInvested[msg.sender] += profit;\n    }\n\n    function withdrawAffiliateCommision() public { \n        uint256 commission = _getAffiliateCommision[msg.sender];\n        require(commission > 0);\n        _getAffiliateCommision[msg.sender] = 0;\n        msg.sender.transfer(commission);\n    }\n\n    function calculateProfit(address user) private view returns(uint256) { \n        uint256 timeDifference = now - _lastInvest[user];\n        uint256 rate = _getInvested[user] * timeDifference;\n        return rate / 8640000; // 100 days in seconds\n    }\n\n    function getBalance() public view returns(uint256) { \n        return address(this).balance;\n    }\n\n    function withdraw() public { \n        uint256 profit = calculateProfit(msg.sender);\n        require(profit > 0);\n        _lastInvest[msg.sender] = now;\n        msg.sender.transfer(profit);\n    }\n\n    function getAffiliateCommision() public view returns(uint256) { \n        return _getAffiliateCommision[msg.sender];\n    }\n\n    function() external payable { \n        revert();\n    }\n}\n```\n\nPlease note that the decompiled code was not complete and did not contain any variable type or function names. The provided solidity code is an interpretation and adaptation of the decompiled code. Some assumptions have been made about the functionality of the contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469938,
	"id": "chatcmpl-8R6LSh7hU6WqX9Oa4Vzm875EVD7MQ",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 07:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x6f05b59d3b20000);\n    v0 = 0x4ad(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x4ad(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2);\n    }\n    v3 = _SafeDiv(20, msg.value);\n    v4 = v5 = varg0 != msg.sender;\n    if (v5) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    assert(v3 + _getAffiliateCommision[_investETH] >= _getAffiliateCommision[_investETH]);\n    _getAffiliateCommision[_investETH] += v3;\n    assert(v3 + _getAffiliateCommision[stor_4_0_19] >= _getAffiliateCommision[stor_4_0_19]);\n    _getAffiliateCommision[stor_4_0_19] += v3;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x4ad(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(_getAffiliateCommision[msg.sender] > 0);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0);\n}\n\nfunction 0x4ad(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = _SafeDiv(0x54600, v2);\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1);\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x12065fe0) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 07:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x6f05b59d3b20000);\n    v0 = 0x4ad(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x4ad(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2);\n    }\n    v3 = _SafeDiv(20, msg.value);\n    v4 = v5 = varg0 != msg.sender;\n    if (v5) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    assert(v3 + _getAffiliateCommision[_investETH] >= _getAffiliateCommision[_investETH]);\n    _getAffiliateCommision[_investETH] += v3;\n    assert(v3 + _getAffiliateCommision[stor_4_0_19] >= _getAffiliateCommision[stor_4_0_19]);\n    _getAffiliateCommision[stor_4_0_19] += v3;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x4ad(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(_getAffiliateCommision[msg.sender] > 0);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0);\n}\n\nfunction 0x4ad(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = _SafeDiv(0x54600, v2);\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1);\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x12065fe0) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 07:33 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x6f05b59d3b20000);\n    v0 = 0x4ad(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x4ad(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2);\n    }\n    v3 = _SafeDiv(20, msg.value);\n    v4 = v5 = varg0 != msg.sender;\n    if (v5) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    assert(v3 + _getAffiliateCommision[_investETH] >= _getAffiliateCommision[_investETH]);\n    _getAffiliateCommision[_investETH] += v3;\n    assert(v3 + _getAffiliateCommision[stor_4_0_19] >= _getAffiliateCommision[stor_4_0_19]);\n    _getAffiliateCommision[stor_4_0_19] += v3;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x4ad(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(_getAffiliateCommision[msg.sender] > 0);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0);\n}\n\nfunction 0x4ad(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = _SafeDiv(0x54600, v2);\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction getBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction withdraw() public nonPayable { \n    v0 = 0x4ad(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1);\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x12065fe0) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 33.88500380516052,
	"usage": {
		"completion_tokens": 780,
		"prompt_tokens": 1584,
		"total_tokens": 2364
	}
}