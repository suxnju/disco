{
	"address": "0xfc8eeb3ab713c1bd98e16ae906d9a99fd7598632",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here's a Solidity representation of the given decompiled code. Note that due to the nature of decompiled code, some parts may not translate perfectly, and certain variable and function names may be replaced by their memory addresses or similar identifiers:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract ICO {\n    // Variables\n    uint256 private _refund;\n    uint256 private stor_2;\n    uint256 private stor_3;\n    mapping (uint256 => uint256) private _balances;\n    uint256 private _startIcoPreICO;\n    uint256 private _startIcoPreICO2ndRound;\n    uint256 private _startIcoMainSale;\n    uint256 private _endIcoPreICO;\n    uint256 private _endIcoMainSale;\n    uint256 private _totalSoldTokens;\n    uint256 private _minPurchasePreICO;\n    uint256 private _rateIcoPreICO;\n    uint256 private _rateIcoMainSale;\n    uint256 private _unconfirmedSum;\n    mapping (uint256 => uint256) private _unconfirmedSumAddr;\n    address private _owner;\n    address private _token;\n    address private _wallet;\n    \n    // Events\n    event TokenProcurement(address indexed buyer, address indexed varg0, uint256 value, uint256 amount);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    // Functions\n    function rateIcoPreICO() public view returns (uint256) {\n        return _rateIcoPreICO;\n    }\n\n    // Other functions omitted for brevity...\n    \n    function transferOwnership(address newOwner) public {\n        require(msg.sender == _owner);\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    // Fallback function\n    fallback() external payable {\n        // Logic...\n    }\n}\n```\n\nPlease note that this is a simplified version of the contract, and many of the original functions have been omitted for brevity. Also, the original contract seems to interact with another contract (`_token`), which isn't fully defined in the provided code, so those interactions are not completely accurate in the Solidity version. You will need to replace placeholders such as `// Logic...` with the actual implementation depending on your specific needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1701462565,
	"id": "chatcmpl-8R4QXmz6p0QtjLqx1GWDm581gou2Q",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.23 23:44 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _refund; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x5]\nuint256 _startIcoPreICO; // STORAGE[0x6]\nuint256 _startIcoPreICO2ndRound; // STORAGE[0x7]\nuint256 _startIcoMainSale; // STORAGE[0x8]\nuint256 _endIcoPreICO; // STORAGE[0x9]\nuint256 _endIcoMainSale; // STORAGE[0xa]\nuint256 _totalSoldTokens; // STORAGE[0xb]\nuint256 _minPurchasePreICO; // STORAGE[0xc]\nuint256 _rateIcoPreICO; // STORAGE[0xd]\nuint256 _rateIcoMainSale; // STORAGE[0xe]\nuint256 _unconfirmedSum; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _unconfirmedSumAddr; // STORAGE[0x10]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x4] bytes 0 to 19\naddress _wallet; // STORAGE[0x11] bytes 0 to 19\n\n// Events\nTokenProcurement(address, address, uint256, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1737(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = varg0 >= _startIcoPreICO;\n    if (v5) {\n        v4 = v6 = varg0 < _endIcoPreICO;\n    }\n    if (v4) {\n        v2 = v7 = _rateIcoPreICO;\n    }\n    v8 = v9 = varg0 >= _startIcoMainSale;\n    if (v9) {\n        v8 = v10 = varg0 < _endIcoMainSale;\n    }\n    if (v8) {\n        v2 = v11 = _rateIcoMainSale;\n    }\n    v12 = v13 = varg0 >= _startIcoPreICO;\n    if (v13) {\n        v12 = v14 = varg0 < _startIcoPreICO2ndRound;\n    }\n    if (!v12) {\n        v15 = v16 = varg0 >= _startIcoPreICO2ndRound;\n        if (v16) {\n            v15 = v17 = varg0 < _endIcoPreICO;\n        }\n        if (!v15) {\n            if (varg0 >= _startIcoMainSale) {\n                v0 = v18 = 100 - ((varg0 - _startIcoMainSale) / 0x15180 << 1);\n                if (v18 < 0) {\n                    v0 = v19 = 0;\n                }\n            }\n        } else {\n            v0 = v20 = 200;\n        }\n    } else {\n        v0 = v21 = 300;\n    }\n    v22 = 0x2479(v0, v2);\n    assert(1000);\n    return v2 + v22 / 1000;\n}\n\nfunction fallback() public payable { \n    0x971(msg.sender);\n}\n\nfunction rateIcoPreICO() public nonPayable { \n    return _rateIcoPreICO;\n}\n\nfunction getRateIcoWithBonus() public nonPayable { \n    v0 = 0x1737(block.timestamp);\n    return v0;\n}\n\nfunction endIcoMainSale() public nonPayable { \n    return _endIcoMainSale;\n}\n\nfunction 0x2479(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction startIcoPreICO2ndRound() public nonPayable { \n    return _startIcoPreICO2ndRound;\n}\n\nfunction setStartIcoPreICO2ndRound(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = varg0 > _startIcoPreICO;\n    if (v1) {\n        v0 = v2 = varg0 < _endIcoPreICO;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO2ndRound = varg0;\n}\n\nfunction SetPermissionsList(address varg0, uint8 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token.code.size);\n    v2 = _token.SetPermissionsList(varg0, 0xff & (0xff & (0xff & varg1))).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    if (0xff & (0xff & varg1) == 0) {\n        if (0xff & v1 != 0xff & (0xff & varg1)) {\n            assert(_unconfirmedSumAddr[varg0] <= _unconfirmedSum);\n            _unconfirmedSum = _unconfirmedSum - _unconfirmedSumAddr[varg0];\n            _unconfirmedSumAddr[varg0] = 0;\n        }\n    }\n}\n\nfunction setStartIcoMainICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = _endIcoPreICO < varg0;\n    if (v1) {\n        v0 = v2 = varg0 < _endIcoMainSale;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoMainSale = varg0;\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0 = _token.unpause().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction transferEthToMultisig() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = block.timestamp < _startIcoMainSale;\n    if (block.timestamp >= _startIcoMainSale) {\n        assert(_unconfirmedSum <= _totalSoldTokens);\n        v0 = v2 = _totalSoldTokens - _unconfirmedSum >= _refund;\n        if (v2) {\n            v0 = block.timestamp > _endIcoMainSale;\n        }\n    }\n    require(v0);\n    v3 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction rateIcoMainSale() public nonPayable { \n    return _rateIcoMainSale;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction minPurchasePreICO() public nonPayable { \n    return _minPurchasePreICO;\n}\n\nfunction refund() public nonPayable { \n    assert(_unconfirmedSum <= _totalSoldTokens);\n    v0 = v1 = _totalSoldTokens - _unconfirmedSum < _refund;\n    if (v1) {\n        v0 = block.timestamp > _endIcoMainSale;\n    }\n    require(v0);\n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    v2 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getRateIcoWithBonusByDate(uint256 varg0) public nonPayable { \n    v0 = 0x1737(varg0);\n    return v0;\n}\n\nfunction endIcoPreICO() public nonPayable { \n    return _endIcoPreICO;\n}\n\nfunction GetPermissionsList(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return 0xff & (0xff & v1);\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0 = _token.pause().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction contractBalanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setStartIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 < _endIcoPreICO);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO = varg0;\n}\n\nfunction unconfirmedSum() public nonPayable { \n    return _unconfirmedSum;\n}\n\nfunction setEndIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = _startIcoPreICO < varg0;\n    if (v1) {\n        v0 = v2 = varg0 < _startIcoMainSale;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _endIcoPreICO = varg0;\n}\n\nfunction setIcoDates(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 < varg1);\n    require(varg1 < varg2);\n    require(varg2 <= varg3);\n    require(varg3 < varg4);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO = varg0;\n    _startIcoPreICO2ndRound = varg1;\n    _endIcoPreICO = varg2;\n    _startIcoMainSale = varg3;\n    _endIcoMainSale = varg4;\n}\n\nfunction startIcoMainSale() public nonPayable { \n    return _startIcoMainSale;\n}\n\nfunction procureTokens(address varg0) public payable { \n    0x971(varg0);\n}\n\nfunction setRateIcoMainSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rateIcoMainSale = varg0;\n}\n\nfunction startIcoPreICO() public nonPayable { \n    return _startIcoPreICO;\n}\n\nfunction refundUnconfirmed() public nonPayable { \n    require(block.timestamp > _endIcoMainSale + 0x15180);\n    require(_balances[msg.sender] > 0);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0xff & v1 == 1);\n    _balances[msg.sender] = 0;\n    v2 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v2); // checks call status, propagates error data on error\n    _unconfirmedSumAddr[msg.sender] = 0;\n    require(_token.code.size);\n    v3 = _token.burn(msg.sender, _unconfirmedSumAddr[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction totalSoldTokens() public nonPayable { \n    return _totalSoldTokens;\n}\n\nfunction setRateIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rateIcoPreICO = varg0;\n}\n\nfunction setEndIcoMainICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_startIcoMainSale < varg0);\n    require(block.timestamp < _startIcoPreICO);\n    _endIcoMainSale = varg0;\n}\n\nfunction tokenBalanceOf(address varg0) public nonPayable { \n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction unconfirmedSumAddr(address varg0) public nonPayable { \n    return _unconfirmedSumAddr[varg0];\n}\n\nfunction 0x971(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = msg.value;\n    require(address(varg0) != 0);\n    v6 = 0x1737(block.timestamp);\n    v7 = v8 = block.timestamp >= _startIcoPreICO;\n    if (v8) {\n        v7 = v9 = block.timestamp < _endIcoPreICO;\n    }\n    if (v7) {\n        v7 = v10 = _totalSoldTokens < stor_2;\n    }\n    if (v7) {\n        require(v5 >= _minPurchasePreICO);\n        v0 = v11 = 0x2479(v6, v5);\n        assert(_totalSoldTokens <= stor_2);\n        if (stor_2 - _totalSoldTokens < v11) {\n            assert(_totalSoldTokens <= stor_2);\n            v0 = v12 = stor_2 - _totalSoldTokens;\n            assert(v6);\n            v4 = v13 = v12 / v6;\n            assert(v13 <= msg.value);\n            v2 = v14 = msg.value - v13;\n        }\n    }\n    assert(stor_3 + stor_2 >= stor_3);\n    v15 = v16 = block.timestamp >= _startIcoMainSale;\n    if (v16) {\n        v15 = v17 = block.timestamp < _endIcoMainSale;\n    }\n    if (v15) {\n        v15 = v18 = _totalSoldTokens < stor_3 + stor_2;\n    }\n    if (v15) {\n        v0 = v19 = 0x2479(v6, v4);\n        assert(_totalSoldTokens <= stor_3 + stor_2);\n        if (stor_3 + stor_2 - _totalSoldTokens < v19) {\n            assert(_totalSoldTokens <= stor_3 + stor_2);\n            v0 = stor_3 + stor_2 - _totalSoldTokens;\n            assert(v6);\n            v4 = v0 / v6;\n            assert(v4 <= msg.value);\n            v2 = msg.value - v4;\n        }\n    }\n    require(v0 > 0);\n    assert(_totalSoldTokens + v0 >= _totalSoldTokens);\n    _totalSoldTokens = _totalSoldTokens + v0;\n    assert(_balances[msg.sender] + v4 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v4;\n    require(_token.code.size);\n    v20, v21 = _token.mint(msg.sender, v0).gas(msg.gas);\n    require(v20); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(_unconfirmedSum + v0 >= _unconfirmedSum);\n    _unconfirmedSum = _unconfirmedSum + v0;\n    assert(_unconfirmedSumAddr[msg.sender] + v0 >= _unconfirmedSumAddr[msg.sender]);\n    _unconfirmedSumAddr[msg.sender] = _unconfirmedSumAddr[msg.sender] + v0;\n    v22 = address(varg0);\n    require(_token.code.size);\n    v23 = _token.SetPermissionsList(v22, 1).gas(msg.gas);\n    require(v23); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v24 = msg.sender.call().value(v2).gas(!v2 * 2300);\n        require(v24); // checks call status, propagates error data on error\n    }\n    emit TokenProcurement(msg.sender, address(varg0), v4, v0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1e1bcf7 == function_selector) {\n            rateIcoPreICO();\n        } else if (0x207beb59 == function_selector) {\n            getRateIcoWithBonus();\n        } else if (0x243eb89f == function_selector) {\n            endIcoMainSale();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x29bd028a == function_selector) {\n            startIcoPreICO2ndRound();\n        } else if (0x34b4eef2 == function_selector) {\n            setStartIcoPreICO2ndRound(uint256);\n        } else if (0x3871bf85 == function_selector) {\n            SetPermissionsList(address,uint8);\n        } else if (0x3af9e169 == function_selector) {\n            setStartIcoMainICO(uint256);\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x476a73ec == function_selector) {\n            transferEthToMultisig();\n        } else if (0x51fb4001 == function_selector) {\n            rateIcoMainSale();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x5509f0f3 == function_selector) {\n            minPurchasePreICO();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x5a86c914 == function_selector) {\n            getRateIcoWithBonusByDate(uint256);\n        } else if (0x7aae42c9 == function_selector) {\n            endIcoPreICO();\n        } else if (0x7d38b027 == function_selector) {\n            GetPermissionsList(address);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8481573e == function_selector) {\n            contractBalanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8fae065c == function_selector) {\n            setStartIcoPreICO(uint256);\n        } else if (0xa0493834 == function_selector) {\n            unconfirmedSum();\n        } else if (0xafaaa654 == function_selector) {\n            setEndIcoPreICO(uint256);\n        } else if (0xb734cbba == function_selector) {\n            setIcoDates(uint256,uint256,uint256,uint256,uint256);\n        } else if (0xb75014c0 == function_selector) {\n            startIcoMainSale();\n        } else if (0xc70dd8b3 == function_selector) {\n            procureTokens(address);\n        } else if (0xd186659d == function_selector) {\n            setRateIcoMainSale(uint256);\n        } else if (0xd1eca85e == function_selector) {\n            startIcoPreICO();\n        } else if (0xd3631e00 == function_selector) {\n            refundUnconfirmed();\n        } else if (0xd7ca9949 == function_selector) {\n            totalSoldTokens();\n        } else if (0xdb71c776 == function_selector) {\n            setRateIcoPreICO(uint256);\n        } else if (0xdcbad97b == function_selector) {\n            setEndIcoMainICO(uint256);\n        } else if (0xe42c08f2 == function_selector) {\n            tokenBalanceOf(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfc9a5097 == function_selector) {\n            unconfirmedSumAddr(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 23:44 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _refund; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x5]\nuint256 _startIcoPreICO; // STORAGE[0x6]\nuint256 _startIcoPreICO2ndRound; // STORAGE[0x7]\nuint256 _startIcoMainSale; // STORAGE[0x8]\nuint256 _endIcoPreICO; // STORAGE[0x9]\nuint256 _endIcoMainSale; // STORAGE[0xa]\nuint256 _totalSoldTokens; // STORAGE[0xb]\nuint256 _minPurchasePreICO; // STORAGE[0xc]\nuint256 _rateIcoPreICO; // STORAGE[0xd]\nuint256 _rateIcoMainSale; // STORAGE[0xe]\nuint256 _unconfirmedSum; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _unconfirmedSumAddr; // STORAGE[0x10]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x4] bytes 0 to 19\naddress _wallet; // STORAGE[0x11] bytes 0 to 19\n\n// Events\nTokenProcurement(address, address, uint256, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1737(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = varg0 >= _startIcoPreICO;\n    if (v5) {\n        v4 = v6 = varg0 < _endIcoPreICO;\n    }\n    if (v4) {\n        v2 = v7 = _rateIcoPreICO;\n    }\n    v8 = v9 = varg0 >= _startIcoMainSale;\n    if (v9) {\n        v8 = v10 = varg0 < _endIcoMainSale;\n    }\n    if (v8) {\n        v2 = v11 = _rateIcoMainSale;\n    }\n    v12 = v13 = varg0 >= _startIcoPreICO;\n    if (v13) {\n        v12 = v14 = varg0 < _startIcoPreICO2ndRound;\n    }\n    if (!v12) {\n        v15 = v16 = varg0 >= _startIcoPreICO2ndRound;\n        if (v16) {\n            v15 = v17 = varg0 < _endIcoPreICO;\n        }\n        if (!v15) {\n            if (varg0 >= _startIcoMainSale) {\n                v0 = v18 = 100 - ((varg0 - _startIcoMainSale) / 0x15180 << 1);\n                if (v18 < 0) {\n                    v0 = v19 = 0;\n                }\n            }\n        } else {\n            v0 = v20 = 200;\n        }\n    } else {\n        v0 = v21 = 300;\n    }\n    v22 = 0x2479(v0, v2);\n    assert(1000);\n    return v2 + v22 / 1000;\n}\n\nfunction fallback() public payable { \n    0x971(msg.sender);\n}\n\nfunction rateIcoPreICO() public nonPayable { \n    return _rateIcoPreICO;\n}\n\nfunction getRateIcoWithBonus() public nonPayable { \n    v0 = 0x1737(block.timestamp);\n    return v0;\n}\n\nfunction endIcoMainSale() public nonPayable { \n    return _endIcoMainSale;\n}\n\nfunction 0x2479(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction startIcoPreICO2ndRound() public nonPayable { \n    return _startIcoPreICO2ndRound;\n}\n\nfunction setStartIcoPreICO2ndRound(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = varg0 > _startIcoPreICO;\n    if (v1) {\n        v0 = v2 = varg0 < _endIcoPreICO;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO2ndRound = varg0;\n}\n\nfunction SetPermissionsList(address varg0, uint8 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token.code.size);\n    v2 = _token.SetPermissionsList(varg0, 0xff & (0xff & (0xff & varg1))).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    if (0xff & (0xff & varg1) == 0) {\n        if (0xff & v1 != 0xff & (0xff & varg1)) {\n            assert(_unconfirmedSumAddr[varg0] <= _unconfirmedSum);\n            _unconfirmedSum = _unconfirmedSum - _unconfirmedSumAddr[varg0];\n            _unconfirmedSumAddr[varg0] = 0;\n        }\n    }\n}\n\nfunction setStartIcoMainICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = _endIcoPreICO < varg0;\n    if (v1) {\n        v0 = v2 = varg0 < _endIcoMainSale;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoMainSale = varg0;\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0 = _token.unpause().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction transferEthToMultisig() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = block.timestamp < _startIcoMainSale;\n    if (block.timestamp >= _startIcoMainSale) {\n        assert(_unconfirmedSum <= _totalSoldTokens);\n        v0 = v2 = _totalSoldTokens - _unconfirmedSum >= _refund;\n        if (v2) {\n            v0 = block.timestamp > _endIcoMainSale;\n        }\n    }\n    require(v0);\n    v3 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction rateIcoMainSale() public nonPayable { \n    return _rateIcoMainSale;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction minPurchasePreICO() public nonPayable { \n    return _minPurchasePreICO;\n}\n\nfunction refund() public nonPayable { \n    assert(_unconfirmedSum <= _totalSoldTokens);\n    v0 = v1 = _totalSoldTokens - _unconfirmedSum < _refund;\n    if (v1) {\n        v0 = block.timestamp > _endIcoMainSale;\n    }\n    require(v0);\n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    v2 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getRateIcoWithBonusByDate(uint256 varg0) public nonPayable { \n    v0 = 0x1737(varg0);\n    return v0;\n}\n\nfunction endIcoPreICO() public nonPayable { \n    return _endIcoPreICO;\n}\n\nfunction GetPermissionsList(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return 0xff & (0xff & v1);\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0 = _token.pause().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction contractBalanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setStartIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 < _endIcoPreICO);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO = varg0;\n}\n\nfunction unconfirmedSum() public nonPayable { \n    return _unconfirmedSum;\n}\n\nfunction setEndIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = _startIcoPreICO < varg0;\n    if (v1) {\n        v0 = v2 = varg0 < _startIcoMainSale;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _endIcoPreICO = varg0;\n}\n\nfunction setIcoDates(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 < varg1);\n    require(varg1 < varg2);\n    require(varg2 <= varg3);\n    require(varg3 < varg4);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO = varg0;\n    _startIcoPreICO2ndRound = varg1;\n    _endIcoPreICO = varg2;\n    _startIcoMainSale = varg3;\n    _endIcoMainSale = varg4;\n}\n\nfunction startIcoMainSale() public nonPayable { \n    return _startIcoMainSale;\n}\n\nfunction procureTokens(address varg0) public payable { \n    0x971(varg0);\n}\n\nfunction setRateIcoMainSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rateIcoMainSale = varg0;\n}\n\nfunction startIcoPreICO() public nonPayable { \n    return _startIcoPreICO;\n}\n\nfunction refundUnconfirmed() public nonPayable { \n    require(block.timestamp > _endIcoMainSale + 0x15180);\n    require(_balances[msg.sender] > 0);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0xff & v1 == 1);\n    _balances[msg.sender] = 0;\n    v2 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v2); // checks call status, propagates error data on error\n    _unconfirmedSumAddr[msg.sender] = 0;\n    require(_token.code.size);\n    v3 = _token.burn(msg.sender, _unconfirmedSumAddr[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction totalSoldTokens() public nonPayable { \n    return _totalSoldTokens;\n}\n\nfunction setRateIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rateIcoPreICO = varg0;\n}\n\nfunction setEndIcoMainICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_startIcoMainSale < varg0);\n    require(block.timestamp < _startIcoPreICO);\n    _endIcoMainSale = varg0;\n}\n\nfunction tokenBalanceOf(address varg0) public nonPayable { \n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction unconfirmedSumAddr(address varg0) public nonPayable { \n    return _unconfirmedSumAddr[varg0];\n}\n\nfunction 0x971(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = msg.value;\n    require(address(varg0) != 0);\n    v6 = 0x1737(block.timestamp);\n    v7 = v8 = block.timestamp >= _startIcoPreICO;\n    if (v8) {\n        v7 = v9 = block.timestamp < _endIcoPreICO;\n    }\n    if (v7) {\n        v7 = v10 = _totalSoldTokens < stor_2;\n    }\n    if (v7) {\n        require(v5 >= _minPurchasePreICO);\n        v0 = v11 = 0x2479(v6, v5);\n        assert(_totalSoldTokens <= stor_2);\n        if (stor_2 - _totalSoldTokens < v11) {\n            assert(_totalSoldTokens <= stor_2);\n            v0 = v12 = stor_2 - _totalSoldTokens;\n            assert(v6);\n            v4 = v13 = v12 / v6;\n            assert(v13 <= msg.value);\n            v2 = v14 = msg.value - v13;\n        }\n    }\n    assert(stor_3 + stor_2 >= stor_3);\n    v15 = v16 = block.timestamp >= _startIcoMainSale;\n    if (v16) {\n        v15 = v17 = block.timestamp < _endIcoMainSale;\n    }\n    if (v15) {\n        v15 = v18 = _totalSoldTokens < stor_3 + stor_2;\n    }\n    if (v15) {\n        v0 = v19 = 0x2479(v6, v4);\n        assert(_totalSoldTokens <= stor_3 + stor_2);\n        if (stor_3 + stor_2 - _totalSoldTokens < v19) {\n            assert(_totalSoldTokens <= stor_3 + stor_2);\n            v0 = stor_3 + stor_2 - _totalSoldTokens;\n            assert(v6);\n            v4 = v0 / v6;\n            assert(v4 <= msg.value);\n            v2 = msg.value - v4;\n        }\n    }\n    require(v0 > 0);\n    assert(_totalSoldTokens + v0 >= _totalSoldTokens);\n    _totalSoldTokens = _totalSoldTokens + v0;\n    assert(_balances[msg.sender] + v4 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v4;\n    require(_token.code.size);\n    v20, v21 = _token.mint(msg.sender, v0).gas(msg.gas);\n    require(v20); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(_unconfirmedSum + v0 >= _unconfirmedSum);\n    _unconfirmedSum = _unconfirmedSum + v0;\n    assert(_unconfirmedSumAddr[msg.sender] + v0 >= _unconfirmedSumAddr[msg.sender]);\n    _unconfirmedSumAddr[msg.sender] = _unconfirmedSumAddr[msg.sender] + v0;\n    v22 = address(varg0);\n    require(_token.code.size);\n    v23 = _token.SetPermissionsList(v22, 1).gas(msg.gas);\n    require(v23); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v24 = msg.sender.call().value(v2).gas(!v2 * 2300);\n        require(v24); // checks call status, propagates error data on error\n    }\n    emit TokenProcurement(msg.sender, address(varg0), v4, v0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1e1bcf7 == function_selector) {\n            rateIcoPreICO();\n        } else if (0x207beb59 == function_selector) {\n            getRateIcoWithBonus();\n        } else if (0x243eb89f == function_selector) {\n            endIcoMainSale();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x29bd028a == function_selector) {\n            startIcoPreICO2ndRound();\n        } else if (0x34b4eef2 == function_selector) {\n            setStartIcoPreICO2ndRound(uint256);\n        } else if (0x3871bf85 == function_selector) {\n            SetPermissionsList(address,uint8);\n        } else if (0x3af9e169 == function_selector) {\n            setStartIcoMainICO(uint256);\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x476a73ec == function_selector) {\n            transferEthToMultisig();\n        } else if (0x51fb4001 == function_selector) {\n            rateIcoMainSale();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x5509f0f3 == function_selector) {\n            minPurchasePreICO();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x5a86c914 == function_selector) {\n            getRateIcoWithBonusByDate(uint256);\n        } else if (0x7aae42c9 == function_selector) {\n            endIcoPreICO();\n        } else if (0x7d38b027 == function_selector) {\n            GetPermissionsList(address);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8481573e == function_selector) {\n            contractBalanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8fae065c == function_selector) {\n            setStartIcoPreICO(uint256);\n        } else if (0xa0493834 == function_selector) {\n            unconfirmedSum();\n        } else if (0xafaaa654 == function_selector) {\n            setEndIcoPreICO(uint256);\n        } else if (0xb734cbba == function_selector) {\n            setIcoDates(uint256,uint256,uint256,uint256,uint256);\n        } else if (0xb75014c0 == function_selector) {\n            startIcoMainSale();\n        } else if (0xc70dd8b3 == function_selector) {\n            procureTokens(address);\n        } else if (0xd186659d == function_selector) {\n            setRateIcoMainSale(uint256);\n        } else if (0xd1eca85e == function_selector) {\n            startIcoPreICO();\n        } else if (0xd3631e00 == function_selector) {\n            refundUnconfirmed();\n        } else if (0xd7ca9949 == function_selector) {\n            totalSoldTokens();\n        } else if (0xdb71c776 == function_selector) {\n            setRateIcoPreICO(uint256);\n        } else if (0xdcbad97b == function_selector) {\n            setEndIcoMainICO(uint256);\n        } else if (0xe42c08f2 == function_selector) {\n            tokenBalanceOf(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfc9a5097 == function_selector) {\n            unconfirmedSumAddr(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.23 23:44 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _refund; // STORAGE[0x1]\nuint256 stor_2; // STORAGE[0x2]\nuint256 stor_3; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balances; // STORAGE[0x5]\nuint256 _startIcoPreICO; // STORAGE[0x6]\nuint256 _startIcoPreICO2ndRound; // STORAGE[0x7]\nuint256 _startIcoMainSale; // STORAGE[0x8]\nuint256 _endIcoPreICO; // STORAGE[0x9]\nuint256 _endIcoMainSale; // STORAGE[0xa]\nuint256 _totalSoldTokens; // STORAGE[0xb]\nuint256 _minPurchasePreICO; // STORAGE[0xc]\nuint256 _rateIcoPreICO; // STORAGE[0xd]\nuint256 _rateIcoMainSale; // STORAGE[0xe]\nuint256 _unconfirmedSum; // STORAGE[0xf]\nmapping (uint256 => [uint256]) _unconfirmedSumAddr; // STORAGE[0x10]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _token; // STORAGE[0x4] bytes 0 to 19\naddress _wallet; // STORAGE[0x11] bytes 0 to 19\n\n// Events\nTokenProcurement(address, address, uint256, uint256);\nOwnershipTransferred(address, address);\n\nfunction 0x1737(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = varg0 >= _startIcoPreICO;\n    if (v5) {\n        v4 = v6 = varg0 < _endIcoPreICO;\n    }\n    if (v4) {\n        v2 = v7 = _rateIcoPreICO;\n    }\n    v8 = v9 = varg0 >= _startIcoMainSale;\n    if (v9) {\n        v8 = v10 = varg0 < _endIcoMainSale;\n    }\n    if (v8) {\n        v2 = v11 = _rateIcoMainSale;\n    }\n    v12 = v13 = varg0 >= _startIcoPreICO;\n    if (v13) {\n        v12 = v14 = varg0 < _startIcoPreICO2ndRound;\n    }\n    if (!v12) {\n        v15 = v16 = varg0 >= _startIcoPreICO2ndRound;\n        if (v16) {\n            v15 = v17 = varg0 < _endIcoPreICO;\n        }\n        if (!v15) {\n            if (varg0 >= _startIcoMainSale) {\n                v0 = v18 = 100 - ((varg0 - _startIcoMainSale) / 0x15180 << 1);\n                if (v18 < 0) {\n                    v0 = v19 = 0;\n                }\n            }\n        } else {\n            v0 = v20 = 200;\n        }\n    } else {\n        v0 = v21 = 300;\n    }\n    v22 = 0x2479(v0, v2);\n    assert(1000);\n    return v2 + v22 / 1000;\n}\n\nfunction fallback() public payable { \n    0x971(msg.sender);\n}\n\nfunction rateIcoPreICO() public nonPayable { \n    return _rateIcoPreICO;\n}\n\nfunction getRateIcoWithBonus() public nonPayable { \n    v0 = 0x1737(block.timestamp);\n    return v0;\n}\n\nfunction endIcoMainSale() public nonPayable { \n    return _endIcoMainSale;\n}\n\nfunction 0x2479(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction balances(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction startIcoPreICO2ndRound() public nonPayable { \n    return _startIcoPreICO2ndRound;\n}\n\nfunction setStartIcoPreICO2ndRound(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = varg0 > _startIcoPreICO;\n    if (v1) {\n        v0 = v2 = varg0 < _endIcoPreICO;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO2ndRound = varg0;\n}\n\nfunction SetPermissionsList(address varg0, uint8 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(_token.code.size);\n    v2 = _token.SetPermissionsList(varg0, 0xff & (0xff & (0xff & varg1))).gas(msg.gas);\n    require(v2); // checks call status, propagates error data on error\n    if (0xff & (0xff & varg1) == 0) {\n        if (0xff & v1 != 0xff & (0xff & varg1)) {\n            assert(_unconfirmedSumAddr[varg0] <= _unconfirmedSum);\n            _unconfirmedSum = _unconfirmedSum - _unconfirmedSumAddr[varg0];\n            _unconfirmedSumAddr[varg0] = 0;\n        }\n    }\n}\n\nfunction setStartIcoMainICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = _endIcoPreICO < varg0;\n    if (v1) {\n        v0 = v2 = varg0 < _endIcoMainSale;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoMainSale = varg0;\n}\n\nfunction unpause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0 = _token.unpause().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction transferEthToMultisig() public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = block.timestamp < _startIcoMainSale;\n    if (block.timestamp >= _startIcoMainSale) {\n        assert(_unconfirmedSum <= _totalSoldTokens);\n        v0 = v2 = _totalSoldTokens - _unconfirmedSum >= _refund;\n        if (v2) {\n            v0 = block.timestamp > _endIcoMainSale;\n        }\n    }\n    require(v0);\n    v3 = _wallet.call().value((address(this)).balance).gas(!(address(this)).balance * 2300);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction rateIcoMainSale() public nonPayable { \n    return _rateIcoMainSale;\n}\n\nfunction wallet() public nonPayable { \n    return _wallet;\n}\n\nfunction minPurchasePreICO() public nonPayable { \n    return _minPurchasePreICO;\n}\n\nfunction refund() public nonPayable { \n    assert(_unconfirmedSum <= _totalSoldTokens);\n    v0 = v1 = _totalSoldTokens - _unconfirmedSum < _refund;\n    if (v1) {\n        v0 = block.timestamp > _endIcoMainSale;\n    }\n    require(v0);\n    require(_balances[msg.sender] > 0);\n    _balances[msg.sender] = 0;\n    v2 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getRateIcoWithBonusByDate(uint256 varg0) public nonPayable { \n    v0 = 0x1737(varg0);\n    return v0;\n}\n\nfunction endIcoPreICO() public nonPayable { \n    return _endIcoPreICO;\n}\n\nfunction GetPermissionsList(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return 0xff & (0xff & v1);\n}\n\nfunction pause() public nonPayable { \n    require(msg.sender == _owner);\n    require(_token.code.size);\n    v0 = _token.pause().gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction contractBalanceOf(address varg0) public nonPayable { \n    return _balances[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction setStartIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 < _endIcoPreICO);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO = varg0;\n}\n\nfunction unconfirmedSum() public nonPayable { \n    return _unconfirmedSum;\n}\n\nfunction setEndIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    v0 = v1 = _startIcoPreICO < varg0;\n    if (v1) {\n        v0 = v2 = varg0 < _startIcoMainSale;\n    }\n    require(v0);\n    require(block.timestamp < _startIcoPreICO);\n    _endIcoPreICO = varg0;\n}\n\nfunction setIcoDates(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 < varg1);\n    require(varg1 < varg2);\n    require(varg2 <= varg3);\n    require(varg3 < varg4);\n    require(block.timestamp < _startIcoPreICO);\n    _startIcoPreICO = varg0;\n    _startIcoPreICO2ndRound = varg1;\n    _endIcoPreICO = varg2;\n    _startIcoMainSale = varg3;\n    _endIcoMainSale = varg4;\n}\n\nfunction startIcoMainSale() public nonPayable { \n    return _startIcoMainSale;\n}\n\nfunction procureTokens(address varg0) public payable { \n    0x971(varg0);\n}\n\nfunction setRateIcoMainSale(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rateIcoMainSale = varg0;\n}\n\nfunction startIcoPreICO() public nonPayable { \n    return _startIcoPreICO;\n}\n\nfunction refundUnconfirmed() public nonPayable { \n    require(block.timestamp > _endIcoMainSale + 0x15180);\n    require(_balances[msg.sender] > 0);\n    require(_token.code.size);\n    v0, v1 = _token.GetPermissionsList(msg.sender).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(0xff & v1 == 1);\n    _balances[msg.sender] = 0;\n    v2 = msg.sender.call().value(_balances[msg.sender]).gas(!_balances[msg.sender] * 2300);\n    require(v2); // checks call status, propagates error data on error\n    _unconfirmedSumAddr[msg.sender] = 0;\n    require(_token.code.size);\n    v3 = _token.burn(msg.sender, _unconfirmedSumAddr[msg.sender]).gas(msg.gas);\n    require(v3); // checks call status, propagates error data on error\n}\n\nfunction totalSoldTokens() public nonPayable { \n    return _totalSoldTokens;\n}\n\nfunction setRateIcoPreICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _rateIcoPreICO = varg0;\n}\n\nfunction setEndIcoMainICO(uint256 varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(_startIcoMainSale < varg0);\n    require(block.timestamp < _startIcoPreICO);\n    _endIcoMainSale = varg0;\n}\n\nfunction tokenBalanceOf(address varg0) public nonPayable { \n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(varg0).gas(msg.gas);\n    require(v0); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction unconfirmedSumAddr(address varg0) public nonPayable { \n    return _unconfirmedSumAddr[varg0];\n}\n\nfunction 0x971(uint256 varg0) private { \n    v0 = v1 = 0;\n    v2 = v3 = 0;\n    v4 = v5 = msg.value;\n    require(address(varg0) != 0);\n    v6 = 0x1737(block.timestamp);\n    v7 = v8 = block.timestamp >= _startIcoPreICO;\n    if (v8) {\n        v7 = v9 = block.timestamp < _endIcoPreICO;\n    }\n    if (v7) {\n        v7 = v10 = _totalSoldTokens < stor_2;\n    }\n    if (v7) {\n        require(v5 >= _minPurchasePreICO);\n        v0 = v11 = 0x2479(v6, v5);\n        assert(_totalSoldTokens <= stor_2);\n        if (stor_2 - _totalSoldTokens < v11) {\n            assert(_totalSoldTokens <= stor_2);\n            v0 = v12 = stor_2 - _totalSoldTokens;\n            assert(v6);\n            v4 = v13 = v12 / v6;\n            assert(v13 <= msg.value);\n            v2 = v14 = msg.value - v13;\n        }\n    }\n    assert(stor_3 + stor_2 >= stor_3);\n    v15 = v16 = block.timestamp >= _startIcoMainSale;\n    if (v16) {\n        v15 = v17 = block.timestamp < _endIcoMainSale;\n    }\n    if (v15) {\n        v15 = v18 = _totalSoldTokens < stor_3 + stor_2;\n    }\n    if (v15) {\n        v0 = v19 = 0x2479(v6, v4);\n        assert(_totalSoldTokens <= stor_3 + stor_2);\n        if (stor_3 + stor_2 - _totalSoldTokens < v19) {\n            assert(_totalSoldTokens <= stor_3 + stor_2);\n            v0 = stor_3 + stor_2 - _totalSoldTokens;\n            assert(v6);\n            v4 = v0 / v6;\n            assert(v4 <= msg.value);\n            v2 = msg.value - v4;\n        }\n    }\n    require(v0 > 0);\n    assert(_totalSoldTokens + v0 >= _totalSoldTokens);\n    _totalSoldTokens = _totalSoldTokens + v0;\n    assert(_balances[msg.sender] + v4 >= _balances[msg.sender]);\n    _balances[msg.sender] = _balances[msg.sender] + v4;\n    require(_token.code.size);\n    v20, v21 = _token.mint(msg.sender, v0).gas(msg.gas);\n    require(v20); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    assert(_unconfirmedSum + v0 >= _unconfirmedSum);\n    _unconfirmedSum = _unconfirmedSum + v0;\n    assert(_unconfirmedSumAddr[msg.sender] + v0 >= _unconfirmedSumAddr[msg.sender]);\n    _unconfirmedSumAddr[msg.sender] = _unconfirmedSumAddr[msg.sender] + v0;\n    v22 = address(varg0);\n    require(_token.code.size);\n    v23 = _token.SetPermissionsList(v22, 1).gas(msg.gas);\n    require(v23); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v24 = msg.sender.call().value(v2).gas(!v2 * 2300);\n        require(v24); // checks call status, propagates error data on error\n    }\n    emit TokenProcurement(msg.sender, address(varg0), v4, v0);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1e1bcf7 == function_selector) {\n            rateIcoPreICO();\n        } else if (0x207beb59 == function_selector) {\n            getRateIcoWithBonus();\n        } else if (0x243eb89f == function_selector) {\n            endIcoMainSale();\n        } else if (0x27e235e3 == function_selector) {\n            balances(address);\n        } else if (0x29bd028a == function_selector) {\n            startIcoPreICO2ndRound();\n        } else if (0x34b4eef2 == function_selector) {\n            setStartIcoPreICO2ndRound(uint256);\n        } else if (0x3871bf85 == function_selector) {\n            SetPermissionsList(address,uint8);\n        } else if (0x3af9e169 == function_selector) {\n            setStartIcoMainICO(uint256);\n        } else if (0x3f4ba83a == function_selector) {\n            unpause();\n        } else if (0x476a73ec == function_selector) {\n            transferEthToMultisig();\n        } else if (0x51fb4001 == function_selector) {\n            rateIcoMainSale();\n        } else if (0x521eb273 == function_selector) {\n            wallet();\n        } else if (0x5509f0f3 == function_selector) {\n            minPurchasePreICO();\n        } else if (0x590e1ae3 == function_selector) {\n            refund();\n        } else if (0x5a86c914 == function_selector) {\n            getRateIcoWithBonusByDate(uint256);\n        } else if (0x7aae42c9 == function_selector) {\n            endIcoPreICO();\n        } else if (0x7d38b027 == function_selector) {\n            GetPermissionsList(address);\n        } else if (0x8456cb59 == function_selector) {\n            pause();\n        } else if (0x8481573e == function_selector) {\n            contractBalanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x8fae065c == function_selector) {\n            setStartIcoPreICO(uint256);\n        } else if (0xa0493834 == function_selector) {\n            unconfirmedSum();\n        } else if (0xafaaa654 == function_selector) {\n            setEndIcoPreICO(uint256);\n        } else if (0xb734cbba == function_selector) {\n            setIcoDates(uint256,uint256,uint256,uint256,uint256);\n        } else if (0xb75014c0 == function_selector) {\n            startIcoMainSale();\n        } else if (0xc70dd8b3 == function_selector) {\n            procureTokens(address);\n        } else if (0xd186659d == function_selector) {\n            setRateIcoMainSale(uint256);\n        } else if (0xd1eca85e == function_selector) {\n            startIcoPreICO();\n        } else if (0xd3631e00 == function_selector) {\n            refundUnconfirmed();\n        } else if (0xd7ca9949 == function_selector) {\n            totalSoldTokens();\n        } else if (0xdb71c776 == function_selector) {\n            setRateIcoPreICO(uint256);\n        } else if (0xdcbad97b == function_selector) {\n            setEndIcoMainICO(uint256);\n        } else if (0xe42c08f2 == function_selector) {\n            tokenBalanceOf(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == function_selector) {\n            token();\n        } else if (0xfc9a5097 == function_selector) {\n            unconfirmedSumAddr(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 23.114442110061646,
	"usage": {
		"completion_tokens": 488,
		"prompt_tokens": 4867,
		"total_tokens": 5355
	}
}