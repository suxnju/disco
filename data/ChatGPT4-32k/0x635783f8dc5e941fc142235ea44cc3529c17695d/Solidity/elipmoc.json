{
	"address": "0x635783f8dc5e941fc142235ea44cc3529c17695d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a solidity implementation based on the decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Game {\n    mapping (uint256 => uint256[]) _earnings;\n    mapping (uint256 => uint256[]) _dividendShares;\n    uint256 _totalDividendShares;\n    uint256 _dividendFund;\n    uint256 _round;\n    uint256 _pot;\n    uint256 _leaderTimestamp;\n    uint256 _leaderBid;\n    address _leader;\n\n    event Winner(uint256 timestamp, address leader, uint256 reward, uint256 round, uint256 leaderTimestamp);\n    event Bid(uint256 timestamp, address bidder, uint256 bid, uint256 leaderBid, uint256 round, uint256 pot);\n    event DividendsWithdrawal(uint256 timestamp, address withdrawer, uint256 shares, uint256 dividend, uint256 totalShares, uint256 fund);\n    event EarningsWithdrawal(uint256 timestamp, address withdrawer, uint256 earnings);\n\n    function PAYOUT_FRAC_BOT() public pure returns(uint256) {\n        return 100;\n    }\n\n    function round() public view returns(uint256) {\n        return _round;\n    }\n\n    function bid() public payable {\n        require(_leaderTimestamp <= block.timestamp, \"Invalid timestamp\");\n        uint256 v0 = _pot / 10;\n        uint256 v1 = v0 / 10;\n        uint256 v3 = _leaderBid * ((block.timestamp - _leaderTimestamp) / 300);\n        uint256 v4 = v3 / 100;\n        v1 = v4;\n        _earnings[_round].push(_earnings[_round][_round] + v1);\n        _pot -= v1;\n        emit Winner(block.timestamp, _leader, v1, _round, _leaderTimestamp);\n        uint256 v5 = _pot;\n        uint256 v6 = msg.value;\n        uint256 v7;\n        if (_totalDividendShares != 0) {\n            v7 = _dividendFund / _totalDividendShares;\n        } else {\n            v7 = v5 / 200;\n        }\n        _dividendFund += v6 / 2;\n        _pot += msg.value - v6 / 2;\n        if (msg.value > v5 / 100) {\n            uint256 v10 = msg.value - v5 / 100;\n            _dividendShares[_round].push(_dividendShares[_round][_round] + v10 / 2 / v7);\n            _totalDividendShares += v10 / 2 / v7;\n        }\n        _round += 1;\n        _leader = msg.sender;\n        _leaderTimestamp = block.timestamp;\n        _leaderBid = msg.value;\n        if (_leaderBid > v5 / 100) {\n            _leaderBid = v5 / 100;\n        }\n        emit Bid(block.timestamp, msg.sender, msg.value, _leaderBid, _round, _pot);\n    }\n\n    function dividendFund() public view returns(uint256) {\n        return _dividendFund;\n    }\n\n    function MAX_BID_FRAC_BOT() public pure returns(uint256) {\n        return 100;\n    }\n\n    function MAX_PAYOUT_FRAC_BOT() public pure returns(uint256) {\n        return 10;\n    }\n\n    function withdrawDividends() public {\n        require(_dividendShares[_round][_round] > 0, \"No dividends to withdraw\");\n        uint256 v0 = _dividendShares[_round][_round] * _dividendFund;\n        _dividendShares[_round][_round] = 0;\n        _totalDividendShares -= _dividendShares[_round][_round];\n        _dividendFund -= v0 / _totalDividendShares;\n        payable(msg.sender).transfer(v0 / _totalDividendShares);\n        emit DividendsWithdrawal(block.timestamp, msg.sender, _dividendShares[_round][_round], v0 / _totalDividendShares, _totalDividendShares, _dividendFund);\n    }\n\n    function leader() public view returns(address) {\n        return _leader;\n    }\n\n    function PAYOUT_FRAC_TOP() public pure returns(uint256) {\n        return 10;\n    }\n\n    function pot() public view returns(uint256) {\n        return _pot;\n    }\n\n    function earnings(uint256 round) public view returns(uint256[] memory) {\n        return _earnings[round];\n    }\n\n    function PAYOUT_TIME() public pure returns(uint256) {\n        return 300;\n    }\n\n    function MAX_BID_FRAC_TOP() public pure returns(uint256) {\n        return 1;\n    }\n\n    function withdrawEarnings() public {\n        require(_earnings[_round][_round] > 0, \"No earnings to withdraw\");\n        _earnings[_round][_round] = 0;\n        payable(msg.sender).transfer(_earnings[_round][_round]);\n        emit EarningsWithdrawal(block.timestamp, msg.sender, _earnings[_round][_round]);\n    }\n\n    function DIVIDEND_FUND_FRAC_BOT() public pure returns(uint256) {\n        return 2;\n    }\n\n    function MAX_PAYOUT_FRAC_TOP() public pure returns(uint256) {\n        return 1;\n    }\n\n    function leaderBid() public view returns(uint256) {\n        return _leaderBid;\n    }\n\n    function totalDividendShares() public view returns(uint256) {\n        return _totalDividendShares;\n    }\n\n    function DIVIDEND_FUND_FRAC_TOP() public pure returns(uint256) {\n        return 1;\n    }\n\n    function leaderTimestamp() public view returns(uint256) {\n        return _leaderTimestamp;\n    }\n\n    function dividendShares(uint256 round) public view returns(uint256[] memory) {\n        return _dividendShares[round];\n    }\n}\n```\nPlease note that the above implementation assumes that `_earnings` and `_dividendShares` are mappings from round number to arrays of earnings and shares respectively. The actual structure might be different based on the original contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459023,
	"id": "chatcmpl-8R3VPA9x0zLJGy617Lt01EJiTSzGf",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 10:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _earnings; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _dividendShares; // STORAGE[0x2]\nuint256 _totalDividendShares; // STORAGE[0x3]\nuint256 _dividendFund; // STORAGE[0x4]\nuint256 _round; // STORAGE[0x5]\nuint256 _pot; // STORAGE[0x6]\nuint256 _leaderTimestamp; // STORAGE[0x8]\nuint256 _leaderBid; // STORAGE[0x9]\naddress _leader; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nWinner(uint256, address, uint256, uint256, uint256);\nBid(uint256, address, uint256, uint256, uint256, uint256);\nDividendsWithdrawal(uint256, address, uint256, uint256, uint256, uint256);\nEarningsWithdrawal(uint256, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction PAYOUT_FRAC_BOT() public nonPayable { \n    return 100;\n}\n\nfunction round() public nonPayable { \n    return _round;\n}\n\nfunction bid() public payable { \n    v0 = 0xed3(1, _pot);\n    assert(10);\n    v1 = v2 = v0 / 10;\n    assert(_leaderTimestamp <= block.timestamp);\n    assert(300);\n    v3 = 0xed3(_leaderBid, (block.timestamp - _leaderTimestamp) / 300);\n    v4 = 0xed3(10, v3);\n    assert(100);\n    v1 = v4 / 100;\n    assert(_earnings[_leader] + v1 >= _earnings[_leader]);\n    _earnings[_leader] = _earnings[_leader] + v1;\n    assert(v1 <= _pot);\n    _pot = _pot - v1;\n    emit Winner(block.timestamp, _leader, v1, _round, _leaderTimestamp);\n    v5 = 0xed3(1, _pot);\n    assert(100);\n    v6 = 0xed3(1, msg.value);\n    assert(2);\n    assert(v6 >> 1 <= msg.value);\n    if (_totalDividendShares != 0) {\n        assert(_totalDividendShares);\n        v7 = v8 = _dividendFund / _totalDividendShares;\n    } else {\n        v9 = 0xed3(1, v5 / 100);\n        assert(2);\n        v7 = v9 >> 1;\n    }\n    assert(_dividendFund + (v6 >> 1) >= _dividendFund);\n    _dividendFund = _dividendFund + (v6 >> 1);\n    assert(_pot + (msg.value - (v6 >> 1)) >= _pot);\n    _pot = _pot + (msg.value - (v6 >> 1));\n    if (msg.value > v5 / 100) {\n        assert(v5 / 100 <= msg.value);\n        v10 = 0xed3(1, msg.value - v5 / 100);\n        assert(2);\n        assert(v7);\n        assert(_dividendShares[msg.sender] + (v10 >> 1) / v7 >= _dividendShares[msg.sender]);\n        _dividendShares[msg.sender] = _dividendShares[msg.sender] + (v10 >> 1) / v7;\n        assert(_totalDividendShares + (v10 >> 1) / v7 >= _totalDividendShares);\n        _totalDividendShares = _totalDividendShares + (v10 >> 1) / v7;\n    }\n    _round += 1;\n    _leader = msg.sender;\n    _leaderTimestamp = block.timestamp;\n    _leaderBid = msg.value;\n    if (_leaderBid > v5 / 100) {\n        _leaderBid = v5 / 100;\n    }\n    emit Bid(block.timestamp, msg.sender, msg.value, _leaderBid, _round, _pot);\n}\n\nfunction dividendFund() public nonPayable { \n    return _dividendFund;\n}\n\nfunction MAX_BID_FRAC_BOT() public nonPayable { \n    return 100;\n}\n\nfunction MAX_PAYOUT_FRAC_BOT() public nonPayable { \n    return 10;\n}\n\nfunction withdrawDividends() public nonPayable { \n    require(_dividendShares[msg.sender] > 0);\n    assert(_dividendShares[msg.sender] <= _totalDividendShares);\n    v0 = 0xed3(_dividendShares[msg.sender], _dividendFund);\n    assert(_totalDividendShares);\n    assert(v0 / _totalDividendShares <= (address(this)).balance);\n    _dividendShares[msg.sender] = 0;\n    assert(_dividendShares[msg.sender] <= _totalDividendShares);\n    _totalDividendShares = _totalDividendShares - _dividendShares[msg.sender];\n    assert(v0 / _totalDividendShares <= _dividendFund);\n    _dividendFund = _dividendFund - v0 / _totalDividendShares;\n    v1 = msg.sender.call().value(v0 / _totalDividendShares).gas(!(v0 / _totalDividendShares) * 2300);\n    require(v1);\n    emit DividendsWithdrawal(block.timestamp, msg.sender, _dividendShares[msg.sender], v0 / _totalDividendShares, _totalDividendShares, _dividendFund);\n}\n\nfunction leader() public nonPayable { \n    return _leader;\n}\n\nfunction PAYOUT_FRAC_TOP() public nonPayable { \n    return 10;\n}\n\nfunction pot() public nonPayable { \n    return _pot;\n}\n\nfunction earnings(address varg0) public nonPayable { \n    return _earnings[varg0];\n}\n\nfunction PAYOUT_TIME() public nonPayable { \n    return 300;\n}\n\nfunction MAX_BID_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction withdrawEarnings() public nonPayable { \n    require(_earnings[msg.sender] > 0);\n    assert(_earnings[msg.sender] <= (address(this)).balance);\n    _earnings[msg.sender] = 0;\n    v0 = msg.sender.call().value(_earnings[msg.sender]).gas(!_earnings[msg.sender] * 2300);\n    require(v0);\n    emit EarningsWithdrawal(block.timestamp, msg.sender, _earnings[msg.sender]);\n}\n\nfunction DIVIDEND_FUND_FRAC_BOT() public nonPayable { \n    return 2;\n}\n\nfunction MAX_PAYOUT_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction leaderBid() public nonPayable { \n    return _leaderBid;\n}\n\nfunction totalDividendShares() public nonPayable { \n    return _totalDividendShares;\n}\n\nfunction DIVIDEND_FUND_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction leaderTimestamp() public nonPayable { \n    return _leaderTimestamp;\n}\n\nfunction dividendShares(address varg0) public nonPayable { \n    return _dividendShares[varg0];\n}\n\nfunction 0xed3(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x8306af3 == function_selector) {\n            PAYOUT_FRAC_BOT();\n        } else if (0x146ca531 == function_selector) {\n            round();\n        } else if (0x1998aeef == function_selector) {\n            bid();\n        } else if (0x1a06008a == function_selector) {\n            dividendFund();\n        } else if (0x1bc44213 == function_selector) {\n            MAX_BID_FRAC_BOT();\n        } else if (0x2871587d == function_selector) {\n            MAX_PAYOUT_FRAC_BOT();\n        } else if (0x2e92abdd == function_selector) {\n            withdrawDividends();\n        } else if (0x40eedabb == function_selector) {\n            leader();\n        } else if (0x41c0dc59 == function_selector) {\n            PAYOUT_FRAC_TOP();\n        } else if (0x4ba2363a == function_selector) {\n            pot();\n        } else if (0x543fd313 == function_selector) {\n            earnings(address);\n        } else if (0x84c6f650 == function_selector) {\n            PAYOUT_TIME();\n        } else if (0x8a7ed05c == function_selector) {\n            MAX_BID_FRAC_TOP();\n        } else if (0xb73c6ce9 == function_selector) {\n            withdrawEarnings();\n        } else if (0xb74e825e == function_selector) {\n            DIVIDEND_FUND_FRAC_BOT();\n        } else if (0xbcc9ed6f == function_selector) {\n            MAX_PAYOUT_FRAC_TOP();\n        } else if (0xc395a16b == function_selector) {\n            leaderBid();\n        } else if (0xc64fa2e4 == function_selector) {\n            totalDividendShares();\n        } else if (0xd90025d1 == function_selector) {\n            DIVIDEND_FUND_FRAC_TOP();\n        } else if (0xe2896598 == function_selector) {\n            leaderTimestamp();\n        } else if (0xfc9774c1 == function_selector) {\n            dividendShares(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 10:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _earnings; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _dividendShares; // STORAGE[0x2]\nuint256 _totalDividendShares; // STORAGE[0x3]\nuint256 _dividendFund; // STORAGE[0x4]\nuint256 _round; // STORAGE[0x5]\nuint256 _pot; // STORAGE[0x6]\nuint256 _leaderTimestamp; // STORAGE[0x8]\nuint256 _leaderBid; // STORAGE[0x9]\naddress _leader; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nWinner(uint256, address, uint256, uint256, uint256);\nBid(uint256, address, uint256, uint256, uint256, uint256);\nDividendsWithdrawal(uint256, address, uint256, uint256, uint256, uint256);\nEarningsWithdrawal(uint256, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction PAYOUT_FRAC_BOT() public nonPayable { \n    return 100;\n}\n\nfunction round() public nonPayable { \n    return _round;\n}\n\nfunction bid() public payable { \n    v0 = 0xed3(1, _pot);\n    assert(10);\n    v1 = v2 = v0 / 10;\n    assert(_leaderTimestamp <= block.timestamp);\n    assert(300);\n    v3 = 0xed3(_leaderBid, (block.timestamp - _leaderTimestamp) / 300);\n    v4 = 0xed3(10, v3);\n    assert(100);\n    v1 = v4 / 100;\n    assert(_earnings[_leader] + v1 >= _earnings[_leader]);\n    _earnings[_leader] = _earnings[_leader] + v1;\n    assert(v1 <= _pot);\n    _pot = _pot - v1;\n    emit Winner(block.timestamp, _leader, v1, _round, _leaderTimestamp);\n    v5 = 0xed3(1, _pot);\n    assert(100);\n    v6 = 0xed3(1, msg.value);\n    assert(2);\n    assert(v6 >> 1 <= msg.value);\n    if (_totalDividendShares != 0) {\n        assert(_totalDividendShares);\n        v7 = v8 = _dividendFund / _totalDividendShares;\n    } else {\n        v9 = 0xed3(1, v5 / 100);\n        assert(2);\n        v7 = v9 >> 1;\n    }\n    assert(_dividendFund + (v6 >> 1) >= _dividendFund);\n    _dividendFund = _dividendFund + (v6 >> 1);\n    assert(_pot + (msg.value - (v6 >> 1)) >= _pot);\n    _pot = _pot + (msg.value - (v6 >> 1));\n    if (msg.value > v5 / 100) {\n        assert(v5 / 100 <= msg.value);\n        v10 = 0xed3(1, msg.value - v5 / 100);\n        assert(2);\n        assert(v7);\n        assert(_dividendShares[msg.sender] + (v10 >> 1) / v7 >= _dividendShares[msg.sender]);\n        _dividendShares[msg.sender] = _dividendShares[msg.sender] + (v10 >> 1) / v7;\n        assert(_totalDividendShares + (v10 >> 1) / v7 >= _totalDividendShares);\n        _totalDividendShares = _totalDividendShares + (v10 >> 1) / v7;\n    }\n    _round += 1;\n    _leader = msg.sender;\n    _leaderTimestamp = block.timestamp;\n    _leaderBid = msg.value;\n    if (_leaderBid > v5 / 100) {\n        _leaderBid = v5 / 100;\n    }\n    emit Bid(block.timestamp, msg.sender, msg.value, _leaderBid, _round, _pot);\n}\n\nfunction dividendFund() public nonPayable { \n    return _dividendFund;\n}\n\nfunction MAX_BID_FRAC_BOT() public nonPayable { \n    return 100;\n}\n\nfunction MAX_PAYOUT_FRAC_BOT() public nonPayable { \n    return 10;\n}\n\nfunction withdrawDividends() public nonPayable { \n    require(_dividendShares[msg.sender] > 0);\n    assert(_dividendShares[msg.sender] <= _totalDividendShares);\n    v0 = 0xed3(_dividendShares[msg.sender], _dividendFund);\n    assert(_totalDividendShares);\n    assert(v0 / _totalDividendShares <= (address(this)).balance);\n    _dividendShares[msg.sender] = 0;\n    assert(_dividendShares[msg.sender] <= _totalDividendShares);\n    _totalDividendShares = _totalDividendShares - _dividendShares[msg.sender];\n    assert(v0 / _totalDividendShares <= _dividendFund);\n    _dividendFund = _dividendFund - v0 / _totalDividendShares;\n    v1 = msg.sender.call().value(v0 / _totalDividendShares).gas(!(v0 / _totalDividendShares) * 2300);\n    require(v1);\n    emit DividendsWithdrawal(block.timestamp, msg.sender, _dividendShares[msg.sender], v0 / _totalDividendShares, _totalDividendShares, _dividendFund);\n}\n\nfunction leader() public nonPayable { \n    return _leader;\n}\n\nfunction PAYOUT_FRAC_TOP() public nonPayable { \n    return 10;\n}\n\nfunction pot() public nonPayable { \n    return _pot;\n}\n\nfunction earnings(address varg0) public nonPayable { \n    return _earnings[varg0];\n}\n\nfunction PAYOUT_TIME() public nonPayable { \n    return 300;\n}\n\nfunction MAX_BID_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction withdrawEarnings() public nonPayable { \n    require(_earnings[msg.sender] > 0);\n    assert(_earnings[msg.sender] <= (address(this)).balance);\n    _earnings[msg.sender] = 0;\n    v0 = msg.sender.call().value(_earnings[msg.sender]).gas(!_earnings[msg.sender] * 2300);\n    require(v0);\n    emit EarningsWithdrawal(block.timestamp, msg.sender, _earnings[msg.sender]);\n}\n\nfunction DIVIDEND_FUND_FRAC_BOT() public nonPayable { \n    return 2;\n}\n\nfunction MAX_PAYOUT_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction leaderBid() public nonPayable { \n    return _leaderBid;\n}\n\nfunction totalDividendShares() public nonPayable { \n    return _totalDividendShares;\n}\n\nfunction DIVIDEND_FUND_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction leaderTimestamp() public nonPayable { \n    return _leaderTimestamp;\n}\n\nfunction dividendShares(address varg0) public nonPayable { \n    return _dividendShares[varg0];\n}\n\nfunction 0xed3(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x8306af3 == function_selector) {\n            PAYOUT_FRAC_BOT();\n        } else if (0x146ca531 == function_selector) {\n            round();\n        } else if (0x1998aeef == function_selector) {\n            bid();\n        } else if (0x1a06008a == function_selector) {\n            dividendFund();\n        } else if (0x1bc44213 == function_selector) {\n            MAX_BID_FRAC_BOT();\n        } else if (0x2871587d == function_selector) {\n            MAX_PAYOUT_FRAC_BOT();\n        } else if (0x2e92abdd == function_selector) {\n            withdrawDividends();\n        } else if (0x40eedabb == function_selector) {\n            leader();\n        } else if (0x41c0dc59 == function_selector) {\n            PAYOUT_FRAC_TOP();\n        } else if (0x4ba2363a == function_selector) {\n            pot();\n        } else if (0x543fd313 == function_selector) {\n            earnings(address);\n        } else if (0x84c6f650 == function_selector) {\n            PAYOUT_TIME();\n        } else if (0x8a7ed05c == function_selector) {\n            MAX_BID_FRAC_TOP();\n        } else if (0xb73c6ce9 == function_selector) {\n            withdrawEarnings();\n        } else if (0xb74e825e == function_selector) {\n            DIVIDEND_FUND_FRAC_BOT();\n        } else if (0xbcc9ed6f == function_selector) {\n            MAX_PAYOUT_FRAC_TOP();\n        } else if (0xc395a16b == function_selector) {\n            leaderBid();\n        } else if (0xc64fa2e4 == function_selector) {\n            totalDividendShares();\n        } else if (0xd90025d1 == function_selector) {\n            DIVIDEND_FUND_FRAC_TOP();\n        } else if (0xe2896598 == function_selector) {\n            leaderTimestamp();\n        } else if (0xfc9774c1 == function_selector) {\n            dividendShares(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 10:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _earnings; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _dividendShares; // STORAGE[0x2]\nuint256 _totalDividendShares; // STORAGE[0x3]\nuint256 _dividendFund; // STORAGE[0x4]\nuint256 _round; // STORAGE[0x5]\nuint256 _pot; // STORAGE[0x6]\nuint256 _leaderTimestamp; // STORAGE[0x8]\nuint256 _leaderBid; // STORAGE[0x9]\naddress _leader; // STORAGE[0x7] bytes 0 to 19\n\n// Events\nWinner(uint256, address, uint256, uint256, uint256);\nBid(uint256, address, uint256, uint256, uint256, uint256);\nDividendsWithdrawal(uint256, address, uint256, uint256, uint256, uint256);\nEarningsWithdrawal(uint256, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction PAYOUT_FRAC_BOT() public nonPayable { \n    return 100;\n}\n\nfunction round() public nonPayable { \n    return _round;\n}\n\nfunction bid() public payable { \n    v0 = 0xed3(1, _pot);\n    assert(10);\n    v1 = v2 = v0 / 10;\n    assert(_leaderTimestamp <= block.timestamp);\n    assert(300);\n    v3 = 0xed3(_leaderBid, (block.timestamp - _leaderTimestamp) / 300);\n    v4 = 0xed3(10, v3);\n    assert(100);\n    v1 = v4 / 100;\n    assert(_earnings[_leader] + v1 >= _earnings[_leader]);\n    _earnings[_leader] = _earnings[_leader] + v1;\n    assert(v1 <= _pot);\n    _pot = _pot - v1;\n    emit Winner(block.timestamp, _leader, v1, _round, _leaderTimestamp);\n    v5 = 0xed3(1, _pot);\n    assert(100);\n    v6 = 0xed3(1, msg.value);\n    assert(2);\n    assert(v6 >> 1 <= msg.value);\n    if (_totalDividendShares != 0) {\n        assert(_totalDividendShares);\n        v7 = v8 = _dividendFund / _totalDividendShares;\n    } else {\n        v9 = 0xed3(1, v5 / 100);\n        assert(2);\n        v7 = v9 >> 1;\n    }\n    assert(_dividendFund + (v6 >> 1) >= _dividendFund);\n    _dividendFund = _dividendFund + (v6 >> 1);\n    assert(_pot + (msg.value - (v6 >> 1)) >= _pot);\n    _pot = _pot + (msg.value - (v6 >> 1));\n    if (msg.value > v5 / 100) {\n        assert(v5 / 100 <= msg.value);\n        v10 = 0xed3(1, msg.value - v5 / 100);\n        assert(2);\n        assert(v7);\n        assert(_dividendShares[msg.sender] + (v10 >> 1) / v7 >= _dividendShares[msg.sender]);\n        _dividendShares[msg.sender] = _dividendShares[msg.sender] + (v10 >> 1) / v7;\n        assert(_totalDividendShares + (v10 >> 1) / v7 >= _totalDividendShares);\n        _totalDividendShares = _totalDividendShares + (v10 >> 1) / v7;\n    }\n    _round += 1;\n    _leader = msg.sender;\n    _leaderTimestamp = block.timestamp;\n    _leaderBid = msg.value;\n    if (_leaderBid > v5 / 100) {\n        _leaderBid = v5 / 100;\n    }\n    emit Bid(block.timestamp, msg.sender, msg.value, _leaderBid, _round, _pot);\n}\n\nfunction dividendFund() public nonPayable { \n    return _dividendFund;\n}\n\nfunction MAX_BID_FRAC_BOT() public nonPayable { \n    return 100;\n}\n\nfunction MAX_PAYOUT_FRAC_BOT() public nonPayable { \n    return 10;\n}\n\nfunction withdrawDividends() public nonPayable { \n    require(_dividendShares[msg.sender] > 0);\n    assert(_dividendShares[msg.sender] <= _totalDividendShares);\n    v0 = 0xed3(_dividendShares[msg.sender], _dividendFund);\n    assert(_totalDividendShares);\n    assert(v0 / _totalDividendShares <= (address(this)).balance);\n    _dividendShares[msg.sender] = 0;\n    assert(_dividendShares[msg.sender] <= _totalDividendShares);\n    _totalDividendShares = _totalDividendShares - _dividendShares[msg.sender];\n    assert(v0 / _totalDividendShares <= _dividendFund);\n    _dividendFund = _dividendFund - v0 / _totalDividendShares;\n    v1 = msg.sender.call().value(v0 / _totalDividendShares).gas(!(v0 / _totalDividendShares) * 2300);\n    require(v1);\n    emit DividendsWithdrawal(block.timestamp, msg.sender, _dividendShares[msg.sender], v0 / _totalDividendShares, _totalDividendShares, _dividendFund);\n}\n\nfunction leader() public nonPayable { \n    return _leader;\n}\n\nfunction PAYOUT_FRAC_TOP() public nonPayable { \n    return 10;\n}\n\nfunction pot() public nonPayable { \n    return _pot;\n}\n\nfunction earnings(address varg0) public nonPayable { \n    return _earnings[varg0];\n}\n\nfunction PAYOUT_TIME() public nonPayable { \n    return 300;\n}\n\nfunction MAX_BID_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction withdrawEarnings() public nonPayable { \n    require(_earnings[msg.sender] > 0);\n    assert(_earnings[msg.sender] <= (address(this)).balance);\n    _earnings[msg.sender] = 0;\n    v0 = msg.sender.call().value(_earnings[msg.sender]).gas(!_earnings[msg.sender] * 2300);\n    require(v0);\n    emit EarningsWithdrawal(block.timestamp, msg.sender, _earnings[msg.sender]);\n}\n\nfunction DIVIDEND_FUND_FRAC_BOT() public nonPayable { \n    return 2;\n}\n\nfunction MAX_PAYOUT_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction leaderBid() public nonPayable { \n    return _leaderBid;\n}\n\nfunction totalDividendShares() public nonPayable { \n    return _totalDividendShares;\n}\n\nfunction DIVIDEND_FUND_FRAC_TOP() public nonPayable { \n    return 1;\n}\n\nfunction leaderTimestamp() public nonPayable { \n    return _leaderTimestamp;\n}\n\nfunction dividendShares(address varg0) public nonPayable { \n    return _dividendShares[varg0];\n}\n\nfunction 0xed3(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (0x8306af3 == function_selector) {\n            PAYOUT_FRAC_BOT();\n        } else if (0x146ca531 == function_selector) {\n            round();\n        } else if (0x1998aeef == function_selector) {\n            bid();\n        } else if (0x1a06008a == function_selector) {\n            dividendFund();\n        } else if (0x1bc44213 == function_selector) {\n            MAX_BID_FRAC_BOT();\n        } else if (0x2871587d == function_selector) {\n            MAX_PAYOUT_FRAC_BOT();\n        } else if (0x2e92abdd == function_selector) {\n            withdrawDividends();\n        } else if (0x40eedabb == function_selector) {\n            leader();\n        } else if (0x41c0dc59 == function_selector) {\n            PAYOUT_FRAC_TOP();\n        } else if (0x4ba2363a == function_selector) {\n            pot();\n        } else if (0x543fd313 == function_selector) {\n            earnings(address);\n        } else if (0x84c6f650 == function_selector) {\n            PAYOUT_TIME();\n        } else if (0x8a7ed05c == function_selector) {\n            MAX_BID_FRAC_TOP();\n        } else if (0xb73c6ce9 == function_selector) {\n            withdrawEarnings();\n        } else if (0xb74e825e == function_selector) {\n            DIVIDEND_FUND_FRAC_BOT();\n        } else if (0xbcc9ed6f == function_selector) {\n            MAX_PAYOUT_FRAC_TOP();\n        } else if (0xc395a16b == function_selector) {\n            leaderBid();\n        } else if (0xc64fa2e4 == function_selector) {\n            totalDividendShares();\n        } else if (0xd90025d1 == function_selector) {\n            DIVIDEND_FUND_FRAC_TOP();\n        } else if (0xe2896598 == function_selector) {\n            leaderTimestamp();\n        } else if (0xfc9774c1 == function_selector) {\n            dividendShares(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 93.54562044143677,
	"usage": {
		"completion_tokens": 1260,
		"prompt_tokens": 2248,
		"total_tokens": 3508
	}
}