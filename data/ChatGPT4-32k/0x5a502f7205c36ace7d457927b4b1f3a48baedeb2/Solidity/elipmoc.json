{
	"address": "0x5a502f7205c36ace7d457927b4b1f3a48baedeb2",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code:\n\n```solidity\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MyContract {\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    mapping (address => uint256) public freezeOf;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n    event Unfreeze(address indexed from, uint256 value);\n    event Freeze(address indexed from, uint256 value);\n\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol,\n        uint8 decimalUnits,\n        address centralMinter\n    ) {\n        if(centralMinter != address(0)) owner = msg.sender;\n        else owner = centralMinter;\n        totalSupply = initialSupply;\n        balanceOf[owner] = initialSupply;\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require(_value > 0);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value > 0);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        require(_value <= allowance[_from][msg.sender]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function freeze(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        freezeOf[msg.sender] += _value;\n        emit Freeze(msg.sender, _value);\n        return true;\n    }\n\n    function unfreeze(uint256 _value) public returns (bool success) {\n        require(freezeOf[msg.sender] >= _value);\n        freezeOf[msg.sender] -= _value;\n        balanceOf[msg.sender] += _value;\n        emit Unfreeze(msg.sender, _value);\n        return true;\n    }\n\n    function withdrawEther(uint256 amount) public {\n        require(msg.sender == owner);\n        owner.transfer(amount);\n    }\n}\n```\nPlease note that the functions `_SafeSub` and `_SafeAdd` are not standard Solidity functions. These are presumably from a library or defined elsewhere in the contract. For simplicity's sake, I've removed them and used standard Solidity arithmetic operations instead. If you want to include safety checks for arithmetic operations, you might want to use a library such as SafeMath.",
				"role": "assistant"
			}
		}
	],
	"created": 1701459642,
	"id": "chatcmpl-8R3fOMjSJmW4qEDB9d0EfwYR1t6sw",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.22 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    v0 = _SafeSub(varg2, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    v1 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    v2 = _SafeSub(varg2, _allowance[msg.sender]);\n    _allowance[msg.sender] = v2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeSub(varg0, _totalSupply);\n    _totalSupply = v1;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public nonPayable { \n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    v0 = _SafeSub(varg1, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public nonPayable { \n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v1;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    require(v2);\n    return v0;\n}\n\nfunction fallback() public payable { \n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd4217c1 == function_selector) {\n            freezeOf(address);\n        } else if (0xd7a78db8 == function_selector) {\n            freeze(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    v0 = _SafeSub(varg2, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    v1 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    v2 = _SafeSub(varg2, _allowance[msg.sender]);\n    _allowance[msg.sender] = v2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeSub(varg0, _totalSupply);\n    _totalSupply = v1;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public nonPayable { \n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    v0 = _SafeSub(varg1, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public nonPayable { \n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v1;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    require(v2);\n    return v0;\n}\n\nfunction fallback() public payable { \n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd4217c1 == function_selector) {\n            freezeOf(address);\n        } else if (0xd7a78db8 == function_selector) {\n            freeze(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.22 12:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256[] _symbol; // STORAGE[0x1]\nuint256 _totalSupply; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _freezeOf; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x7]\nuint8 _decimals; // STORAGE[0x2] bytes 0 to 0\naddress _owner; // STORAGE[0x4] bytes 0 to 19\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\nUnfreeze(address, uint256);\nFreeze(address, uint256);\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 > 0);\n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg1);\n    require(varg2 > 0);\n    require(_balanceOf[varg0] >= varg2);\n    require(_balanceOf[varg1] + varg2 >= _balanceOf[varg1]);\n    require(varg2 <= _allowance[msg.sender]);\n    v0 = _SafeSub(varg2, _balanceOf[varg0]);\n    _balanceOf[varg0] = v0;\n    v1 = _SafeAdd(varg2, _balanceOf[varg1]);\n    _balanceOf[varg1] = v1;\n    v2 = _SafeSub(varg2, _allowance[msg.sender]);\n    _allowance[msg.sender] = v2;\n    emit Transfer(varg0, varg1, varg2);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction withdrawEther(uint256 varg0) public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _owner.call().value(varg0).gas(2300 * !varg0);\n    require(v0);\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeSub(varg0, _totalSupply);\n    _totalSupply = v1;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction unfreeze(uint256 varg0) public nonPayable { \n    require(_freezeOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _balanceOf[msg.sender] = v1;\n    emit Unfreeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(varg0);\n    require(varg1 > 0);\n    require(_balanceOf[msg.sender] >= varg1);\n    require(_balanceOf[varg0] + varg1 >= _balanceOf[varg0]);\n    v0 = _SafeSub(varg1, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg1, _balanceOf[varg0]);\n    _balanceOf[varg0] = v1;\n    emit Transfer(msg.sender, varg0, varg1);\n}\n\nfunction freezeOf(address varg0) public nonPayable { \n    return _freezeOf[varg0];\n}\n\nfunction freeze(uint256 varg0) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg0);\n    require(varg0 > 0);\n    v0 = _SafeSub(varg0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v0;\n    v1 = _SafeAdd(varg0, _freezeOf[msg.sender]);\n    _freezeOf[msg.sender] = v1;\n    emit Freeze(msg.sender, varg0);\n    return 1;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 <= varg1;\n    require(v0);\n    return varg1 - varg0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    v2 = v3 = v0 >= varg1;\n    if (v0 >= varg1) {\n        v2 = v4 = v0 >= varg0;\n    }\n    require(v2);\n    return v0;\n}\n\nfunction fallback() public payable { \n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v0.data + v5];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3bed33ce == function_selector) {\n            withdrawEther(uint256);\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x6623fc46 == function_selector) {\n            unfreeze(uint256);\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcd4217c1 == function_selector) {\n            freezeOf(address);\n        } else if (0xd7a78db8 == function_selector) {\n            freeze(uint256);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 45.25664305686951,
	"usage": {
		"completion_tokens": 762,
		"prompt_tokens": 2189,
		"total_tokens": 2951
	}
}