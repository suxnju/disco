{
	"address": "0xa4b373c22477e95c33de40bb6cf600b063279e5c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity implementation based on the decompiled code above. Note that decompiled code might not be 100% accurate, as it is generated by analysing EVM bytecode.\n\nPlease note that the following code is a simplification and does not cover all the aspects of the original contract, such as the actual implementation of the `name()` and `symbol()` functions.\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract FireDate {\n    uint256 _totalSupply;\n    mapping (address => uint256) _balanceOf;\n    mapping (address => mapping (address => uint256)) _allowance;\n    uint256 _fundingStartBlock;\n    uint256 _fundingEndBlock;\n    uint256 _crowdsaleSupply;\n    uint256 _tokenExchangeRate;\n    uint256 _tokenCrowdsaleCap;\n    address _ethFundDeposit;\n    address _tokenFundDeposit;\n    bool _isFinalized;\n\n    event CreateFIREDATE(address indexed sender, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function finalize(uint256 amount) external payable {\n        require(!_isFinalized);\n        require(amount < address(this).balance);\n        _isFinalized = true;\n        (bool success,) = _ethFundDeposit.call{value: amount}(\"\");\n        require(success);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool) {\n        require(value <= _balanceOf[from]);\n        require(value <= _allowance[from][msg.sender]);\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n        _allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        return _balanceOf[owner];\n    }\n\n    function isFinalized() external view returns (bool) {\n        return _isFinalized;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        require(value <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= value;\n        _balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining) {\n        return _allowance[owner][spender];\n    }\n}\n```\n\nPlease note that the above contract is a simplification of the original contract and thus may not cover all functionalities of the original contract. It's also important to note that the recompiled contract does not include all safety checks and necessary error handling. This is just a rough translation from the decompiled code to Solidity and it's likely to not compile or work as intended without further modifications.",
				"role": "assistant"
			}
		}
	],
	"created": 1701466968,
	"id": "chatcmpl-8R5ZYB20IhjRp4T6tgQ9faW2diJc9",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 20:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256[] _version; // STORAGE[0x3]\nuint256 _fundingStartBlock; // STORAGE[0x6]\nuint256 _fundingEndBlock; // STORAGE[0x7]\nuint256 _crowdsaleSupply; // STORAGE[0x8]\nuint256 _tokenExchangeRate; // STORAGE[0x9]\nuint256 _tokenCrowdsaleCap; // STORAGE[0xa]\naddress _ethFundDeposit; // STORAGE[0x4] bytes 0 to 19\nuint160 _tokenFundDeposit; // STORAGE[0x5] bytes 0 to 19\nuint8 _isFinalized; // STORAGE[0x5] bytes 20 to 20\n\n// Events\nCreateFIREDATE(address, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(!_isFinalized);\n    require(block.number >= _fundingStartBlock);\n    require(block.number < _fundingEndBlock);\n    require(msg.value > 0);\n    v0 = _SafeMul(_tokenExchangeRate, msg.value);\n    v1 = _SafeAdd(v0, _crowdsaleSupply);\n    _crowdsaleSupply = v1;\n    require(_tokenCrowdsaleCap >= v1);\n    v2 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    v3 = _SafeSub(v0, _balanceOf[_tokenFundDeposit]);\n    _balanceOf[_tokenFundDeposit] = v3;\n    emit CreateFIREDATE(msg.sender, v0);\n}\n\nfunction finalize(uint256 varg0) public nonPayable { \n    assert(!_isFinalized);\n    _isFinalized = 1;\n    require(varg0 < this.balance);\n    v0 = _ethFundDeposit.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'FIREDATE';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x6af(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 0;\n}\n\nfunction tokenExchangeRate() public nonPayable { \n    return _tokenExchangeRate;\n}\n\nfunction checkContractBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[]((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n        if (31 < (_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction tokenCreationCap() public nonPayable { \n    return 0x48cab98f1671af58000000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction isFinalized() public nonPayable { \n    return _isFinalized;\n}\n\nfunction fundingEndBlock() public nonPayable { \n    return _fundingEndBlock;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4c49505300000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction tokenFundDeposit() public nonPayable { \n    return _tokenFundDeposit;\n}\n\nfunction ethFundDeposit() public nonPayable { \n    return _ethFundDeposit;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x5830x8ceB0x486;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = v4 = 1;\n    }\n    return v2;\n}\n\nfunction updateParams(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    assert(block.number < _fundingStartBlock);\n    assert(!_isFinalized);\n    _tokenExchangeRate = varg0;\n    _tokenCrowdsaleCap = varg1;\n    _fundingStartBlock = varg2;\n    _fundingEndBlock = varg3;\n}\n\nfunction createTokens() public payable { \n    require(!_isFinalized);\n    require(block.number >= _fundingStartBlock);\n    require(block.number < _fundingEndBlock);\n    require(msg.value > 0);\n    v0 = _SafeMul(_tokenExchangeRate, msg.value);\n    v1 = _SafeAdd(v0, _crowdsaleSupply);\n    _crowdsaleSupply = v1;\n    require(_tokenCrowdsaleCap >= v1);\n    v2 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    v3 = _SafeSub(v0, _balanceOf[_tokenFundDeposit]);\n    _balanceOf[_tokenFundDeposit] = v3;\n    emit CreateFIREDATE(msg.sender, v0);\n}\n\nfunction crowdsaleSupply() public nonPayable { \n    return _crowdsaleSupply;\n}\n\nfunction fundingStartBlock() public nonPayable { \n    return _fundingStartBlock;\n}\n\nfunction tokenCrowdsaleCap() public nonPayable { \n    return _tokenCrowdsaleCap;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    if (v1) {\n        assert(!v1);\n    } else {\n        assert(v0 >= varg0);\n    }\n    return v0;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= varg1);\n    return varg1 - varg0;\n}\n\nfunction 0x6af(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = varg0 > _balanceOf[v0];\n    v2 = v3 = varg0 <= _balanceOf[v0];\n    if (varg0 <= _balanceOf[v0]) {\n        v4 = address(varg2);\n        v2 = v5 = varg0 <= _allowance[msg.sender];\n    }\n    if (v2) {\n        v2 = v6 = varg0 > 0;\n    }\n    if (!v2) {\n        return 0;\n    } else {\n        v7 = address(varg1);\n        _balanceOf[v7] += varg0;\n        v8 = address(varg2);\n        _balanceOf[v8] = _balanceOf[v8] - varg0;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n        emit Transfer(v8, v7, varg0);\n        return 1;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x5261aea) {\n            finalize(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4172d080 == function_selector) {\n            tokenExchangeRate();\n        } else if (0x50312c9e == function_selector) {\n            checkContractBalance();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x6f7920fd == function_selector) {\n            tokenCreationCap();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8d4e4083 == function_selector) {\n            isFinalized();\n        } else if (0x91b43d13 == function_selector) {\n            fundingEndBlock();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9a0750d5 == function_selector) {\n            tokenFundDeposit();\n        } else if (0xa81c3bdf == function_selector) {\n            ethFundDeposit();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb0557bf1 == function_selector) {\n            updateParams(uint256,uint256,uint256,uint256);\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xcdcb3cdb == function_selector) {\n            crowdsaleSupply();\n        } else if (0xd648a647 == function_selector) {\n            fundingStartBlock();\n        } else if (0xd6f3c45f == function_selector) {\n            tokenCrowdsaleCap();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 20:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256[] _version; // STORAGE[0x3]\nuint256 _fundingStartBlock; // STORAGE[0x6]\nuint256 _fundingEndBlock; // STORAGE[0x7]\nuint256 _crowdsaleSupply; // STORAGE[0x8]\nuint256 _tokenExchangeRate; // STORAGE[0x9]\nuint256 _tokenCrowdsaleCap; // STORAGE[0xa]\naddress _ethFundDeposit; // STORAGE[0x4] bytes 0 to 19\nuint160 _tokenFundDeposit; // STORAGE[0x5] bytes 0 to 19\nuint8 _isFinalized; // STORAGE[0x5] bytes 20 to 20\n\n// Events\nCreateFIREDATE(address, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(!_isFinalized);\n    require(block.number >= _fundingStartBlock);\n    require(block.number < _fundingEndBlock);\n    require(msg.value > 0);\n    v0 = _SafeMul(_tokenExchangeRate, msg.value);\n    v1 = _SafeAdd(v0, _crowdsaleSupply);\n    _crowdsaleSupply = v1;\n    require(_tokenCrowdsaleCap >= v1);\n    v2 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    v3 = _SafeSub(v0, _balanceOf[_tokenFundDeposit]);\n    _balanceOf[_tokenFundDeposit] = v3;\n    emit CreateFIREDATE(msg.sender, v0);\n}\n\nfunction finalize(uint256 varg0) public nonPayable { \n    assert(!_isFinalized);\n    _isFinalized = 1;\n    require(varg0 < this.balance);\n    v0 = _ethFundDeposit.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'FIREDATE';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x6af(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 0;\n}\n\nfunction tokenExchangeRate() public nonPayable { \n    return _tokenExchangeRate;\n}\n\nfunction checkContractBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[]((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n        if (31 < (_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction tokenCreationCap() public nonPayable { \n    return 0x48cab98f1671af58000000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction isFinalized() public nonPayable { \n    return _isFinalized;\n}\n\nfunction fundingEndBlock() public nonPayable { \n    return _fundingEndBlock;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4c49505300000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction tokenFundDeposit() public nonPayable { \n    return _tokenFundDeposit;\n}\n\nfunction ethFundDeposit() public nonPayable { \n    return _ethFundDeposit;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x5830x8ceB0x486;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = v4 = 1;\n    }\n    return v2;\n}\n\nfunction updateParams(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    assert(block.number < _fundingStartBlock);\n    assert(!_isFinalized);\n    _tokenExchangeRate = varg0;\n    _tokenCrowdsaleCap = varg1;\n    _fundingStartBlock = varg2;\n    _fundingEndBlock = varg3;\n}\n\nfunction createTokens() public payable { \n    require(!_isFinalized);\n    require(block.number >= _fundingStartBlock);\n    require(block.number < _fundingEndBlock);\n    require(msg.value > 0);\n    v0 = _SafeMul(_tokenExchangeRate, msg.value);\n    v1 = _SafeAdd(v0, _crowdsaleSupply);\n    _crowdsaleSupply = v1;\n    require(_tokenCrowdsaleCap >= v1);\n    v2 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    v3 = _SafeSub(v0, _balanceOf[_tokenFundDeposit]);\n    _balanceOf[_tokenFundDeposit] = v3;\n    emit CreateFIREDATE(msg.sender, v0);\n}\n\nfunction crowdsaleSupply() public nonPayable { \n    return _crowdsaleSupply;\n}\n\nfunction fundingStartBlock() public nonPayable { \n    return _fundingStartBlock;\n}\n\nfunction tokenCrowdsaleCap() public nonPayable { \n    return _tokenCrowdsaleCap;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    if (v1) {\n        assert(!v1);\n    } else {\n        assert(v0 >= varg0);\n    }\n    return v0;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= varg1);\n    return varg1 - varg0;\n}\n\nfunction 0x6af(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = varg0 > _balanceOf[v0];\n    v2 = v3 = varg0 <= _balanceOf[v0];\n    if (varg0 <= _balanceOf[v0]) {\n        v4 = address(varg2);\n        v2 = v5 = varg0 <= _allowance[msg.sender];\n    }\n    if (v2) {\n        v2 = v6 = varg0 > 0;\n    }\n    if (!v2) {\n        return 0;\n    } else {\n        v7 = address(varg1);\n        _balanceOf[v7] += varg0;\n        v8 = address(varg2);\n        _balanceOf[v8] = _balanceOf[v8] - varg0;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n        emit Transfer(v8, v7, varg0);\n        return 1;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x5261aea) {\n            finalize(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4172d080 == function_selector) {\n            tokenExchangeRate();\n        } else if (0x50312c9e == function_selector) {\n            checkContractBalance();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x6f7920fd == function_selector) {\n            tokenCreationCap();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8d4e4083 == function_selector) {\n            isFinalized();\n        } else if (0x91b43d13 == function_selector) {\n            fundingEndBlock();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9a0750d5 == function_selector) {\n            tokenFundDeposit();\n        } else if (0xa81c3bdf == function_selector) {\n            ethFundDeposit();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb0557bf1 == function_selector) {\n            updateParams(uint256,uint256,uint256,uint256);\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xcdcb3cdb == function_selector) {\n            crowdsaleSupply();\n        } else if (0xd648a647 == function_selector) {\n            fundingStartBlock();\n        } else if (0xd6f3c45f == function_selector) {\n            tokenCrowdsaleCap();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 20:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x2]\nuint256[] _version; // STORAGE[0x3]\nuint256 _fundingStartBlock; // STORAGE[0x6]\nuint256 _fundingEndBlock; // STORAGE[0x7]\nuint256 _crowdsaleSupply; // STORAGE[0x8]\nuint256 _tokenExchangeRate; // STORAGE[0x9]\nuint256 _tokenCrowdsaleCap; // STORAGE[0xa]\naddress _ethFundDeposit; // STORAGE[0x4] bytes 0 to 19\nuint160 _tokenFundDeposit; // STORAGE[0x5] bytes 0 to 19\nuint8 _isFinalized; // STORAGE[0x5] bytes 20 to 20\n\n// Events\nCreateFIREDATE(address, uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction fallback() public payable { \n    assert(!_isFinalized);\n    require(block.number >= _fundingStartBlock);\n    require(block.number < _fundingEndBlock);\n    require(msg.value > 0);\n    v0 = _SafeMul(_tokenExchangeRate, msg.value);\n    v1 = _SafeAdd(v0, _crowdsaleSupply);\n    _crowdsaleSupply = v1;\n    require(_tokenCrowdsaleCap >= v1);\n    v2 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    v3 = _SafeSub(v0, _balanceOf[_tokenFundDeposit]);\n    _balanceOf[_tokenFundDeposit] = v3;\n    emit CreateFIREDATE(msg.sender, v0);\n}\n\nfunction finalize(uint256 varg0) public nonPayable { \n    assert(!_isFinalized);\n    _isFinalized = 1;\n    require(varg0 < this.balance);\n    v0 = _ethFundDeposit.call().value(varg0).gas(2300 * !varg0);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction name() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (8) {\n        MEM[v0.data] = ~0xffffffffffffffffffffffffffffffffffffffffffffffff & 'FIREDATE';\n    }\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    emit Approval(msg.sender, varg0, varg1);\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    v0 = 0x6af(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction decimals() public nonPayable { \n    return 0;\n}\n\nfunction tokenExchangeRate() public nonPayable { \n    return _tokenExchangeRate;\n}\n\nfunction checkContractBalance() public nonPayable { \n    return this.balance;\n}\n\nfunction version() public nonPayable { \n    v0 = new bytes[]((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n        if (31 < (_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_version.length & ~0 + (!(_version.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _version.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction tokenCreationCap() public nonPayable { \n    return 0x48cab98f1671af58000000;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction isFinalized() public nonPayable { \n    return _isFinalized;\n}\n\nfunction fundingEndBlock() public nonPayable { \n    return _fundingEndBlock;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new array[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        MEM[v2 + v0.data] = MEM[v2 + v1.data];\n        v2 += 32;\n    }\n    if (4) {\n        MEM[v0.data] = 0x4c49505300000000000000000000000000000000000000000000000000000000;\n    }\n    return v0;\n}\n\nfunction tokenFundDeposit() public nonPayable { \n    return _tokenFundDeposit;\n}\n\nfunction ethFundDeposit() public nonPayable { \n    return _ethFundDeposit;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    v0 = v1 = varg1 <= _balanceOf[msg.sender];\n    if (varg1 <= _balanceOf[msg.sender]) {\n        v0 = varg1 > 0;\n    }\n    if (!v0) {\n        v2 = v3 = 0;\n        goto 0x5830x8ceB0x486;\n    } else {\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        emit Transfer(msg.sender, varg0, varg1);\n        v2 = v4 = 1;\n    }\n    return v2;\n}\n\nfunction updateParams(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) public nonPayable { \n    assert(block.number < _fundingStartBlock);\n    assert(!_isFinalized);\n    _tokenExchangeRate = varg0;\n    _tokenCrowdsaleCap = varg1;\n    _fundingStartBlock = varg2;\n    _fundingEndBlock = varg3;\n}\n\nfunction createTokens() public payable { \n    require(!_isFinalized);\n    require(block.number >= _fundingStartBlock);\n    require(block.number < _fundingEndBlock);\n    require(msg.value > 0);\n    v0 = _SafeMul(_tokenExchangeRate, msg.value);\n    v1 = _SafeAdd(v0, _crowdsaleSupply);\n    _crowdsaleSupply = v1;\n    require(_tokenCrowdsaleCap >= v1);\n    v2 = _SafeAdd(v0, _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = v2;\n    v3 = _SafeSub(v0, _balanceOf[_tokenFundDeposit]);\n    _balanceOf[_tokenFundDeposit] = v3;\n    emit CreateFIREDATE(msg.sender, v0);\n}\n\nfunction crowdsaleSupply() public nonPayable { \n    return _crowdsaleSupply;\n}\n\nfunction fundingStartBlock() public nonPayable { \n    return _fundingStartBlock;\n}\n\nfunction tokenCrowdsaleCap() public nonPayable { \n    return _tokenCrowdsaleCap;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 * varg1;\n    v1 = v2 = !varg1;\n    if (varg1) {\n        assert(varg1);\n        v1 = v3 = v0 / varg1 == varg0;\n    }\n    assert(v1);\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    v1 = v0 < varg1;\n    if (v1) {\n        assert(!v1);\n    } else {\n        assert(v0 >= varg0);\n    }\n    return v0;\n}\n\nfunction _SafeSub(uint256 varg0, uint256 varg1) private { \n    assert(varg0 <= varg1);\n    return varg1 - varg0;\n}\n\nfunction 0x6af(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg2);\n    v1 = varg0 > _balanceOf[v0];\n    v2 = v3 = varg0 <= _balanceOf[v0];\n    if (varg0 <= _balanceOf[v0]) {\n        v4 = address(varg2);\n        v2 = v5 = varg0 <= _allowance[msg.sender];\n    }\n    if (v2) {\n        v2 = v6 = varg0 > 0;\n    }\n    if (!v2) {\n        return 0;\n    } else {\n        v7 = address(varg1);\n        _balanceOf[v7] += varg0;\n        v8 = address(varg2);\n        _balanceOf[v8] = _balanceOf[v8] - varg0;\n        _allowance[msg.sender] = _allowance[msg.sender] - varg0;\n        emit Transfer(v8, v7, varg0);\n        return 1;\n    }\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x5261aea) {\n            finalize(uint256);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x4172d080 == function_selector) {\n            tokenExchangeRate();\n        } else if (0x50312c9e == function_selector) {\n            checkContractBalance();\n        } else if (0x54fd4d50 == function_selector) {\n            version();\n        } else if (0x6f7920fd == function_selector) {\n            tokenCreationCap();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8d4e4083 == function_selector) {\n            isFinalized();\n        } else if (0x91b43d13 == function_selector) {\n            fundingEndBlock();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0x9a0750d5 == function_selector) {\n            tokenFundDeposit();\n        } else if (0xa81c3bdf == function_selector) {\n            ethFundDeposit();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xb0557bf1 == function_selector) {\n            updateParams(uint256,uint256,uint256,uint256);\n        } else if (0xb4427263 == function_selector) {\n            createTokens();\n        } else if (0xcdcb3cdb == function_selector) {\n            crowdsaleSupply();\n        } else if (0xd648a647 == function_selector) {\n            fundingStartBlock();\n        } else if (0xd6f3c45f == function_selector) {\n            tokenCrowdsaleCap();\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 30.838289976119995,
	"usage": {
		"completion_tokens": 665,
		"prompt_tokens": 2955,
		"total_tokens": 3620
	}
}