{
	"address": "0x2b78a837c37549539c62ab54a235a8e19fea812f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Apologies, but the decompiled code is very complex and it includes a lot of low-level EVM instructions which are not directly translatable to Solidity. Furthermore, it seems to include some pseudo-operations which are not part of the EVM's instruction set, such as `CALLDATACOPY`. Additionally, it appears to include some placeholder values such as `(?)` which are not valid Solidity. \n\nDue to these factors, it's not possible to accurately translate this decompiled code into a Solidity smart contract without more context or clarity. The decompiled code seems to be involved in various operations such as adding and removing administrators, settling transactions, withdrawing and depositing funds, etc. It is recommended to refer to original Solidity code or documentation to understand the contract's functionality. \n\nHere is a simple example of a smart contract in Solidity for reference:\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract SimpleContract {\n    uint256 public count;\n\n    function incrementCount() public {\n        count += 1;\n    }\n}\n```\nThis contract has a single public state variable `count` and a function `incrementCount` that increases the `count` by one each time it's called.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039581,
	"id": "chatcmpl-8Chx7jPkZFiIxY4DhRlyW87qV24YM",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.24 21:00 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _admins; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _settle; // STORAGE[0x2]\nuint256 _getEscrowBalance; // STORAGE[0x3]\n\n// Events\nDebit(bytes32, uint256, uint256);\nWithdraw(bytes32, uint256, uint256, address);\nDeposit(bytes32, address, uint256);\nLink(bytes32, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction settle(bytes32[] varg0, uint256[] varg1, uint256[] varg2) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v4 = v5 = v1.length == v2.length;\n    if (v5) {\n        v4 = v6 = v1.length == v3.length;\n    }\n    require(v4);\n    v7 = v8 = _getEscrowBalance;\n    v9 = v10 = 0;\n    while (v9 < v1.length) {\n        assert(v9 < v1.length);\n        assert(v9 < v3.length);\n        require(v3[v9] <= v7);\n        _deposit[v1[v9]] += v3[v9];\n        v7 = v7 - v3[v9];\n        assert(v9 < v2.length);\n        emit 0xcd738c9c0bbe501d6da72544aaef2b26bfdcbffa10507ff2755918321897c56(v1[v9], v2[v9], v3[v9]);\n        v9 = v9 + 1;\n    }\n    _getEscrowBalance = v7;\n}\n\nfunction 0x13ac(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    MEM[MEM[64] + 32] = varg3;\n    MEM[64 + MEM[64]] = address(varg2) << 96;\n    MEM[MEM[64] + 84] = varg1;\n    MEM[MEM[64] + 116] = uint64(varg0) << 192;\n    v0 = v1 = MEM[64] + 124;\n    v2 = v3 = 92;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\nfunction 0x1543(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[MEM[64] + 32] = varg2;\n    MEM[64 + MEM[64]] = varg1;\n    MEM[MEM[64] + 96] = uint64(varg0) << 192;\n    v0 = v1 = MEM[64] + 104;\n    v2 = v3 = 72;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\nfunction admins(uint256 varg0) public nonPayable { \n    assert(varg0 < _admins.length);\n    return address(_admins[varg0]);\n}\n\nfunction removeAdmin(address varg0) public nonPayable { \n    0x9e5(varg0);\n}\n\nfunction debit(bytes32[] varg0, uint256[] varg1, uint64[] varg2, uint8[] varg3, bytes32[] varg4, bytes32[] varg5) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v7 = v8 = v1.length == v2.length;\n    if (v8) {\n        v7 = v9 = v1.length == v3.length;\n    }\n    if (v7) {\n        v7 = v10 = v1.length == v4.length;\n    }\n    if (v7) {\n        v7 = v11 = v1.length == v5.length;\n    }\n    if (v7) {\n        v7 = v12 = v1.length == v6.length;\n    }\n    require(v7);\n    v13 = v14 = 0;\n    v15 = v16 = 0;\n    while (v15 < v1.length) {\n        assert(v15 < v1.length);\n        assert(v15 < v2.length);\n        assert(v15 < v3.length);\n        v17 = 0x1543(v3[v15], v2[v15], v1[v15]);\n        assert(v15 < v4.length);\n        assert(v15 < v5.length);\n        assert(v15 < v6.length);\n        v18 = v19 = 28;\n        v20 = v21 = v22.data;\n        v23 = v24 = 32 + MEM[64];\n        while (v18 >= 32) {\n            MEM[v23] = MEM[v20];\n            v18 = v18 + ~31;\n            v23 += 32;\n            v20 += 32;\n        }\n        MEM[v23] = ~0 + 256 ** (32 - v18) & MEM[v23] | MEM[v20] & ~(~0 + 256 ** (32 - v18));\n        MEM[v24 + v19] = v17;\n        v25 = v26 = 32 + (v24 + v19);\n        v27 = v28 = v24 + v19 - MEM[64];\n        v29 = MEM[64] + 32;\n        while (v27 >= 32) {\n            MEM[v25] = MEM[v29];\n            v27 = v27 + ~31;\n            v25 += 32;\n            v29 += 32;\n        }\n        MEM[v25] = ~0 + 256 ** (32 - v27) & MEM[v25] | MEM[v29] & ~(~0 + 256 ** (32 - v27));\n        MEM[v30.data] = 0;\n        MEM[32 + v30.data] = keccak256(v30.data);\n        MEM[64 + v30.data] = v4[v15] & 0xff;\n        MEM[v30.data + 96] = v5[v15];\n        MEM[v30.data + 128] = v6[v15];\n        v31 = ecrecover(MEM[(MEM[64]) len (160 + (v30.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v31); // checks call status, propagates error data on error\n        v32 = v33 = uint64(_deposit[v1[v15]][2]) < uint64(v3[v15]);\n        if (v33) {\n            v32 = v34 = v2[v15] <= _deposit[v1[v15]];\n        }\n        if (v32) {\n            v32 = v35 = 0xff & STORAGE[keccak256(address(MEM[~31 + MEM[64]]), keccak256(v1[v15], 1) + 1)];\n        }\n        if (v32) {\n            _deposit[v1[v15]][2] = uint64(v3[v15]) | ~0xffffffffffffffff & _deposit[v1[v15]][0x2];\n            _deposit[v1[v15]] = _deposit[v1[v15]] - v2[v15];\n            emit Debit(v1[v15], uint64(v3[v15]), v2[v15]);\n            v13 += v2[v15];\n        }\n        v15 = v15 + 1;\n    }\n    _getEscrowBalance += v13;\n}\n\nfunction getMessageSigner(bytes32 varg0, uint8 varg1, bytes32 varg2, bytes32 varg3) public nonPayable { \n    v0 = v1 = 28;\n    v2 = v3 = v4.data;\n    v5 = v6 = 32 + MEM[64];\n    while (v0 >= 32) {\n        MEM[v5] = MEM[v2];\n        v0 = v0 + ~31;\n        v5 += 32;\n        v2 += 32;\n    }\n    MEM[v5] = ~0 + 256 ** (32 - v0) & MEM[v5] | MEM[v2] & ~(~0 + 256 ** (32 - v0));\n    MEM[v6 + v1] = varg0;\n    v7 = v8 = 32 + (v6 + v1);\n    v9 = v10 = 60;\n    v11 = MEM[64] + 32;\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v9 = v9 + ~31;\n        v7 += 32;\n        v11 += 32;\n    }\n    MEM[v7] = ~0 + 256 ** (32 - v9) & MEM[v7] | MEM[v11] & ~(~0 + 256 ** (32 - v9));\n    MEM[v12.data] = 0;\n    MEM[32 + v12.data] = keccak256(v12.data);\n    MEM[64 + v12.data] = varg1 & 0xff & 0xff;\n    MEM[v12.data + 96] = varg2;\n    MEM[v12.data + 128] = varg3;\n    v13, v14 = ecrecover(keccak256(v12.data), varg1 & 0xff & 0xff, varg2, varg3);\n    require(v13); // checks call status, propagates error data on error\n    return address(MEM[~31 + MEM[64]]);\n}\n\nfunction getLinkDigest(bytes32 varg0, address varg1) public nonPayable { \n    v0 = 0xee0(varg1, varg0);\n    return v0;\n}\n\nfunction withdraw(bytes32[] varg0, address[] varg1, uint256[] varg2, uint64[] varg3, uint8[] varg4, bytes32[] varg5, bytes32[] varg6) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    CALLDATACOPY(v7.data, 36 + varg6, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v8 = v9 = v1.length == v2.length;\n    if (v9) {\n        v8 = v10 = v1.length == v3.length;\n    }\n    if (v8) {\n        v8 = v11 = v1.length == v4.length;\n    }\n    if (v8) {\n        v8 = v12 = v1.length == v5.length;\n    }\n    if (v8) {\n        v8 = v13 = v1.length == v6.length;\n    }\n    if (v8) {\n        v8 = v1.length == v7.length;\n    }\n    require(v8);\n    v14 = v15 = 0;\n    while (v14 < v1.length) {\n        if (v14 < v1.length) {\n            break;\n        }\n        assert(v14 < v1.length);\n        assert(v14 < v2.length);\n        assert(v14 < v3.length);\n        assert(v14 < v4.length);\n        v16 = 0x13ac(v4[v14], v3[v14], v2[v14], v1[v14]);\n        assert(v14 < v5.length);\n        assert(v14 < v6.length);\n        assert(v14 < v7.length);\n        v17 = v18 = 28;\n        v19 = v20 = v21.data;\n        v22 = v23 = 32 + MEM[64];\n        while (v17 >= 32) {\n            MEM[v22] = MEM[v19];\n            v17 = v17 + ~31;\n            v22 += 32;\n            v19 += 32;\n        }\n        MEM[v22] = ~0 + 256 ** (32 - v17) & MEM[v22] | MEM[v19] & ~(~0 + 256 ** (32 - v17));\n        MEM[v23 + v18] = v16;\n        v24 = v25 = 32 + (v23 + v18);\n        v26 = v27 = v23 + v18 - MEM[64];\n        v28 = v29 = MEM[64] + 32;\n        while (v26 >= 32) {\n            MEM[v24] = MEM[v28];\n            v26 = v26 + ~31;\n            v24 += 32;\n            v28 += 32;\n        }\n        MEM[v24] = ~0 + 256 ** (32 - v26) & MEM[v24] | MEM[v28] & ~(~0 + 256 ** (32 - v26));\n        MEM[v30.data] = 0;\n        MEM[32 + v30.data] = keccak256(v30.data);\n        MEM[64 + v30.data] = v5[v14] & 0xff;\n        MEM[v30.data + 96] = v6[v14];\n        MEM[v30.data + 128] = v7[v14];\n        v31 = ecrecover(MEM[(MEM[64]) len (160 + (v30.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v31); // checks call status, propagates error data on error\n        v32 = v33 = uint64(_deposit[v1[v14]][2] >> 64) < uint64(v4[v14]);\n        if (v33) {\n            v32 = v34 = v3[v14] <= _deposit[v1[v14]];\n        }\n        if (v32) {\n            v32 = v35 = 0xff & STORAGE[keccak256(address(MEM[~31 + MEM[64]]), keccak256(v1[v14], 1) + 1)];\n        }\n        if (v32) {\n            v32 = address(v2[v14]).call().value(v3[v14]).gas(2300 * !v3[v14]);\n        }\n        if (v32) {\n            _deposit[v1[v14]][2] = _deposit[v1[v14]][0x2] & ~0xffffffffffffffff0000000000000000 | uint64(v4[v14]) << 64;\n            _deposit[v1[v14]] = _deposit[v1[v14]] - v3[v14];\n            emit Withdraw(v1[v14], uint64(v4[v14]), v3[v14], address(v2[v14]));\n        }\n        v14 = v14 + 1;\n    }\n}\n\nfunction getNameDigest(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = v3 = 32 + MEM[64];\n    v4 = v5 = v0.length;\n    v6 = v7 = v0.data;\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v6];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v6 += 32;\n    }\n    MEM[v2] = MEM[v6] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v8 = v9 = v9.data;\n    v10 = v11 = v5 + v3 - MEM[64] - 32;\n    v12 = v13 = 32 + MEM[64];\n    while (v10 >= 32) {\n        MEM[v8] = MEM[v12];\n        v10 = v10 + ~31;\n        v8 += 32;\n        v12 += 32;\n    }\n    MEM[v8] = MEM[v8] & ~0 + 256 ** (32 - v10) | MEM[v12] & ~(~0 + 256 ** (32 - v10));\n    return keccak256(v9);\n}\n\nfunction changeRootAdmin(address varg0) public nonPayable { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    v0 = v1 = 0xff & _settle[varg0];\n    if (v1) {\n        assert(0 < _admins.length);\n        v0 = v2 = address(_admins[0x0]) != varg0;\n    }\n    if (v0) {\n        0x9e5(varg0);\n    }\n    assert(0 < _admins.length);\n    _admins[0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _admins[0x0];\n    _settle[varg0] = 0x1 | ~0xff & _settle[varg0];\n}\n\nfunction getWithdrawDigest(bytes32 varg0, address varg1, uint256 varg2, uint64 varg3) public nonPayable { \n    v0 = 0x13ac(varg3, varg2, varg1, varg0);\n    return v0;\n}\n\nfunction addAdmin(address varg0) public nonPayable { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    require(!(0xff & _settle[varg0]));\n    _settle[varg0] = 0x1 | ~0xff & _settle[varg0];\n    _admins.length = _admins.length + 1;\n    MEM[0] = 0;\n    STORAGE[0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563 + _admins.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563 + _admins.length];\n}\n\nfunction getDebitDigest(bytes32 varg0, uint256 varg1, uint64 varg2) public nonPayable { \n    v0 = 0x1543(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction getBalance(bytes32 varg0) public nonPayable { \n    return _deposit[varg0];\n}\n\nfunction deposit(bytes32 varg0) public payable { \n    _deposit[varg0] += msg.value;\n    emit Deposit(varg0, msg.sender, msg.value);\n}\n\nfunction link(bytes32[] varg0, bytes32[] varg1, address[] varg2, uint8[] varg3, bytes32[] varg4, bytes32[] varg5) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v7 = v8 = v1.length == v2.length;\n    if (v8) {\n        v7 = v9 = v1.length == v3.length;\n    }\n    if (v7) {\n        v7 = v10 = v1.length == v4.length;\n    }\n    if (v7) {\n        v7 = v11 = v1.length == v5.length;\n    }\n    if (v7) {\n        v7 = v1.length == v6.length;\n    }\n    require(v7);\n    v12 = v13 = 0;\n    while (v12 < v1.length) {\n        assert(v12 < v1.length);\n        assert(v12 < v3.length);\n        v14 = 0xee0(v3[v12], v1[v12]);\n        assert(v12 < v4.length);\n        assert(v12 < v5.length);\n        assert(v12 < v6.length);\n        v15 = v16 = 28;\n        v17 = v18 = v19.data;\n        v20 = v21 = 32 + MEM[64];\n        while (v15 >= 32) {\n            MEM[v20] = MEM[v17];\n            v15 = v15 + ~31;\n            v20 += 32;\n            v17 += 32;\n        }\n        MEM[v20] = ~0 + 256 ** (32 - v15) & MEM[v20] | MEM[v17] & ~(~0 + 256 ** (32 - v15));\n        MEM[v21 + v16] = v14;\n        v22 = v23 = 32 + (v21 + v16);\n        v24 = v25 = v21 + v16 - MEM[64];\n        v26 = v27 = MEM[64] + 32;\n        while (v24 >= 32) {\n            MEM[v22] = MEM[v26];\n            v24 = v24 + ~31;\n            v22 += 32;\n            v26 += 32;\n        }\n        MEM[v22] = ~0 + 256 ** (32 - v24) & MEM[v22] | MEM[v26] & ~(~0 + 256 ** (32 - v24));\n        MEM[v28.data] = 0;\n        MEM[32 + v28.data] = keccak256(v28.data);\n        MEM[64 + v28.data] = v4[v12] & 0xff;\n        MEM[v28.data + 96] = v5[v12];\n        MEM[v28.data + 128] = v6[v12];\n        v29 = ecrecover(MEM[(MEM[64]) len (160 + (v28.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v29); // checks call status, propagates error data on error\n        v30 = v31 = 0xff & _deposit[address(MEM[~31 + MEM[64]])];\n        if (!v31) {\n            assert(v12 < v2.length);\n            MEM[MEM[64] + 32] = v2[v12];\n            MEM[64 + MEM[64]] = address(MEM[~31 + MEM[64]]) << 96;\n            v32 = v33 = MEM[64] + 84;\n            v34 = v35 = 52;\n            v36 = v37 = MEM[64] + 32;\n            while (v34 >= 32) {\n                MEM[v32] = MEM[v36];\n                v34 = v34 + ~31;\n                v32 += 32;\n                v36 += 32;\n            }\n            MEM[v32] = MEM[v32] & ~0 + 256 ** (32 - v34) | MEM[v36] & ~(~0 + 256 ** (32 - v34));\n            v30 = v1[v12] == keccak256(v38.data);\n        }\n        if (v30) {\n            STORAGE[keccak256(address(v3[v12]), 1 + keccak256(v1[v12], 1))] = 0x1 | ~0xff & STORAGE[keccak256(address(v3[v12]), 1 + keccak256(v1[v12], 1))];\n            emit Link(v1[v12], address(v3[v12]));\n        }\n        v12 = v12 + 1;\n    }\n}\n\nfunction getDebitNonce(bytes32 varg0) public nonPayable { \n    return uint64(1 + uint64(_deposit[varg0][2]));\n}\n\nfunction getEscrowBalance() public nonPayable { \n    return _getEscrowBalance;\n}\n\nfunction getWithdrawNonce(bytes32 varg0) public nonPayable { \n    return uint64(1 + uint64(_deposit[varg0][2] >> 64));\n}\n\nfunction getLinkStatus(bytes32 varg0, address varg1) public nonPayable { \n    return 0xff & _deposit[varg1];\n}\n\nfunction 0x9e5(uint256 varg0) private { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    v0 = address(varg0);\n    v1 = v2 = 0xff & _settle[v0];\n    if (v2) {\n        assert(0 < _admins.length);\n        v1 = v3 = address(_admins[0x0]) != address(varg0);\n    }\n    require(v1);\n    v4 = v5 = 0;\n    v6 = v7 = 1;\n    while (v6 < ~0 + _admins.length) {\n        v8 = v9 = !v4;\n        if (v9) {\n            assert(v6 < _admins.length);\n            v8 = v10 = address(_admins[v6]) == address(varg0);\n        }\n        if (v8) {\n            v4 = v11 = 1;\n        }\n        if (v4) {\n            assert(v6 + 1 < _admins.length);\n            assert(v6 < _admins.length);\n            _admins[v6] = address(_admins[v6 + 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _admins[v6];\n        }\n        v6 += 1;\n    }\n    _admins.length = _admins.length + ~0;\n    if (_admins.length > _admins.length + ~0) {\n        v12 = v13 = _admins.length + ~0 + keccak256(0);\n        while (keccak256(0) + _admins.length > v12) {\n            STORAGE[v12] = 0;\n            v12 += 1;\n        }\n    }\n    v14 = address(varg0);\n    _settle[v14] = ~0xff & _settle[v14];\n    return ;\n}\n\nfunction 0xee0(uint256 varg0, uint256 varg1) private { \n    MEM[MEM[64] + 32] = varg1;\n    MEM[64 + MEM[64]] = address(varg0) << 96;\n    v0 = v1 = MEM[64] + 84;\n    v2 = v3 = 52;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x3612cb5) {\n            settle(bytes32[],uint256[],uint256[]);\n        } else if (0x14bfd6d0 == function_selector) {\n            admins(uint256);\n        } else if (0x1785f53c == function_selector) {\n            removeAdmin(address);\n        } else if (0x2a856fcf == function_selector) {\n            debit(bytes32[],uint256[],uint64[],uint8[],bytes32[],bytes32[]);\n        } else if (0x2bfd91d4 == function_selector) {\n            getMessageSigner(bytes32,uint8,bytes32,bytes32);\n        } else {\n            if (0x3d44c476 != function_selector) {\n                if (0x4eb933bf == function_selector) {\n                    withdraw(bytes32[],address[],uint256[],uint64[],uint8[],bytes32[],bytes32[]);\n                } else if (0x62502fe7 == function_selector) {\n                    getNameDigest(string);\n                } else if (0x66eb463f == function_selector) {\n                    changeRootAdmin(address);\n                } else if (0x6e7c1c2b == function_selector) {\n                    getWithdrawDigest(bytes32,address,uint256,uint64);\n                } else if (0x70480275 == function_selector) {\n                    addAdmin(address);\n                } else if (0x71eb9710 == function_selector) {\n                    getDebitDigest(bytes32,uint256,uint64);\n                } else if (0x8e739461 == function_selector) {\n                    getBalance(bytes32);\n                } else if (0x9dc4ca42 != function_selector) {\n                    if (0xb214faa5 == function_selector) {\n                        deposit(bytes32);\n                    } else if (0xb5a030d8 == function_selector) {\n                        link(bytes32[],bytes32[],address[],uint8[],bytes32[],bytes32[]);\n                    } else if (0xbb0c08b6 == function_selector) {\n                        getDebitNonce(bytes32);\n                    } else if (0xc56e610e == function_selector) {\n                        getEscrowBalance();\n                    } else if (0xde9b33f9 == function_selector) {\n                        getWithdrawNonce(bytes32);\n                    } else if (0xf8dcc3e0 == function_selector) {\n                        getLinkStatus(bytes32,address);\n                    }\n                }\n            }\n            getLinkDigest(bytes32,address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 21:00 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _admins; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _settle; // STORAGE[0x2]\nuint256 _getEscrowBalance; // STORAGE[0x3]\n\n// Events\nDebit(bytes32, uint256, uint256);\nWithdraw(bytes32, uint256, uint256, address);\nDeposit(bytes32, address, uint256);\nLink(bytes32, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction settle(bytes32[] varg0, uint256[] varg1, uint256[] varg2) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v4 = v5 = v1.length == v2.length;\n    if (v5) {\n        v4 = v6 = v1.length == v3.length;\n    }\n    require(v4);\n    v7 = v8 = _getEscrowBalance;\n    v9 = v10 = 0;\n    while (v9 < v1.length) {\n        assert(v9 < v1.length);\n        assert(v9 < v3.length);\n        require(v3[v9] <= v7);\n        _deposit[v1[v9]] += v3[v9];\n        v7 = v7 - v3[v9];\n        assert(v9 < v2.length);\n        emit 0xcd738c9c0bbe501d6da72544aaef2b26bfdcbffa10507ff2755918321897c56(v1[v9], v2[v9], v3[v9]);\n        v9 = v9 + 1;\n    }\n    _getEscrowBalance = v7;\n}\n\nfunction 0x13ac(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    MEM[MEM[64] + 32] = varg3;\n    MEM[64 + MEM[64]] = address(varg2) << 96;\n    MEM[MEM[64] + 84] = varg1;\n    MEM[MEM[64] + 116] = uint64(varg0) << 192;\n    v0 = v1 = MEM[64] + 124;\n    v2 = v3 = 92;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\nfunction 0x1543(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[MEM[64] + 32] = varg2;\n    MEM[64 + MEM[64]] = varg1;\n    MEM[MEM[64] + 96] = uint64(varg0) << 192;\n    v0 = v1 = MEM[64] + 104;\n    v2 = v3 = 72;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\nfunction admins(uint256 varg0) public nonPayable { \n    assert(varg0 < _admins.length);\n    return address(_admins[varg0]);\n}\n\nfunction removeAdmin(address varg0) public nonPayable { \n    0x9e5(varg0);\n}\n\nfunction debit(bytes32[] varg0, uint256[] varg1, uint64[] varg2, uint8[] varg3, bytes32[] varg4, bytes32[] varg5) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v7 = v8 = v1.length == v2.length;\n    if (v8) {\n        v7 = v9 = v1.length == v3.length;\n    }\n    if (v7) {\n        v7 = v10 = v1.length == v4.length;\n    }\n    if (v7) {\n        v7 = v11 = v1.length == v5.length;\n    }\n    if (v7) {\n        v7 = v12 = v1.length == v6.length;\n    }\n    require(v7);\n    v13 = v14 = 0;\n    v15 = v16 = 0;\n    while (v15 < v1.length) {\n        assert(v15 < v1.length);\n        assert(v15 < v2.length);\n        assert(v15 < v3.length);\n        v17 = 0x1543(v3[v15], v2[v15], v1[v15]);\n        assert(v15 < v4.length);\n        assert(v15 < v5.length);\n        assert(v15 < v6.length);\n        v18 = v19 = 28;\n        v20 = v21 = v22.data;\n        v23 = v24 = 32 + MEM[64];\n        while (v18 >= 32) {\n            MEM[v23] = MEM[v20];\n            v18 = v18 + ~31;\n            v23 += 32;\n            v20 += 32;\n        }\n        MEM[v23] = ~0 + 256 ** (32 - v18) & MEM[v23] | MEM[v20] & ~(~0 + 256 ** (32 - v18));\n        MEM[v24 + v19] = v17;\n        v25 = v26 = 32 + (v24 + v19);\n        v27 = v28 = v24 + v19 - MEM[64];\n        v29 = MEM[64] + 32;\n        while (v27 >= 32) {\n            MEM[v25] = MEM[v29];\n            v27 = v27 + ~31;\n            v25 += 32;\n            v29 += 32;\n        }\n        MEM[v25] = ~0 + 256 ** (32 - v27) & MEM[v25] | MEM[v29] & ~(~0 + 256 ** (32 - v27));\n        MEM[v30.data] = 0;\n        MEM[32 + v30.data] = keccak256(v30.data);\n        MEM[64 + v30.data] = v4[v15] & 0xff;\n        MEM[v30.data + 96] = v5[v15];\n        MEM[v30.data + 128] = v6[v15];\n        v31 = ecrecover(MEM[(MEM[64]) len (160 + (v30.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v31); // checks call status, propagates error data on error\n        v32 = v33 = uint64(_deposit[v1[v15]][2]) < uint64(v3[v15]);\n        if (v33) {\n            v32 = v34 = v2[v15] <= _deposit[v1[v15]];\n        }\n        if (v32) {\n            v32 = v35 = 0xff & STORAGE[keccak256(address(MEM[~31 + MEM[64]]), keccak256(v1[v15], 1) + 1)];\n        }\n        if (v32) {\n            _deposit[v1[v15]][2] = uint64(v3[v15]) | ~0xffffffffffffffff & _deposit[v1[v15]][0x2];\n            _deposit[v1[v15]] = _deposit[v1[v15]] - v2[v15];\n            emit Debit(v1[v15], uint64(v3[v15]), v2[v15]);\n            v13 += v2[v15];\n        }\n        v15 = v15 + 1;\n    }\n    _getEscrowBalance += v13;\n}\n\nfunction getMessageSigner(bytes32 varg0, uint8 varg1, bytes32 varg2, bytes32 varg3) public nonPayable { \n    v0 = v1 = 28;\n    v2 = v3 = v4.data;\n    v5 = v6 = 32 + MEM[64];\n    while (v0 >= 32) {\n        MEM[v5] = MEM[v2];\n        v0 = v0 + ~31;\n        v5 += 32;\n        v2 += 32;\n    }\n    MEM[v5] = ~0 + 256 ** (32 - v0) & MEM[v5] | MEM[v2] & ~(~0 + 256 ** (32 - v0));\n    MEM[v6 + v1] = varg0;\n    v7 = v8 = 32 + (v6 + v1);\n    v9 = v10 = 60;\n    v11 = MEM[64] + 32;\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v9 = v9 + ~31;\n        v7 += 32;\n        v11 += 32;\n    }\n    MEM[v7] = ~0 + 256 ** (32 - v9) & MEM[v7] | MEM[v11] & ~(~0 + 256 ** (32 - v9));\n    MEM[v12.data] = 0;\n    MEM[32 + v12.data] = keccak256(v12.data);\n    MEM[64 + v12.data] = varg1 & 0xff & 0xff;\n    MEM[v12.data + 96] = varg2;\n    MEM[v12.data + 128] = varg3;\n    v13, v14 = ecrecover(keccak256(v12.data), varg1 & 0xff & 0xff, varg2, varg3);\n    require(v13); // checks call status, propagates error data on error\n    return address(MEM[~31 + MEM[64]]);\n}\n\nfunction getLinkDigest(bytes32 varg0, address varg1) public nonPayable { \n    v0 = 0xee0(varg1, varg0);\n    return v0;\n}\n\nfunction withdraw(bytes32[] varg0, address[] varg1, uint256[] varg2, uint64[] varg3, uint8[] varg4, bytes32[] varg5, bytes32[] varg6) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    CALLDATACOPY(v7.data, 36 + varg6, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v8 = v9 = v1.length == v2.length;\n    if (v9) {\n        v8 = v10 = v1.length == v3.length;\n    }\n    if (v8) {\n        v8 = v11 = v1.length == v4.length;\n    }\n    if (v8) {\n        v8 = v12 = v1.length == v5.length;\n    }\n    if (v8) {\n        v8 = v13 = v1.length == v6.length;\n    }\n    if (v8) {\n        v8 = v1.length == v7.length;\n    }\n    require(v8);\n    v14 = v15 = 0;\n    while (v14 < v1.length) {\n        if (v14 < v1.length) {\n            break;\n        }\n        assert(v14 < v1.length);\n        assert(v14 < v2.length);\n        assert(v14 < v3.length);\n        assert(v14 < v4.length);\n        v16 = 0x13ac(v4[v14], v3[v14], v2[v14], v1[v14]);\n        assert(v14 < v5.length);\n        assert(v14 < v6.length);\n        assert(v14 < v7.length);\n        v17 = v18 = 28;\n        v19 = v20 = v21.data;\n        v22 = v23 = 32 + MEM[64];\n        while (v17 >= 32) {\n            MEM[v22] = MEM[v19];\n            v17 = v17 + ~31;\n            v22 += 32;\n            v19 += 32;\n        }\n        MEM[v22] = ~0 + 256 ** (32 - v17) & MEM[v22] | MEM[v19] & ~(~0 + 256 ** (32 - v17));\n        MEM[v23 + v18] = v16;\n        v24 = v25 = 32 + (v23 + v18);\n        v26 = v27 = v23 + v18 - MEM[64];\n        v28 = v29 = MEM[64] + 32;\n        while (v26 >= 32) {\n            MEM[v24] = MEM[v28];\n            v26 = v26 + ~31;\n            v24 += 32;\n            v28 += 32;\n        }\n        MEM[v24] = ~0 + 256 ** (32 - v26) & MEM[v24] | MEM[v28] & ~(~0 + 256 ** (32 - v26));\n        MEM[v30.data] = 0;\n        MEM[32 + v30.data] = keccak256(v30.data);\n        MEM[64 + v30.data] = v5[v14] & 0xff;\n        MEM[v30.data + 96] = v6[v14];\n        MEM[v30.data + 128] = v7[v14];\n        v31 = ecrecover(MEM[(MEM[64]) len (160 + (v30.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v31); // checks call status, propagates error data on error\n        v32 = v33 = uint64(_deposit[v1[v14]][2] >> 64) < uint64(v4[v14]);\n        if (v33) {\n            v32 = v34 = v3[v14] <= _deposit[v1[v14]];\n        }\n        if (v32) {\n            v32 = v35 = 0xff & STORAGE[keccak256(address(MEM[~31 + MEM[64]]), keccak256(v1[v14], 1) + 1)];\n        }\n        if (v32) {\n            v32 = address(v2[v14]).call().value(v3[v14]).gas(2300 * !v3[v14]);\n        }\n        if (v32) {\n            _deposit[v1[v14]][2] = _deposit[v1[v14]][0x2] & ~0xffffffffffffffff0000000000000000 | uint64(v4[v14]) << 64;\n            _deposit[v1[v14]] = _deposit[v1[v14]] - v3[v14];\n            emit Withdraw(v1[v14], uint64(v4[v14]), v3[v14], address(v2[v14]));\n        }\n        v14 = v14 + 1;\n    }\n}\n\nfunction getNameDigest(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = v3 = 32 + MEM[64];\n    v4 = v5 = v0.length;\n    v6 = v7 = v0.data;\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v6];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v6 += 32;\n    }\n    MEM[v2] = MEM[v6] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v8 = v9 = v9.data;\n    v10 = v11 = v5 + v3 - MEM[64] - 32;\n    v12 = v13 = 32 + MEM[64];\n    while (v10 >= 32) {\n        MEM[v8] = MEM[v12];\n        v10 = v10 + ~31;\n        v8 += 32;\n        v12 += 32;\n    }\n    MEM[v8] = MEM[v8] & ~0 + 256 ** (32 - v10) | MEM[v12] & ~(~0 + 256 ** (32 - v10));\n    return keccak256(v9);\n}\n\nfunction changeRootAdmin(address varg0) public nonPayable { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    v0 = v1 = 0xff & _settle[varg0];\n    if (v1) {\n        assert(0 < _admins.length);\n        v0 = v2 = address(_admins[0x0]) != varg0;\n    }\n    if (v0) {\n        0x9e5(varg0);\n    }\n    assert(0 < _admins.length);\n    _admins[0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _admins[0x0];\n    _settle[varg0] = 0x1 | ~0xff & _settle[varg0];\n}\n\nfunction getWithdrawDigest(bytes32 varg0, address varg1, uint256 varg2, uint64 varg3) public nonPayable { \n    v0 = 0x13ac(varg3, varg2, varg1, varg0);\n    return v0;\n}\n\nfunction addAdmin(address varg0) public nonPayable { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    require(!(0xff & _settle[varg0]));\n    _settle[varg0] = 0x1 | ~0xff & _settle[varg0];\n    _admins.length = _admins.length + 1;\n    MEM[0] = 0;\n    STORAGE[0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563 + _admins.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563 + _admins.length];\n}\n\nfunction getDebitDigest(bytes32 varg0, uint256 varg1, uint64 varg2) public nonPayable { \n    v0 = 0x1543(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction getBalance(bytes32 varg0) public nonPayable { \n    return _deposit[varg0];\n}\n\nfunction deposit(bytes32 varg0) public payable { \n    _deposit[varg0] += msg.value;\n    emit Deposit(varg0, msg.sender, msg.value);\n}\n\nfunction link(bytes32[] varg0, bytes32[] varg1, address[] varg2, uint8[] varg3, bytes32[] varg4, bytes32[] varg5) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v7 = v8 = v1.length == v2.length;\n    if (v8) {\n        v7 = v9 = v1.length == v3.length;\n    }\n    if (v7) {\n        v7 = v10 = v1.length == v4.length;\n    }\n    if (v7) {\n        v7 = v11 = v1.length == v5.length;\n    }\n    if (v7) {\n        v7 = v1.length == v6.length;\n    }\n    require(v7);\n    v12 = v13 = 0;\n    while (v12 < v1.length) {\n        assert(v12 < v1.length);\n        assert(v12 < v3.length);\n        v14 = 0xee0(v3[v12], v1[v12]);\n        assert(v12 < v4.length);\n        assert(v12 < v5.length);\n        assert(v12 < v6.length);\n        v15 = v16 = 28;\n        v17 = v18 = v19.data;\n        v20 = v21 = 32 + MEM[64];\n        while (v15 >= 32) {\n            MEM[v20] = MEM[v17];\n            v15 = v15 + ~31;\n            v20 += 32;\n            v17 += 32;\n        }\n        MEM[v20] = ~0 + 256 ** (32 - v15) & MEM[v20] | MEM[v17] & ~(~0 + 256 ** (32 - v15));\n        MEM[v21 + v16] = v14;\n        v22 = v23 = 32 + (v21 + v16);\n        v24 = v25 = v21 + v16 - MEM[64];\n        v26 = v27 = MEM[64] + 32;\n        while (v24 >= 32) {\n            MEM[v22] = MEM[v26];\n            v24 = v24 + ~31;\n            v22 += 32;\n            v26 += 32;\n        }\n        MEM[v22] = ~0 + 256 ** (32 - v24) & MEM[v22] | MEM[v26] & ~(~0 + 256 ** (32 - v24));\n        MEM[v28.data] = 0;\n        MEM[32 + v28.data] = keccak256(v28.data);\n        MEM[64 + v28.data] = v4[v12] & 0xff;\n        MEM[v28.data + 96] = v5[v12];\n        MEM[v28.data + 128] = v6[v12];\n        v29 = ecrecover(MEM[(MEM[64]) len (160 + (v28.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v29); // checks call status, propagates error data on error\n        v30 = v31 = 0xff & _deposit[address(MEM[~31 + MEM[64]])];\n        if (!v31) {\n            assert(v12 < v2.length);\n            MEM[MEM[64] + 32] = v2[v12];\n            MEM[64 + MEM[64]] = address(MEM[~31 + MEM[64]]) << 96;\n            v32 = v33 = MEM[64] + 84;\n            v34 = v35 = 52;\n            v36 = v37 = MEM[64] + 32;\n            while (v34 >= 32) {\n                MEM[v32] = MEM[v36];\n                v34 = v34 + ~31;\n                v32 += 32;\n                v36 += 32;\n            }\n            MEM[v32] = MEM[v32] & ~0 + 256 ** (32 - v34) | MEM[v36] & ~(~0 + 256 ** (32 - v34));\n            v30 = v1[v12] == keccak256(v38.data);\n        }\n        if (v30) {\n            STORAGE[keccak256(address(v3[v12]), 1 + keccak256(v1[v12], 1))] = 0x1 | ~0xff & STORAGE[keccak256(address(v3[v12]), 1 + keccak256(v1[v12], 1))];\n            emit Link(v1[v12], address(v3[v12]));\n        }\n        v12 = v12 + 1;\n    }\n}\n\nfunction getDebitNonce(bytes32 varg0) public nonPayable { \n    return uint64(1 + uint64(_deposit[varg0][2]));\n}\n\nfunction getEscrowBalance() public nonPayable { \n    return _getEscrowBalance;\n}\n\nfunction getWithdrawNonce(bytes32 varg0) public nonPayable { \n    return uint64(1 + uint64(_deposit[varg0][2] >> 64));\n}\n\nfunction getLinkStatus(bytes32 varg0, address varg1) public nonPayable { \n    return 0xff & _deposit[varg1];\n}\n\nfunction 0x9e5(uint256 varg0) private { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    v0 = address(varg0);\n    v1 = v2 = 0xff & _settle[v0];\n    if (v2) {\n        assert(0 < _admins.length);\n        v1 = v3 = address(_admins[0x0]) != address(varg0);\n    }\n    require(v1);\n    v4 = v5 = 0;\n    v6 = v7 = 1;\n    while (v6 < ~0 + _admins.length) {\n        v8 = v9 = !v4;\n        if (v9) {\n            assert(v6 < _admins.length);\n            v8 = v10 = address(_admins[v6]) == address(varg0);\n        }\n        if (v8) {\n            v4 = v11 = 1;\n        }\n        if (v4) {\n            assert(v6 + 1 < _admins.length);\n            assert(v6 < _admins.length);\n            _admins[v6] = address(_admins[v6 + 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _admins[v6];\n        }\n        v6 += 1;\n    }\n    _admins.length = _admins.length + ~0;\n    if (_admins.length > _admins.length + ~0) {\n        v12 = v13 = _admins.length + ~0 + keccak256(0);\n        while (keccak256(0) + _admins.length > v12) {\n            STORAGE[v12] = 0;\n            v12 += 1;\n        }\n    }\n    v14 = address(varg0);\n    _settle[v14] = ~0xff & _settle[v14];\n    return ;\n}\n\nfunction 0xee0(uint256 varg0, uint256 varg1) private { \n    MEM[MEM[64] + 32] = varg1;\n    MEM[64 + MEM[64]] = address(varg0) << 96;\n    v0 = v1 = MEM[64] + 84;\n    v2 = v3 = 52;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x3612cb5) {\n            settle(bytes32[],uint256[],uint256[]);\n        } else if (0x14bfd6d0 == function_selector) {\n            admins(uint256);\n        } else if (0x1785f53c == function_selector) {\n            removeAdmin(address);\n        } else if (0x2a856fcf == function_selector) {\n            debit(bytes32[],uint256[],uint64[],uint8[],bytes32[],bytes32[]);\n        } else if (0x2bfd91d4 == function_selector) {\n            getMessageSigner(bytes32,uint8,bytes32,bytes32);\n        } else {\n            if (0x3d44c476 != function_selector) {\n                if (0x4eb933bf == function_selector) {\n                    withdraw(bytes32[],address[],uint256[],uint64[],uint8[],bytes32[],bytes32[]);\n                } else if (0x62502fe7 == function_selector) {\n                    getNameDigest(string);\n                } else if (0x66eb463f == function_selector) {\n                    changeRootAdmin(address);\n                } else if (0x6e7c1c2b == function_selector) {\n                    getWithdrawDigest(bytes32,address,uint256,uint64);\n                } else if (0x70480275 == function_selector) {\n                    addAdmin(address);\n                } else if (0x71eb9710 == function_selector) {\n                    getDebitDigest(bytes32,uint256,uint64);\n                } else if (0x8e739461 == function_selector) {\n                    getBalance(bytes32);\n                } else if (0x9dc4ca42 != function_selector) {\n                    if (0xb214faa5 == function_selector) {\n                        deposit(bytes32);\n                    } else if (0xb5a030d8 == function_selector) {\n                        link(bytes32[],bytes32[],address[],uint8[],bytes32[],bytes32[]);\n                    } else if (0xbb0c08b6 == function_selector) {\n                        getDebitNonce(bytes32);\n                    } else if (0xc56e610e == function_selector) {\n                        getEscrowBalance();\n                    } else if (0xde9b33f9 == function_selector) {\n                        getWithdrawNonce(bytes32);\n                    } else if (0xf8dcc3e0 == function_selector) {\n                        getLinkStatus(bytes32,address);\n                    }\n                }\n            }\n            getLinkDigest(bytes32,address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.24 21:00 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _admins; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _deposit; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _settle; // STORAGE[0x2]\nuint256 _getEscrowBalance; // STORAGE[0x3]\n\n// Events\nDebit(bytes32, uint256, uint256);\nWithdraw(bytes32, uint256, uint256, address);\nDeposit(bytes32, address, uint256);\nLink(bytes32, address);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction settle(bytes32[] varg0, uint256[] varg1, uint256[] varg2) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v4 = v5 = v1.length == v2.length;\n    if (v5) {\n        v4 = v6 = v1.length == v3.length;\n    }\n    require(v4);\n    v7 = v8 = _getEscrowBalance;\n    v9 = v10 = 0;\n    while (v9 < v1.length) {\n        assert(v9 < v1.length);\n        assert(v9 < v3.length);\n        require(v3[v9] <= v7);\n        _deposit[v1[v9]] += v3[v9];\n        v7 = v7 - v3[v9];\n        assert(v9 < v2.length);\n        emit 0xcd738c9c0bbe501d6da72544aaef2b26bfdcbffa10507ff2755918321897c56(v1[v9], v2[v9], v3[v9]);\n        v9 = v9 + 1;\n    }\n    _getEscrowBalance = v7;\n}\n\nfunction 0x13ac(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    MEM[MEM[64] + 32] = varg3;\n    MEM[64 + MEM[64]] = address(varg2) << 96;\n    MEM[MEM[64] + 84] = varg1;\n    MEM[MEM[64] + 116] = uint64(varg0) << 192;\n    v0 = v1 = MEM[64] + 124;\n    v2 = v3 = 92;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\nfunction 0x1543(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    MEM[MEM[64] + 32] = varg2;\n    MEM[64 + MEM[64]] = varg1;\n    MEM[MEM[64] + 96] = uint64(varg0) << 192;\n    v0 = v1 = MEM[64] + 104;\n    v2 = v3 = 72;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\nfunction admins(uint256 varg0) public nonPayable { \n    assert(varg0 < _admins.length);\n    return address(_admins[varg0]);\n}\n\nfunction removeAdmin(address varg0) public nonPayable { \n    0x9e5(varg0);\n}\n\nfunction debit(bytes32[] varg0, uint256[] varg1, uint64[] varg2, uint8[] varg3, bytes32[] varg4, bytes32[] varg5) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v7 = v8 = v1.length == v2.length;\n    if (v8) {\n        v7 = v9 = v1.length == v3.length;\n    }\n    if (v7) {\n        v7 = v10 = v1.length == v4.length;\n    }\n    if (v7) {\n        v7 = v11 = v1.length == v5.length;\n    }\n    if (v7) {\n        v7 = v12 = v1.length == v6.length;\n    }\n    require(v7);\n    v13 = v14 = 0;\n    v15 = v16 = 0;\n    while (v15 < v1.length) {\n        assert(v15 < v1.length);\n        assert(v15 < v2.length);\n        assert(v15 < v3.length);\n        v17 = 0x1543(v3[v15], v2[v15], v1[v15]);\n        assert(v15 < v4.length);\n        assert(v15 < v5.length);\n        assert(v15 < v6.length);\n        v18 = v19 = 28;\n        v20 = v21 = v22.data;\n        v23 = v24 = 32 + MEM[64];\n        while (v18 >= 32) {\n            MEM[v23] = MEM[v20];\n            v18 = v18 + ~31;\n            v23 += 32;\n            v20 += 32;\n        }\n        MEM[v23] = ~0 + 256 ** (32 - v18) & MEM[v23] | MEM[v20] & ~(~0 + 256 ** (32 - v18));\n        MEM[v24 + v19] = v17;\n        v25 = v26 = 32 + (v24 + v19);\n        v27 = v28 = v24 + v19 - MEM[64];\n        v29 = MEM[64] + 32;\n        while (v27 >= 32) {\n            MEM[v25] = MEM[v29];\n            v27 = v27 + ~31;\n            v25 += 32;\n            v29 += 32;\n        }\n        MEM[v25] = ~0 + 256 ** (32 - v27) & MEM[v25] | MEM[v29] & ~(~0 + 256 ** (32 - v27));\n        MEM[v30.data] = 0;\n        MEM[32 + v30.data] = keccak256(v30.data);\n        MEM[64 + v30.data] = v4[v15] & 0xff;\n        MEM[v30.data + 96] = v5[v15];\n        MEM[v30.data + 128] = v6[v15];\n        v31 = ecrecover(MEM[(MEM[64]) len (160 + (v30.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v31); // checks call status, propagates error data on error\n        v32 = v33 = uint64(_deposit[v1[v15]][2]) < uint64(v3[v15]);\n        if (v33) {\n            v32 = v34 = v2[v15] <= _deposit[v1[v15]];\n        }\n        if (v32) {\n            v32 = v35 = 0xff & STORAGE[keccak256(address(MEM[~31 + MEM[64]]), keccak256(v1[v15], 1) + 1)];\n        }\n        if (v32) {\n            _deposit[v1[v15]][2] = uint64(v3[v15]) | ~0xffffffffffffffff & _deposit[v1[v15]][0x2];\n            _deposit[v1[v15]] = _deposit[v1[v15]] - v2[v15];\n            emit Debit(v1[v15], uint64(v3[v15]), v2[v15]);\n            v13 += v2[v15];\n        }\n        v15 = v15 + 1;\n    }\n    _getEscrowBalance += v13;\n}\n\nfunction getMessageSigner(bytes32 varg0, uint8 varg1, bytes32 varg2, bytes32 varg3) public nonPayable { \n    v0 = v1 = 28;\n    v2 = v3 = v4.data;\n    v5 = v6 = 32 + MEM[64];\n    while (v0 >= 32) {\n        MEM[v5] = MEM[v2];\n        v0 = v0 + ~31;\n        v5 += 32;\n        v2 += 32;\n    }\n    MEM[v5] = ~0 + 256 ** (32 - v0) & MEM[v5] | MEM[v2] & ~(~0 + 256 ** (32 - v0));\n    MEM[v6 + v1] = varg0;\n    v7 = v8 = 32 + (v6 + v1);\n    v9 = v10 = 60;\n    v11 = MEM[64] + 32;\n    while (v9 >= 32) {\n        MEM[v7] = MEM[v11];\n        v9 = v9 + ~31;\n        v7 += 32;\n        v11 += 32;\n    }\n    MEM[v7] = ~0 + 256 ** (32 - v9) & MEM[v7] | MEM[v11] & ~(~0 + 256 ** (32 - v9));\n    MEM[v12.data] = 0;\n    MEM[32 + v12.data] = keccak256(v12.data);\n    MEM[64 + v12.data] = varg1 & 0xff & 0xff;\n    MEM[v12.data + 96] = varg2;\n    MEM[v12.data + 128] = varg3;\n    v13, v14 = ecrecover(keccak256(v12.data), varg1 & 0xff & 0xff, varg2, varg3);\n    require(v13); // checks call status, propagates error data on error\n    return address(MEM[~31 + MEM[64]]);\n}\n\nfunction getLinkDigest(bytes32 varg0, address varg1) public nonPayable { \n    v0 = 0xee0(varg1, varg0);\n    return v0;\n}\n\nfunction withdraw(bytes32[] varg0, address[] varg1, uint256[] varg2, uint64[] varg3, uint8[] varg4, bytes32[] varg5, bytes32[] varg6) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    CALLDATACOPY(v7.data, 36 + varg6, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v8 = v9 = v1.length == v2.length;\n    if (v9) {\n        v8 = v10 = v1.length == v3.length;\n    }\n    if (v8) {\n        v8 = v11 = v1.length == v4.length;\n    }\n    if (v8) {\n        v8 = v12 = v1.length == v5.length;\n    }\n    if (v8) {\n        v8 = v13 = v1.length == v6.length;\n    }\n    if (v8) {\n        v8 = v1.length == v7.length;\n    }\n    require(v8);\n    v14 = v15 = 0;\n    while (v14 < v1.length) {\n        if (v14 < v1.length) {\n            break;\n        }\n        assert(v14 < v1.length);\n        assert(v14 < v2.length);\n        assert(v14 < v3.length);\n        assert(v14 < v4.length);\n        v16 = 0x13ac(v4[v14], v3[v14], v2[v14], v1[v14]);\n        assert(v14 < v5.length);\n        assert(v14 < v6.length);\n        assert(v14 < v7.length);\n        v17 = v18 = 28;\n        v19 = v20 = v21.data;\n        v22 = v23 = 32 + MEM[64];\n        while (v17 >= 32) {\n            MEM[v22] = MEM[v19];\n            v17 = v17 + ~31;\n            v22 += 32;\n            v19 += 32;\n        }\n        MEM[v22] = ~0 + 256 ** (32 - v17) & MEM[v22] | MEM[v19] & ~(~0 + 256 ** (32 - v17));\n        MEM[v23 + v18] = v16;\n        v24 = v25 = 32 + (v23 + v18);\n        v26 = v27 = v23 + v18 - MEM[64];\n        v28 = v29 = MEM[64] + 32;\n        while (v26 >= 32) {\n            MEM[v24] = MEM[v28];\n            v26 = v26 + ~31;\n            v24 += 32;\n            v28 += 32;\n        }\n        MEM[v24] = ~0 + 256 ** (32 - v26) & MEM[v24] | MEM[v28] & ~(~0 + 256 ** (32 - v26));\n        MEM[v30.data] = 0;\n        MEM[32 + v30.data] = keccak256(v30.data);\n        MEM[64 + v30.data] = v5[v14] & 0xff;\n        MEM[v30.data + 96] = v6[v14];\n        MEM[v30.data + 128] = v7[v14];\n        v31 = ecrecover(MEM[(MEM[64]) len (160 + (v30.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v31); // checks call status, propagates error data on error\n        v32 = v33 = uint64(_deposit[v1[v14]][2] >> 64) < uint64(v4[v14]);\n        if (v33) {\n            v32 = v34 = v3[v14] <= _deposit[v1[v14]];\n        }\n        if (v32) {\n            v32 = v35 = 0xff & STORAGE[keccak256(address(MEM[~31 + MEM[64]]), keccak256(v1[v14], 1) + 1)];\n        }\n        if (v32) {\n            v32 = address(v2[v14]).call().value(v3[v14]).gas(2300 * !v3[v14]);\n        }\n        if (v32) {\n            _deposit[v1[v14]][2] = _deposit[v1[v14]][0x2] & ~0xffffffffffffffff0000000000000000 | uint64(v4[v14]) << 64;\n            _deposit[v1[v14]] = _deposit[v1[v14]] - v3[v14];\n            emit Withdraw(v1[v14], uint64(v4[v14]), v3[v14], address(v2[v14]));\n        }\n        v14 = v14 + 1;\n    }\n}\n\nfunction getNameDigest(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = v3 = 32 + MEM[64];\n    v4 = v5 = v0.length;\n    v6 = v7 = v0.data;\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v6];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v6 += 32;\n    }\n    MEM[v2] = MEM[v6] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v8 = v9 = v9.data;\n    v10 = v11 = v5 + v3 - MEM[64] - 32;\n    v12 = v13 = 32 + MEM[64];\n    while (v10 >= 32) {\n        MEM[v8] = MEM[v12];\n        v10 = v10 + ~31;\n        v8 += 32;\n        v12 += 32;\n    }\n    MEM[v8] = MEM[v8] & ~0 + 256 ** (32 - v10) | MEM[v12] & ~(~0 + 256 ** (32 - v10));\n    return keccak256(v9);\n}\n\nfunction changeRootAdmin(address varg0) public nonPayable { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    v0 = v1 = 0xff & _settle[varg0];\n    if (v1) {\n        assert(0 < _admins.length);\n        v0 = v2 = address(_admins[0x0]) != varg0;\n    }\n    if (v0) {\n        0x9e5(varg0);\n    }\n    assert(0 < _admins.length);\n    _admins[0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _admins[0x0];\n    _settle[varg0] = 0x1 | ~0xff & _settle[varg0];\n}\n\nfunction getWithdrawDigest(bytes32 varg0, address varg1, uint256 varg2, uint64 varg3) public nonPayable { \n    v0 = 0x13ac(varg3, varg2, varg1, varg0);\n    return v0;\n}\n\nfunction addAdmin(address varg0) public nonPayable { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    require(!(0xff & _settle[varg0]));\n    _settle[varg0] = 0x1 | ~0xff & _settle[varg0];\n    _admins.length = _admins.length + 1;\n    MEM[0] = 0;\n    STORAGE[0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563 + _admins.length] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563 + _admins.length];\n}\n\nfunction getDebitDigest(bytes32 varg0, uint256 varg1, uint64 varg2) public nonPayable { \n    v0 = 0x1543(varg2, varg1, varg0);\n    return v0;\n}\n\nfunction getBalance(bytes32 varg0) public nonPayable { \n    return _deposit[varg0];\n}\n\nfunction deposit(bytes32 varg0) public payable { \n    _deposit[varg0] += msg.value;\n    emit Deposit(varg0, msg.sender, msg.value);\n}\n\nfunction link(bytes32[] varg0, bytes32[] varg1, address[] varg2, uint8[] varg3, bytes32[] varg4, bytes32[] varg5) public nonPayable { \n    v0 = msg.data.length;\n    CALLDATACOPY(v1.data, 36 + varg0, (?).length << 5);\n    CALLDATACOPY(v2.data, 36 + varg1, (?).length << 5);\n    CALLDATACOPY(v3.data, 36 + varg2, (?).length << 5);\n    CALLDATACOPY(v4.data, 36 + varg3, (?).length << 5);\n    CALLDATACOPY(v5.data, 36 + varg4, (?).length << 5);\n    CALLDATACOPY(v6.data, 36 + varg5, (?).length << 5);\n    require(0xff & _settle[msg.sender]);\n    v7 = v8 = v1.length == v2.length;\n    if (v8) {\n        v7 = v9 = v1.length == v3.length;\n    }\n    if (v7) {\n        v7 = v10 = v1.length == v4.length;\n    }\n    if (v7) {\n        v7 = v11 = v1.length == v5.length;\n    }\n    if (v7) {\n        v7 = v1.length == v6.length;\n    }\n    require(v7);\n    v12 = v13 = 0;\n    while (v12 < v1.length) {\n        assert(v12 < v1.length);\n        assert(v12 < v3.length);\n        v14 = 0xee0(v3[v12], v1[v12]);\n        assert(v12 < v4.length);\n        assert(v12 < v5.length);\n        assert(v12 < v6.length);\n        v15 = v16 = 28;\n        v17 = v18 = v19.data;\n        v20 = v21 = 32 + MEM[64];\n        while (v15 >= 32) {\n            MEM[v20] = MEM[v17];\n            v15 = v15 + ~31;\n            v20 += 32;\n            v17 += 32;\n        }\n        MEM[v20] = ~0 + 256 ** (32 - v15) & MEM[v20] | MEM[v17] & ~(~0 + 256 ** (32 - v15));\n        MEM[v21 + v16] = v14;\n        v22 = v23 = 32 + (v21 + v16);\n        v24 = v25 = v21 + v16 - MEM[64];\n        v26 = v27 = MEM[64] + 32;\n        while (v24 >= 32) {\n            MEM[v22] = MEM[v26];\n            v24 = v24 + ~31;\n            v22 += 32;\n            v26 += 32;\n        }\n        MEM[v22] = ~0 + 256 ** (32 - v24) & MEM[v22] | MEM[v26] & ~(~0 + 256 ** (32 - v24));\n        MEM[v28.data] = 0;\n        MEM[32 + v28.data] = keccak256(v28.data);\n        MEM[64 + v28.data] = v4[v12] & 0xff;\n        MEM[v28.data + 96] = v5[v12];\n        MEM[v28.data + 128] = v6[v12];\n        v29 = ecrecover(MEM[(MEM[64]) len (160 + (v28.data - MEM[64]))], MEM[(MEM[64] + ~31) len 32]);\n        require(v29); // checks call status, propagates error data on error\n        v30 = v31 = 0xff & _deposit[address(MEM[~31 + MEM[64]])];\n        if (!v31) {\n            assert(v12 < v2.length);\n            MEM[MEM[64] + 32] = v2[v12];\n            MEM[64 + MEM[64]] = address(MEM[~31 + MEM[64]]) << 96;\n            v32 = v33 = MEM[64] + 84;\n            v34 = v35 = 52;\n            v36 = v37 = MEM[64] + 32;\n            while (v34 >= 32) {\n                MEM[v32] = MEM[v36];\n                v34 = v34 + ~31;\n                v32 += 32;\n                v36 += 32;\n            }\n            MEM[v32] = MEM[v32] & ~0 + 256 ** (32 - v34) | MEM[v36] & ~(~0 + 256 ** (32 - v34));\n            v30 = v1[v12] == keccak256(v38.data);\n        }\n        if (v30) {\n            STORAGE[keccak256(address(v3[v12]), 1 + keccak256(v1[v12], 1))] = 0x1 | ~0xff & STORAGE[keccak256(address(v3[v12]), 1 + keccak256(v1[v12], 1))];\n            emit Link(v1[v12], address(v3[v12]));\n        }\n        v12 = v12 + 1;\n    }\n}\n\nfunction getDebitNonce(bytes32 varg0) public nonPayable { \n    return uint64(1 + uint64(_deposit[varg0][2]));\n}\n\nfunction getEscrowBalance() public nonPayable { \n    return _getEscrowBalance;\n}\n\nfunction getWithdrawNonce(bytes32 varg0) public nonPayable { \n    return uint64(1 + uint64(_deposit[varg0][2] >> 64));\n}\n\nfunction getLinkStatus(bytes32 varg0, address varg1) public nonPayable { \n    return 0xff & _deposit[varg1];\n}\n\nfunction 0x9e5(uint256 varg0) private { \n    assert(0 < _admins.length);\n    require(msg.sender == address(_admins[0x0]));\n    v0 = address(varg0);\n    v1 = v2 = 0xff & _settle[v0];\n    if (v2) {\n        assert(0 < _admins.length);\n        v1 = v3 = address(_admins[0x0]) != address(varg0);\n    }\n    require(v1);\n    v4 = v5 = 0;\n    v6 = v7 = 1;\n    while (v6 < ~0 + _admins.length) {\n        v8 = v9 = !v4;\n        if (v9) {\n            assert(v6 < _admins.length);\n            v8 = v10 = address(_admins[v6]) == address(varg0);\n        }\n        if (v8) {\n            v4 = v11 = 1;\n        }\n        if (v4) {\n            assert(v6 + 1 < _admins.length);\n            assert(v6 < _admins.length);\n            _admins[v6] = address(_admins[v6 + 1]) | ~0xffffffffffffffffffffffffffffffffffffffff & _admins[v6];\n        }\n        v6 += 1;\n    }\n    _admins.length = _admins.length + ~0;\n    if (_admins.length > _admins.length + ~0) {\n        v12 = v13 = _admins.length + ~0 + keccak256(0);\n        while (keccak256(0) + _admins.length > v12) {\n            STORAGE[v12] = 0;\n            v12 += 1;\n        }\n    }\n    v14 = address(varg0);\n    _settle[v14] = ~0xff & _settle[v14];\n    return ;\n}\n\nfunction 0xee0(uint256 varg0, uint256 varg1) private { \n    MEM[MEM[64] + 32] = varg1;\n    MEM[64 + MEM[64]] = address(varg0) << 96;\n    v0 = v1 = MEM[64] + 84;\n    v2 = v3 = 52;\n    v4 = v5 = MEM[64] + 32;\n    while (v2 >= 32) {\n        MEM[v0] = MEM[v4];\n        v2 = v2 + ~31;\n        v0 += 32;\n        v4 += 32;\n    }\n    MEM[v0] = MEM[v0] & ~0 + 256 ** (32 - v2) | MEM[v4] & ~(~0 + 256 ** (32 - v2));\n    return keccak256(v6.data);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x3612cb5) {\n            settle(bytes32[],uint256[],uint256[]);\n        } else if (0x14bfd6d0 == function_selector) {\n            admins(uint256);\n        } else if (0x1785f53c == function_selector) {\n            removeAdmin(address);\n        } else if (0x2a856fcf == function_selector) {\n            debit(bytes32[],uint256[],uint64[],uint8[],bytes32[],bytes32[]);\n        } else if (0x2bfd91d4 == function_selector) {\n            getMessageSigner(bytes32,uint8,bytes32,bytes32);\n        } else {\n            if (0x3d44c476 != function_selector) {\n                if (0x4eb933bf == function_selector) {\n                    withdraw(bytes32[],address[],uint256[],uint64[],uint8[],bytes32[],bytes32[]);\n                } else if (0x62502fe7 == function_selector) {\n                    getNameDigest(string);\n                } else if (0x66eb463f == function_selector) {\n                    changeRootAdmin(address);\n                } else if (0x6e7c1c2b == function_selector) {\n                    getWithdrawDigest(bytes32,address,uint256,uint64);\n                } else if (0x70480275 == function_selector) {\n                    addAdmin(address);\n                } else if (0x71eb9710 == function_selector) {\n                    getDebitDigest(bytes32,uint256,uint64);\n                } else if (0x8e739461 == function_selector) {\n                    getBalance(bytes32);\n                } else if (0x9dc4ca42 != function_selector) {\n                    if (0xb214faa5 == function_selector) {\n                        deposit(bytes32);\n                    } else if (0xb5a030d8 == function_selector) {\n                        link(bytes32[],bytes32[],address[],uint8[],bytes32[],bytes32[]);\n                    } else if (0xbb0c08b6 == function_selector) {\n                        getDebitNonce(bytes32);\n                    } else if (0xc56e610e == function_selector) {\n                        getEscrowBalance();\n                    } else if (0xde9b33f9 == function_selector) {\n                        getWithdrawNonce(bytes32);\n                    } else if (0xf8dcc3e0 == function_selector) {\n                        getLinkStatus(bytes32,address);\n                    }\n                }\n            }\n            getLinkDigest(bytes32,address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 15.242872476577759,
	"usage": {
		"completion_tokens": 249,
		"prompt_tokens": 7101,
		"total_tokens": 7350
	}
}