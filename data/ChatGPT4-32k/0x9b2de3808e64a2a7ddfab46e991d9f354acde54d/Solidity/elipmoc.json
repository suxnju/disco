{
	"address": "0x9b2de3808e64a2a7ddfab46e991d9f354acde54d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity code corresponding to the provided decompiled code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Funding {\n    uint256 public _fundingGoal;\n    uint256 public _amountRaised;\n    uint256 public _deadline;\n    uint256 public _price;\n    mapping (address => uint256) public _balanceOf;\n    address payable public _beneficiary;\n    bool public _safeWithdrawal;\n    bool public _fallback;\n    IERC20 public _tokenReward;\n\n    event FundTransfer(address backer, uint amount, bool isContribution);\n    event GoalReached(address recipient, uint totalAmountRaised);\n\n    function checkGoalReached() public { \n        if (block.timestamp >= _deadline) {\n            if (_amountRaised >= _fundingGoal) {\n                _safeWithdrawal = true;\n                emit GoalReached(_beneficiary, _amountRaised);\n            }\n            _fallback = true;\n        }\n    }\n\n    function safeWithdrawal() public { \n        if (block.timestamp >= _deadline) {\n            if (!_safeWithdrawal) {\n                uint amount = _balanceOf[msg.sender];\n                _balanceOf[msg.sender] = 0;\n                if (amount > 0) {\n                    if (!payable(msg.sender).send(amount)) {\n                        _balanceOf[msg.sender] = amount;\n                    } else {\n                        emit FundTransfer(msg.sender, amount, false);\n                    }\n                }\n            }\n            if (_safeWithdrawal && _beneficiary == msg.sender) {\n                if (_beneficiary.send(_amountRaised)) {\n                    emit FundTransfer(_beneficiary, _amountRaised, false);\n                } else {\n                    _safeWithdrawal = false;\n                }\n            }\n        }\n    }\n\n    function withdrawCoins() public { \n        require(msg.sender == _beneficiary, \"Only beneficiary can withdraw coins\");\n        selfdestruct(_beneficiary);\n    }\n\n    fallback() external payable { \n        require(!_fallback, \"Fallback not allowed\");\n        _balanceOf[msg.sender] += msg.value;\n        _amountRaised += msg.value;\n        uint256 amount = msg.value;\n        amount /= _price;\n        if (msg.value > 0x8ac7230489e80000) {\n            amount += msg.value / _price / 20;\n        }\n        require(_tokenReward.transfer(msg.sender, amount), \"Transfer failed\");\n        emit FundTransfer(msg.sender, msg.value, true);\n    }\n}\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\n\nNote: This is a simple crowdfunding contract where users can contribute funds until a deadline is reached. If the funding goal is reached by the deadline, the beneficiary can withdraw the funds. If the funding goal is not reached, contributors can withdraw their contributions. The contract also provides token rewards for contributions. The `_fallback` variable is used to prevent contributions after the deadline. The original bytecode also contains some unreachable code which appears to be related to function selector handling. This is not present in the above Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701464653,
	"id": "chatcmpl-8R4yDdDR1TmHLko7Ox4CFr4FJR6wj",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 04:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x1]\nuint256 _amountRaised; // STORAGE[0x2]\nuint256 _deadline; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\naddress _beneficiary; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_4_0_0; // STORAGE[0x4] bytes 0 to 0\nuint8 _safeWithdrawal; // STORAGE[0x7] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x7] bytes 1 to 1\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _safeWithdrawal = 1;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n        _fallback = 1;\n    }\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!_safeWithdrawal) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(!_balanceOf[msg.sender] * 2300);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = _safeWithdrawal;\n        if (v2) {\n            v1 = _beneficiary == msg.sender;\n        }\n        if (v1) {\n            v3 = _beneficiary.call().value(_amountRaised).gas(!_amountRaised * 2300);\n            if (!v3) {\n                _safeWithdrawal = 0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\nfunction withdrawCoins() public nonPayable { \n    if (msg.sender != _beneficiary) {\n        goto 0x5cc;\n    } else {\n        selfdestruct(_beneficiary);\n    }\n}\n\nfunction fallback() public payable { \n    require(!_fallback);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    _amountRaised = _amountRaised + msg.value;\n    if (msg.value <= 0x8ac7230489e80000) {\n        assert(stor_4_0_0);\n        assert(2);\n        assert(stor_4_0_0);\n        require(_tokenReward.code.size);\n        v0 = _tokenReward.transfer(msg.sender, msg.value / _price + (msg.value / _price >> 1)).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n    } else {\n        assert(stor_4_0_0);\n        assert(20);\n        assert(stor_4_0_0);\n        assert(2);\n        assert(stor_4_0_0);\n        require(_tokenReward.code.size);\n        v1 = _tokenReward.transfer(msg.sender, msg.value / _price + (msg.value / _price >> 1) + msg.value / _price / 20).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n    }\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1cb3b20 == function_selector) {\n            checkGoalReached();\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x6e66f6e9 == function_selector) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == function_selector) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        } else if (0xffbb62a3 == function_selector) {\n            withdrawCoins();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 04:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x1]\nuint256 _amountRaised; // STORAGE[0x2]\nuint256 _deadline; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\naddress _beneficiary; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_4_0_0; // STORAGE[0x4] bytes 0 to 0\nuint8 _safeWithdrawal; // STORAGE[0x7] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x7] bytes 1 to 1\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _safeWithdrawal = 1;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n        _fallback = 1;\n    }\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!_safeWithdrawal) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(!_balanceOf[msg.sender] * 2300);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = _safeWithdrawal;\n        if (v2) {\n            v1 = _beneficiary == msg.sender;\n        }\n        if (v1) {\n            v3 = _beneficiary.call().value(_amountRaised).gas(!_amountRaised * 2300);\n            if (!v3) {\n                _safeWithdrawal = 0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\nfunction withdrawCoins() public nonPayable { \n    if (msg.sender != _beneficiary) {\n        goto 0x5cc;\n    } else {\n        selfdestruct(_beneficiary);\n    }\n}\n\nfunction fallback() public payable { \n    require(!_fallback);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    _amountRaised = _amountRaised + msg.value;\n    if (msg.value <= 0x8ac7230489e80000) {\n        assert(stor_4_0_0);\n        assert(2);\n        assert(stor_4_0_0);\n        require(_tokenReward.code.size);\n        v0 = _tokenReward.transfer(msg.sender, msg.value / _price + (msg.value / _price >> 1)).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n    } else {\n        assert(stor_4_0_0);\n        assert(20);\n        assert(stor_4_0_0);\n        assert(2);\n        assert(stor_4_0_0);\n        require(_tokenReward.code.size);\n        v1 = _tokenReward.transfer(msg.sender, msg.value / _price + (msg.value / _price >> 1) + msg.value / _price / 20).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n    }\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1cb3b20 == function_selector) {\n            checkGoalReached();\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x6e66f6e9 == function_selector) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == function_selector) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        } else if (0xffbb62a3 == function_selector) {\n            withdrawCoins();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 04:48 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _fundingGoal; // STORAGE[0x1]\nuint256 _amountRaised; // STORAGE[0x2]\nuint256 _deadline; // STORAGE[0x3]\nuint256 _price; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x6]\naddress _beneficiary; // STORAGE[0x0] bytes 0 to 19\nuint8 stor_4_0_0; // STORAGE[0x4] bytes 0 to 0\nuint8 _safeWithdrawal; // STORAGE[0x7] bytes 0 to 0\nuint8 _fallback; // STORAGE[0x7] bytes 1 to 1\naddress _tokenReward; // STORAGE[0x5] bytes 0 to 19\n\n// Events\nFundTransfer(address, uint256, bool);\nGoalReached(address, uint256);\n\nfunction checkGoalReached() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (_amountRaised >= _fundingGoal) {\n            _safeWithdrawal = 1;\n            emit GoalReached(_beneficiary, _amountRaised);\n        }\n        _fallback = 1;\n    }\n}\n\nfunction deadline() public nonPayable { \n    return _deadline;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction tokenReward() public nonPayable { \n    return _tokenReward;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction fundingGoal() public nonPayable { \n    return _fundingGoal;\n}\n\nfunction amountRaised() public nonPayable { \n    return _amountRaised;\n}\n\nfunction price() public nonPayable { \n    return _price;\n}\n\nfunction safeWithdrawal() public nonPayable { \n    if (block.timestamp >= _deadline) {\n        if (!_safeWithdrawal) {\n            _balanceOf[msg.sender] = 0;\n            if (_balanceOf[msg.sender] > 0) {\n                v0 = msg.sender.call().value(_balanceOf[msg.sender]).gas(!_balanceOf[msg.sender] * 2300);\n                if (!v0) {\n                    _balanceOf[msg.sender] = _balanceOf[msg.sender];\n                } else {\n                    emit FundTransfer(msg.sender, _balanceOf[msg.sender], 0);\n                }\n            }\n        }\n        v1 = v2 = _safeWithdrawal;\n        if (v2) {\n            v1 = _beneficiary == msg.sender;\n        }\n        if (v1) {\n            v3 = _beneficiary.call().value(_amountRaised).gas(!_amountRaised * 2300);\n            if (!v3) {\n                _safeWithdrawal = 0;\n            } else {\n                emit FundTransfer(_beneficiary, _amountRaised, 0);\n            }\n        }\n    }\n}\n\nfunction withdrawCoins() public nonPayable { \n    if (msg.sender != _beneficiary) {\n        goto 0x5cc;\n    } else {\n        selfdestruct(_beneficiary);\n    }\n}\n\nfunction fallback() public payable { \n    require(!_fallback);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] + msg.value;\n    _amountRaised = _amountRaised + msg.value;\n    if (msg.value <= 0x8ac7230489e80000) {\n        assert(stor_4_0_0);\n        assert(2);\n        assert(stor_4_0_0);\n        require(_tokenReward.code.size);\n        v0 = _tokenReward.transfer(msg.sender, msg.value / _price + (msg.value / _price >> 1)).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n    } else {\n        assert(stor_4_0_0);\n        assert(20);\n        assert(stor_4_0_0);\n        assert(2);\n        assert(stor_4_0_0);\n        require(_tokenReward.code.size);\n        v1 = _tokenReward.transfer(msg.sender, msg.value / _price + (msg.value / _price >> 1) + msg.value / _price / 20).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n    }\n    emit FundTransfer(msg.sender, msg.value, 1);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x1cb3b20 == function_selector) {\n            checkGoalReached();\n        } else if (0x29dcb0cf == function_selector) {\n            deadline();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x6e66f6e9 == function_selector) {\n            tokenReward();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x7a3a0e84 == function_selector) {\n            fundingGoal();\n        } else if (0x7b3e5e7b == function_selector) {\n            amountRaised();\n        } else if (0xa035b1fe == function_selector) {\n            price();\n        } else if (0xfd6b7ef8 == function_selector) {\n            safeWithdrawal();\n        } else if (0xffbb62a3 == function_selector) {\n            withdrawCoins();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 23.12828516960144,
	"usage": {
		"completion_tokens": 627,
		"prompt_tokens": 1298,
		"total_tokens": 1925
	}
}