{
	"address": "0x3956925d7d5199a6db1f42347fedbcd35312ae82",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given the decompiled code, here is a simplified version expressed in Solidity:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    mapping (address => bool) private _isERC777;\n    mapping (address => bool) private _isApproved;\n    mapping (address => uint256) private _balanceOf;\n    mapping (address => address) private _owner;\n    mapping (address => bool) private _isSpender;\n    address private _latestSpender;\n    \n    event Approved(address indexed from, address indexed to);\n    event AddedSpender(address indexed spender);\n    event Withdrawn(address indexed from, address indexed to, uint256 value);\n    event Unapproved(address indexed from, address indexed to);\n    event Deposited(address indexed from, address indexed to, uint256 value);\n\n    function fallback() public payable { \n        revert();\n    }\n\n    function tokensReceived(address from, address to, uint256 value) public {\n        require(_isERC777[from], \"Not a valid ERC777 token\");\n        _balanceOf[from] += value;\n        emit Deposited(from, to, value);\n    }\n\n    function setERC777(address token) public {\n        _isERC777[token] = true;\n    }\n\n    function isOwner(address account) public view returns (bool) {\n        return _owner[account] != address(0);\n    }\n\n    function withdrawOverflow(address to) public {\n        require(isOwner(msg.sender), \"Not the contract owner\");\n        uint256 balance = _balanceOf[to];\n        _balanceOf[to] = 0;\n        payable(to).transfer(balance);\n    }\n\n    function deposit(address to, uint256 value) public payable {\n        _balanceOf[to] += value;\n    }\n\n    function latestSpender() public view returns (address) {\n        return _latestSpender;\n    }\n\n    function removeSpender(address spender) public {\n        require(isOwner(msg.sender), \"Not the contract owner\");\n        _isSpender[spender] = false;\n        emit Unapproved(msg.sender, spender);\n    }\n\n    function unsetERC777(address token) public {\n        require(isOwner(msg.sender), \"Not the contract owner\");\n        _isERC777[token] = false;\n    }\n\n    function isSpender(address spender) public view returns (bool) {\n        return _isSpender[spender];\n    }\n\n    function isApproved(address approver, address spender) public view returns (bool) {\n        return _isApproved[spender];\n    }\n\n    function isERC777(address token) public view returns (bool) {\n        return _isERC777[token];\n    }\n\n    function approve(address spender) public {\n        require(isSpender(spender), \"Not a valid spender\");\n        _isApproved[msg.sender] = true;\n        emit Approved(msg.sender, spender);\n    }\n\n    function addSpender(address spender) public {\n        require(isOwner(msg.sender), \"Not the contract owner\");\n        _isSpender[spender] = true;\n        _latestSpender = spender;\n        emit AddedSpender(spender);\n    }\n\n    function transfer(address from, address to, uint256 value) public {\n        require(isApproved(from, msg.sender), \"Not approved to transfer\");\n        require(_balanceOf[from] >= value, \"Insufficient balance\");\n        _balanceOf[from] -= value;\n        _balanceOf[to] += value;\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(isOwner(msg.sender), \"Not the contract owner\");\n        _owner[msg.sender] = newOwner;\n    }\n\n    function withdraw(address to, uint256 value) public {\n        require(_balanceOf[msg.sender] >= value, \"Insufficient balance\");\n        _balanceOf[msg.sender] -= value;\n        payable(to).transfer(value);\n        emit Withdrawn(msg.sender, to, value);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balanceOf[account];\n    }\n\n    function unapprove(address spender) public {\n        _isApproved[spender] = false;\n        emit Unapproved(msg.sender, spender);\n    }\n}\n```\nPlease note that the given EVM bytecode decompiled code was quite complex and not all parts could be translated directly into Solidity. This Solidity code is a simplified approximation of the original contract's functionality. Please carefully review and adjust it according to your needs.",
				"role": "assistant"
			}
		}
	],
	"created": 1702473403,
	"id": "chatcmpl-8VJONvlyKAy96Gv7s5wTutKdlBTXh",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 20:43 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _isERC777; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isApproved; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _isSpender; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint160 _latestSpender; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nApproved(address, address);\nAddedSpender(address);\nWithdrawn(address, address, uint256);\nUnapproved(address, address);\nDeposited(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction tokensReceived(address varg0, address varg1, address varg2, uint256 varg3, bytes varg4, bytes varg5) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg4, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg5, (?).length);\n    if (!(0xff & _isERC777[msg.sender])) {\n        _isERC777[msg.sender] = 0x1 | ~0xff & _isERC777[msg.sender];\n    }\n    0x189c(varg3, msg.sender, varg1);\n}\n\nfunction 0x189c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg1);\n    v1 = address(varg2);\n    v2 = _balanceOf[v1] + varg0;\n    assert(v2 >= _balanceOf[v1]);\n    v3 = address(varg1);\n    v4 = address(varg2);\n    _balanceOf[v4] = v2;\n    v5 = address(varg1);\n    v6 = _balanceOf[v5] + varg0;\n    assert(v6 >= _balanceOf[v5]);\n    v7 = address(varg1);\n    owner_4[v7] = v6;\n    v8 = address(varg1);\n    emit Deposited(address(varg2), v8, varg0);\n    return ;\n}\n\nfunction 0x1c9c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (address(varg1) != 0) {\n        v0 = address(varg1);\n        if (!(0xff & _isERC777[v0])) {\n            v1 = address(varg1);\n            v2 = address(varg2);\n            require(v1.code.size);\n            v3, v4 = v1.transfer(v2, varg0).gas(msg.gas);\n            require(v3); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(v4);\n        } else {\n            v5 = address(varg1);\n            v6 = address(varg2);\n            require(v5.code.size);\n            v7 = v5.send(v6, varg0).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n        }\n    } else {\n        v8 = address(varg2).call().value(varg0).gas(!varg0 * 2300);\n        require(v8); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction setERC777(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isERC777[varg0] = 0x1 | ~0xff & _isERC777[varg0];\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return _owner == varg0;\n}\n\nfunction withdrawOverflow(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    if (varg0 != 0) {\n        require(varg0.code.size);\n        v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(owner_4[varg0] <= v1);\n        v2 = v3 = v1 - owner_4[varg0];\n    } else {\n        assert(owner_4[varg0] <= (address(this)).balance);\n        v2 = (address(this)).balance - owner_4[varg0];\n    }\n    0x1c9c(v2, varg0, msg.sender);\n}\n\nfunction deposit(address varg0, uint256 varg1) public payable { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = msg.value == 0;\n    }\n    require(v0);\n    if (varg0 != 0) {\n        require(varg0.code.size);\n        v2, v3 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v3);\n    } else {\n        v4 = v5 = msg.value;\n    }\n    0x189c(v4, varg0, msg.sender);\n}\n\nfunction latestSpender() public nonPayable { \n    return _latestSpender;\n}\n\nfunction ETH() public nonPayable { \n    return 0;\n}\n\nfunction removeSpender(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isSpender[varg0] = 0x0 | ~0xff & _isSpender[varg0];\n    emit 0xe2fc808ab0ead56889f8ff2a8ea0841ba4c0b8311607a902eb24b834857e1b5(varg0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction unsetERC777(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isERC777[varg0] = 0x0 | ~0xff & _isERC777[varg0];\n}\n\nfunction isSpender(address varg0) public nonPayable { \n    return 0xff & _isSpender[varg0];\n}\n\nfunction isApproved(address varg0, address varg1) public nonPayable { \n    return 0xff & _isApproved[varg1];\n}\n\nfunction isERC777(address varg0) public nonPayable { \n    return 0xff & _isERC777[varg0];\n}\n\nfunction tokenFallback(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x189c(varg1, msg.sender, varg0);\n}\n\nfunction approve(address varg0) public nonPayable { \n    require(0xff & _isSpender[varg0]);\n    _isApproved[varg0] = 0x1 | ~0xff & _isApproved[varg0];\n    emit Approved(msg.sender, varg0);\n}\n\nfunction addSpender(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0 != 0);\n    _isSpender[varg0] = 0x1 | ~0xff & _isSpender[varg0];\n    _latestSpender = varg0;\n    emit AddedSpender(varg0);\n}\n\nfunction transfer(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(0xff & _isSpender[msg.sender]);\n    require(0xff & _isApproved[msg.sender]);\n    require(varg3 > 0);\n    assert(varg3 <= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] - varg3;\n    assert(_balanceOf[varg2] + varg3 >= _balanceOf[varg2]);\n    _balanceOf[varg2] = _balanceOf[varg2] + varg3;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 <= _balanceOf[varg0]);\n    owner_4[varg0] = _balanceOf[varg0] - varg1;\n    0x1c9c(varg1, varg0, msg.sender);\n    emit Withdrawn(msg.sender, varg0, varg1);\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _balanceOf[varg1];\n}\n\nfunction unapprove(address varg0) public nonPayable { \n    _isApproved[varg0] = 0x0 | ~0xff & _isApproved[varg0];\n    emit Unapproved(msg.sender, varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x23de29 == function_selector) {\n            tokensReceived(address,address,address,uint256,bytes,bytes);\n        } else if (0x2670bdf0 == function_selector) {\n            setERC777(address);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3a30452a == function_selector) {\n            withdrawOverflow(address);\n        } else if (0x47e7ef24 == function_selector) {\n            deposit(address,uint256);\n        } else if (0x6f362c2b == function_selector) {\n            latestSpender();\n        } else if (0x8322fff2 == function_selector) {\n            ETH();\n        } else if (0x8ce5877c == function_selector) {\n            removeSpender(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x900888a3 == function_selector) {\n            unsetERC777(address);\n        } else if (0x9a206ece == function_selector) {\n            isSpender(address);\n        } else if (0xa389783e == function_selector) {\n            isApproved(address,address);\n        } else if (0xab7b70d3 == function_selector) {\n            isERC777(address);\n        } else if (0xc0ee0b8a == function_selector) {\n            tokenFallback(address,uint256,bytes);\n        } else if (0xdaea85c5 == function_selector) {\n            approve(address);\n        } else if (0xe7e31e7a == function_selector) {\n            addSpender(address);\n        } else if (0xf18d03cc == function_selector) {\n            transfer(address,address,address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xfbf1f78a == function_selector) {\n            unapprove(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 20:43 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _isERC777; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isApproved; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _isSpender; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint160 _latestSpender; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nApproved(address, address);\nAddedSpender(address);\nWithdrawn(address, address, uint256);\nUnapproved(address, address);\nDeposited(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction tokensReceived(address varg0, address varg1, address varg2, uint256 varg3, bytes varg4, bytes varg5) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg4, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg5, (?).length);\n    if (!(0xff & _isERC777[msg.sender])) {\n        _isERC777[msg.sender] = 0x1 | ~0xff & _isERC777[msg.sender];\n    }\n    0x189c(varg3, msg.sender, varg1);\n}\n\nfunction 0x189c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg1);\n    v1 = address(varg2);\n    v2 = _balanceOf[v1] + varg0;\n    assert(v2 >= _balanceOf[v1]);\n    v3 = address(varg1);\n    v4 = address(varg2);\n    _balanceOf[v4] = v2;\n    v5 = address(varg1);\n    v6 = _balanceOf[v5] + varg0;\n    assert(v6 >= _balanceOf[v5]);\n    v7 = address(varg1);\n    owner_4[v7] = v6;\n    v8 = address(varg1);\n    emit Deposited(address(varg2), v8, varg0);\n    return ;\n}\n\nfunction 0x1c9c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (address(varg1) != 0) {\n        v0 = address(varg1);\n        if (!(0xff & _isERC777[v0])) {\n            v1 = address(varg1);\n            v2 = address(varg2);\n            require(v1.code.size);\n            v3, v4 = v1.transfer(v2, varg0).gas(msg.gas);\n            require(v3); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(v4);\n        } else {\n            v5 = address(varg1);\n            v6 = address(varg2);\n            require(v5.code.size);\n            v7 = v5.send(v6, varg0).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n        }\n    } else {\n        v8 = address(varg2).call().value(varg0).gas(!varg0 * 2300);\n        require(v8); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction setERC777(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isERC777[varg0] = 0x1 | ~0xff & _isERC777[varg0];\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return _owner == varg0;\n}\n\nfunction withdrawOverflow(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    if (varg0 != 0) {\n        require(varg0.code.size);\n        v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(owner_4[varg0] <= v1);\n        v2 = v3 = v1 - owner_4[varg0];\n    } else {\n        assert(owner_4[varg0] <= (address(this)).balance);\n        v2 = (address(this)).balance - owner_4[varg0];\n    }\n    0x1c9c(v2, varg0, msg.sender);\n}\n\nfunction deposit(address varg0, uint256 varg1) public payable { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = msg.value == 0;\n    }\n    require(v0);\n    if (varg0 != 0) {\n        require(varg0.code.size);\n        v2, v3 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v3);\n    } else {\n        v4 = v5 = msg.value;\n    }\n    0x189c(v4, varg0, msg.sender);\n}\n\nfunction latestSpender() public nonPayable { \n    return _latestSpender;\n}\n\nfunction ETH() public nonPayable { \n    return 0;\n}\n\nfunction removeSpender(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isSpender[varg0] = 0x0 | ~0xff & _isSpender[varg0];\n    emit 0xe2fc808ab0ead56889f8ff2a8ea0841ba4c0b8311607a902eb24b834857e1b5(varg0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction unsetERC777(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isERC777[varg0] = 0x0 | ~0xff & _isERC777[varg0];\n}\n\nfunction isSpender(address varg0) public nonPayable { \n    return 0xff & _isSpender[varg0];\n}\n\nfunction isApproved(address varg0, address varg1) public nonPayable { \n    return 0xff & _isApproved[varg1];\n}\n\nfunction isERC777(address varg0) public nonPayable { \n    return 0xff & _isERC777[varg0];\n}\n\nfunction tokenFallback(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x189c(varg1, msg.sender, varg0);\n}\n\nfunction approve(address varg0) public nonPayable { \n    require(0xff & _isSpender[varg0]);\n    _isApproved[varg0] = 0x1 | ~0xff & _isApproved[varg0];\n    emit Approved(msg.sender, varg0);\n}\n\nfunction addSpender(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0 != 0);\n    _isSpender[varg0] = 0x1 | ~0xff & _isSpender[varg0];\n    _latestSpender = varg0;\n    emit AddedSpender(varg0);\n}\n\nfunction transfer(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(0xff & _isSpender[msg.sender]);\n    require(0xff & _isApproved[msg.sender]);\n    require(varg3 > 0);\n    assert(varg3 <= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] - varg3;\n    assert(_balanceOf[varg2] + varg3 >= _balanceOf[varg2]);\n    _balanceOf[varg2] = _balanceOf[varg2] + varg3;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 <= _balanceOf[varg0]);\n    owner_4[varg0] = _balanceOf[varg0] - varg1;\n    0x1c9c(varg1, varg0, msg.sender);\n    emit Withdrawn(msg.sender, varg0, varg1);\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _balanceOf[varg1];\n}\n\nfunction unapprove(address varg0) public nonPayable { \n    _isApproved[varg0] = 0x0 | ~0xff & _isApproved[varg0];\n    emit Unapproved(msg.sender, varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x23de29 == function_selector) {\n            tokensReceived(address,address,address,uint256,bytes,bytes);\n        } else if (0x2670bdf0 == function_selector) {\n            setERC777(address);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3a30452a == function_selector) {\n            withdrawOverflow(address);\n        } else if (0x47e7ef24 == function_selector) {\n            deposit(address,uint256);\n        } else if (0x6f362c2b == function_selector) {\n            latestSpender();\n        } else if (0x8322fff2 == function_selector) {\n            ETH();\n        } else if (0x8ce5877c == function_selector) {\n            removeSpender(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x900888a3 == function_selector) {\n            unsetERC777(address);\n        } else if (0x9a206ece == function_selector) {\n            isSpender(address);\n        } else if (0xa389783e == function_selector) {\n            isApproved(address,address);\n        } else if (0xab7b70d3 == function_selector) {\n            isERC777(address);\n        } else if (0xc0ee0b8a == function_selector) {\n            tokenFallback(address,uint256,bytes);\n        } else if (0xdaea85c5 == function_selector) {\n            approve(address);\n        } else if (0xe7e31e7a == function_selector) {\n            addSpender(address);\n        } else if (0xf18d03cc == function_selector) {\n            transfer(address,address,address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xfbf1f78a == function_selector) {\n            unapprove(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 20:43 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _isERC777; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _isApproved; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x3]\nmapping (uint256 => [uint256]) owner_4; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _isSpender; // STORAGE[0x5]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\nuint160 _latestSpender; // STORAGE[0x6] bytes 0 to 19\n\n// Events\nApproved(address, address);\nAddedSpender(address);\nWithdrawn(address, address, uint256);\nUnapproved(address, address);\nDeposited(address, address, uint256);\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction tokensReceived(address varg0, address varg1, address varg2, uint256 varg3, bytes varg4, bytes varg5) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg4, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg5, (?).length);\n    if (!(0xff & _isERC777[msg.sender])) {\n        _isERC777[msg.sender] = 0x1 | ~0xff & _isERC777[msg.sender];\n    }\n    0x189c(varg3, msg.sender, varg1);\n}\n\nfunction 0x189c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = address(varg1);\n    v1 = address(varg2);\n    v2 = _balanceOf[v1] + varg0;\n    assert(v2 >= _balanceOf[v1]);\n    v3 = address(varg1);\n    v4 = address(varg2);\n    _balanceOf[v4] = v2;\n    v5 = address(varg1);\n    v6 = _balanceOf[v5] + varg0;\n    assert(v6 >= _balanceOf[v5]);\n    v7 = address(varg1);\n    owner_4[v7] = v6;\n    v8 = address(varg1);\n    emit Deposited(address(varg2), v8, varg0);\n    return ;\n}\n\nfunction 0x1c9c(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (address(varg1) != 0) {\n        v0 = address(varg1);\n        if (!(0xff & _isERC777[v0])) {\n            v1 = address(varg1);\n            v2 = address(varg2);\n            require(v1.code.size);\n            v3, v4 = v1.transfer(v2, varg0).gas(msg.gas);\n            require(v3); // checks call status, propagates error data on error\n            require(RETURNDATASIZE() >= 32);\n            require(v4);\n        } else {\n            v5 = address(varg1);\n            v6 = address(varg2);\n            require(v5.code.size);\n            v7 = v5.send(v6, varg0).gas(msg.gas);\n            require(v7); // checks call status, propagates error data on error\n        }\n    } else {\n        v8 = address(varg2).call().value(varg0).gas(!varg0 * 2300);\n        require(v8); // checks call status, propagates error data on error\n    }\n    return ;\n}\n\nfunction setERC777(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isERC777[varg0] = 0x1 | ~0xff & _isERC777[varg0];\n}\n\nfunction isOwner(address varg0) public nonPayable { \n    return _owner == varg0;\n}\n\nfunction withdrawOverflow(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    if (varg0 != 0) {\n        require(varg0.code.size);\n        v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);\n        require(v0); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        assert(owner_4[varg0] <= v1);\n        v2 = v3 = v1 - owner_4[varg0];\n    } else {\n        assert(owner_4[varg0] <= (address(this)).balance);\n        v2 = (address(this)).balance - owner_4[varg0];\n    }\n    0x1c9c(v2, varg0, msg.sender);\n}\n\nfunction deposit(address varg0, uint256 varg1) public payable { \n    v0 = v1 = varg0 == 0;\n    if (varg0 != 0) {\n        v0 = msg.value == 0;\n    }\n    require(v0);\n    if (varg0 != 0) {\n        require(varg0.code.size);\n        v2, v3 = varg0.transferFrom(msg.sender, address(this), varg1).gas(msg.gas);\n        require(v2); // checks call status, propagates error data on error\n        require(RETURNDATASIZE() >= 32);\n        require(v3);\n    } else {\n        v4 = v5 = msg.value;\n    }\n    0x189c(v4, varg0, msg.sender);\n}\n\nfunction latestSpender() public nonPayable { \n    return _latestSpender;\n}\n\nfunction ETH() public nonPayable { \n    return 0;\n}\n\nfunction removeSpender(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isSpender[varg0] = 0x0 | ~0xff & _isSpender[varg0];\n    emit 0xe2fc808ab0ead56889f8ff2a8ea0841ba4c0b8311607a902eb24b834857e1b5(varg0);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction unsetERC777(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _isERC777[varg0] = 0x0 | ~0xff & _isERC777[varg0];\n}\n\nfunction isSpender(address varg0) public nonPayable { \n    return 0xff & _isSpender[varg0];\n}\n\nfunction isApproved(address varg0, address varg1) public nonPayable { \n    return 0xff & _isApproved[varg1];\n}\n\nfunction isERC777(address varg0) public nonPayable { \n    return 0xff & _isERC777[varg0];\n}\n\nfunction tokenFallback(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg2, (?).length);\n    0x189c(varg1, msg.sender, varg0);\n}\n\nfunction approve(address varg0) public nonPayable { \n    require(0xff & _isSpender[varg0]);\n    _isApproved[varg0] = 0x1 | ~0xff & _isApproved[varg0];\n    emit Approved(msg.sender, varg0);\n}\n\nfunction addSpender(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0 != 0);\n    _isSpender[varg0] = 0x1 | ~0xff & _isSpender[varg0];\n    _latestSpender = varg0;\n    emit AddedSpender(varg0);\n}\n\nfunction transfer(address varg0, address varg1, address varg2, uint256 varg3) public nonPayable { \n    require(0xff & _isSpender[msg.sender]);\n    require(0xff & _isApproved[msg.sender]);\n    require(varg3 > 0);\n    assert(varg3 <= _balanceOf[varg1]);\n    _balanceOf[varg1] = _balanceOf[varg1] - varg3;\n    assert(_balanceOf[varg2] + varg3 >= _balanceOf[varg2]);\n    _balanceOf[varg2] = _balanceOf[varg2] + varg3;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    _owner = varg0;\n}\n\nfunction withdraw(address varg0, uint256 varg1) public nonPayable { \n    require(_balanceOf[msg.sender] >= varg1);\n    assert(varg1 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n    assert(varg1 <= _balanceOf[varg0]);\n    owner_4[varg0] = _balanceOf[varg0] - varg1;\n    0x1c9c(varg1, varg0, msg.sender);\n    emit Withdrawn(msg.sender, varg0, varg1);\n}\n\nfunction balanceOf(address varg0, address varg1) public nonPayable { \n    return _balanceOf[varg1];\n}\n\nfunction unapprove(address varg0) public nonPayable { \n    _isApproved[varg0] = 0x0 | ~0xff & _isApproved[varg0];\n    emit Unapproved(msg.sender, varg0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x23de29 == function_selector) {\n            tokensReceived(address,address,address,uint256,bytes,bytes);\n        } else if (0x2670bdf0 == function_selector) {\n            setERC777(address);\n        } else if (0x2f54bf6e == function_selector) {\n            isOwner(address);\n        } else if (0x3a30452a == function_selector) {\n            withdrawOverflow(address);\n        } else if (0x47e7ef24 == function_selector) {\n            deposit(address,uint256);\n        } else if (0x6f362c2b == function_selector) {\n            latestSpender();\n        } else if (0x8322fff2 == function_selector) {\n            ETH();\n        } else if (0x8ce5877c == function_selector) {\n            removeSpender(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x900888a3 == function_selector) {\n            unsetERC777(address);\n        } else if (0x9a206ece == function_selector) {\n            isSpender(address);\n        } else if (0xa389783e == function_selector) {\n            isApproved(address,address);\n        } else if (0xab7b70d3 == function_selector) {\n            isERC777(address);\n        } else if (0xc0ee0b8a == function_selector) {\n            tokenFallback(address,uint256,bytes);\n        } else if (0xdaea85c5 == function_selector) {\n            approve(address);\n        } else if (0xe7e31e7a == function_selector) {\n            addSpender(address);\n        } else if (0xf18d03cc == function_selector) {\n            transfer(address,address,address,uint256);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf3fef3a3 == function_selector) {\n            withdraw(address,uint256);\n        } else if (0xf7888aec == function_selector) {\n            balanceOf(address,address);\n        } else if (0xfbf1f78a == function_selector) {\n            unapprove(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 39.83898186683655,
	"usage": {
		"completion_tokens": 902,
		"prompt_tokens": 2752,
		"total_tokens": 3654
	}
}