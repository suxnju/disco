{
	"address": "0x3f291a4561a7f6230394a76096fd054d7c2886aa",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is a Solidity contract code based on the provided decompiled code. However, please note that certain parts of the code (especially function calls and logic within the functions) might not be accurate due to the complexity and the opaqueness of the decompiled code. \n\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\ncontract YourContract {\n\n    mapping (uint256 => uint256) private _balanceOf;\n    mapping (uint256 => mapping (uint256 => uint256)) private _allowance;\n    mapping (uint256 => uint256) private map_3;\n    mapping (uint256 => uint256) private owner_4;\n    mapping (uint256 => uint256) private _isBot;\n    mapping (uint256 => uint256) private owner_6;\n    uint256 private stor_8;\n    uint256 private stor_9;\n    uint256 private stor_a;\n    uint256 private stor_b;\n    uint256 private stor_c;\n    uint256 private stor_d;\n    uint256 private stor_e;\n    uint256 private __maxTxAmount;\n    uint256 private __maxWalletSize;\n    uint256 private __taxSwapThreshold;\n    uint256 private __maxTaxSwap;\n    uint256 private _@swapTokensForEth_1181;\n    uint256 private _owner;\n    uint256 private _transferDelayEnabled;\n    uint256 private _manualSwap;\n    uint256 private stor_14_0_19;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event MaxTxAmountUpdated(uint256 maxTxAmount);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        _owner = msg.sender;\n    }\n\n    // ... other functions goes here ...\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer_1090(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function _transfer_1090(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        // Implement your business logic here ...\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve_734(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve_734(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        \n        _allowance[owner][spender] = amount;\n        \n        emit Approval(owner, spender, amount);\n    }\n\n    // ... other functions goes here ...\n\n}\n```\n\nPlease make sure to replace `YourContract` with the actual name of your contract and implement your business logic in the `_transfer_1090` and `_approve_734` functions where I've left comments. The rest of the functions should be adapted based on the business logic of your contract, the decompiled code doesn't provide enough information to recreate them accurately.",
				"role": "assistant"
			}
		}
	],
	"created": 1701486242,
	"id": "chatcmpl-8RAaQ4cSeXfcsZXprGhXuY0aTaSW8",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.20 13:55 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x5]\nmapping (uint256 => uint256) owner_6; // STORAGE[0x6]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __maxTxAmount; // STORAGE[0x10]\nuint256 __maxWalletSize; // STORAGE[0x11]\nuint256 __taxSwapThreshold; // STORAGE[0x12]\nuint256 __maxTaxSwap; // STORAGE[0x13]\nuint256 _@swapTokensForEth_1181; // STORAGE[0x15]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x7] bytes 0 to 0\nuint256 _manualSwap; // STORAGE[0x7] bytes 1 to 20\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @swapTokensForEth_1181(uint256 varg0) private { \n    _@swapTokensForEth_1181 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n    if (varg0) {\n        if (uint8(_@swapTokensForEth_1181 >> 160)) {\n            v0 = new address[](2);\n            CALLDATACOPY(v0.data, msg.data.length, 64);\n            require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v1 = v0.data;\n            v0[0] = address(this);\n            v2, /* address */ v3 = stor_14_0_19.WETH().gas(msg.gas);\n            require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            require(v3 == address(v3));\n            require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v0[1] = address(v3);\n            @_approve_734(varg0, stor_14_0_19, this);\n            v4 = new address[](v0.length);\n            v5 = v6 = v4.data;\n            v7 = v8 = v0.data;\n            v9 = v10 = 0;\n            while (v9 < v0.length) {\n                MEM[v5] = address(MEM[v7]);\n                v7 += 32;\n                v5 += 32;\n                v9 += 1;\n            }\n            require(bool(stor_14_0_19.code.size));\n            v11 = stor_14_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n            require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        }\n    }\n    _@swapTokensForEth_1181 = ~0xff000000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n    return ;\n}\n\nfunction @min_1108(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_734(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x989680;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1090(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_734(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 8;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    if (_balanceOf[this]) {\n        @swapTokensForEth_1181(_balanceOf[this]);\n    }\n    if (this.balance) {\n        v0 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        // Unknown jump to Block 0x1f69. Refer to 3-address code (TAC);\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x989680;\n    v1 = _SafeExp(10, uint8(8));\n    require((v1 == v1 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x989680;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(8));\n    require((v2 == v2 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x989680);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1090(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(_@swapTokensForEth_1181 >> 160), Error('trading is already open'));\n    stor_14_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    @_approve_734(v0 * 0x989680, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_14_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_14_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).getPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    _@swapTokensForEth_1181 = address(v6) | bytes12(_@swapTokensForEth_1181);\n    if (!address(v6)) {\n        v7, /* address */ v8 = stor_14_0_19.WETH().gas(msg.gas);\n        require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        require(v8 == address(v8));\n        v9, /* address */ v10 = address(v2).createPair(address(this), address(v8)).gas(msg.gas);\n        require(bool(v9), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        require(v10 == address(v10));\n        _@swapTokensForEth_1181 = address(v10) | bytes12(_@swapTokensForEth_1181);\n    }\n    v11, /* uint256 */ v12, /* uint256 */ v13, /* uint256 */ v14 = stor_14_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v15, /* bool */ v16 = address(_@swapTokensForEth_1181).approve(stor_14_0_19, ~0).gas(msg.gas);\n    require(bool(v15), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v16 == bool(v16));\n    _@swapTokensForEth_1181 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_734(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1090(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3518;\n        v10 = v11 = 100;\n        v12 = v13 = 8754;\n        if (uint8(_@swapTokensForEth_1181 >> 160)) {\n            v14 = v15 = 0;\n        } else {\n            v14 = v16 = stor_8;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x14fc. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x227c', '0x2257', '0x2232'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x1009', '0xdbe', '0x10aa'}. Refer to 3-address code (TAC);\n                    if (_transferDelayEnabled) {\n                        v19 = v20 = stor_14_0_19 != address(varg1);\n                        if (stor_14_0_19 != address(varg1)) {\n                            v19 = v21 = address(_@swapTokensForEth_1181) != address(varg1);\n                        }\n                        if (v19) {\n                            require(block.number > owner_6[tx.origin], Error('Only one transfer per block allowed.', 'Only one transfer per block allowed.'));\n                            owner_6[tx.origin] = block.number;\n                        }\n                    }\n                    v22 = v23 = address(_@swapTokensForEth_1181) == varg2;\n                    if (v23) {\n                        v22 = v24 = stor_14_0_19 != address(varg1);\n                    }\n                    if (v22) {\n                        v22 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v22) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        if (stor_f < stor_e) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_f + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_f += 1;\n                        owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(varg1)]);\n                        v8 = v26 = 4105;\n                        v10 = v27 = 100;\n                        v12 = v28 = 8791;\n                        if (stor_c < stor_f) {\n                            v14 = v29 = stor_a;\n                        } else {\n                            v14 = v30 = stor_8;\n                            continue;\n                        }\n                    }\n                    v31 = v32 = address(_@swapTokensForEth_1181) == address(varg1);\n                    if (v32) {\n                        v31 = v33 = this != varg2;\n                    }\n                    if (v31) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        v8 = v34 = 4266;\n                        v10 = v35 = 100;\n                        v12 = v36 = 8828;\n                        if (stor_f > stor_d) {\n                            v14 = v37 = stor_b;\n                        } else {\n                            v14 = v38 = stor_9;\n                            continue;\n                        }\n                    }\n                    v39 = v40 = !uint8(_@swapTokensForEth_1181 >> 168);\n                    if (!bool(uint8(_@swapTokensForEth_1181 >> 168))) {\n                        v39 = v41 = address(_@swapTokensForEth_1181) == address(varg1);\n                    }\n                    if (v39) {\n                        v39 = v42 = uint8(_@swapTokensForEth_1181 >> 176);\n                    }\n                    if (v39) {\n                        v39 = v43 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v39) {\n                        v39 = v44 = stor_f > stor_e;\n                    }\n                    if (v39) {\n                        v45 = @min_1108(__maxTaxSwap, _balanceOf[this]);\n                        v46 = @min_1108(v45, varg0);\n                        @swapTokensForEth_1181(v46);\n                        if (this.balance) {\n                            v47 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n                            require(bool(v47), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                    v48 = v49 = stor_f > stor_e;\n                    if (stor_f <= stor_e) {\n                        v48 = v50 = uint8(owner_4[address(varg2)]);\n                    }\n                    require(v48, Error('Seller is not buyer'));\n                } else {\n                    v51 = new bytes[](v52.length);\n                    v53 = v54 = 0;\n                    while (v53 < v52.length) {\n                        v51[v53] = v52[v53];\n                        v53 += 32;\n                    }\n                    v51[v52.length] = 0;\n                    revert(Error(v51));\n                }\n                // Unknown jump to Block 0x1572. Refer to 3-address code (TAC);\n                // Unknown jump to Block 0x1572. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x227c', '0x2257', '0x2232'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v55 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v55;\n        emit Transfer(varg2, this, v0);\n    }\n    v56 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v56;\n    v57 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v58 = _SafeAdd(v57, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v58;\n    v59 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v59;\n    emit Transfer(varg2, address(varg1), v59);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 13:55 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x5]\nmapping (uint256 => uint256) owner_6; // STORAGE[0x6]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __maxTxAmount; // STORAGE[0x10]\nuint256 __maxWalletSize; // STORAGE[0x11]\nuint256 __taxSwapThreshold; // STORAGE[0x12]\nuint256 __maxTaxSwap; // STORAGE[0x13]\nuint256 _@swapTokensForEth_1181; // STORAGE[0x15]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x7] bytes 0 to 0\nuint256 _manualSwap; // STORAGE[0x7] bytes 1 to 20\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @swapTokensForEth_1181(uint256 varg0) private { \n    _@swapTokensForEth_1181 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n    if (varg0) {\n        if (uint8(_@swapTokensForEth_1181 >> 160)) {\n            v0 = new address[](2);\n            CALLDATACOPY(v0.data, msg.data.length, 64);\n            require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v1 = v0.data;\n            v0[0] = address(this);\n            v2, /* address */ v3 = stor_14_0_19.WETH().gas(msg.gas);\n            require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            require(v3 == address(v3));\n            require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v0[1] = address(v3);\n            @_approve_734(varg0, stor_14_0_19, this);\n            v4 = new address[](v0.length);\n            v5 = v6 = v4.data;\n            v7 = v8 = v0.data;\n            v9 = v10 = 0;\n            while (v9 < v0.length) {\n                MEM[v5] = address(MEM[v7]);\n                v7 += 32;\n                v5 += 32;\n                v9 += 1;\n            }\n            require(bool(stor_14_0_19.code.size));\n            v11 = stor_14_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n            require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        }\n    }\n    _@swapTokensForEth_1181 = ~0xff000000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n    return ;\n}\n\nfunction @min_1108(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_734(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x989680;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1090(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_734(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 8;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    if (_balanceOf[this]) {\n        @swapTokensForEth_1181(_balanceOf[this]);\n    }\n    if (this.balance) {\n        v0 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        // Unknown jump to Block 0x1f69. Refer to 3-address code (TAC);\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x989680;\n    v1 = _SafeExp(10, uint8(8));\n    require((v1 == v1 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x989680;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(8));\n    require((v2 == v2 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x989680);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1090(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(_@swapTokensForEth_1181 >> 160), Error('trading is already open'));\n    stor_14_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    @_approve_734(v0 * 0x989680, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_14_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_14_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).getPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    _@swapTokensForEth_1181 = address(v6) | bytes12(_@swapTokensForEth_1181);\n    if (!address(v6)) {\n        v7, /* address */ v8 = stor_14_0_19.WETH().gas(msg.gas);\n        require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        require(v8 == address(v8));\n        v9, /* address */ v10 = address(v2).createPair(address(this), address(v8)).gas(msg.gas);\n        require(bool(v9), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        require(v10 == address(v10));\n        _@swapTokensForEth_1181 = address(v10) | bytes12(_@swapTokensForEth_1181);\n    }\n    v11, /* uint256 */ v12, /* uint256 */ v13, /* uint256 */ v14 = stor_14_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v15, /* bool */ v16 = address(_@swapTokensForEth_1181).approve(stor_14_0_19, ~0).gas(msg.gas);\n    require(bool(v15), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v16 == bool(v16));\n    _@swapTokensForEth_1181 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_734(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1090(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3518;\n        v10 = v11 = 100;\n        v12 = v13 = 8754;\n        if (uint8(_@swapTokensForEth_1181 >> 160)) {\n            v14 = v15 = 0;\n        } else {\n            v14 = v16 = stor_8;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x14fc. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x227c', '0x2257', '0x2232'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x1009', '0xdbe', '0x10aa'}. Refer to 3-address code (TAC);\n                    if (_transferDelayEnabled) {\n                        v19 = v20 = stor_14_0_19 != address(varg1);\n                        if (stor_14_0_19 != address(varg1)) {\n                            v19 = v21 = address(_@swapTokensForEth_1181) != address(varg1);\n                        }\n                        if (v19) {\n                            require(block.number > owner_6[tx.origin], Error('Only one transfer per block allowed.', 'Only one transfer per block allowed.'));\n                            owner_6[tx.origin] = block.number;\n                        }\n                    }\n                    v22 = v23 = address(_@swapTokensForEth_1181) == varg2;\n                    if (v23) {\n                        v22 = v24 = stor_14_0_19 != address(varg1);\n                    }\n                    if (v22) {\n                        v22 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v22) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        if (stor_f < stor_e) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_f + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_f += 1;\n                        owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(varg1)]);\n                        v8 = v26 = 4105;\n                        v10 = v27 = 100;\n                        v12 = v28 = 8791;\n                        if (stor_c < stor_f) {\n                            v14 = v29 = stor_a;\n                        } else {\n                            v14 = v30 = stor_8;\n                            continue;\n                        }\n                    }\n                    v31 = v32 = address(_@swapTokensForEth_1181) == address(varg1);\n                    if (v32) {\n                        v31 = v33 = this != varg2;\n                    }\n                    if (v31) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        v8 = v34 = 4266;\n                        v10 = v35 = 100;\n                        v12 = v36 = 8828;\n                        if (stor_f > stor_d) {\n                            v14 = v37 = stor_b;\n                        } else {\n                            v14 = v38 = stor_9;\n                            continue;\n                        }\n                    }\n                    v39 = v40 = !uint8(_@swapTokensForEth_1181 >> 168);\n                    if (!bool(uint8(_@swapTokensForEth_1181 >> 168))) {\n                        v39 = v41 = address(_@swapTokensForEth_1181) == address(varg1);\n                    }\n                    if (v39) {\n                        v39 = v42 = uint8(_@swapTokensForEth_1181 >> 176);\n                    }\n                    if (v39) {\n                        v39 = v43 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v39) {\n                        v39 = v44 = stor_f > stor_e;\n                    }\n                    if (v39) {\n                        v45 = @min_1108(__maxTaxSwap, _balanceOf[this]);\n                        v46 = @min_1108(v45, varg0);\n                        @swapTokensForEth_1181(v46);\n                        if (this.balance) {\n                            v47 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n                            require(bool(v47), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                    v48 = v49 = stor_f > stor_e;\n                    if (stor_f <= stor_e) {\n                        v48 = v50 = uint8(owner_4[address(varg2)]);\n                    }\n                    require(v48, Error('Seller is not buyer'));\n                } else {\n                    v51 = new bytes[](v52.length);\n                    v53 = v54 = 0;\n                    while (v53 < v52.length) {\n                        v51[v53] = v52[v53];\n                        v53 += 32;\n                    }\n                    v51[v52.length] = 0;\n                    revert(Error(v51));\n                }\n                // Unknown jump to Block 0x1572. Refer to 3-address code (TAC);\n                // Unknown jump to Block 0x1572. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x227c', '0x2257', '0x2232'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v55 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v55;\n        emit Transfer(varg2, this, v0);\n    }\n    v56 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v56;\n    v57 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v58 = _SafeAdd(v57, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v58;\n    v59 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v59;\n    emit Transfer(varg2, address(varg1), v59);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.20 13:55 UTC\n// Compiled using the solidity compiler version 0.8.20\n\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => uint256) _balanceOf; // STORAGE[0x1]\nmapping (uint256 => mapping (uint256 => uint256)) _allowance; // STORAGE[0x2]\nmapping (uint256 => uint256) map_3; // STORAGE[0x3]\nmapping (uint256 => uint256) owner_4; // STORAGE[0x4]\nmapping (uint256 => uint256) _isBot; // STORAGE[0x5]\nmapping (uint256 => uint256) owner_6; // STORAGE[0x6]\nuint256 stor_8; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\nuint256 stor_a; // STORAGE[0xa]\nuint256 stor_b; // STORAGE[0xb]\nuint256 stor_c; // STORAGE[0xc]\nuint256 stor_d; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 __maxTxAmount; // STORAGE[0x10]\nuint256 __maxWalletSize; // STORAGE[0x11]\nuint256 __taxSwapThreshold; // STORAGE[0x12]\nuint256 __maxTaxSwap; // STORAGE[0x13]\nuint256 _@swapTokensForEth_1181; // STORAGE[0x15]\nuint256 _owner; // STORAGE[0x0] bytes 0 to 19\nuint256 _transferDelayEnabled; // STORAGE[0x7] bytes 0 to 0\nuint256 _manualSwap; // STORAGE[0x7] bytes 1 to 20\nuint256 stor_14_0_19; // STORAGE[0x14] bytes 0 to 19\n\n\n// Events\nOwnershipTransferred(address, address);\nMaxTxAmountUpdated(uint256);\nApproval(address, address, uint256);\nTransfer(address, address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction _SafeSub(bytes varg0, uint256 varg1, uint256 varg2) private { \n    if (varg1 <= varg2) {\n        require(varg2 - varg1 <= varg2, Panic(17)); // arithmetic overflow or underflow\n        return varg2 - varg1;\n    } else {\n        v0 = new bytes[](varg0.length);\n        v1 = v2 = 0;\n        while (v1 < varg0.length) {\n            v0[v1] = varg0[v1];\n            v1 += 32;\n        }\n        v0[varg0.length] = 0;\n        revert(Error(v0));\n    }\n}\n\nfunction @swapTokensForEth_1181(uint256 varg0) private { \n    _@swapTokensForEth_1181 = 0x1000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n    if (varg0) {\n        if (uint8(_@swapTokensForEth_1181 >> 160)) {\n            v0 = new address[](2);\n            CALLDATACOPY(v0.data, msg.data.length, 64);\n            require(0 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v1 = v0.data;\n            v0[0] = address(this);\n            v2, /* address */ v3 = stor_14_0_19.WETH().gas(msg.gas);\n            require(bool(v2), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n            require(v3 == address(v3));\n            require(1 < v0.length, Panic(50)); // access an out-of-bounds or negative index of bytesN array or slice\n            v0[1] = address(v3);\n            @_approve_734(varg0, stor_14_0_19, this);\n            v4 = new address[](v0.length);\n            v5 = v6 = v4.data;\n            v7 = v8 = v0.data;\n            v9 = v10 = 0;\n            while (v9 < v0.length) {\n                MEM[v5] = address(MEM[v7]);\n                v7 += 32;\n                v5 += 32;\n                v9 += 1;\n            }\n            require(bool(stor_14_0_19.code.size));\n            v11 = stor_14_0_19.swapExactTokensForETHSupportingFeeOnTransferTokens(varg0, 0, v4, address(this), block.timestamp, v12, address(this)).gas(msg.gas);\n            require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        }\n    }\n    _@swapTokensForEth_1181 = ~0xff000000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n    return ;\n}\n\nfunction @min_1108(uint256 varg0, uint256 varg1) private { \n    if (varg1 > varg0) {\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    require(varg1 <= v0, Panic(17)); // arithmetic overflow or underflow\n    require(v0 >= varg1, Error('SafeMath: addition overflow'));\n    return v0;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_approve_734(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _SafeExp(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        if (varg0) {\n            if (varg0 == 1) {\n                return 1;\n            } else if (varg0 == 2) {\n                require(varg1 <= uint8.max, Panic(17)); // arithmetic overflow or underflow\n                return 1 << varg1;\n            } else if (!((varg0 < 11) & (varg1 < 78) | (varg0 < 307) & (varg1 < 32))) {\n                v0 = v1 = 1;\n                while (varg1 > v1) {\n                    require(varg0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                    if (varg1 & v1) {\n                        v0 *= varg0;\n                    }\n                    varg1 = varg1 >> v1;\n                    varg0 *= varg0;\n                }\n                require(v0 <= ~0 / varg0, Panic(17)); // arithmetic overflow or underflow\n                return varg0 * v0;\n            } else {\n                return varg0 ** varg1;\n            }\n        } else {\n            return 0;\n        }\n    } else {\n        return 1;\n    }\n}\n\nfunction _maxTaxSwap() public nonPayable { \n    return __maxTaxSwap;\n}\n\nfunction totalSupply() public nonPayable { \n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    return v0 * 0x989680;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(msg.data.length - 4 >= 96);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    @_transfer_1090(varg2, varg1, varg0);\n    v0 = _SafeSub('ERC20: transfer amount exceeds allowance', varg2, _allowance[varg0][msg.sender]);\n    @_approve_734(v0, msg.sender, varg0);\n    return bool(1);\n}\n\nfunction decimals() public nonPayable { \n    return 8;\n}\n\nfunction isBot(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return bool(uint8(_isBot[address(varg0)]));\n}\n\nfunction manualSwap() public nonPayable { \n    require(msg.sender == _manualSwap);\n    if (_balanceOf[this]) {\n        @swapTokensForEth_1181(_balanceOf[this]);\n    }\n    if (this.balance) {\n        v0 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n        require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        // Unknown jump to Block 0x1f69. Refer to 3-address code (TAC);\n    }\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    return _balanceOf[varg0];\n}\n\nfunction () public payable { \n}\n\nfunction renounceOwnership() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    emit OwnershipTransferred(_owner, 0);\n    _owner = 0;\n}\n\nfunction removeLimits() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    __maxTxAmount = v0 * 0x989680;\n    v1 = _SafeExp(10, uint8(8));\n    require((v1 == v1 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    __maxWalletSize = v1 * 0x989680;\n    _transferDelayEnabled = 0;\n    v2 = _SafeExp(10, uint8(8));\n    require((v2 == v2 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    emit MaxTxAmountUpdated(v2 * 0x989680);\n}\n\nfunction _maxTxAmount() public nonPayable { \n    return __maxTxAmount;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction _maxWalletSize() public nonPayable { \n    return __maxWalletSize;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](v1.length);\n    v2 = v3 = 0;\n    while (v2 < v1.length) {\n        v0[v2] = v1[v2];\n        v2 += 32;\n    }\n    v0[v1.length] = 0;\n    return v0;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    @_transfer_1090(varg1, varg0, msg.sender);\n    return bool(1);\n}\n\nfunction _taxSwapThreshold() public nonPayable { \n    return __taxSwapThreshold;\n}\n\nfunction transferDelayEnabled() public nonPayable { \n    return _transferDelayEnabled;\n}\n\nfunction openTrading() public nonPayable { \n    require(msg.sender == _owner, Error('Ownable: caller is not the owner'));\n    require(!uint8(_@swapTokensForEth_1181 >> 160), Error('trading is already open'));\n    stor_14_0_19 = 0x7a250d5630b4cf539739df2c5dacb4c659f2488d;\n    v0 = _SafeExp(10, uint8(8));\n    require((v0 == v0 * 0x989680 / 0x989680) | !0x989680, Panic(17)); // arithmetic overflow or underflow\n    @_approve_734(v0 * 0x989680, 0x7a250d5630b4cf539739df2c5dacb4c659f2488d, this);\n    v1, /* address */ v2 = stor_14_0_19.factory().gas(msg.gas);\n    require(bool(v1), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v2 == address(v2));\n    v3, /* address */ v4 = stor_14_0_19.WETH().gas(msg.gas);\n    require(bool(v3), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v4 == address(v4));\n    v5, /* address */ v6 = address(v2).getPair(address(this), address(v4)).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v6 == address(v6));\n    _@swapTokensForEth_1181 = address(v6) | bytes12(_@swapTokensForEth_1181);\n    if (!address(v6)) {\n        v7, /* address */ v8 = stor_14_0_19.WETH().gas(msg.gas);\n        require(bool(v7), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        require(v8 == address(v8));\n        v9, /* address */ v10 = address(v2).createPair(address(this), address(v8)).gas(msg.gas);\n        require(bool(v9), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n        require(v10 == address(v10));\n        _@swapTokensForEth_1181 = address(v10) | bytes12(_@swapTokensForEth_1181);\n    }\n    v11, /* uint256 */ v12, /* uint256 */ v13, /* uint256 */ v14 = stor_14_0_19.addLiquidityETH(address(this), _balanceOf[address(this)], 0, 0, _owner, block.timestamp).value(this.balance).gas(msg.gas);\n    require(bool(v11), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);\n    v15, /* bool */ v16 = address(_@swapTokensForEth_1181).approve(stor_14_0_19, ~0).gas(msg.gas);\n    require(bool(v15), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);\n    require(v16 == bool(v16));\n    _@swapTokensForEth_1181 = 0x100010000000000000000000000000000000000000000 | ~0xff00ff0000000000000000000000000000000000000000 & _@swapTokensForEth_1181;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 == varg1);\n    return _allowance[varg0][varg1];\n}\n\nfunction @_approve_734(uint256 varg0, address varg1, address varg2) private { \n    require(varg2, Error('ERC20: approve from the zero address', 'ERC20: approve from the zero address'));\n    require(varg1, Error('ERC20: approve to the zero address'));\n    _allowance[varg2][varg1] = varg0;\n    emit Approval(varg2, varg1, varg0);\n    return ;\n}\n\nfunction @_transfer_1090(uint256 varg0, uint256 varg1, address varg2) private { \n    require(varg2, Error('ERC20: transfer from the zero address'));\n    require(address(varg1), Error('ERC20: transfer to the zero address'));\n    require(varg0 > 0, Error('Transfer amount must be greater than zero'));\n    v0 = v1 = 0;\n    v2 = v3 = _owner != varg2;\n    if (_owner != varg2) {\n        v2 = v4 = _owner != address(varg1);\n    }\n    if (v2) {\n        v5 = v6 = !uint8(_isBot[address(varg2)]);\n        if (!bool(uint8(_isBot[address(varg2)]))) {\n            v5 = v7 = !uint8(_isBot[address(varg1)]);\n        }\n        require(v5);\n        v8 = v9 = 3518;\n        v10 = v11 = 100;\n        v12 = v13 = 8754;\n        if (uint8(_@swapTokensForEth_1181 >> 160)) {\n            v14 = v15 = 0;\n        } else {\n            v14 = v16 = stor_8;\n        }\n        while (1) {\n            while (1) {\n                if (0 - varg0) {\n                    // Unknown jump to Block 0x14fc. Refer to 3-address code (TAC);\n                }\n                v17 = v18 = 0;\n                // Unknown jump to Block {'0x227c', '0x2257', '0x2232'}. Refer to 3-address code (TAC);\n                if (v10) {\n                    require(v10, Panic(18)); // division by zero\n                    v0 = v17 / v10;\n                    // Unknown jump to Block {'0x1009', '0xdbe', '0x10aa'}. Refer to 3-address code (TAC);\n                    if (_transferDelayEnabled) {\n                        v19 = v20 = stor_14_0_19 != address(varg1);\n                        if (stor_14_0_19 != address(varg1)) {\n                            v19 = v21 = address(_@swapTokensForEth_1181) != address(varg1);\n                        }\n                        if (v19) {\n                            require(block.number > owner_6[tx.origin], Error('Only one transfer per block allowed.', 'Only one transfer per block allowed.'));\n                            owner_6[tx.origin] = block.number;\n                        }\n                    }\n                    v22 = v23 = address(_@swapTokensForEth_1181) == varg2;\n                    if (v23) {\n                        v22 = v24 = stor_14_0_19 != address(varg1);\n                    }\n                    if (v22) {\n                        v22 = v25 = !uint8(map_3[address(varg1)]);\n                    }\n                    if (v22) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        require(_balanceOf[address(varg1)] <= varg0 + _balanceOf[address(varg1)], Panic(17)); // arithmetic overflow or underflow\n                        require(varg0 + _balanceOf[address(varg1)] <= __maxWalletSize, Error('Exceeds the maxWalletSize.'));\n                        if (stor_f < stor_e) {\n                            require(!varg1.code.size);\n                        }\n                        require(stor_f + 1, Panic(17)); // arithmetic overflow or underflow\n                        stor_f += 1;\n                        owner_4[address(varg1)] = 0x1 | bytes31(owner_4[address(varg1)]);\n                        v8 = v26 = 4105;\n                        v10 = v27 = 100;\n                        v12 = v28 = 8791;\n                        if (stor_c < stor_f) {\n                            v14 = v29 = stor_a;\n                        } else {\n                            v14 = v30 = stor_8;\n                            continue;\n                        }\n                    }\n                    v31 = v32 = address(_@swapTokensForEth_1181) == address(varg1);\n                    if (v32) {\n                        v31 = v33 = this != varg2;\n                    }\n                    if (v31) {\n                        require(varg0 <= __maxTxAmount, Error('Exceeds the _maxTxAmount.'));\n                        v8 = v34 = 4266;\n                        v10 = v35 = 100;\n                        v12 = v36 = 8828;\n                        if (stor_f > stor_d) {\n                            v14 = v37 = stor_b;\n                        } else {\n                            v14 = v38 = stor_9;\n                            continue;\n                        }\n                    }\n                    v39 = v40 = !uint8(_@swapTokensForEth_1181 >> 168);\n                    if (!bool(uint8(_@swapTokensForEth_1181 >> 168))) {\n                        v39 = v41 = address(_@swapTokensForEth_1181) == address(varg1);\n                    }\n                    if (v39) {\n                        v39 = v42 = uint8(_@swapTokensForEth_1181 >> 176);\n                    }\n                    if (v39) {\n                        v39 = v43 = _balanceOf[this] > __taxSwapThreshold;\n                    }\n                    if (v39) {\n                        v39 = v44 = stor_f > stor_e;\n                    }\n                    if (v39) {\n                        v45 = @min_1108(__maxTaxSwap, _balanceOf[this]);\n                        v46 = @min_1108(v45, varg0);\n                        @swapTokensForEth_1181(v46);\n                        if (this.balance) {\n                            v47 = _manualSwap.call().value(this.balance).gas(!this.balance * 2300);\n                            require(bool(v47), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                        }\n                    }\n                    v48 = v49 = stor_f > stor_e;\n                    if (stor_f <= stor_e) {\n                        v48 = v50 = uint8(owner_4[address(varg2)]);\n                    }\n                    require(v48, Error('Seller is not buyer'));\n                } else {\n                    v51 = new bytes[](v52.length);\n                    v53 = v54 = 0;\n                    while (v53 < v52.length) {\n                        v51[v53] = v52[v53];\n                        v53 += 32;\n                    }\n                    v51[v52.length] = 0;\n                    revert(Error(v51));\n                }\n                // Unknown jump to Block 0x1572. Refer to 3-address code (TAC);\n                // Unknown jump to Block 0x1572. Refer to 3-address code (TAC);\n                v17 = v14 * varg0;\n                require((v14 == v17 / varg0) | !varg0, Panic(17)); // arithmetic overflow or underflow\n                require(varg0, Panic(18)); // division by zero\n                require(v17 / varg0 == v14, Error('SafeMath: multiplication overflow'));\n                // Unknown jump to Block {'0x227c', '0x2257', '0x2232'}. Refer to 3-address code (TAC);\n            }\n        }\n    }\n    if (v0) {\n        v55 = _SafeAdd(v0, _balanceOf[this]);\n        _balanceOf[this] = v55;\n        emit Transfer(varg2, this, v0);\n    }\n    v56 = _SafeSub('SafeMath: subtraction overflow', varg0, _balanceOf[varg2]);\n    _balanceOf[varg2] = v56;\n    v57 = _SafeSub('SafeMath: subtraction overflow\\x00\\x00\\x1eSafeMath: subtraction overflow', v0, varg0);\n    v58 = _SafeAdd(v57, _balanceOf[address(varg1)]);\n    _balanceOf[address(varg1)] = v58;\n    v59 = _SafeSub('SafeMath: subtraction overflow', v0, varg0);\n    MEM[MEM[64]] = v59;\n    emit Transfer(varg2, address(varg1), v59);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        require(!msg.data.length);\n        ();\n    } else if (0x751039fc > function_selector >> 224) {\n        if (0x313ce567 > function_selector >> 224) {\n            if (0x6fdde03 == function_selector >> 224) {\n                name();\n            } else if (0x95ea7b3 == function_selector >> 224) {\n                approve(address,uint256);\n            } else if (0xfaee56f == function_selector >> 224) {\n                _maxTaxSwap();\n            } else if (0x18160ddd == function_selector >> 224) {\n                totalSupply();\n            } else {\n                require(0x23b872dd == function_selector >> 224);\n                transferFrom(address,address,uint256);\n            }\n        } else if (0x313ce567 == function_selector >> 224) {\n            decimals();\n        } else if (0x3bbac579 == function_selector >> 224) {\n            isBot(address);\n        } else if (0x51bc3c85 == function_selector >> 224) {\n            manualSwap();\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else {\n            require(0x715018a6 == function_selector >> 224);\n            renounceOwnership();\n        }\n    } else if (0xa9059cbb > function_selector >> 224) {\n        if (0x751039fc == function_selector >> 224) {\n            removeLimits();\n        } else if (0x7d1db4a5 == function_selector >> 224) {\n            _maxTxAmount();\n        } else if (0x8da5cb5b == function_selector >> 224) {\n            owner();\n        } else if (0x8f9a55c0 == function_selector >> 224) {\n            _maxWalletSize();\n        } else {\n            require(0x95d89b41 == function_selector >> 224);\n            symbol();\n        }\n    } else if (0xa9059cbb == function_selector >> 224) {\n        transfer(address,uint256);\n    } else if (0xbf474bed == function_selector >> 224) {\n        _taxSwapThreshold();\n    } else if (0xc876d0b9 == function_selector >> 224) {\n        transferDelayEnabled();\n    } else if (0xc9567bf9 == function_selector >> 224) {\n        openTrading();\n    } else {\n        require(0xdd62ed3e == function_selector >> 224);\n        allowance(address,address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 30.20880436897278,
	"usage": {
		"completion_tokens": 707,
		"prompt_tokens": 6315,
		"total_tokens": 7022
	}
}