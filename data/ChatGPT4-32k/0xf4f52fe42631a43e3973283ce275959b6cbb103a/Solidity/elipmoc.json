{
	"address": "0xf4f52fe42631a43e3973283ce275959b6cbb103a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The original solidity code that corresponds to the decompiled code would look like the following:\n\n```solidity\npragma solidity ^0.5.1;\n\ncontract MyContract {\n    mapping (address => uint256) private _getInvested;\n    mapping (address => uint256) private _lastInvest;\n    mapping (address => uint256) private _getAffiliateCommision;\n    address private _investETH;\n    address private stor_4_0_19;\n\n    function withdraw() public {\n        require(_getInvested[msg.sender] > 0);\n        _lastInvest[msg.sender] = block.timestamp;\n        (bool success, ) = msg.sender.call.value(_getInvested[msg.sender])(\"\");\n        require(success);\n    }\n\n    function getAffiliateCommision() public view returns (uint256) {\n        return _getAffiliateCommision[msg.sender];\n    }\n\n    function affiliateCommision(address addr) public view returns (uint256) {\n        return _getAffiliateCommision[addr];\n    }\n\n    function getProfitFromSender() public view returns (uint256) {\n        return _getInvested[msg.sender];\n    }\n\n    function investETH(address addr) public payable {\n        require(msg.value >= 1 ether);\n        if (_getInvested[msg.sender] > 0) {\n            _lastInvest[msg.sender] = block.timestamp;\n            (bool success, ) = msg.sender.call.value(_getInvested[msg.sender])(\"\");\n            require(success);\n        }\n        uint256 commision = msg.value * 20 / 100;\n        if (msg.sender != addr) {\n            require(_investETH != addr);\n            require(stor_4_0_19 != addr);\n            _getAffiliateCommision[addr] += commision;\n        }\n        _getAffiliateCommision[_investETH] += commision;\n        _getAffiliateCommision[stor_4_0_19] += commision;\n        _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n        _lastInvest[msg.sender] = block.timestamp;\n    }\n\n    function lastInvest(address addr) public view returns (uint256) {\n        return _lastInvest[addr];\n    }\n\n    function getBonus() public pure returns (uint256) {\n        return 0;\n    }\n\n    function getInvested() public view returns (uint256) {\n        return _getInvested[msg.sender];\n    }\n\n    function getProfit(address addr) public view returns (uint256) {\n        return _getInvested[addr];\n    }\n\n    function investedETH(address addr) public view returns (uint256) {\n        return _getInvested[addr];\n    }\n\n    function reinvestProfit() public {\n        require(_getInvested[msg.sender] > 0);\n        _lastInvest[msg.sender] = block.timestamp;\n        _getInvested[msg.sender] += _lastInvest[msg.sender];\n    }\n\n    function withdrawAffiliateCommision() public {\n        require(_getAffiliateCommision[msg.sender] > 0);\n        _getAffiliateCommision[msg.sender] = 0;\n        (bool success, ) = msg.sender.call.value(_getAffiliateCommision[msg.sender])(\"\");\n        require(success);\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function() external payable {\n        revert();\n    }\n}\n```\nPlease note that the implementation of the `investETH` function in the original contract might be different due to the lack of exact context in the decompiled code. Also, the `getBonus` function always returns `0` because the corresponding function `0x553` in the decompiled code didn't have any logic defined.",
				"role": "assistant"
			}
		}
	],
	"created": 1701464948,
	"id": "chatcmpl-8R52yJAiqz4qH7WAmrL3zOCdP1bgG",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 10:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction withdraw() public nonPayable { \n    v0 = 0x643(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x643(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x16345785d8a0000);\n    v0 = 0x643(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x643(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2); // checks call status, propagates error data on error\n    }\n    v3 = _SafeDiv(20, msg.value);\n    v4 = v5 = msg.sender != varg0;\n    if (msg.sender != varg0) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    assert(v3 + _getAffiliateCommision[_investETH] >= _getAffiliateCommision[_investETH]);\n    _getAffiliateCommision[_investETH] += v3;\n    assert(v3 + _getAffiliateCommision[stor_4_0_19] >= _getAffiliateCommision[stor_4_0_19]);\n    _getAffiliateCommision[stor_4_0_19] += v3;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getBonus() public nonPayable { \n    v0 = 0x553();\n    return v0;\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x643(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x643(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(0 < _getAffiliateCommision[msg.sender]);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction 0x553() private { \n    v0 = v1 = 0;\n    v2 = v3 = _getInvested[msg.sender] >= 0x16345785d8a0000;\n    if (v3) {\n        v2 = v4 = 0x3782dace9d900000 >= _getInvested[msg.sender];\n    }\n    if (!v2) {\n        v5 = v6 = _getInvested[msg.sender] >= 0x37a661c10d510000;\n        if (v6) {\n            v5 = v7 = 0x6124fee993bc0000 >= _getInvested[msg.sender];\n        }\n        if (!v5) {\n            v8 = v9 = _getInvested[msg.sender] >= 0x614885dc037d0000;\n            if (v9) {\n                v8 = v10 = 0x8ac7230489e80000 >= _getInvested[msg.sender];\n            }\n            if (!v8) {\n                v11 = v12 = _getInvested[msg.sender] >= 0x8aeaa9f6f9a90000;\n                if (v12) {\n                    v11 = v13 = 0xd02ab486cedc0000 >= _getInvested[msg.sender];\n                }\n                if (!v11) {\n                    if (_getInvested[msg.sender] >= 0xd04e3b793e9d0000) {\n                        v0 = v14 = 25;\n                    }\n                } else {\n                    v0 = v15 = 15;\n                }\n            } else {\n                v0 = v16 = 10;\n            }\n        } else {\n            v0 = v17 = 5;\n        }\n    } else {\n        v0 = v18 = 0;\n    }\n    return v0;\n}\n\nfunction 0x643(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = v4 = _SafeDiv(0x83d600, v2);\n    v5 = 0x553();\n    if (v5) {\n        v6 = _SafeMul(v5, v4);\n        v7 = _SafeDiv(100, v6);\n        v3 = v7 + v4;\n        assert(v3 >= v4);\n    }\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction divestETH() public nonPayable { \n    v0 = 0x643(msg.sender);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = _SafeDiv(5, _lastInvest[msg.sender]);\n    assert(v1 <= _lastInvest[msg.sender]);\n    assert(v0 + (_lastInvest[msg.sender] - v1) >= _lastInvest[msg.sender] - v1);\n    require(v0 + (_lastInvest[msg.sender] - v1) > 0);\n    _getInvested[msg.sender] = 0;\n    v2 = msg.sender.call().value(v0 + (_lastInvest[msg.sender] - v1)).gas(2300 * !(v0 + (_lastInvest[msg.sender] - v1)));\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1054d657) {\n            divestETH();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0x8bdff161 == function_selector) {\n            getBonus();\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 10:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction withdraw() public nonPayable { \n    v0 = 0x643(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x643(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x16345785d8a0000);\n    v0 = 0x643(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x643(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2); // checks call status, propagates error data on error\n    }\n    v3 = _SafeDiv(20, msg.value);\n    v4 = v5 = msg.sender != varg0;\n    if (msg.sender != varg0) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    assert(v3 + _getAffiliateCommision[_investETH] >= _getAffiliateCommision[_investETH]);\n    _getAffiliateCommision[_investETH] += v3;\n    assert(v3 + _getAffiliateCommision[stor_4_0_19] >= _getAffiliateCommision[stor_4_0_19]);\n    _getAffiliateCommision[stor_4_0_19] += v3;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getBonus() public nonPayable { \n    v0 = 0x553();\n    return v0;\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x643(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x643(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(0 < _getAffiliateCommision[msg.sender]);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction 0x553() private { \n    v0 = v1 = 0;\n    v2 = v3 = _getInvested[msg.sender] >= 0x16345785d8a0000;\n    if (v3) {\n        v2 = v4 = 0x3782dace9d900000 >= _getInvested[msg.sender];\n    }\n    if (!v2) {\n        v5 = v6 = _getInvested[msg.sender] >= 0x37a661c10d510000;\n        if (v6) {\n            v5 = v7 = 0x6124fee993bc0000 >= _getInvested[msg.sender];\n        }\n        if (!v5) {\n            v8 = v9 = _getInvested[msg.sender] >= 0x614885dc037d0000;\n            if (v9) {\n                v8 = v10 = 0x8ac7230489e80000 >= _getInvested[msg.sender];\n            }\n            if (!v8) {\n                v11 = v12 = _getInvested[msg.sender] >= 0x8aeaa9f6f9a90000;\n                if (v12) {\n                    v11 = v13 = 0xd02ab486cedc0000 >= _getInvested[msg.sender];\n                }\n                if (!v11) {\n                    if (_getInvested[msg.sender] >= 0xd04e3b793e9d0000) {\n                        v0 = v14 = 25;\n                    }\n                } else {\n                    v0 = v15 = 15;\n                }\n            } else {\n                v0 = v16 = 10;\n            }\n        } else {\n            v0 = v17 = 5;\n        }\n    } else {\n        v0 = v18 = 0;\n    }\n    return v0;\n}\n\nfunction 0x643(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = v4 = _SafeDiv(0x83d600, v2);\n    v5 = 0x553();\n    if (v5) {\n        v6 = _SafeMul(v5, v4);\n        v7 = _SafeDiv(100, v6);\n        v3 = v7 + v4;\n        assert(v3 >= v4);\n    }\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction divestETH() public nonPayable { \n    v0 = 0x643(msg.sender);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = _SafeDiv(5, _lastInvest[msg.sender]);\n    assert(v1 <= _lastInvest[msg.sender]);\n    assert(v0 + (_lastInvest[msg.sender] - v1) >= _lastInvest[msg.sender] - v1);\n    require(v0 + (_lastInvest[msg.sender] - v1) > 0);\n    _getInvested[msg.sender] = 0;\n    v2 = msg.sender.call().value(v0 + (_lastInvest[msg.sender] - v1)).gas(2300 * !(v0 + (_lastInvest[msg.sender] - v1)));\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1054d657) {\n            divestETH();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0x8bdff161 == function_selector) {\n            getBonus();\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 10:19 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nmapping (uint256 => [uint256]) _getInvested; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _lastInvest; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _getAffiliateCommision; // STORAGE[0x2]\nuint160 _investETH; // STORAGE[0x3] bytes 0 to 19\nuint160 stor_4_0_19; // STORAGE[0x4] bytes 0 to 19\n\n\nfunction withdraw() public nonPayable { \n    v0 = 0x643(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = msg.sender.call().value(v0).gas(2300 * !v0);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction getAffiliateCommision() public nonPayable { \n    return _getAffiliateCommision[msg.sender];\n}\n\nfunction affiliateCommision(address varg0) public nonPayable { \n    return _getAffiliateCommision[varg0];\n}\n\nfunction getProfitFromSender() public nonPayable { \n    v0 = 0x643(msg.sender);\n    return v0;\n}\n\nfunction investETH(address varg0) public payable { \n    require(msg.value >= 0x16345785d8a0000);\n    v0 = 0x643(msg.sender);\n    if (v0 > 0) {\n        v1 = 0x643(msg.sender);\n        _lastInvest[msg.sender] = block.timestamp;\n        v2 = msg.sender.call().value(v1).gas(2300 * !v1);\n        require(v2); // checks call status, propagates error data on error\n    }\n    v3 = _SafeDiv(20, msg.value);\n    v4 = v5 = msg.sender != varg0;\n    if (msg.sender != varg0) {\n        v4 = v6 = 1 != varg0;\n    }\n    if (v4) {\n        v4 = v7 = _investETH != varg0;\n    }\n    if (v4) {\n        v4 = v8 = stor_4_0_19 != varg0;\n    }\n    if (v4) {\n        assert(v3 + _getAffiliateCommision[varg0] >= _getAffiliateCommision[varg0]);\n        _getAffiliateCommision[varg0] += v3;\n    }\n    assert(v3 + _getAffiliateCommision[_investETH] >= _getAffiliateCommision[_investETH]);\n    _getAffiliateCommision[_investETH] += v3;\n    assert(v3 + _getAffiliateCommision[stor_4_0_19] >= _getAffiliateCommision[stor_4_0_19]);\n    _getAffiliateCommision[stor_4_0_19] += v3;\n    assert(msg.value + _getAffiliateCommision[msg.sender] >= _getAffiliateCommision[msg.sender]);\n    _getInvested[msg.sender] = msg.value + _getAffiliateCommision[msg.sender];\n    _lastInvest[msg.sender] = block.timestamp;\n}\n\nfunction lastInvest(address varg0) public nonPayable { \n    return _lastInvest[varg0];\n}\n\nfunction getBonus() public nonPayable { \n    v0 = 0x553();\n    return v0;\n}\n\nfunction getInvested() public nonPayable { \n    return _getInvested[msg.sender];\n}\n\nfunction getProfit(address varg0) public nonPayable { \n    v0 = 0x643(varg0);\n    return v0;\n}\n\nfunction investedETH(address varg0) public nonPayable { \n    return _getInvested[varg0];\n}\n\nfunction reinvestProfit() public nonPayable { \n    v0 = 0x643(msg.sender);\n    require(v0 > 0);\n    _lastInvest[msg.sender] = block.timestamp;\n    assert(v0 + _lastInvest[msg.sender] >= _lastInvest[msg.sender]);\n    _getInvested[msg.sender] = v0 + _lastInvest[msg.sender];\n}\n\nfunction withdrawAffiliateCommision() public nonPayable { \n    require(0 < _getAffiliateCommision[msg.sender]);\n    _getAffiliateCommision[msg.sender] = 0;\n    v0 = msg.sender.call().value(_getAffiliateCommision[msg.sender]).gas(2300 * !_getAffiliateCommision[msg.sender]);\n    require(v0); // checks call status, propagates error data on error\n}\n\nfunction 0x553() private { \n    v0 = v1 = 0;\n    v2 = v3 = _getInvested[msg.sender] >= 0x16345785d8a0000;\n    if (v3) {\n        v2 = v4 = 0x3782dace9d900000 >= _getInvested[msg.sender];\n    }\n    if (!v2) {\n        v5 = v6 = _getInvested[msg.sender] >= 0x37a661c10d510000;\n        if (v6) {\n            v5 = v7 = 0x6124fee993bc0000 >= _getInvested[msg.sender];\n        }\n        if (!v5) {\n            v8 = v9 = _getInvested[msg.sender] >= 0x614885dc037d0000;\n            if (v9) {\n                v8 = v10 = 0x8ac7230489e80000 >= _getInvested[msg.sender];\n            }\n            if (!v8) {\n                v11 = v12 = _getInvested[msg.sender] >= 0x8aeaa9f6f9a90000;\n                if (v12) {\n                    v11 = v13 = 0xd02ab486cedc0000 >= _getInvested[msg.sender];\n                }\n                if (!v11) {\n                    if (_getInvested[msg.sender] >= 0xd04e3b793e9d0000) {\n                        v0 = v14 = 25;\n                    }\n                } else {\n                    v0 = v15 = 15;\n                }\n            } else {\n                v0 = v16 = 10;\n            }\n        } else {\n            v0 = v17 = 5;\n        }\n    } else {\n        v0 = v18 = 0;\n    }\n    return v0;\n}\n\nfunction 0x643(uint256 varg0) private { \n    v0 = address(varg0);\n    assert(_lastInvest[v0] <= block.timestamp);\n    v1 = address(varg0);\n    v2 = _SafeMul(_getInvested[v1], block.timestamp - _lastInvest[v0]);\n    v3 = v4 = _SafeDiv(0x83d600, v2);\n    v5 = 0x553();\n    if (v5) {\n        v6 = _SafeMul(v5, v4);\n        v7 = _SafeDiv(100, v6);\n        v3 = v7 + v4;\n        assert(v3 >= v4);\n    }\n    return v3;\n}\n\nfunction _SafeDiv(uint256 varg0, uint256 varg1) private { \n    assert(varg0);\n    return varg1 / varg0;\n}\n\nfunction _SafeMul(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = varg0 * varg1;\n        assert(varg1);\n        assert(v0 / varg1 == varg0);\n        return v0;\n    } else {\n        return 0;\n    }\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction divestETH() public nonPayable { \n    v0 = 0x643(msg.sender);\n    _lastInvest[msg.sender] = block.timestamp;\n    v1 = _SafeDiv(5, _lastInvest[msg.sender]);\n    assert(v1 <= _lastInvest[msg.sender]);\n    assert(v0 + (_lastInvest[msg.sender] - v1) >= _lastInvest[msg.sender] - v1);\n    require(v0 + (_lastInvest[msg.sender] - v1) > 0);\n    _getInvested[msg.sender] = 0;\n    v2 = msg.sender.call().value(v0 + (_lastInvest[msg.sender] - v1)).gas(2300 * !(v0 + (_lastInvest[msg.sender] - v1)));\n    require(v2); // checks call status, propagates error data on error\n}\n\nfunction getBalance() public nonPayable { \n    return this.balance;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x1054d657) {\n            divestETH();\n        } else if (0x12065fe0 == function_selector) {\n            getBalance();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x43c6e10d == function_selector) {\n            getAffiliateCommision();\n        } else if (0x5c5f0265 == function_selector) {\n            affiliateCommision(address);\n        } else if (0x5f3619b1 == function_selector) {\n            getProfitFromSender();\n        } else if (0x7a99ba4f == function_selector) {\n            investETH(address);\n        } else if (0x7be00510 == function_selector) {\n            lastInvest(address);\n        } else if (0x8bdff161 == function_selector) {\n            getBonus();\n        } else if (0xbefc3e2b == function_selector) {\n            getInvested();\n        } else if (0xc600e1dc == function_selector) {\n            getProfit(address);\n        } else if (0xd86479df == function_selector) {\n            investedETH(address);\n        } else if (0xe3b61135 == function_selector) {\n            reinvestProfit();\n        } else if (0xf09dd7c6 == function_selector) {\n            withdrawAffiliateCommision();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 38.24538540840149,
	"usage": {
		"completion_tokens": 772,
		"prompt_tokens": 2321,
		"total_tokens": 3093
	}
}