{
	"address": "0xf4c27b8b002389864ac214cb13bfeef4cc5c4e8d",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "As a solidity developer, below is the proposed contract code from the decompiled code, note that some functions couldn't be mapped exactly due to incomplete decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract ExampleContract {\n    address public owner;\n    uint256 public FEE_MUL;\n    uint256 public expireDelay;\n    address public feeCollectorAddress;\n    uint256 public makeFee;\n    uint256 public takeFee;\n    address public signerAddress;\n\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public tokens;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function setSigner(address _signer) public onlyOwner {\n        signerAddress = _signer;\n    }\n\n    function setFeeCollector(address _feeCollector) public onlyOwner {\n        feeCollectorAddress = _feeCollector;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n\n    function setExpireDelay(uint256 _expireDelay) public onlyOwner {\n        require(_expireDelay <= 600);\n        expireDelay = _expireDelay;\n    }\n\n    function setMakeFee(uint256 _makeFee) public onlyOwner {\n        require(_makeFee <= 5000);\n        makeFee = _makeFee;\n    }\n\n    function setTakeFee(uint256 _takeFee) public onlyOwner {\n        require(_takeFee <= 5000);\n        takeFee = _takeFee;\n    }\n\n    function depositEther() public payable {\n        require(msg.value + balances[msg.sender] >= balances[msg.sender]);\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawEther(uint256 amount) public {\n        require(amount <= balances[msg.sender]);\n        balances[msg.sender] -= amount;\n        msg.sender.transfer(amount);\n    }\n\n    function depositToken(address token, uint256 amount) public {\n        // assuming a basic ERC20 token\n        ERC20 t = ERC20(token);\n        require(t.transferFrom(msg.sender, address(this), amount));\n        tokens[token][msg.sender] += amount;\n    }\n\n    function withdrawToken(address token, uint256 amount) public {\n        require(amount <= tokens[token][msg.sender]);\n        tokens[token][msg.sender] -= amount;\n        ERC20 t = ERC20(token);\n        require(t.transfer(msg.sender, amount));\n    }\n\n    // ... other functions\n\n}\n\ninterface ERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n```\n\nThis code basically outlines a contract that allows for depositing and withdrawing of Ether and ERC20 tokens, along with some administrative functionality such as setting fees and transfer of ownership. The contract introduces a concept of signer and fee collector. Various constants and mappings are also defined for handling balances, tokens and fees.\n\nPlease note that this is a simplified version of a contract and doesn't include all the logic from the decompiled code. The decompiled code was quite complex and incomplete, hence the exact match can't be provided. Also, the contract may not compile due to missing parts from the decompiled code.\n\nIt's also important to note that the real-world use of this contract could potentially have security vulnerabilities. The contract should be thoroughly tested and audited by a professional before deploying on a live network.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472779,
	"id": "chatcmpl-8MuwFjLrm58SoPIijqfnAHJmBWiYh",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\nconst BUY = 1\nconst SELL = 0\nconst MAX_FEE = 5000\nconst MAX_EXPIRE_DELAY = 600\nconst PRICE_MUL = 10^18\nconst ETH_SIGN_TYPED_DATA_ARGHASH = 0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74\n\ndef storage:\n  stor0 is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  FEE_MUL is uint256 at storage 1\n  expireDelay is uint256 at storage 2\n  feeCollectorAddress is address at storage 3\n  makeFee is uint256 at storage 4\n  takeFee is uint256 at storage 5\n  balances is mapping of uint256 at storage 6\n  tokens is mapping of uint256 at storage 7\n  filled is mapping of uint256 at storage 8\n  stor9 is mapping of uint8 at storage 9\n  signerAddress is address at storage 10\n  coeffs is mapping of struct at storage 11\n  pack is mapping of uint256 at storage 12\n\ndef trades(address _param1, uint256 _param2): # not payable\n  return bool(stor9[_param1][_param2])\n\ndef takeFee(): # not payable\n  return takeFee\n\ndef makeFee(): # not payable\n  return makeFee\n\ndef signer(): # not payable\n  return signerAddress\n\ndef balances(address _param1): # not payable\n  return balances[_param1]\n\ndef FEE_MUL(): # not payable\n  return FEE_MUL\n\ndef tokens(address _param1, address _param2): # not payable\n  return tokens[_param1][_param2]\n\ndef paused(): # not payable\n  return bool(stor0)\n\ndef getPack(uint8 _coeff, uint128 _duration): # not payable\n  return pack[_coeff + (uint128(_duration) << 8)]\n\ndef filled(address _param1, uint256 _param2): # not payable\n  return filled[_param1][_param2]\n\ndef expireDelay(): # not payable\n  return expireDelay\n\ndef owner(): # not payable\n  return owner\n\ndef packs(uint256 _param1): # not payable\n  return pack[_param1]\n\ndef coeffs(address _param1): # not payable\n  return uint8(coeffs[_param1].field_0), uint128(coeffs[_param1].field_8)\n\ndef feeCollector(): # not payable\n  return feeCollectorAddress\n\n#\n#  Regular functions\n#\n\ndef setSigner(address _signer): # not payable\n  require owner == caller\n  signerAddress = _signer\n\ndef unpause(): # not payable\n  require owner == caller\n  require stor0\n  stor0 = 0\n  log Unpause()\n\ndef pause(): # not payable\n  require owner == caller\n  require not stor0\n  stor0 = 1\n  log Pause()\n\ndef setFeeCollector(address _feeCollector): # not payable\n  require owner == caller\n  feeCollectorAddress = _feeCollector\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  if newOwner:\n      owner = newOwner\n\ndef setExpireDelay(uint256 _expireDelay): # not payable\n  require owner == caller\n  require _expireDelay <= 600\n  expireDelay = _expireDelay\n\ndef setMakeFee(uint256 _makeFee): # not payable\n  require owner == caller\n  require _makeFee <= 5000\n  makeFee = _makeFee\n  log NewMakeFee(uint256 makeFee=_makeFee)\n\ndef setTakeFee(uint256 _takeFee): # not payable\n  require owner == caller\n  require _takeFee <= 5000\n  takeFee = _takeFee\n  log NewTakeFee(uint256 takeFee=_takeFee)\n\ndef delPack(uint8 _coeff, uint128 _duration): # not payable\n  require owner == caller\n  pack[_coeff + (uint128(_duration) << 8)] = 0\n\ndef depositEther() payable: \n  require call.value + balances[caller] >= balances[caller]\n  balances[caller] += call.value\n  log DepositEther(\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 total=call.value + balances[caller])\n\ndef addPack(uint8 _coeff, uint128 _duration, uint256 _price): # not payable\n  require owner == caller\n  require _coeff < 100\n  require _duration > 0\n  require _price > 0\n  pack[_coeff + (uint128(_duration) << 8)] = _price\n\ndef _fallback(?) payable: # default function\n  require call.value + balances[caller] >= balances[caller]\n  balances[caller] += call.value\n  log DepositEther(\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 total=call.value + balances[caller])\n\ndef withdrawEther(uint256 amount): # not payable\n  require amount <= balances[caller]\n  balances[caller] -= amount\n  call caller with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log WithdrawEther(\n        address _addr=caller,\n        uint256 _value=amount,\n        uint256 _when=balances[caller])\n\ndef withdrawToken(address token, uint256 amount): # not payable\n  require amount <= tokens[caller][address(token)]\n  tokens[caller][address(token)] -= amount\n  require ext_code.size(token)\n  call token.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  log WithdrawToken(\n        address token=caller,\n        address beneficiary=address(token),\n        uint256 id=amount,\n        uint256 amount=tokens[caller][address(token)])\n\ndef setCoeff(uint8 _coeff, uint128 _expire, uint8 _v, bytes32 _r, bytes32 _s): # not payable\n  signer = erecover(sha3(this.address, caller, _coeff, _expire), _v << 248, _r, _s) # precompiled\n  require erecover.result\n  require address(signer) == signerAddress\n  require _coeff < 100\n  require _expire > block.timestamp\n  require _expire <= block.timestamp + (840 * 24 * 3600)\n  uint8(coeffs[caller].field_0) = _coeff\n  uint128(coeffs[caller].field_8) = _expire\n  log NewFeeCoeff(\n        address user=caller,\n        uint8 coeff=_coeff << 248,\n        uint128 expire=_expire << 128,\n        uint256 price=0)\n\ndef depositToken(address token, uint256 amount): # not payable\n  require ext_code.size(token)\n  call token.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, address(this.address), amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  require amount + tokens[caller][address(token)] >= tokens[caller][address(token)]\n  tokens[caller][address(token)] += amount\n  log DepositToken(\n        address user=caller,\n        address token=address(token),\n        uint256 amount=amount,\n        uint256 total=amount + tokens[caller][address(token)])\n\ndef buyPack(uint8 _coeff, uint128 _duration) payable: \n  require block.timestamp >= uint128(coeffs[caller].field_8)\n  require pack[_coeff + (uint128(_duration) << 8)] > 0\n  require pack[_coeff + (uint128(_duration) << 8)] == call.value\n  uint8(coeffs[caller].field_0) = _coeff\n  uint128(coeffs[caller].field_8) = uint128(block.timestamp + _duration)\n  log NewFeeCoeff(\n        address user=caller,\n        uint8 coeff=_coeff << 248,\n        uint128 expire=block.timestamp + _duration << 128,\n        uint256 price=pack[_coeff + (uint128(_duration) << 8)])\n  require call.value + balances[stor3] >= balances[stor3]\n  balances[stor3] += call.value\n\ndef cancel(uint8 _order, address _token, uint256 _nonce, uint256 _price, uint256 _amount, uint256 _expire, uint256 _v, bytes32 _r, bytes32 _s): # not payable\n  if _order != 1:\n      require not _order\n  if block.timestamp <= _expire + expireDelay:\n      if _v >= 1000:\n          signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(address(this.address), Mask(72, 0, _token), _nonce, _price, _amount, _expire)), _v - 1000 << 248, _r, _s) # precompiled\n      else:\n          if _order != 1:\n              require not _order\n          mem[180 len 0] = None\n          if 1 == _order:\n              mem[180 len 29] = Mask(232, 0, 0, mem[192 len 17])\n              signer = erecover(sha3(0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74, sha3(this.address, mem[180 len 3], _token, _nonce, _price, _amount, _expire)), _v << 248, _r, _s) # precompiled\n          else:\n              mem[180 len 28] = Mask(224, 0, 0, mem[192 len 16])\n              signer = erecover(sha3(0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74, sha3(this.address, mem[180 len 4], _token, _nonce, _price, _amount, _expire)), _v << 248, _r, _s) # precompiled\n      require erecover.result\n      require address(signer) == caller\n      filled[caller][_nonce] = _amount\n      log Cancel(\n            uint8 order=_order << 248,\n            address owner=caller,\n            uint256 nonce=_nonce,\n            address token=address(_token),\n            uint256 price=_price,\n            uint256 amount=_amount)\n\ndef trade(uint256[] _nums, address[] _addrs, bytes32[] _rss): # not payable\n  mem[128 len 32 * _nums.length] = call.data[_nums + 36 len 32 * _nums.length]\n  mem[(32 * _nums.length) + 128] = _addrs.length\n  mem[(32 * _nums.length) + 160 len 32 * _addrs.length] = call.data[_addrs + 36 len 32 * _addrs.length]\n  mem[(32 * _nums.length) + (32 * _addrs.length) + 160] = _rss.length\n  mem[(32 * _nums.length) + (32 * _addrs.length) + 192 len 32 * _rss.length] = call.data[_rss + 36 len 32 * _rss.length]\n  require not stor0\n  require _nums.length == (6 * _addrs.length) - 2\n  require _rss.length == (2 * _addrs.length - 1) + 2\n  require 0 < _nums.length\n  if mem[128] == 1:\n      require 1 < _nums.length\n      require not stor9[caller][mem[160]]\n      stor9[caller][mem[160]] = 1\n      require 3 < _nums.length\n      require block.timestamp <= mem[224]\n      require 0 < _nums.length\n      require 0 < _addrs.length\n      require 1 < _nums.length\n      require 3 < _nums.length\n      _37 = mem[224]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = address(this.address)\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 212] = caller\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 232] = mem[128] << 248\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 233] = address(mem[(32 * _nums.length) + 160])\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 253] = mem[160]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 285] = _37\n      if 0 >= _addrs.length - 1:\n          require 2 < _nums.length\n          require 0 < _rss.length\n          require 1 < _rss.length\n          signer = erecover(sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37), mem[192] << 248, mem[(32 * _nums.length) + (32 * _addrs.length) + 192], mem[(32 * _nums.length) + (32 * _addrs.length) + 224]) # precompiled\n          require erecover.result\n          require address(signer) == signerAddress\n          require 1 < _nums.length\n          require 0 < _nums.length\n          require 0 < _addrs.length\n          require 0 < _addrs.length\n          log Trade(\n                address trader=caller,\n                uint256 nonce=mem[160],\n                uint256 trade=mem[128],\n                address token=mem[(32 * _nums.length) + 172 len 20],\n                uint256 traderFinalTokens=tokens[caller][mem[(32 * _nums.length) + 172 len 20]],\n                uint256 traderFinalEther=balances[caller])\n          stop\n      require 7 < _nums.length\n      require block.timestamp <= mem[352] + expireDelay\n      require 0 < _nums.length\n      require 1 < _addrs.length\n      if mem[128] == 1:\n          _86 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _127 = mem[320]\n          require 7 < _nums.length\n          _138 = mem[352]\n          require 8 < _nums.length\n          _151 = mem[384]\n          require 2 < _rss.length\n          _159 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _167 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _184 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _127, _138))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _127, _138))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_151 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _159\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _167\n              signer = erecover(_184, _151 - 1000 << 248, _159, _167) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_86)\n              require 9 < _nums.length\n              _236 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _184\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _236\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _343 = mem[288]\n              require 6 < _nums.length\n              _352 = mem[320]\n              require 9 < _nums.length\n              _365 = mem[416]\n              _390 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                                      require FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                                      require FEE_MUL * balances[caller] / balances[caller] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[caller]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]:\n                                  if mem[128] != 1:\n                                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                          log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                              _352 - stor[_390],\n                                              tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                          if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _343 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _343:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * mem[416] / mem[416] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[416],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[address(mem[(32 * _nums.length) + 192])]:\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if not mem[416]:\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[address(mem[(32 * _nums.length) + 192])]:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[caller]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require mem[288] * mem[416] / mem[416] == mem[288]\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _365,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require _343 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _343\n              if mem[128] != 1:\n                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      if makeFee:\n              else:\n                  if block.timestamp < uint128(coeffs[caller].field_8):\n                      if takeFee:\n      else:\n          _88 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _129 = mem[320]\n          require 7 < _nums.length\n          _140 = mem[352]\n          require 8 < _nums.length\n          _153 = mem[384]\n          require 2 < _rss.length\n          _161 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _168 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _190 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _129, _140))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _129, _140))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_153 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _161\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _168\n              signer = erecover(_190, _153 - 1000 << 248, _161, _168) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_88)\n              require 9 < _nums.length\n              _240 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _190\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _240\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _345 = mem[288]\n              require 6 < _nums.length\n              _355 = mem[320]\n              require 9 < _nums.length\n              _370 = mem[416]\n              _394 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                                      require FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                                      require FEE_MUL * balances[caller] / balances[caller] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[caller]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]:\n                                  if mem[128] != 1:\n                                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                          log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                              _355 - stor[_394],\n                                              tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                          if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _345 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _345:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * mem[416] / mem[416] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[416],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[address(mem[(32 * _nums.length) + 192])]:\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if not mem[416]:\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[address(mem[(32 * _nums.length) + 192])]:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[caller]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require mem[288] * mem[416] / mem[416] == mem[288]\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _370,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require _345 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _345\n              if mem[128] != 1:\n                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      if makeFee:\n              else:\n                  if block.timestamp < uint128(coeffs[caller].field_8):\n                      if takeFee:\n  else:\n      require 0 < _nums.length\n      require not mem[128]\n      require 1 < _nums.length\n      require not stor9[caller][mem[160]]\n      stor9[caller][mem[160]] = 1\n      require 3 < _nums.length\n      require block.timestamp <= mem[224]\n      require 0 < _nums.length\n      require 0 < _addrs.length\n      require 1 < _nums.length\n      require 3 < _nums.length\n      _45 = mem[224]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = address(this.address)\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 212] = caller\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 232] = mem[128] << 248\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 233] = address(mem[(32 * _nums.length) + 160])\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 253] = mem[160]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 285] = _45\n      if 0 >= _addrs.length - 1:\n          require 2 < _nums.length\n          require 0 < _rss.length\n          require 1 < _rss.length\n          signer = erecover(sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45), mem[192] << 248, mem[(32 * _nums.length) + (32 * _addrs.length) + 192], mem[(32 * _nums.length) + (32 * _addrs.length) + 224]) # precompiled\n          require erecover.result\n          require address(signer) == signerAddress\n          require 1 < _nums.length\n          require 0 < _nums.length\n          require 0 < _addrs.length\n          require 0 < _addrs.length\n          log Trade(\n                address trader=caller,\n                uint256 nonce=mem[160],\n                uint256 trade=mem[128],\n                address token=mem[(32 * _nums.length) + 172 len 20],\n                uint256 traderFinalTokens=tokens[caller][mem[(32 * _nums.length) + 172 len 20]],\n                uint256 traderFinalEther=balances[caller])\n          stop\n      require 7 < _nums.length\n      require block.timestamp <= mem[352] + expireDelay\n      require 0 < _nums.length\n      require 1 < _addrs.length\n      if mem[128] == 1:\n          _108 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _155 = mem[320]\n          require 7 < _nums.length\n          _163 = mem[352]\n          require 8 < _nums.length\n          _169 = mem[384]\n          require 2 < _rss.length\n          _173 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _177 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _208 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _155, _163))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _155, _163))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_169 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _173\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _177\n              signer = erecover(_208, _169 - 1000 << 248, _173, _177) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_108)\n              require 9 < _nums.length\n              _283 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _208\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _283\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _372 = mem[288]\n              require 6 < _nums.length\n              _380 = mem[320]\n              require 9 < _nums.length\n              _397 = mem[416]\n              _416 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                  log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                      _380 - stor[_416],\n                                      tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                  if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      require _372 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _372\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  log NotEnoughTokens(\n                        address owner=caller,\n                        address token=mem[(32 * _nums.length) + 172 len 20],\n                        uint256 shouldHaveAmount=mem[416],\n                        uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                  if tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[416]:\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _397,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  require _372 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _372\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n              else:\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          if makeFee:\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n                          if takeFee:\n      else:\n          _110 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _157 = mem[320]\n          require 7 < _nums.length\n          _165 = mem[352]\n          require 8 < _nums.length\n          _171 = mem[384]\n          require 2 < _rss.length\n          _175 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _178 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _214 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _157, _165))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _157, _165))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_171 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _175\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _178\n              signer = erecover(_214, _171 - 1000 << 248, _175, _178) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_110)\n              require 9 < _nums.length\n              _287 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _214\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _287\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _374 = mem[288]\n              require 6 < _nums.length\n              _383 = mem[320]\n              require 9 < _nums.length\n              _402 = mem[416]\n              _420 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                  log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                      _383 - stor[_420],\n                                      tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                  if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      require _374 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _374\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  log NotEnoughTokens(\n                        address owner=caller,\n                        address token=mem[(32 * _nums.length) + 172 len 20],\n                        uint256 shouldHaveAmount=mem[416],\n                        uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                  if tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[416]:\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _402,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  require _374 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _374\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n              else:\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          if makeFee:\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n                          if takeFee:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\nconst BUY = 1\nconst SELL = 0\nconst MAX_FEE = 5000\nconst MAX_EXPIRE_DELAY = 600\nconst PRICE_MUL = 10^18\nconst ETH_SIGN_TYPED_DATA_ARGHASH = 0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74\n\ndef storage:\n  stor0 is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  FEE_MUL is uint256 at storage 1\n  expireDelay is uint256 at storage 2\n  feeCollectorAddress is address at storage 3\n  makeFee is uint256 at storage 4\n  takeFee is uint256 at storage 5\n  balances is mapping of uint256 at storage 6\n  tokens is mapping of uint256 at storage 7\n  filled is mapping of uint256 at storage 8\n  stor9 is mapping of uint8 at storage 9\n  signerAddress is address at storage 10\n  coeffs is mapping of struct at storage 11\n  pack is mapping of uint256 at storage 12\n\ndef trades(address _param1, uint256 _param2): # not payable\n  return bool(stor9[_param1][_param2])\n\ndef takeFee(): # not payable\n  return takeFee\n\ndef makeFee(): # not payable\n  return makeFee\n\ndef signer(): # not payable\n  return signerAddress\n\ndef balances(address _param1): # not payable\n  return balances[_param1]\n\ndef FEE_MUL(): # not payable\n  return FEE_MUL\n\ndef tokens(address _param1, address _param2): # not payable\n  return tokens[_param1][_param2]\n\ndef paused(): # not payable\n  return bool(stor0)\n\ndef getPack(uint8 _coeff, uint128 _duration): # not payable\n  return pack[_coeff + (uint128(_duration) << 8)]\n\ndef filled(address _param1, uint256 _param2): # not payable\n  return filled[_param1][_param2]\n\ndef expireDelay(): # not payable\n  return expireDelay\n\ndef owner(): # not payable\n  return owner\n\ndef packs(uint256 _param1): # not payable\n  return pack[_param1]\n\ndef coeffs(address _param1): # not payable\n  return uint8(coeffs[_param1].field_0), uint128(coeffs[_param1].field_8)\n\ndef feeCollector(): # not payable\n  return feeCollectorAddress\n\n#\n#  Regular functions\n#\n\ndef setSigner(address _signer): # not payable\n  require owner == caller\n  signerAddress = _signer\n\ndef unpause(): # not payable\n  require owner == caller\n  require stor0\n  stor0 = 0\n  log Unpause()\n\ndef pause(): # not payable\n  require owner == caller\n  require not stor0\n  stor0 = 1\n  log Pause()\n\ndef setFeeCollector(address _feeCollector): # not payable\n  require owner == caller\n  feeCollectorAddress = _feeCollector\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  if newOwner:\n      owner = newOwner\n\ndef setExpireDelay(uint256 _expireDelay): # not payable\n  require owner == caller\n  require _expireDelay <= 600\n  expireDelay = _expireDelay\n\ndef setMakeFee(uint256 _makeFee): # not payable\n  require owner == caller\n  require _makeFee <= 5000\n  makeFee = _makeFee\n  log NewMakeFee(uint256 makeFee=_makeFee)\n\ndef setTakeFee(uint256 _takeFee): # not payable\n  require owner == caller\n  require _takeFee <= 5000\n  takeFee = _takeFee\n  log NewTakeFee(uint256 takeFee=_takeFee)\n\ndef delPack(uint8 _coeff, uint128 _duration): # not payable\n  require owner == caller\n  pack[_coeff + (uint128(_duration) << 8)] = 0\n\ndef depositEther() payable: \n  require call.value + balances[caller] >= balances[caller]\n  balances[caller] += call.value\n  log DepositEther(\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 total=call.value + balances[caller])\n\ndef addPack(uint8 _coeff, uint128 _duration, uint256 _price): # not payable\n  require owner == caller\n  require _coeff < 100\n  require _duration > 0\n  require _price > 0\n  pack[_coeff + (uint128(_duration) << 8)] = _price\n\ndef _fallback(?) payable: # default function\n  require call.value + balances[caller] >= balances[caller]\n  balances[caller] += call.value\n  log DepositEther(\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 total=call.value + balances[caller])\n\ndef withdrawEther(uint256 amount): # not payable\n  require amount <= balances[caller]\n  balances[caller] -= amount\n  call caller with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log WithdrawEther(\n        address _addr=caller,\n        uint256 _value=amount,\n        uint256 _when=balances[caller])\n\ndef withdrawToken(address token, uint256 amount): # not payable\n  require amount <= tokens[caller][address(token)]\n  tokens[caller][address(token)] -= amount\n  require ext_code.size(token)\n  call token.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  log WithdrawToken(\n        address token=caller,\n        address beneficiary=address(token),\n        uint256 id=amount,\n        uint256 amount=tokens[caller][address(token)])\n\ndef setCoeff(uint8 _coeff, uint128 _expire, uint8 _v, bytes32 _r, bytes32 _s): # not payable\n  signer = erecover(sha3(this.address, caller, _coeff, _expire), _v << 248, _r, _s) # precompiled\n  require erecover.result\n  require address(signer) == signerAddress\n  require _coeff < 100\n  require _expire > block.timestamp\n  require _expire <= block.timestamp + (840 * 24 * 3600)\n  uint8(coeffs[caller].field_0) = _coeff\n  uint128(coeffs[caller].field_8) = _expire\n  log NewFeeCoeff(\n        address user=caller,\n        uint8 coeff=_coeff << 248,\n        uint128 expire=_expire << 128,\n        uint256 price=0)\n\ndef depositToken(address token, uint256 amount): # not payable\n  require ext_code.size(token)\n  call token.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, address(this.address), amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  require amount + tokens[caller][address(token)] >= tokens[caller][address(token)]\n  tokens[caller][address(token)] += amount\n  log DepositToken(\n        address user=caller,\n        address token=address(token),\n        uint256 amount=amount,\n        uint256 total=amount + tokens[caller][address(token)])\n\ndef buyPack(uint8 _coeff, uint128 _duration) payable: \n  require block.timestamp >= uint128(coeffs[caller].field_8)\n  require pack[_coeff + (uint128(_duration) << 8)] > 0\n  require pack[_coeff + (uint128(_duration) << 8)] == call.value\n  uint8(coeffs[caller].field_0) = _coeff\n  uint128(coeffs[caller].field_8) = uint128(block.timestamp + _duration)\n  log NewFeeCoeff(\n        address user=caller,\n        uint8 coeff=_coeff << 248,\n        uint128 expire=block.timestamp + _duration << 128,\n        uint256 price=pack[_coeff + (uint128(_duration) << 8)])\n  require call.value + balances[stor3] >= balances[stor3]\n  balances[stor3] += call.value\n\ndef cancel(uint8 _order, address _token, uint256 _nonce, uint256 _price, uint256 _amount, uint256 _expire, uint256 _v, bytes32 _r, bytes32 _s): # not payable\n  if _order != 1:\n      require not _order\n  if block.timestamp <= _expire + expireDelay:\n      if _v >= 1000:\n          signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(address(this.address), Mask(72, 0, _token), _nonce, _price, _amount, _expire)), _v - 1000 << 248, _r, _s) # precompiled\n      else:\n          if _order != 1:\n              require not _order\n          mem[180 len 0] = None\n          if 1 == _order:\n              mem[180 len 29] = Mask(232, 0, 0, mem[192 len 17])\n              signer = erecover(sha3(0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74, sha3(this.address, mem[180 len 3], _token, _nonce, _price, _amount, _expire)), _v << 248, _r, _s) # precompiled\n          else:\n              mem[180 len 28] = Mask(224, 0, 0, mem[192 len 16])\n              signer = erecover(sha3(0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74, sha3(this.address, mem[180 len 4], _token, _nonce, _price, _amount, _expire)), _v << 248, _r, _s) # precompiled\n      require erecover.result\n      require address(signer) == caller\n      filled[caller][_nonce] = _amount\n      log Cancel(\n            uint8 order=_order << 248,\n            address owner=caller,\n            uint256 nonce=_nonce,\n            address token=address(_token),\n            uint256 price=_price,\n            uint256 amount=_amount)\n\ndef trade(uint256[] _nums, address[] _addrs, bytes32[] _rss): # not payable\n  mem[128 len 32 * _nums.length] = call.data[_nums + 36 len 32 * _nums.length]\n  mem[(32 * _nums.length) + 128] = _addrs.length\n  mem[(32 * _nums.length) + 160 len 32 * _addrs.length] = call.data[_addrs + 36 len 32 * _addrs.length]\n  mem[(32 * _nums.length) + (32 * _addrs.length) + 160] = _rss.length\n  mem[(32 * _nums.length) + (32 * _addrs.length) + 192 len 32 * _rss.length] = call.data[_rss + 36 len 32 * _rss.length]\n  require not stor0\n  require _nums.length == (6 * _addrs.length) - 2\n  require _rss.length == (2 * _addrs.length - 1) + 2\n  require 0 < _nums.length\n  if mem[128] == 1:\n      require 1 < _nums.length\n      require not stor9[caller][mem[160]]\n      stor9[caller][mem[160]] = 1\n      require 3 < _nums.length\n      require block.timestamp <= mem[224]\n      require 0 < _nums.length\n      require 0 < _addrs.length\n      require 1 < _nums.length\n      require 3 < _nums.length\n      _37 = mem[224]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = address(this.address)\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 212] = caller\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 232] = mem[128] << 248\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 233] = address(mem[(32 * _nums.length) + 160])\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 253] = mem[160]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 285] = _37\n      if 0 >= _addrs.length - 1:\n          require 2 < _nums.length\n          require 0 < _rss.length\n          require 1 < _rss.length\n          signer = erecover(sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37), mem[192] << 248, mem[(32 * _nums.length) + (32 * _addrs.length) + 192], mem[(32 * _nums.length) + (32 * _addrs.length) + 224]) # precompiled\n          require erecover.result\n          require address(signer) == signerAddress\n          require 1 < _nums.length\n          require 0 < _nums.length\n          require 0 < _addrs.length\n          require 0 < _addrs.length\n          log Trade(\n                address trader=caller,\n                uint256 nonce=mem[160],\n                uint256 trade=mem[128],\n                address token=mem[(32 * _nums.length) + 172 len 20],\n                uint256 traderFinalTokens=tokens[caller][mem[(32 * _nums.length) + 172 len 20]],\n                uint256 traderFinalEther=balances[caller])\n          stop\n      require 7 < _nums.length\n      require block.timestamp <= mem[352] + expireDelay\n      require 0 < _nums.length\n      require 1 < _addrs.length\n      if mem[128] == 1:\n          _86 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _127 = mem[320]\n          require 7 < _nums.length\n          _138 = mem[352]\n          require 8 < _nums.length\n          _151 = mem[384]\n          require 2 < _rss.length\n          _159 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _167 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _184 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _127, _138))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _127, _138))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_151 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _159\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _167\n              signer = erecover(_184, _151 - 1000 << 248, _159, _167) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_86)\n              require 9 < _nums.length\n              _236 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _184\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _236\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _343 = mem[288]\n              require 6 < _nums.length\n              _352 = mem[320]\n              require 9 < _nums.length\n              _365 = mem[416]\n              _390 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                                      require FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                                      require FEE_MUL * balances[caller] / balances[caller] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[caller]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]:\n                                  if mem[128] != 1:\n                                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                          log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                              _352 - stor[_390],\n                                              tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                          if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _343 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _343:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * mem[416] / mem[416] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[416],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[address(mem[(32 * _nums.length) + 192])]:\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if not mem[416]:\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[address(mem[(32 * _nums.length) + 192])]:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[caller]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require mem[288] * mem[416] / mem[416] == mem[288]\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _365,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require _343 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _343\n              if mem[128] != 1:\n                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      if makeFee:\n              else:\n                  if block.timestamp < uint128(coeffs[caller].field_8):\n                      if takeFee:\n      else:\n          _88 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _129 = mem[320]\n          require 7 < _nums.length\n          _140 = mem[352]\n          require 8 < _nums.length\n          _153 = mem[384]\n          require 2 < _rss.length\n          _161 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _168 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _190 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _129, _140))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _129, _140))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_153 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _161\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _168\n              signer = erecover(_190, _153 - 1000 << 248, _161, _168) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_88)\n              require 9 < _nums.length\n              _240 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _190\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _240\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _345 = mem[288]\n              require 6 < _nums.length\n              _355 = mem[320]\n              require 9 < _nums.length\n              _370 = mem[416]\n              _394 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                                      require FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                                      require FEE_MUL * balances[caller] / balances[caller] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[caller]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]:\n                                  if mem[128] != 1:\n                                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                          log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                              _355 - stor[_394],\n                                              tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                          if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _345 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _345:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * mem[416] / mem[416] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[416],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[address(mem[(32 * _nums.length) + 192])]:\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if not mem[416]:\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[address(mem[(32 * _nums.length) + 192])]:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[caller]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require mem[288] * mem[416] / mem[416] == mem[288]\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _370,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require _345 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _345\n              if mem[128] != 1:\n                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      if makeFee:\n              else:\n                  if block.timestamp < uint128(coeffs[caller].field_8):\n                      if takeFee:\n  else:\n      require 0 < _nums.length\n      require not mem[128]\n      require 1 < _nums.length\n      require not stor9[caller][mem[160]]\n      stor9[caller][mem[160]] = 1\n      require 3 < _nums.length\n      require block.timestamp <= mem[224]\n      require 0 < _nums.length\n      require 0 < _addrs.length\n      require 1 < _nums.length\n      require 3 < _nums.length\n      _45 = mem[224]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = address(this.address)\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 212] = caller\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 232] = mem[128] << 248\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 233] = address(mem[(32 * _nums.length) + 160])\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 253] = mem[160]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 285] = _45\n      if 0 >= _addrs.length - 1:\n          require 2 < _nums.length\n          require 0 < _rss.length\n          require 1 < _rss.length\n          signer = erecover(sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45), mem[192] << 248, mem[(32 * _nums.length) + (32 * _addrs.length) + 192], mem[(32 * _nums.length) + (32 * _addrs.length) + 224]) # precompiled\n          require erecover.result\n          require address(signer) == signerAddress\n          require 1 < _nums.length\n          require 0 < _nums.length\n          require 0 < _addrs.length\n          require 0 < _addrs.length\n          log Trade(\n                address trader=caller,\n                uint256 nonce=mem[160],\n                uint256 trade=mem[128],\n                address token=mem[(32 * _nums.length) + 172 len 20],\n                uint256 traderFinalTokens=tokens[caller][mem[(32 * _nums.length) + 172 len 20]],\n                uint256 traderFinalEther=balances[caller])\n          stop\n      require 7 < _nums.length\n      require block.timestamp <= mem[352] + expireDelay\n      require 0 < _nums.length\n      require 1 < _addrs.length\n      if mem[128] == 1:\n          _108 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _155 = mem[320]\n          require 7 < _nums.length\n          _163 = mem[352]\n          require 8 < _nums.length\n          _169 = mem[384]\n          require 2 < _rss.length\n          _173 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _177 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _208 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _155, _163))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _155, _163))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_169 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _173\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _177\n              signer = erecover(_208, _169 - 1000 << 248, _173, _177) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_108)\n              require 9 < _nums.length\n              _283 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _208\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _283\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _372 = mem[288]\n              require 6 < _nums.length\n              _380 = mem[320]\n              require 9 < _nums.length\n              _397 = mem[416]\n              _416 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                  log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                      _380 - stor[_416],\n                                      tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                  if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      require _372 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _372\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  log NotEnoughTokens(\n                        address owner=caller,\n                        address token=mem[(32 * _nums.length) + 172 len 20],\n                        uint256 shouldHaveAmount=mem[416],\n                        uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                  if tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[416]:\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _397,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  require _372 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _372\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n              else:\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          if makeFee:\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n                          if takeFee:\n      else:\n          _110 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _157 = mem[320]\n          require 7 < _nums.length\n          _165 = mem[352]\n          require 8 < _nums.length\n          _171 = mem[384]\n          require 2 < _rss.length\n          _175 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _178 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _214 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _157, _165))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _157, _165))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_171 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _175\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _178\n              signer = erecover(_214, _171 - 1000 << 248, _175, _178) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_110)\n              require 9 < _nums.length\n              _287 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _214\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _287\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _374 = mem[288]\n              require 6 < _nums.length\n              _383 = mem[320]\n              require 9 < _nums.length\n              _402 = mem[416]\n              _420 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                  log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                      _383 - stor[_420],\n                                      tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                  if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      require _374 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _374\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  log NotEnoughTokens(\n                        address owner=caller,\n                        address token=mem[(32 * _nums.length) + 172 len 20],\n                        uint256 shouldHaveAmount=mem[416],\n                        uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                  if tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[416]:\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _402,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  require _374 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _374\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n              else:\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          if makeFee:\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n                          if takeFee:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\nconst BUY = 1\nconst SELL = 0\nconst MAX_FEE = 5000\nconst MAX_EXPIRE_DELAY = 600\nconst PRICE_MUL = 10^18\nconst ETH_SIGN_TYPED_DATA_ARGHASH = 0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74\n\ndef storage:\n  stor0 is uint8 at storage 0 offset 160\n  owner is address at storage 0\n  FEE_MUL is uint256 at storage 1\n  expireDelay is uint256 at storage 2\n  feeCollectorAddress is address at storage 3\n  makeFee is uint256 at storage 4\n  takeFee is uint256 at storage 5\n  balances is mapping of uint256 at storage 6\n  tokens is mapping of uint256 at storage 7\n  filled is mapping of uint256 at storage 8\n  stor9 is mapping of uint8 at storage 9\n  signerAddress is address at storage 10\n  coeffs is mapping of struct at storage 11\n  pack is mapping of uint256 at storage 12\n\ndef trades(address _param1, uint256 _param2): # not payable\n  return bool(stor9[_param1][_param2])\n\ndef takeFee(): # not payable\n  return takeFee\n\ndef makeFee(): # not payable\n  return makeFee\n\ndef signer(): # not payable\n  return signerAddress\n\ndef balances(address _param1): # not payable\n  return balances[_param1]\n\ndef FEE_MUL(): # not payable\n  return FEE_MUL\n\ndef tokens(address _param1, address _param2): # not payable\n  return tokens[_param1][_param2]\n\ndef paused(): # not payable\n  return bool(stor0)\n\ndef getPack(uint8 _coeff, uint128 _duration): # not payable\n  return pack[_coeff + (uint128(_duration) << 8)]\n\ndef filled(address _param1, uint256 _param2): # not payable\n  return filled[_param1][_param2]\n\ndef expireDelay(): # not payable\n  return expireDelay\n\ndef owner(): # not payable\n  return owner\n\ndef packs(uint256 _param1): # not payable\n  return pack[_param1]\n\ndef coeffs(address _param1): # not payable\n  return uint8(coeffs[_param1].field_0), uint128(coeffs[_param1].field_8)\n\ndef feeCollector(): # not payable\n  return feeCollectorAddress\n\n#\n#  Regular functions\n#\n\ndef setSigner(address _signer): # not payable\n  require owner == caller\n  signerAddress = _signer\n\ndef unpause(): # not payable\n  require owner == caller\n  require stor0\n  stor0 = 0\n  log Unpause()\n\ndef pause(): # not payable\n  require owner == caller\n  require not stor0\n  stor0 = 1\n  log Pause()\n\ndef setFeeCollector(address _feeCollector): # not payable\n  require owner == caller\n  feeCollectorAddress = _feeCollector\n\ndef transferOwnership(address newOwner): # not payable\n  require owner == caller\n  if newOwner:\n      owner = newOwner\n\ndef setExpireDelay(uint256 _expireDelay): # not payable\n  require owner == caller\n  require _expireDelay <= 600\n  expireDelay = _expireDelay\n\ndef setMakeFee(uint256 _makeFee): # not payable\n  require owner == caller\n  require _makeFee <= 5000\n  makeFee = _makeFee\n  log NewMakeFee(uint256 makeFee=_makeFee)\n\ndef setTakeFee(uint256 _takeFee): # not payable\n  require owner == caller\n  require _takeFee <= 5000\n  takeFee = _takeFee\n  log NewTakeFee(uint256 takeFee=_takeFee)\n\ndef delPack(uint8 _coeff, uint128 _duration): # not payable\n  require owner == caller\n  pack[_coeff + (uint128(_duration) << 8)] = 0\n\ndef depositEther() payable: \n  require call.value + balances[caller] >= balances[caller]\n  balances[caller] += call.value\n  log DepositEther(\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 total=call.value + balances[caller])\n\ndef addPack(uint8 _coeff, uint128 _duration, uint256 _price): # not payable\n  require owner == caller\n  require _coeff < 100\n  require _duration > 0\n  require _price > 0\n  pack[_coeff + (uint128(_duration) << 8)] = _price\n\ndef _fallback(?) payable: # default function\n  require call.value + balances[caller] >= balances[caller]\n  balances[caller] += call.value\n  log DepositEther(\n        address user=caller,\n        uint256 amount=call.value,\n        uint256 total=call.value + balances[caller])\n\ndef withdrawEther(uint256 amount): # not payable\n  require amount <= balances[caller]\n  balances[caller] -= amount\n  call caller with:\n     value amount wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log WithdrawEther(\n        address _addr=caller,\n        uint256 _value=amount,\n        uint256 _when=balances[caller])\n\ndef withdrawToken(address token, uint256 amount): # not payable\n  require amount <= tokens[caller][address(token)]\n  tokens[caller][address(token)] -= amount\n  require ext_code.size(token)\n  call token.transfer(address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  log WithdrawToken(\n        address token=caller,\n        address beneficiary=address(token),\n        uint256 id=amount,\n        uint256 amount=tokens[caller][address(token)])\n\ndef setCoeff(uint8 _coeff, uint128 _expire, uint8 _v, bytes32 _r, bytes32 _s): # not payable\n  signer = erecover(sha3(this.address, caller, _coeff, _expire), _v << 248, _r, _s) # precompiled\n  require erecover.result\n  require address(signer) == signerAddress\n  require _coeff < 100\n  require _expire > block.timestamp\n  require _expire <= block.timestamp + (840 * 24 * 3600)\n  uint8(coeffs[caller].field_0) = _coeff\n  uint128(coeffs[caller].field_8) = _expire\n  log NewFeeCoeff(\n        address user=caller,\n        uint8 coeff=_coeff << 248,\n        uint128 expire=_expire << 128,\n        uint256 price=0)\n\ndef depositToken(address token, uint256 amount): # not payable\n  require ext_code.size(token)\n  call token.transferFrom(address sender, address recipient, uint256 amount) with:\n       gas gas_remaining - 710 wei\n      args caller, address(this.address), amount\n  require ext_call.success\n  require ext_call.return_data[0]\n  require amount + tokens[caller][address(token)] >= tokens[caller][address(token)]\n  tokens[caller][address(token)] += amount\n  log DepositToken(\n        address user=caller,\n        address token=address(token),\n        uint256 amount=amount,\n        uint256 total=amount + tokens[caller][address(token)])\n\ndef buyPack(uint8 _coeff, uint128 _duration) payable: \n  require block.timestamp >= uint128(coeffs[caller].field_8)\n  require pack[_coeff + (uint128(_duration) << 8)] > 0\n  require pack[_coeff + (uint128(_duration) << 8)] == call.value\n  uint8(coeffs[caller].field_0) = _coeff\n  uint128(coeffs[caller].field_8) = uint128(block.timestamp + _duration)\n  log NewFeeCoeff(\n        address user=caller,\n        uint8 coeff=_coeff << 248,\n        uint128 expire=block.timestamp + _duration << 128,\n        uint256 price=pack[_coeff + (uint128(_duration) << 8)])\n  require call.value + balances[stor3] >= balances[stor3]\n  balances[stor3] += call.value\n\ndef cancel(uint8 _order, address _token, uint256 _nonce, uint256 _price, uint256 _amount, uint256 _expire, uint256 _v, bytes32 _r, bytes32 _s): # not payable\n  if _order != 1:\n      require not _order\n  if block.timestamp <= _expire + expireDelay:\n      if _v >= 1000:\n          signer = erecover(sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(address(this.address), Mask(72, 0, _token), _nonce, _price, _amount, _expire)), _v - 1000 << 248, _r, _s) # precompiled\n      else:\n          if _order != 1:\n              require not _order\n          mem[180 len 0] = None\n          if 1 == _order:\n              mem[180 len 29] = Mask(232, 0, 0, mem[192 len 17])\n              signer = erecover(sha3(0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74, sha3(this.address, mem[180 len 3], _token, _nonce, _price, _amount, _expire)), _v << 248, _r, _s) # precompiled\n          else:\n              mem[180 len 28] = Mask(224, 0, 0, mem[192 len 16])\n              signer = erecover(sha3(0x3da4a05d8449a7bc291302cce8a490cf367b98ec37200076c3f13f1f2308fd74, sha3(this.address, mem[180 len 4], _token, _nonce, _price, _amount, _expire)), _v << 248, _r, _s) # precompiled\n      require erecover.result\n      require address(signer) == caller\n      filled[caller][_nonce] = _amount\n      log Cancel(\n            uint8 order=_order << 248,\n            address owner=caller,\n            uint256 nonce=_nonce,\n            address token=address(_token),\n            uint256 price=_price,\n            uint256 amount=_amount)\n\ndef trade(uint256[] _nums, address[] _addrs, bytes32[] _rss): # not payable\n  mem[128 len 32 * _nums.length] = call.data[_nums + 36 len 32 * _nums.length]\n  mem[(32 * _nums.length) + 128] = _addrs.length\n  mem[(32 * _nums.length) + 160 len 32 * _addrs.length] = call.data[_addrs + 36 len 32 * _addrs.length]\n  mem[(32 * _nums.length) + (32 * _addrs.length) + 160] = _rss.length\n  mem[(32 * _nums.length) + (32 * _addrs.length) + 192 len 32 * _rss.length] = call.data[_rss + 36 len 32 * _rss.length]\n  require not stor0\n  require _nums.length == (6 * _addrs.length) - 2\n  require _rss.length == (2 * _addrs.length - 1) + 2\n  require 0 < _nums.length\n  if mem[128] == 1:\n      require 1 < _nums.length\n      require not stor9[caller][mem[160]]\n      stor9[caller][mem[160]] = 1\n      require 3 < _nums.length\n      require block.timestamp <= mem[224]\n      require 0 < _nums.length\n      require 0 < _addrs.length\n      require 1 < _nums.length\n      require 3 < _nums.length\n      _37 = mem[224]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = address(this.address)\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 212] = caller\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 232] = mem[128] << 248\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 233] = address(mem[(32 * _nums.length) + 160])\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 253] = mem[160]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 285] = _37\n      if 0 >= _addrs.length - 1:\n          require 2 < _nums.length\n          require 0 < _rss.length\n          require 1 < _rss.length\n          signer = erecover(sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37), mem[192] << 248, mem[(32 * _nums.length) + (32 * _addrs.length) + 192], mem[(32 * _nums.length) + (32 * _addrs.length) + 224]) # precompiled\n          require erecover.result\n          require address(signer) == signerAddress\n          require 1 < _nums.length\n          require 0 < _nums.length\n          require 0 < _addrs.length\n          require 0 < _addrs.length\n          log Trade(\n                address trader=caller,\n                uint256 nonce=mem[160],\n                uint256 trade=mem[128],\n                address token=mem[(32 * _nums.length) + 172 len 20],\n                uint256 traderFinalTokens=tokens[caller][mem[(32 * _nums.length) + 172 len 20]],\n                uint256 traderFinalEther=balances[caller])\n          stop\n      require 7 < _nums.length\n      require block.timestamp <= mem[352] + expireDelay\n      require 0 < _nums.length\n      require 1 < _addrs.length\n      if mem[128] == 1:\n          _86 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _127 = mem[320]\n          require 7 < _nums.length\n          _138 = mem[352]\n          require 8 < _nums.length\n          _151 = mem[384]\n          require 2 < _rss.length\n          _159 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _167 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _184 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _127, _138))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _127, _138))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_151 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _159\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _167\n              signer = erecover(_184, _151 - 1000 << 248, _159, _167) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_86)\n              require 9 < _nums.length\n              _236 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _184\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _236\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _343 = mem[288]\n              require 6 < _nums.length\n              _352 = mem[320]\n              require 9 < _nums.length\n              _365 = mem[416]\n              _390 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                                      require FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                                      require FEE_MUL * balances[caller] / balances[caller] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[caller]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]:\n                                  if mem[128] != 1:\n                                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                          log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                              _352 - stor[_390],\n                                              tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                          if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _343 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _343:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * mem[416] / mem[416] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[416],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[address(mem[(32 * _nums.length) + 192])]:\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if not mem[416]:\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[address(mem[(32 * _nums.length) + 192])]:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[caller]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require mem[288] * mem[416] / mem[416] == mem[288]\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _365,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require _343 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _343\n              if mem[128] != 1:\n                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      if makeFee:\n              else:\n                  if block.timestamp < uint128(coeffs[caller].field_8):\n                      if takeFee:\n      else:\n          _88 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _129 = mem[320]\n          require 7 < _nums.length\n          _140 = mem[352]\n          require 8 < _nums.length\n          _153 = mem[384]\n          require 2 < _rss.length\n          _161 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _168 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _190 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _129, _140))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _129, _140))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_153 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _161\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _168\n              signer = erecover(_190, _153 - 1000 << 248, _161, _168) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_88)\n              require 9 < _nums.length\n              _240 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _37)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _190\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _240\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _345 = mem[288]\n              require 6 < _nums.length\n              _355 = mem[320]\n              require 9 < _nums.length\n              _370 = mem[416]\n              _394 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                                      require FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                                      require FEE_MUL * balances[caller] / balances[caller] == FEE_MUL\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if not balances[caller]:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]:\n                                  if mem[128] != 1:\n                                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  else:\n                                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                          mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                          log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                              _355 - stor[_394],\n                                              tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                          if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if _345 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _345:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[address(mem[(32 * _nums.length) + 192])]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[address(mem[(32 * _nums.length) + 192])] / balances[address(mem[(32 * _nums.length) + 192])] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if not balances[caller]:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if FEE_MUL * balances[caller] / balances[caller] == FEE_MUL:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      else:\n                          if mem[288] * mem[416] / mem[416] == mem[288]:\n                              if mem[128] != 1:\n                                  if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              else:\n                                  if block.timestamp >= uint128(coeffs[caller].field_8):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[416],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  if not makeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[address(mem[(32 * _nums.length) + 192])]:\n                          else:\n                              if block.timestamp < uint128(coeffs[caller].field_8):\n                                  if not takeFee:\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if balances[caller]:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if not mem[416]:\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[address(mem[(32 * _nums.length) + 192])]:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          if balances[caller]:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  require mem[288] * mem[416] / mem[416] == mem[288]\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _370,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if not tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              require _345 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _345\n              if mem[128] != 1:\n                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      if makeFee:\n              else:\n                  if block.timestamp < uint128(coeffs[caller].field_8):\n                      if takeFee:\n  else:\n      require 0 < _nums.length\n      require not mem[128]\n      require 1 < _nums.length\n      require not stor9[caller][mem[160]]\n      stor9[caller][mem[160]] = 1\n      require 3 < _nums.length\n      require block.timestamp <= mem[224]\n      require 0 < _nums.length\n      require 0 < _addrs.length\n      require 1 < _nums.length\n      require 3 < _nums.length\n      _45 = mem[224]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = address(this.address)\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 212] = caller\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 232] = mem[128] << 248\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 233] = address(mem[(32 * _nums.length) + 160])\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 253] = mem[160]\n      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 285] = _45\n      if 0 >= _addrs.length - 1:\n          require 2 < _nums.length\n          require 0 < _rss.length\n          require 1 < _rss.length\n          signer = erecover(sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45), mem[192] << 248, mem[(32 * _nums.length) + (32 * _addrs.length) + 192], mem[(32 * _nums.length) + (32 * _addrs.length) + 224]) # precompiled\n          require erecover.result\n          require address(signer) == signerAddress\n          require 1 < _nums.length\n          require 0 < _nums.length\n          require 0 < _addrs.length\n          require 0 < _addrs.length\n          log Trade(\n                address trader=caller,\n                uint256 nonce=mem[160],\n                uint256 trade=mem[128],\n                address token=mem[(32 * _nums.length) + 172 len 20],\n                uint256 traderFinalTokens=tokens[caller][mem[(32 * _nums.length) + 172 len 20]],\n                uint256 traderFinalEther=balances[caller])\n          stop\n      require 7 < _nums.length\n      require block.timestamp <= mem[352] + expireDelay\n      require 0 < _nums.length\n      require 1 < _addrs.length\n      if mem[128] == 1:\n          _108 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _155 = mem[320]\n          require 7 < _nums.length\n          _163 = mem[352]\n          require 8 < _nums.length\n          _169 = mem[384]\n          require 2 < _rss.length\n          _173 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _177 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _208 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _155, _163))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _155, _163))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_169 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _173\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _177\n              signer = erecover(_208, _169 - 1000 << 248, _173, _177) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_108)\n              require 9 < _nums.length\n              _283 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _208\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _283\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _372 = mem[288]\n              require 6 < _nums.length\n              _380 = mem[320]\n              require 9 < _nums.length\n              _397 = mem[416]\n              _416 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                  log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                      _380 - stor[_416],\n                                      tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                  if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      require _372 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _372\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  log NotEnoughTokens(\n                        address owner=caller,\n                        address token=mem[(32 * _nums.length) + 172 len 20],\n                        uint256 shouldHaveAmount=mem[416],\n                        uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                  if tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[416]:\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _397,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  require _372 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _372\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n              else:\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          if makeFee:\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n                          if takeFee:\n      else:\n          _110 = mem[(32 * _nums.length) + 192]\n          require 0 < _addrs.length\n          require 4 < _nums.length\n          require 5 < _nums.length\n          require 6 < _nums.length\n          _157 = mem[320]\n          require 7 < _nums.length\n          _165 = mem[352]\n          require 8 < _nums.length\n          _171 = mem[384]\n          require 2 < _rss.length\n          _175 = mem[(32 * _nums.length) + (32 * _addrs.length) + 256]\n          require 3 < _rss.length\n          _178 = mem[(32 * _nums.length) + (32 * _addrs.length) + 288]\n          if mem[384] >= 1000:\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 329] = mem[352]\n              _214 = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _157, _165))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(Mask(224, 32, '\\x19Ethereum Signed Message:\\n32') >> 32, sha3(this.address, 0, mem[(32 * _nums.length) + 172 len 20], mem[256], mem[288], _157, _165))\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = uint8(_171 - 1000)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _175\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 320] = _178\n              signer = erecover(_214, _171 - 1000 << 248, _175, _178) # precompiled\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 192] = signer\n              require erecover.result\n              require address(signer) == address(_110)\n              require 9 < _nums.length\n              _287 = mem[416]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = sha3(this.address, caller, mem[159 len 1], mem[(32 * _nums.length) + 172 len 20], mem[160], _45)\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = _214\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 288] = _287\n              require 0 < _nums.length\n              require 0 < _addrs.length\n              require 1 < _addrs.length\n              require 4 < _nums.length\n              require 5 < _nums.length\n              _374 = mem[288]\n              require 6 < _nums.length\n              _383 = mem[320]\n              require 9 < _nums.length\n              _402 = mem[416]\n              _420 = sha3(mem[256], sha3(mem[(32 * _nums.length) + 204 len 20], 8))\n              require filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[320]\n              if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= mem[416]:\n                  if mem[128] != 1:\n                      if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                              if mem[128] != 1:\n                                  if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                      if not makeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[address(mem[(32 * _nums.length) + 192])]:\n                              else:\n                                  if block.timestamp < uint128(coeffs[caller].field_8):\n                                      if not takeFee:\n                                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                      require uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0)\n                                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                                  if balances[caller]:\n                              ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      log NotEnoughTokens(\n                            address owner=caller,\n                            address token=mem[(32 * _nums.length) + 172 len 20],\n                            uint256 shouldHaveAmount=mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]],\n                            uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                      if not tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require (mem[320] * mem[288]) - (filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] * mem[288]) / mem[320] - filled[mem[(32 * _nums.length) + 204 len 20]][mem[256]] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n                  log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                      mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                      _383 - stor[_420],\n                                      tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n                  if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                      require _374 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _374\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[128] != 1:\n                  if mem[416] <= tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      if not mem[416]:\n                          if mem[128] != 1:\n                              if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not makeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          else:\n                              if block.timestamp >= uint128(coeffs[caller].field_8):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if not takeFee:\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                              if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                                  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                          revert\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                              if makeFee:\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                              if takeFee:\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  log NotEnoughTokens(\n                        address owner=caller,\n                        address token=mem[(32 * _nums.length) + 172 len 20],\n                        uint256 shouldHaveAmount=mem[416],\n                        uint256 actualAmount=tokens[caller][address(mem[(32 * _nums.length) + 160])])\n                  if tokens[caller][address(mem[(32 * _nums.length) + 160])]:\n                      require mem[288] * tokens[caller][address(mem[(32 * _nums.length) + 160])] / tokens[caller][address(mem[(32 * _nums.length) + 160])] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              if mem[416] <= tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  if mem[416]:\n                      require mem[288] * mem[416] / mem[416] == mem[288]\n                      if mem[128] != 1:\n                          if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                      else:\n                          if block.timestamp < uint128(coeffs[caller].field_8):\n                      ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  if mem[128] != 1:\n                      if block.timestamp >= uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not makeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0) * makeFee / makeFee == uint8(coeffs[address(mem[(32 * _nums.length) + 192])].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  else:\n                      if block.timestamp >= uint128(coeffs[caller].field_8):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if not takeFee:\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                      if uint8(coeffs[caller].field_0) * takeFee / takeFee == uint8(coeffs[caller].field_0):\n                          ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n                  revert\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224] = mem[(32 * _nums.length) + 204 len 20]\n              mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 256] = mem[(32 * _nums.length) + 172 len 20]\n              log NotEnoughTokens(address owner, address token, uint256 shouldHaveAmount, uint256 actualAmount):\n                                  mem[(32 * _nums.length) + (32 * _addrs.length) + (32 * _rss.length) + 224 len 64],\n                                  _402,\n                                  tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])],\n              if tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])]:\n                  require _374 * tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] / tokens[address(mem[(32 * _nums.length) + 192])][address(mem[(32 * _nums.length) + 160])] == _374\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n              else:\n                  if mem[128] != 1:\n                      if block.timestamp < uint128(coeffs[address(mem[(32 * _nums.length) + 192])].field_8):\n                          if makeFee:\n                  else:\n                      if block.timestamp < uint128(coeffs[caller].field_8):\n                          if takeFee:\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\n.",
	"status": "1",
	"time_cost": 64.49103021621704,
	"usage": {
		"completion_tokens": 720,
		"prompt_tokens": 27266,
		"total_tokens": 27986
	}
}