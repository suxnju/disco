{
	"address": "0x9f2cd125603b15037c922f442740b1b9535d484f",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint256[] private _name;\n    uint256[] private _symbol;\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balanceOf;\n    mapping(address => uint256) private _allowance;\n    uint256 private _buyPrice;\n    address private _owner;\n    uint8 private _decimals;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Burn(address indexed from, uint256 value);\n\n    constructor() {\n        // initialize contract with appropriate values\n        _owner = msg.sender;\n        _decimals = 18;\n    }\n\n    function name() public view returns (uint256[] memory) {\n        return _name;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        _allowance[_spender] = _value;\n        return true;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= _allowance[msg.sender]);\n        _allowance[msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(_value <= _balanceOf[msg.sender]);\n        _balanceOf[msg.sender] -= _value;\n        _totalSupply -= _value;\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    function selfdestructs() public {\n        require(msg.sender == _owner);\n        selfdestruct(payable(_owner));\n    }\n\n    function balanceOf(address _account) public view returns (uint256) {\n        return _balanceOf[_account];\n    }\n\n    function burnFrom(address _account, uint256 _value) public returns (bool success) {\n        require(_value <= _balanceOf[_account]);\n        require(_value <= _allowance[msg.sender]);\n        _balanceOf[_account] -= _value;\n        _allowance[msg.sender] -= _value;\n        _totalSupply -= _value;\n        emit Burn(_account, _value);\n        return true;\n    }\n\n    function buyPrice() public view returns (uint256) {\n        return _buyPrice;\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function symbol() public view returns (uint256[] memory) {\n        return _symbol;\n    }\n\n    function setPrices(uint256 _newBuyPrice) public {\n        require(msg.sender == _owner);\n        _buyPrice = _newBuyPrice;\n    }\n\n    function buy() public payable {\n        uint256 amount = msg.value / _buyPrice;\n        _transfer(_owner, msg.sender, amount);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function allowance(address _spender, address _owner) public view returns (uint256 remaining) {\n        return _allowance[_owner];\n    }\n\n    function transferOwnership(address _newOwner) public {\n        require(msg.sender == _owner);\n        _owner = _newOwner;\n    }\n\n    function _transfer(address _from, address _to, uint256 _value) private {\n        require(_to != address(0));\n        require(_value <= _balanceOf[_from]);\n        require(_balanceOf[_to] + _value > _balanceOf[_to]);\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n    }\n\n    fallback() external payable {\n        uint256 amount = msg.value / _buyPrice;\n        _transfer(_owner, msg.sender, amount);\n    }\n\n    receive() external payable { }\n}\n```\n\nThis contract seems to be a basic ERC20 token contract with some additional functionalities like token burn and buy. The contract owner can set the token price and users can buy tokens by sending Ether to the contract.\n\nPlease note that the code above is a simplified interpretation of the decompiled EVM bytecode. The original contract might have included more advanced security measures, additional functionalities, or specific business logic.",
				"role": "assistant"
			}
		}
	],
	"created": 1701469094,
	"id": "chatcmpl-8R67qXEDvJV084KUe45cJkrF0HfiJ",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 11:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _buyPrice; // STORAGE[0x8]\naddress _selfdestructs; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x43d(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction selfdestructs() public payable { \n    require(msg.sender == _selfdestructs);\n    selfdestruct(_selfdestructs);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[varg0]);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _selfdestructs;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setPrices(uint256 varg0) public nonPayable { \n    require(msg.sender == _selfdestructs);\n    _buyPrice = varg0;\n}\n\nfunction buy() public payable { \n    assert(_buyPrice);\n    0x43d(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x43d(varg1, varg0, msg.sender);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = v3 = 0;\n    _allowance[varg0] = varg1;\n    if (1) {\n        v4 = new array[](v0.length);\n        v5 = v6 = 0;\n        while (v5 < v0.length) {\n            MEM[v5 + v4.data] = MEM[v5 + v0.data];\n            v5 += 32;\n        }\n        v7 = v8 = v0.length + v4.data;\n        if (0x1f & v0.length) {\n            MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v9 = varg0.receiveApproval(msg.sender, varg1, this, v4).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _selfdestructs);\n    _selfdestructs = varg0;\n}\n\nfunction 0x43d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] - varg0;\n    v3 = address(varg1);\n    _balanceOf[v3] += varg0;\n    emit Transfer(v2, v3, varg0);\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = _selfdestructs.call().value(msg.value).gas(2300 * !msg.value);\n    0x43d(_buyPrice * msg.value, msg.sender, _selfdestructs);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x4ed0efd1 == function_selector) {\n            selfdestructs();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa3201daa == function_selector) {\n            setPrices(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 11:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _buyPrice; // STORAGE[0x8]\naddress _selfdestructs; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x43d(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction selfdestructs() public payable { \n    require(msg.sender == _selfdestructs);\n    selfdestruct(_selfdestructs);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[varg0]);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _selfdestructs;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setPrices(uint256 varg0) public nonPayable { \n    require(msg.sender == _selfdestructs);\n    _buyPrice = varg0;\n}\n\nfunction buy() public payable { \n    assert(_buyPrice);\n    0x43d(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x43d(varg1, varg0, msg.sender);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = v3 = 0;\n    _allowance[varg0] = varg1;\n    if (1) {\n        v4 = new array[](v0.length);\n        v5 = v6 = 0;\n        while (v5 < v0.length) {\n            MEM[v5 + v4.data] = MEM[v5 + v0.data];\n            v5 += 32;\n        }\n        v7 = v8 = v0.length + v4.data;\n        if (0x1f & v0.length) {\n            MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v9 = varg0.receiveApproval(msg.sender, varg1, this, v4).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _selfdestructs);\n    _selfdestructs = varg0;\n}\n\nfunction 0x43d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] - varg0;\n    v3 = address(varg1);\n    _balanceOf[v3] += varg0;\n    emit Transfer(v2, v3, varg0);\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = _selfdestructs.call().value(msg.value).gas(2300 * !msg.value);\n    0x43d(_buyPrice * msg.value, msg.sender, _selfdestructs);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x4ed0efd1 == function_selector) {\n            selfdestructs();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa3201daa == function_selector) {\n            setPrices(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 11:50 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _totalSupply; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _allowance; // STORAGE[0x6]\nuint256 _buyPrice; // STORAGE[0x8]\naddress _selfdestructs; // STORAGE[0x0] bytes 0 to 19\nuint8 _decimals; // STORAGE[0x3] bytes 0 to 0\n\n// Events\nTransfer(address, address, uint256);\nBurn(address, uint256);\n\nfunction name() public nonPayable { \n    v0 = new bytes[]((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n        if (31 < (_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_name.length & ~0 + (!(0x1 & _name.length) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction approve(address varg0, uint256 varg1) public nonPayable { \n    _allowance[varg0] = varg1;\n    return 1;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public nonPayable { \n    require(varg2 <= _allowance[msg.sender]);\n    _allowance[msg.sender] = _allowance[msg.sender] - varg2;\n    0x43d(varg2, varg1, varg0);\n    return 1;\n}\n\nfunction decimals() public nonPayable { \n    return _decimals;\n}\n\nfunction burn(uint256 varg0) public nonPayable { \n    require(varg0 <= _balanceOf[msg.sender]);\n    _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg0;\n    _totalSupply = _totalSupply - varg0;\n    emit Burn(msg.sender, varg0);\n    return 1;\n}\n\nfunction selfdestructs() public payable { \n    require(msg.sender == _selfdestructs);\n    selfdestruct(_selfdestructs);\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _balanceOf[varg0];\n}\n\nfunction burnFrom(address varg0, uint256 varg1) public nonPayable { \n    require(varg1 <= _balanceOf[varg0]);\n    require(varg1 <= _allowance[msg.sender]);\n    _balanceOf[varg0] = _balanceOf[varg0] - varg1;\n    _allowance[msg.sender] = _allowance[msg.sender] - varg1;\n    _totalSupply = _totalSupply - varg1;\n    emit Burn(varg0, varg1);\n    return 1;\n}\n\nfunction buyPrice() public nonPayable { \n    return _buyPrice;\n}\n\nfunction owner() public nonPayable { \n    return _selfdestructs;\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[]((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1);\n    v1 = v2 = v0.data;\n    if ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n        if (31 < (_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + ((_symbol.length & ~0 + (!(_symbol.length & 0x1) << 8)) >> 1) <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v5 + v4.data] = MEM[v5 + v0.data];\n        v5 += 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction setPrices(uint256 varg0) public nonPayable { \n    require(msg.sender == _selfdestructs);\n    _buyPrice = varg0;\n}\n\nfunction buy() public payable { \n    assert(_buyPrice);\n    0x43d(msg.value / _buyPrice, msg.sender, this);\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    0x43d(varg1, varg0, msg.sender);\n}\n\nfunction approveAndCall(address varg0, uint256 varg1, bytes varg2) public nonPayable { \n    v0 = new bytes[](varg2.length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg2, varg2.length);\n    v2 = v3 = 0;\n    _allowance[varg0] = varg1;\n    if (1) {\n        v4 = new array[](v0.length);\n        v5 = v6 = 0;\n        while (v5 < v0.length) {\n            MEM[v5 + v4.data] = MEM[v5 + v0.data];\n            v5 += 32;\n        }\n        v7 = v8 = v0.length + v4.data;\n        if (0x1f & v0.length) {\n            MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n        }\n        require(varg0.code.size);\n        v9 = varg0.receiveApproval(msg.sender, varg1, this, v4).gas(msg.gas);\n        require(v9); // checks call status, propagates error data on error\n        v2 = 1;\n    }\n    return v2;\n}\n\nfunction allowance(address varg0, address varg1) public nonPayable { \n    return _allowance[varg1];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _selfdestructs);\n    _selfdestructs = varg0;\n}\n\nfunction 0x43d(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(address(varg1));\n    v0 = address(varg2);\n    require(varg0 <= _balanceOf[v0]);\n    v1 = address(varg1);\n    require(_balanceOf[v1] + varg0 > _balanceOf[v1]);\n    v2 = address(varg2);\n    _balanceOf[v2] = _balanceOf[v2] - varg0;\n    v3 = address(varg1);\n    _balanceOf[v3] += varg0;\n    emit Transfer(v2, v3, varg0);\n    return ;\n}\n\nfunction fallback() public payable { \n    v0 = _selfdestructs.call().value(msg.value).gas(2300 * !msg.value);\n    0x43d(_buyPrice * msg.value, msg.sender, _selfdestructs);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x6fdde03) {\n            name();\n        } else if (0x95ea7b3 == function_selector) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector) {\n            transferFrom(address,address,uint256);\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x42966c68 == function_selector) {\n            burn(uint256);\n        } else if (0x4ed0efd1 == function_selector) {\n            selfdestructs();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x79cc6790 == function_selector) {\n            burnFrom(address,uint256);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa3201daa == function_selector) {\n            setPrices(uint256);\n        } else if (0xa6f2ae3a == function_selector) {\n            buy();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xcae9ca51 == function_selector) {\n            approveAndCall(address,uint256,bytes);\n        } else if (0xdd62ed3e == function_selector) {\n            allowance(address,address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 51.56650400161743,
	"usage": {
		"completion_tokens": 945,
		"prompt_tokens": 2471,
		"total_tokens": 3416
	}
}