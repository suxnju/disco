{
	"address": "0x5535a72556727c221c567e0fc4208c5a99dba1cc",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code based on the provided decompiled EVM Bytecode:\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyContract {\n    uint8 public currentState;\n    uint256 public contributorCount;\n    address payable public owner;\n    mapping(address => uint256) stor3;\n    mapping(uint256 => address) stor4;\n\n    event LogStateChange(uint8 currentState, address indexed caller, address indexed contractAddress);\n    event LogTransfer(uint256 amount, address indexed to, address indexed from);\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only owner can call this function.\");\n        _;\n    }\n\n    constructor() {\n        owner = payable(msg.sender);\n        currentState = 1;\n    }\n\n    function setIdle() public onlyOwner {\n        require(currentState <= 3 && currentState == 0, \"Invalid state.\");\n        currentState = 1;\n        emit LogStateChange(currentState, msg.sender, address(this));\n    }\n\n    function setFailed() public onlyOwner {\n        require(currentState <= 3 && currentState == 1, \"Invalid state.\");\n        currentState = 3;\n        emit LogStateChange(currentState, msg.sender, address(this));\n    }\n\n    function setActive() public onlyOwner {\n        require(currentState <= 3 && currentState == 1, \"Invalid state.\");\n        currentState = 0;\n        emit LogStateChange(currentState, msg.sender, address(this));\n    }\n\n    function setSuccessful() public onlyOwner {\n        require(currentState <= 3 && currentState == 1, \"Invalid state.\");\n        currentState = 2;\n        emit LogStateChange(currentState, msg.sender, address(this));\n    }\n\n    function getContribution(uint256 contractIndex) public view returns (address, uint256) {\n        require(contractIndex < contributorCount, \"Invalid index.\");\n        return (stor4[contractIndex], stor3[stor4[contractIndex]]);\n    }\n\n    function payout() public onlyOwner {\n        require(currentState <= 3 && currentState == 2, \"Invalid state.\");\n        uint256 balance = address(this).balance;\n        owner.transfer(balance);\n        emit LogTransfer(balance, owner, address(this));\n    }\n\n    function refund() public {\n        require(currentState <= 3 && currentState == 3 && stor3[msg.sender] > 0, \"Invalid state or no contribution.\");\n        uint256 refundAmount = stor3[msg.sender];\n        stor3[msg.sender] = 0;\n        payable(msg.sender).transfer(refundAmount);\n        emit LogTransfer(refundAmount, msg.sender, address(this));\n    }\n\n    fallback() external payable {\n        require(currentState <= 3 && currentState == 0 && msg.value > 0, \"Invalid state or no value sent.\");\n        if (stor3[msg.sender] == 0) {\n            stor4[contributorCount] = msg.sender;\n            contributorCount++;\n        }\n        stor3[msg.sender] += msg.value;\n        emit LogTransfer(msg.value, msg.sender, address(this));\n    }\n}\n```\nPlease note that while I've done my best to create an exact replica of the decompiled code, there might be some slight differences due to the fact that EVM Bytecode does not always have a one-to-one mapping with Solidity code.",
				"role": "assistant"
			}
		}
	],
	"created": 1700472205,
	"id": "chatcmpl-8MumzLosycdfaaBaDGbdCJcW9lqMY",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  currentState is uint8 at storage 0\n  contributorCount is uint256 at storage 1\n  owner is address at storage 2\n  stor3 is mapping of address at storage 3\n  stor4 is mapping of uint256 at storage 4\n\ndef currentState(): # not payable\n  require currentState <= 3\n  return currentState\n\ndef owner(): # not payable\n  return owner\n\ndef contributorCount(): # not payable\n  return contributorCount\n\n#\n#  Regular functions\n#\n\ndef setIdle(): # not payable\n  require currentState <= 3\n  require not currentState\n  require caller == owner\n  currentState = 1\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setFailed(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 3\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setActive(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 0\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setSuccessful(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 2\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef getContribution(uint256 contractIndex): # not payable\n  require contractIndex >= 0\n  require contractIndex < contributorCount\n  return stor3[contractIndex], stor4[stor3[contractIndex]]\n\ndef payout(): # not payable\n  require currentState <= 3\n  require 2 == currentState\n  require caller == owner\n  call owner with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xd1ba4ac2: eth.balance(this.address), this.address, owner\n\ndef refund(): # not payable\n  require currentState <= 3\n  require 3 == currentState\n  require stor4[caller] > 0\n  require stor4[caller] <= eth.balance(this.address)\n  stor4[caller] = 0\n  call caller with:\n     value stor4[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xd1ba4ac2: stor4[caller], this.address, caller\n\ndef _fallback() payable: # default function\n  require currentState <= 3\n  require not currentState\n  require call.value > 0\n  if not stor4[caller]:\n      stor3[stor1] = caller\n      require contributorCount + 1 >= contributorCount\n      require contributorCount + 1 >= 1\n      contributorCount++\n  require stor4[caller] + call.value >= stor4[caller]\n  require stor4[caller] + call.value >= call.value\n  stor4[caller] += call.value\n  log 0xd1ba4ac2: call.value, caller, this.address\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  currentState is uint8 at storage 0\n  contributorCount is uint256 at storage 1\n  owner is address at storage 2\n  stor3 is mapping of address at storage 3\n  stor4 is mapping of uint256 at storage 4\n\ndef currentState(): # not payable\n  require currentState <= 3\n  return currentState\n\ndef owner(): # not payable\n  return owner\n\ndef contributorCount(): # not payable\n  return contributorCount\n\n#\n#  Regular functions\n#\n\ndef setIdle(): # not payable\n  require currentState <= 3\n  require not currentState\n  require caller == owner\n  currentState = 1\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setFailed(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 3\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setActive(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 0\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setSuccessful(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 2\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef getContribution(uint256 contractIndex): # not payable\n  require contractIndex >= 0\n  require contractIndex < contributorCount\n  return stor3[contractIndex], stor4[stor3[contractIndex]]\n\ndef payout(): # not payable\n  require currentState <= 3\n  require 2 == currentState\n  require caller == owner\n  call owner with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xd1ba4ac2: eth.balance(this.address), this.address, owner\n\ndef refund(): # not payable\n  require currentState <= 3\n  require 3 == currentState\n  require stor4[caller] > 0\n  require stor4[caller] <= eth.balance(this.address)\n  stor4[caller] = 0\n  call caller with:\n     value stor4[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xd1ba4ac2: stor4[caller], this.address, caller\n\ndef _fallback() payable: # default function\n  require currentState <= 3\n  require not currentState\n  require call.value > 0\n  if not stor4[caller]:\n      stor3[stor1] = caller\n      require contributorCount + 1 >= contributorCount\n      require contributorCount + 1 >= 1\n      contributorCount++\n  require stor4[caller] + call.value >= stor4[caller]\n  require stor4[caller] + call.value >= call.value\n  stor4[caller] += call.value\n  log 0xd1ba4ac2: call.value, caller, this.address\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  currentState is uint8 at storage 0\n  contributorCount is uint256 at storage 1\n  owner is address at storage 2\n  stor3 is mapping of address at storage 3\n  stor4 is mapping of uint256 at storage 4\n\ndef currentState(): # not payable\n  require currentState <= 3\n  return currentState\n\ndef owner(): # not payable\n  return owner\n\ndef contributorCount(): # not payable\n  return contributorCount\n\n#\n#  Regular functions\n#\n\ndef setIdle(): # not payable\n  require currentState <= 3\n  require not currentState\n  require caller == owner\n  currentState = 1\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setFailed(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 3\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setActive(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 0\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef setSuccessful(): # not payable\n  require currentState <= 3\n  require 1 == currentState\n  require caller == owner\n  currentState = 2\n  require currentState <= 3\n  log 0xe9ed7c87: currentState, currentState, caller, this.address\n\ndef getContribution(uint256 contractIndex): # not payable\n  require contractIndex >= 0\n  require contractIndex < contributorCount\n  return stor3[contractIndex], stor4[stor3[contractIndex]]\n\ndef payout(): # not payable\n  require currentState <= 3\n  require 2 == currentState\n  require caller == owner\n  call owner with:\n     value eth.balance(this.address) wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xd1ba4ac2: eth.balance(this.address), this.address, owner\n\ndef refund(): # not payable\n  require currentState <= 3\n  require 3 == currentState\n  require stor4[caller] > 0\n  require stor4[caller] <= eth.balance(this.address)\n  stor4[caller] = 0\n  call caller with:\n     value stor4[caller] wei\n       gas 2300 * is_zero(value) wei\n  require ext_call.success\n  log 0xd1ba4ac2: stor4[caller], this.address, caller\n\ndef _fallback() payable: # default function\n  require currentState <= 3\n  require not currentState\n  require call.value > 0\n  if not stor4[caller]:\n      stor3[stor1] = caller\n      require contributorCount + 1 >= contributorCount\n      require contributorCount + 1 >= 1\n      contributorCount++\n  require stor4[caller] + call.value >= stor4[caller]\n  require stor4[caller] + call.value >= call.value\n  stor4[caller] += call.value\n  log 0xd1ba4ac2: call.value, caller, this.address\n\n.",
	"status": "1",
	"time_cost": 48.06621861457825,
	"usage": {
		"completion_tokens": 678,
		"prompt_tokens": 778,
		"total_tokens": 1456
	}
}