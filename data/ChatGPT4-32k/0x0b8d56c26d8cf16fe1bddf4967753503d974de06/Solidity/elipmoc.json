{
	"address": "0x0b8d56c26d8cf16fe1bddf4967753503d974de06",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Please find below the Solidity code recreated from the decompiled code:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract Contract {\n    uint256 _totalSupply;\n    mapping (address => uint256) _balanceOf;\n    uint256 _price;\n    uint256 _remaining;\n    \n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Buyin(address indexed _buyer, uint256 _price, uint256 _amount);\n    event NewTranch(uint256 _price);\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _owner, uint256 _price, uint256 _amount);\n\n    function totalSupply() public view returns (uint256) { \n        return _totalSupply;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { \n        require(_balanceOf[_from] >= _value && _balanceOf[msg.sender] >= _value);\n        _balanceOf[_from] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function buyin(uint256 _amount) public payable returns (bool success) {\n        require(msg.value >= _price * _amount);\n        _balanceOf[msg.sender] += _amount;\n        _totalSupply += _amount;\n        _remaining -= _amount;\n        emit Buyin(msg.sender, _price, _amount);\n        if (_remaining == 0) {\n            _price += 0x38d7ea4c68000;\n            _remaining = 0x5f5e100;\n            emit NewTranch(_price);\n        }\n        return true;\n    }\n    \n    function remaining() public view returns (uint256) { \n        return _remaining;\n    }\n    \n    function refund(uint256 _amount) public returns (bool success) { \n        require(_balanceOf[msg.sender] >= _amount);\n        _balanceOf[msg.sender] -= _amount;\n        _totalSupply -= _amount;\n        msg.sender.transfer(_amount * _price);\n        emit Refund(msg.sender, _price, _amount);\n        return true;\n    }\n    \n    function balanceOf(address _owner) public view returns (uint256 balance) { \n        return _balanceOf[_owner];\n    }\n    \n    function price() public view returns (uint256) { \n        return _price;\n    }\n    \n    function transfer(address _to, uint256 _value) public returns (bool success) { \n        require(_balanceOf[msg.sender] >= _value);\n        _balanceOf[msg.sender] -= _value;\n        _balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) public returns (bool success) { \n        _balanceOf[_spender] += _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return _balanceOf[_spender];\n    }\n}\n```\n\nThis is a simplified and improved version of the original decompiled code. The contract is about a simple ERC20-style token with some additional features like buying in and refunding tokens. Please double-check for any potential security issues before deploying it.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039891,
	"id": "chatcmpl-8Ci27GXGnoTq1Vn5QsmbTjWhXfhal",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.15 05:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nuint256 _price; // STORAGE[0x2]\nuint256 _remaining; // STORAGE[0x3]\n\n// Events\nApproval(address, address, uint256);\nBuyin(address, uint256, uint256);\nNewTranch(uint256);\nTransfer(address, address, uint256);\nRefund(address, uint256, uint256);\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    v0 = v1 = 0;\n    if (_balanceOf[varg0] >= varg2) {\n        if (_balanceOf[msg.sender] >= varg2) {\n            emit Transfer(varg0, varg1, varg2);\n            v0 = v2 = 1;\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n            _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n            _balanceOf[varg1] += varg2;\n        }\n    }\n    return v0;\n}\n\nfunction buyin(address varg0, uint256 varg1) public payable { \n    v0 = v1 = msg.value;\n    while (1) {\n        v2 = v3 = v0 > 0;\n        if (v0 <= 0) {\n            goto 0xa80x8fB0x195;\n        }\n        v2 = v4 = _price <= varg1;\n        if (!v2) {\n            exit;\n        } else {\n            v0 = v5 = _price * _remaining / 0xf4240;\n            if (v0 <= v5) {\n            }\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v0 * 0xf4240 / _price;\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v0 * 0xf4240 / _price;\n            _balanceOf[msg.sender][1] = block.timestamp + 0x93a80 | ~0xffffffff & _balanceOf[msg.sender][0x1];\n            _totalSupply = _totalSupply + v0 * 0xf4240 / _price;\n            emit Buyin(msg.sender, _price, v0 * 0xf4240 / _price);\n            _remaining = _remaining - v0 * 0xf4240 / _price;\n            v0 = v0 - v0;\n            if (0 == _remaining - v0 * 0xf4240 / _price) {\n                _price += 0x38d7ea4c68000;\n                _remaining = 0x5f5e100;\n                emit NewTranch(0x38d7ea4c68000 + _price);\n            }\n            continue;\n        }\n    }\n}\n\nfunction remaining() public payable { \n    return _remaining;\n}\n\nfunction refund(uint256 varg0, uint256 varg1) public payable { \n    v0 = v1 = 0;\n    v2 = v3 = _balanceOf[msg.sender] < varg1;\n    if (_balanceOf[msg.sender] >= varg1) {\n        v2 = v4 = block.timestamp < uint32(_balanceOf[address(msg.sender)][1]);\n    }\n    if (!v2) {\n        if (_balanceOf[msg.sender] >= varg1) {\n            emit Refund(msg.sender, varg0, varg1);\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n            _totalSupply += varg1;\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n            if (_balanceOf[msg.sender] - varg1 == 0) {\n                _balanceOf[msg.sender][0] = 0;\n                _balanceOf[msg.sender][1] = ~0xffffffff & _balanceOf[msg.sender][0x1];\n            }\n            v5 = msg.sender.call().value(varg1 * varg0 / 0xf4240);\n            assert(v5);\n            v0 = v6 = 1;\n        }\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public payable { \n    return _balanceOf[varg0];\n}\n\nfunction price() public payable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    if (_balanceOf[msg.sender] >= varg1) {\n        emit Transfer(msg.sender, varg0, varg1);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        goto 0x2fe0x289;\n    }\n    return 0;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    return _balanceOf[varg1];\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    emit Approval(msg.sender, varg0, varg1);\n    _balanceOf[varg0] += varg1;\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x95ea7b3) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x29cbdc86 == function_selector >> 224) {\n            buyin(address,uint256);\n        } else if (0x55234ec0 == function_selector >> 224) {\n            remaining();\n        } else if (0x5af36e3e == function_selector >> 224) {\n            refund(uint256,uint256);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0xa035b1fe == function_selector >> 224) {\n            price();\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        }\n    }\n    v0 = msg.sender;\n    v1 = msg.value;\n    while (1) {\n        v2 = v3 = v1 > 0;\n        if (v1 <= 0) {\n            goto 0xa80x0;\n        }\n        v2 = _price <= 0x8000000000000000000000000000000000000000000000000000000000000000;\n        if (!v2) {\n            exit;\n        } else {\n            v1 = v4 = _price * _remaining / 0xf4240;\n            if (v1 <= v4) {\n            }\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v1 * 0xf4240 / _price;\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v1 * 0xf4240 / _price;\n            _balanceOf[msg.sender][1] = block.timestamp + 0x93a80 | ~0xffffffff & _balanceOf[msg.sender][0x1];\n            _totalSupply = _totalSupply + v1 * 0xf4240 / _price;\n            emit Buyin(msg.sender, _price, v1 * 0xf4240 / _price);\n            _remaining = _remaining - v1 * 0xf4240 / _price;\n            v1 = v1 - v1;\n            if (0 == _remaining - v1 * 0xf4240 / _price) {\n                _price += 0x38d7ea4c68000;\n                _remaining = 0x5f5e100;\n                emit NewTranch(0x38d7ea4c68000 + _price);\n            }\n            continue;\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 05:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nuint256 _price; // STORAGE[0x2]\nuint256 _remaining; // STORAGE[0x3]\n\n// Events\nApproval(address, address, uint256);\nBuyin(address, uint256, uint256);\nNewTranch(uint256);\nTransfer(address, address, uint256);\nRefund(address, uint256, uint256);\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    v0 = v1 = 0;\n    if (_balanceOf[varg0] >= varg2) {\n        if (_balanceOf[msg.sender] >= varg2) {\n            emit Transfer(varg0, varg1, varg2);\n            v0 = v2 = 1;\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n            _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n            _balanceOf[varg1] += varg2;\n        }\n    }\n    return v0;\n}\n\nfunction buyin(address varg0, uint256 varg1) public payable { \n    v0 = v1 = msg.value;\n    while (1) {\n        v2 = v3 = v0 > 0;\n        if (v0 <= 0) {\n            goto 0xa80x8fB0x195;\n        }\n        v2 = v4 = _price <= varg1;\n        if (!v2) {\n            exit;\n        } else {\n            v0 = v5 = _price * _remaining / 0xf4240;\n            if (v0 <= v5) {\n            }\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v0 * 0xf4240 / _price;\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v0 * 0xf4240 / _price;\n            _balanceOf[msg.sender][1] = block.timestamp + 0x93a80 | ~0xffffffff & _balanceOf[msg.sender][0x1];\n            _totalSupply = _totalSupply + v0 * 0xf4240 / _price;\n            emit Buyin(msg.sender, _price, v0 * 0xf4240 / _price);\n            _remaining = _remaining - v0 * 0xf4240 / _price;\n            v0 = v0 - v0;\n            if (0 == _remaining - v0 * 0xf4240 / _price) {\n                _price += 0x38d7ea4c68000;\n                _remaining = 0x5f5e100;\n                emit NewTranch(0x38d7ea4c68000 + _price);\n            }\n            continue;\n        }\n    }\n}\n\nfunction remaining() public payable { \n    return _remaining;\n}\n\nfunction refund(uint256 varg0, uint256 varg1) public payable { \n    v0 = v1 = 0;\n    v2 = v3 = _balanceOf[msg.sender] < varg1;\n    if (_balanceOf[msg.sender] >= varg1) {\n        v2 = v4 = block.timestamp < uint32(_balanceOf[address(msg.sender)][1]);\n    }\n    if (!v2) {\n        if (_balanceOf[msg.sender] >= varg1) {\n            emit Refund(msg.sender, varg0, varg1);\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n            _totalSupply += varg1;\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n            if (_balanceOf[msg.sender] - varg1 == 0) {\n                _balanceOf[msg.sender][0] = 0;\n                _balanceOf[msg.sender][1] = ~0xffffffff & _balanceOf[msg.sender][0x1];\n            }\n            v5 = msg.sender.call().value(varg1 * varg0 / 0xf4240);\n            assert(v5);\n            v0 = v6 = 1;\n        }\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public payable { \n    return _balanceOf[varg0];\n}\n\nfunction price() public payable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    if (_balanceOf[msg.sender] >= varg1) {\n        emit Transfer(msg.sender, varg0, varg1);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        goto 0x2fe0x289;\n    }\n    return 0;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    return _balanceOf[varg1];\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    emit Approval(msg.sender, varg0, varg1);\n    _balanceOf[varg0] += varg1;\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x95ea7b3) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x29cbdc86 == function_selector >> 224) {\n            buyin(address,uint256);\n        } else if (0x55234ec0 == function_selector >> 224) {\n            remaining();\n        } else if (0x5af36e3e == function_selector >> 224) {\n            refund(uint256,uint256);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0xa035b1fe == function_selector >> 224) {\n            price();\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        }\n    }\n    v0 = msg.sender;\n    v1 = msg.value;\n    while (1) {\n        v2 = v3 = v1 > 0;\n        if (v1 <= 0) {\n            goto 0xa80x0;\n        }\n        v2 = _price <= 0x8000000000000000000000000000000000000000000000000000000000000000;\n        if (!v2) {\n            exit;\n        } else {\n            v1 = v4 = _price * _remaining / 0xf4240;\n            if (v1 <= v4) {\n            }\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v1 * 0xf4240 / _price;\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v1 * 0xf4240 / _price;\n            _balanceOf[msg.sender][1] = block.timestamp + 0x93a80 | ~0xffffffff & _balanceOf[msg.sender][0x1];\n            _totalSupply = _totalSupply + v1 * 0xf4240 / _price;\n            emit Buyin(msg.sender, _price, v1 * 0xf4240 / _price);\n            _remaining = _remaining - v1 * 0xf4240 / _price;\n            v1 = v1 - v1;\n            if (0 == _remaining - v1 * 0xf4240 / _price) {\n                _price += 0x38d7ea4c68000;\n                _remaining = 0x5f5e100;\n                emit NewTranch(0x38d7ea4c68000 + _price);\n            }\n            continue;\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.15 05:04 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalSupply; // STORAGE[0x0]\nmapping (uint256 => [uint256]) _balanceOf; // STORAGE[0x1]\nuint256 _price; // STORAGE[0x2]\nuint256 _remaining; // STORAGE[0x3]\n\n// Events\nApproval(address, address, uint256);\nBuyin(address, uint256, uint256);\nNewTranch(uint256);\nTransfer(address, address, uint256);\nRefund(address, uint256, uint256);\n\nfunction totalSupply() public payable { \n    return _totalSupply;\n}\n\nfunction transferFrom(address varg0, address varg1, uint256 varg2) public payable { \n    v0 = v1 = 0;\n    if (_balanceOf[varg0] >= varg2) {\n        if (_balanceOf[msg.sender] >= varg2) {\n            emit Transfer(varg0, varg1, varg2);\n            v0 = v2 = 1;\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg2;\n            _balanceOf[varg0] = _balanceOf[varg0] - varg2;\n            _balanceOf[varg1] += varg2;\n        }\n    }\n    return v0;\n}\n\nfunction buyin(address varg0, uint256 varg1) public payable { \n    v0 = v1 = msg.value;\n    while (1) {\n        v2 = v3 = v0 > 0;\n        if (v0 <= 0) {\n            goto 0xa80x8fB0x195;\n        }\n        v2 = v4 = _price <= varg1;\n        if (!v2) {\n            exit;\n        } else {\n            v0 = v5 = _price * _remaining / 0xf4240;\n            if (v0 <= v5) {\n            }\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v0 * 0xf4240 / _price;\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v0 * 0xf4240 / _price;\n            _balanceOf[msg.sender][1] = block.timestamp + 0x93a80 | ~0xffffffff & _balanceOf[msg.sender][0x1];\n            _totalSupply = _totalSupply + v0 * 0xf4240 / _price;\n            emit Buyin(msg.sender, _price, v0 * 0xf4240 / _price);\n            _remaining = _remaining - v0 * 0xf4240 / _price;\n            v0 = v0 - v0;\n            if (0 == _remaining - v0 * 0xf4240 / _price) {\n                _price += 0x38d7ea4c68000;\n                _remaining = 0x5f5e100;\n                emit NewTranch(0x38d7ea4c68000 + _price);\n            }\n            continue;\n        }\n    }\n}\n\nfunction remaining() public payable { \n    return _remaining;\n}\n\nfunction refund(uint256 varg0, uint256 varg1) public payable { \n    v0 = v1 = 0;\n    v2 = v3 = _balanceOf[msg.sender] < varg1;\n    if (_balanceOf[msg.sender] >= varg1) {\n        v2 = v4 = block.timestamp < uint32(_balanceOf[address(msg.sender)][1]);\n    }\n    if (!v2) {\n        if (_balanceOf[msg.sender] >= varg1) {\n            emit Refund(msg.sender, varg0, varg1);\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n            _totalSupply += varg1;\n            _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n            if (_balanceOf[msg.sender] - varg1 == 0) {\n                _balanceOf[msg.sender][0] = 0;\n                _balanceOf[msg.sender][1] = ~0xffffffff & _balanceOf[msg.sender][0x1];\n            }\n            v5 = msg.sender.call().value(varg1 * varg0 / 0xf4240);\n            assert(v5);\n            v0 = v6 = 1;\n        }\n    }\n    return v0;\n}\n\nfunction balanceOf(address varg0) public payable { \n    return _balanceOf[varg0];\n}\n\nfunction price() public payable { \n    return _price;\n}\n\nfunction transfer(address varg0, uint256 varg1) public payable { \n    if (_balanceOf[msg.sender] >= varg1) {\n        emit Transfer(msg.sender, varg0, varg1);\n        _balanceOf[msg.sender] = _balanceOf[msg.sender] - varg1;\n        _balanceOf[varg0] += varg1;\n        goto 0x2fe0x289;\n    }\n    return 0;\n}\n\nfunction allowance(address varg0, address varg1) public payable { \n    return _balanceOf[varg1];\n}\n\nfunction approve(address varg0, uint256 varg1) public payable { \n    emit Approval(msg.sender, varg0, varg1);\n    _balanceOf[varg0] += varg1;\n    return 1;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length) {\n        if (function_selector >> 224 == 0x95ea7b3) {\n            approve(address,uint256);\n        } else if (0x18160ddd == function_selector >> 224) {\n            totalSupply();\n        } else if (0x23b872dd == function_selector >> 224) {\n            transferFrom(address,address,uint256);\n        } else if (0x29cbdc86 == function_selector >> 224) {\n            buyin(address,uint256);\n        } else if (0x55234ec0 == function_selector >> 224) {\n            remaining();\n        } else if (0x5af36e3e == function_selector >> 224) {\n            refund(uint256,uint256);\n        } else if (0x70a08231 == function_selector >> 224) {\n            balanceOf(address);\n        } else if (0xa035b1fe == function_selector >> 224) {\n            price();\n        } else if (0xa9059cbb == function_selector >> 224) {\n            transfer(address,uint256);\n        } else if (0xdd62ed3e == function_selector >> 224) {\n            allowance(address,address);\n        }\n    }\n    v0 = msg.sender;\n    v1 = msg.value;\n    while (1) {\n        v2 = v3 = v1 > 0;\n        if (v1 <= 0) {\n            goto 0xa80x0;\n        }\n        v2 = _price <= 0x8000000000000000000000000000000000000000000000000000000000000000;\n        if (!v2) {\n            exit;\n        } else {\n            v1 = v4 = _price * _remaining / 0xf4240;\n            if (v1 <= v4) {\n            }\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v1 * 0xf4240 / _price;\n            _balanceOf[msg.sender][0] = _balanceOf[msg.sender][0] + v1 * 0xf4240 / _price;\n            _balanceOf[msg.sender][1] = block.timestamp + 0x93a80 | ~0xffffffff & _balanceOf[msg.sender][0x1];\n            _totalSupply = _totalSupply + v1 * 0xf4240 / _price;\n            emit Buyin(msg.sender, _price, v1 * 0xf4240 / _price);\n            _remaining = _remaining - v1 * 0xf4240 / _price;\n            v1 = v1 - v1;\n            if (0 == _remaining - v1 * 0xf4240 / _price) {\n                _price += 0x38d7ea4c68000;\n                _remaining = 0x5f5e100;\n                emit NewTranch(0x38d7ea4c68000 + _price);\n            }\n            continue;\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 51.18886661529541,
	"usage": {
		"completion_tokens": 731,
		"prompt_tokens": 1914,
		"total_tokens": 2645
	}
}