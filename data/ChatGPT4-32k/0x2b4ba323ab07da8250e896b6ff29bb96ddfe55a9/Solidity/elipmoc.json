{
	"address": "0x2b4ba323ab07da8250e896b6ff29bb96ddfe55a9",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Based on the decompiled code provided, here's the equivalent Solidity smart contract code. Please note that the main logic seems to be related to a token pool, where the owner can manage token addresses and prices. Some parts of the decompiled code were hard to understand due to the low-level operations, but I tried to represent them as close as possible in the Solidity code. \n\n```solidity\npragma solidity ^0.5.0;\n\ncontract TokenPool {\n    address[] public supported_tokens;\n    address public owner;\n    string[] public name;\n    mapping(address => uint256) public normalized_token_prices;\n    event TokenAddressUpdated(address tokenAddress, uint256 index);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function poolSize(address arg) public payable returns (uint256) {\n        require(msg.value == 0);\n        uint256 balance = supported_tokens[0].balance;\n        require(balance > 0);\n        return balance;\n    }\n\n    function updateTokenAddress(address newTokenAddress, uint256 index) public payable {\n        require(msg.value == 0);\n        require(msg.sender == owner);\n        supported_tokens[index] = newTokenAddress;\n        emit TokenAddressUpdated(newTokenAddress, index);\n    }\n\n    function updatePrice(address tokenAddress, uint256 price) public payable {\n        require(msg.value == 0);\n        require(msg.sender == owner);\n        normalized_token_prices[tokenAddress] = price;\n    }\n\n    function getSupportedToken(uint256 index) public view returns (address) {\n        return supported_tokens[index];\n    }\n\n    function getNormalizedTokenPrice(address tokenAddress) public view returns (uint256) {\n        return normalized_token_prices[tokenAddress];\n    }\n}\n```\n\nThis contract allows the owner to update the token addresses and their respective prices. It also includes a function to calculate the pool size. Please note that the contract may still need some adjustments depending on the specific use case and the original intent of the decompiled code. The `poolSize` function, for example, seems to be incomplete and its implementation might need to be adjusted.",
				"role": "assistant"
			}
		}
	],
	"created": 1698041377,
	"id": "chatcmpl-8CiQ5m98nuCB9GQSQMwa40tWtIDdw",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.12.04 15:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _owner; // STORAGE[0x1]\nuint256[] _supported_tokens; // STORAGE[0x2]\n\n// Events\nTokenAddressUpdated(address, int128);\n\nfunction poolSize(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    while (0 >= 5) {\n        if (_supported_tokens[0] != 0) {\n            require((_supported_tokens[0]).code.size);\n            require(this != _supported_tokens[0]);\n            v0 = _supported_tokens[0].balanceOf(MEM[320]).gas(msg.gas);\n            require(v0);\n            if (MEM[608]) {\n                require(MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])] / MEM[608] == STORAGE[keccak256(3, _supported_tokens[0])]);\n                v1 = v2 = MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])];\n            } else {\n                v1 = v3 = 0;\n            }\n            require(0 + v1 / 0x5f5e100 >= 0);\n            if (MEM[608]) {\n                require(MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])] / MEM[608] == STORAGE[keccak256(3, _supported_tokens[0])]);\n                v4 = v5 = MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])];\n            } else {\n                v4 = v6 = 0;\n            }\n            MEM[384] = 0 + v4 / 0x5f5e100;\n        }\n        MEM[416] = 1;\n        if (5 == 1) {\n            return MEM[384];\n        }\n    }\n    revert();\n}\n\nfunction updateTokenAddress(address varg0, int128 varg1) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    require(msg.sender == _owner);\n    require(MEM[352] < 5);\n    _supported_tokens[MEM[352]] = MEM[320];\n    emit TokenAddressUpdated(MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction updatePrice(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    require((0xf4240 <= MEM[352]) & (MEM[352] <= 0x52b7d2dcc80cd2e4000000));\n    STORAGE[keccak256(3, MEM[320])] = MEM[352];\n    emit 0xd86730737b142fc160892fa8a0f2db687a92a0e294d1ad70624cf5acef03b84(MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (16 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction supported_tokens(int128 varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(MEM[320] < 5);\n    return _supported_tokens[MEM[320]];\n}\n\nfunction normalized_token_prices(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(3, MEM[320])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xfa75d160) {\n        if (function_selector != 0x3d710a9d) {\n            if (function_selector != 0x457972de) {\n                if (function_selector != 0x6fdde03) {\n                    if (function_selector != 0x8da5cb5b) {\n                        if (function_selector != 0xb1c9f095) {\n                            require(function_selector == 0xf1bb1086);\n                            normalized_token_prices(address);\n                        } else {\n                            supported_tokens(int128);\n                        }\n                    } else {\n                        owner();\n                    }\n                } else {\n                    name();\n                }\n            } else {\n                updatePrice(address,uint256);\n            }\n        } else {\n            updateTokenAddress(address,int128);\n        }\n    } else {\n        poolSize(address);\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 15:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _owner; // STORAGE[0x1]\nuint256[] _supported_tokens; // STORAGE[0x2]\n\n// Events\nTokenAddressUpdated(address, int128);\n\nfunction poolSize(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    while (0 >= 5) {\n        if (_supported_tokens[0] != 0) {\n            require((_supported_tokens[0]).code.size);\n            require(this != _supported_tokens[0]);\n            v0 = _supported_tokens[0].balanceOf(MEM[320]).gas(msg.gas);\n            require(v0);\n            if (MEM[608]) {\n                require(MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])] / MEM[608] == STORAGE[keccak256(3, _supported_tokens[0])]);\n                v1 = v2 = MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])];\n            } else {\n                v1 = v3 = 0;\n            }\n            require(0 + v1 / 0x5f5e100 >= 0);\n            if (MEM[608]) {\n                require(MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])] / MEM[608] == STORAGE[keccak256(3, _supported_tokens[0])]);\n                v4 = v5 = MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])];\n            } else {\n                v4 = v6 = 0;\n            }\n            MEM[384] = 0 + v4 / 0x5f5e100;\n        }\n        MEM[416] = 1;\n        if (5 == 1) {\n            return MEM[384];\n        }\n    }\n    revert();\n}\n\nfunction updateTokenAddress(address varg0, int128 varg1) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    require(msg.sender == _owner);\n    require(MEM[352] < 5);\n    _supported_tokens[MEM[352]] = MEM[320];\n    emit TokenAddressUpdated(MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction updatePrice(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    require((0xf4240 <= MEM[352]) & (MEM[352] <= 0x52b7d2dcc80cd2e4000000));\n    STORAGE[keccak256(3, MEM[320])] = MEM[352];\n    emit 0xd86730737b142fc160892fa8a0f2db687a92a0e294d1ad70624cf5acef03b84(MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (16 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction supported_tokens(int128 varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(MEM[320] < 5);\n    return _supported_tokens[MEM[320]];\n}\n\nfunction normalized_token_prices(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(3, MEM[320])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xfa75d160) {\n        if (function_selector != 0x3d710a9d) {\n            if (function_selector != 0x457972de) {\n                if (function_selector != 0x6fdde03) {\n                    if (function_selector != 0x8da5cb5b) {\n                        if (function_selector != 0xb1c9f095) {\n                            require(function_selector == 0xf1bb1086);\n                            normalized_token_prices(address);\n                        } else {\n                            supported_tokens(int128);\n                        }\n                    } else {\n                        owner();\n                    }\n                } else {\n                    name();\n                }\n            } else {\n                updatePrice(address,uint256);\n            }\n        } else {\n            updateTokenAddress(address,int128);\n        }\n    } else {\n        poolSize(address);\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.12.04 15:29 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x0]\nuint256 _owner; // STORAGE[0x1]\nuint256[] _supported_tokens; // STORAGE[0x2]\n\n// Events\nTokenAddressUpdated(address, int128);\n\nfunction poolSize(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    while (0 >= 5) {\n        if (_supported_tokens[0] != 0) {\n            require((_supported_tokens[0]).code.size);\n            require(this != _supported_tokens[0]);\n            v0 = _supported_tokens[0].balanceOf(MEM[320]).gas(msg.gas);\n            require(v0);\n            if (MEM[608]) {\n                require(MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])] / MEM[608] == STORAGE[keccak256(3, _supported_tokens[0])]);\n                v1 = v2 = MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])];\n            } else {\n                v1 = v3 = 0;\n            }\n            require(0 + v1 / 0x5f5e100 >= 0);\n            if (MEM[608]) {\n                require(MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])] / MEM[608] == STORAGE[keccak256(3, _supported_tokens[0])]);\n                v4 = v5 = MEM[608] * STORAGE[keccak256(3, _supported_tokens[0])];\n            } else {\n                v4 = v6 = 0;\n            }\n            MEM[384] = 0 + v4 / 0x5f5e100;\n        }\n        MEM[416] = 1;\n        if (5 == 1) {\n            return MEM[384];\n        }\n    }\n    revert();\n}\n\nfunction updateTokenAddress(address varg0, int128 varg1) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    require(msg.sender == _owner);\n    require(MEM[352] < 5);\n    _supported_tokens[MEM[352]] = MEM[320];\n    emit TokenAddressUpdated(MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction updatePrice(address varg0) public payable { \n    CALLDATACOPY(320, 4, 64);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    require((0xf4240 <= MEM[352]) & (MEM[352] <= 0x52b7d2dcc80cd2e4000000));\n    STORAGE[keccak256(3, MEM[320])] = MEM[352];\n    emit 0xd86730737b142fc160892fa8a0f2db687a92a0e294d1ad70624cf5acef03b84(MEM[320], MEM[352]);\n    return 1;\n}\n\nfunction name() public nonPayable { \n    while (0 > STORAGE[keccak256(0)] + 32) {\n        MEM[384] = _name[0];\n        MEM[288] = 1;\n        if (2 != 1) {\n            break;\n        }\n    }\n    while (MEM[384] > MEM[384] + 31 - (MEM[384] - 1) % 32) {\n        MEM8[416 + MEM[384]] = 0x0 & 0xFF;\n        if (16 + MEM[384] != 1 + MEM[384]) {\n            break;\n        }\n    }\n    return 32, v0, v0, v0, 1 + MEM[384];\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction supported_tokens(int128 varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(MEM[320] < 5);\n    return _supported_tokens[MEM[320]];\n}\n\nfunction normalized_token_prices(address varg0) public payable { \n    CALLDATACOPY(320, 4, 32);\n    require(!msg.value);\n    require(varg0 < MEM[32]);\n    return STORAGE[keccak256(3, MEM[320])];\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[32] = 0x10000000000000000000000000000000000000000;\n    MEM[96] = 0xffffffffffffffffffffffffffffffff80000000000000000000000000000000;\n    MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n    MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n    if (function_selector != 0xfa75d160) {\n        if (function_selector != 0x3d710a9d) {\n            if (function_selector != 0x457972de) {\n                if (function_selector != 0x6fdde03) {\n                    if (function_selector != 0x8da5cb5b) {\n                        if (function_selector != 0xb1c9f095) {\n                            require(function_selector == 0xf1bb1086);\n                            normalized_token_prices(address);\n                        } else {\n                            supported_tokens(int128);\n                        }\n                    } else {\n                        owner();\n                    }\n                } else {\n                    name();\n                }\n            } else {\n                updatePrice(address,uint256);\n            }\n        } else {\n            updateTokenAddress(address,int128);\n        }\n    } else {\n        poolSize(address);\n    }\n}\n.",
	"status": "1",
	"time_cost": 30.609780073165894,
	"usage": {
		"completion_tokens": 426,
		"prompt_tokens": 1427,
		"total_tokens": 1853
	}
}