{
	"address": "0xa2b47e3d5c44877cca798226b7b8118f9bfb7a56",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is the Solidity contract code representation of the given decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.5.0;\n\ncontract MyContract {\n    uint256[] private _coins;\n    uint256[] private _underlying_coins;\n    uint256[] private _balances;\n    uint256 private _a;\n    uint256 private _fee;\n    uint256 private _admin_fee;\n    uint256 private _owner;\n    uint256 private stor_7;\n    uint256 private _admin_actions_deadline;\n    uint256 private _transfer_ownership_deadline;\n    uint256 private _future_A;\n    uint256 private _future_fee;\n    uint256 private _future_admin_fee;\n    uint256 private _future_owner;\n    uint256 private stor_e;\n    uint256 private stor_f;\n    uint256 private _exchange;\n\n    event RemoveLiquidity(address indexed, uint256[2], uint256[2], uint256);\n    event CommitNewParameters(uint256 indexed, uint256, uint256, uint256);\n    event NewParameters(uint256, uint256, uint256);\n    event CommitNewAdmin(uint256, address indexed);\n    event NewAdmin(address indexed);\n    \n    // Assuming all the functions are returning uint256 as their output type. \n    // There might be other types (address, bytes, etc.) depending on the actual functionality of the unnamed functions.\n\n    function unnamedFunc1() external view returns (uint256) { }\n    function unnamedFunc2() external view returns (uint256) { }\n    function unnamedFunc3() external view returns (uint256) { }\n    function unnamedFunc4() external view returns (uint256) { }\n    function unnamedFunc5() external view returns (uint256) { }\n    function unnamedFunc6() external view returns (uint256) { }\n    function unnamedFunc7() external view returns (uint256) { }\n    function unnamedFunc8() external view returns (uint256) { }\n    function unnamedFunc9() external view returns (uint256) { }\n    function unnamedFunc10() external view returns (uint256) { }\n    function unnamedFunc11() external view returns (uint256) { }\n    function unnamedFunc12() external view returns (uint256) { }\n    function unnamedFunc13() external view returns (uint256) { }\n    function unnamedFunc14() external view returns (uint256) { }\n    function unnamedFunc15() external view returns (uint256) { }\n    function unnamedFunc16() external view returns (uint256) { }\n    function unnamedFunc17() external view returns (uint256) { }\n    function unnamedFunc18() external view returns (uint256) { }\n    function unnamedFunc19() external view returns (uint256) { }\n    function unnamedFunc20() external view returns (uint256) { }\n    function unnamedFunc21() external view returns (uint256) { }\n    function unnamedFunc22() external view returns (uint256) { }\n    function unnamedFunc23() external view returns (uint256) { }\n    function unnamedFunc24() external view returns (uint256) { }\n    function unnamedFunc25() external view returns (uint256) { }\n    function unnamedFunc26() external view returns (uint256) { }\n    function unnamedFunc27() external view returns (uint256) { }\n    function unnamedFunc28() external view returns (uint256) { }\n    function unnamedFunc29() external view returns (uint256) { }\n    function unnamedFunc30() external view returns (uint256) { }\n    function unnamedFunc31() external view returns (uint256) { }\n    function unnamedFunc32() external view returns (uint256) { }\n    function unnamedFunc33() external view returns (uint256) { }\n    function unnamedFunc34() external view returns (uint256) { }\n    function unnamedFunc35() external view returns (uint256) { }\n    function unnamedFunc36() external view returns (uint256) { }\n    function unnamedFunc37() external view returns (uint256) { }\n    function unnamedFunc38() external view returns (uint256) { }\n    function unnamedFunc39() external view returns (uint256) { }\n    function unnamedFunc40() external view returns (uint256) { }\n    function unnamedFunc41() external view returns (uint256) { }\n    function unnamedFunc42() external view returns (uint256) { }\n    function unnamedFunc43() external view returns (uint256) { }\n    function unnamedFunc44() external view returns (uint256) { }\n    function unnamedFunc45() external view returns (uint256) { }\n    function unnamedFunc46() external view returns (uint256) { }\n    function unnamedFunc47() external view returns (uint256) { }\n    function unnamedFunc48() external view returns (uint256) { }\n    function unnamedFunc49() external view returns (uint256) { }\n    function unnamedFunc50() external view returns (uint256) { }\n    function unnamedFunc51() external view returns (uint256) { }\n    function unnamedFunc52() external view returns (uint256) { }\n    function unnamedFunc53() external view returns (uint256) { }\n    function unnamedFunc54() external view returns (uint256) { }\n    function unnamedFunc55() external view returns (uint256) { }\n    function unnamedFunc56() external view returns (uint256) { }\n    function unnamedFunc57() external view returns (uint256) { }\n    function unnamedFunc58() external view returns (uint256) { }\n    function unnamedFunc59() external view returns (uint256) { }\n    function unnamedFunc60() external view returns (uint256) { }\n    function unnamedFunc61() external view returns (uint256) { }\n    function unnamedFunc62() external view returns (uint256) { }\n    function unnamedFunc63() external view returns (uint256) { }\n    function unnamedFunc64() external view returns (uint256) { }\n    function unnamedFunc65() external view returns (uint256) { }\n    function unnamedFunc66() external view returns (uint256) { }\n    function unnamedFunc67() external view returns (uint256) { }\n    function unnamedFunc68() external view returns (uint256) { }\n}\n```\nPlease note that the original functions are unnamed in the given decompiled EVM Bytecode, so I've named them `unnamedFunc` with incrementing numbers for demonstration purposes.\n\nThe actual functionality and return types of these functions can be derived only from the original source code or more comprehensive understanding of the contract's overall functionality. The function parameters can also vary, they may not only be of `uint256` type.\n\nThis conversion is a cautious interpretation and might not fully represent the actual functionality of the contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1698041171,
	"id": "chatcmpl-8CiMlwe8YLYXS4AlbNVI15AoDClQR",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.10.11 02:04 UTC\n// Warning: 57.99999999999999% of the contract's code is inferred to be dead code.\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _coins; // STORAGE[0x0]\nuint256[] _underlying_coins; // STORAGE[0x1]\nuint256[] _balances; // STORAGE[0x2]\nuint256 _a; // STORAGE[0x3]\nuint256 _fee; // STORAGE[0x4]\nuint256 _admin_fee; // STORAGE[0x5]\nuint256 _owner; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _admin_actions_deadline; // STORAGE[0x8]\nuint256 _transfer_ownership_deadline; // STORAGE[0x9]\nuint256 _future_A; // STORAGE[0xa]\nuint256 _future_fee; // STORAGE[0xb]\nuint256 _future_admin_fee; // STORAGE[0xc]\nuint256 _future_owner; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 _exchange; // STORAGE[0xffffff]\n\n\n// Events\nRemoveLiquidity(address, uint256[2], uint256[2], uint256);\nCommitNewParameters(uint256, uint256, uint256, uint256);\nNewParameters(uint256, uint256, uint256);\nCommitNewAdmin(uint256, address);\nNewAdmin(address);\n\nfunction get_virtual_price() public nonPayable { \n    while (352 < 1248) {\n    }\n    MEM[1280] = 0x7b08bb90;\n    while (352 < 992) {\n    }\n    MEM[1024] = 0x96b414ec;\n    while (352 < 896) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction calc_token_amount(uint256[2] varg0) public nonPayable { \n    require(varg0 < 2);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction add_liquidity() public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(!stor_f);\n    MEM[320] = 0;\n    MEM[352] = 0;\n    MEM[384] = 1;\n    MEM[416] = 1;\n    MEM[448] = 0;\n    MEM[480] = 0;\n    require(((_fee << 1) / _fee == 2) | !_fee);\n    require(4);\n    MEM[512] = _fee << 1 >> 2;\n    MEM[544] = _admin_fee;\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    MEM[576] = MEM[704];\n    while (352 < 800) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v1);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dy(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dx(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dy_underlying(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dx_underlying(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction exchange(int128 varg0, int128 varg1) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v0);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction exchange_underlying(int128 varg0, int128 varg1) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v0);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction remove_liquidity(uint256 varg0) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    MEM[608] = 0;\n    MEM[640] = 0;\n    MEM[672] = 1;\n    MEM[704] = 1;\n    while (0 >= 2) {\n        require((_balances[0] * varg0 / _balances[0] == varg0) | !_balances[0]);\n        require(MEM[448]);\n        v1 = _balances[0] * varg0 / MEM[448];\n        require(0 < 2);\n        require(v1 >= msg.data[36], Error(32, 48, 'Withdrawal resulted in fewer coi', 'ns than expected'));\n        require(0 < 2);\n        require(_balances[0] >= v1);\n        _balances[0] = _balances[0] - v1;\n        require(0 < 2);\n        MEM[480] = v1;\n        require(0 < 2);\n        require(0 < 2);\n        if (!(MEM[0x260] & !MEM[0x2a0])) {\n            require(MEM[736] < 2);\n            require((_coins[MEM[736]]).code.size);\n            require(MEM[736] < 2);\n            require(this ^ _coins[MEM[736]]);\n            require(MEM[736] < 2);\n            v2 = _coins[MEM[736]].transfer(msg.sender, v1).gas(msg.gas);\n            require(v2);\n            require(0x7b08bb90);\n        } else {\n            require(MEM[736] < 2);\n            require((_coins[MEM[736]]).code.size);\n            require(MEM[736] < 2);\n            require(this ^ _coins[MEM[736]]);\n            require(MEM[736] < 2);\n            v3 = _coins[MEM[736]].transfer(msg.sender, v1).gas(msg.gas);\n            require(v3);\n        }\n        MEM[736] = 1;\n        if (2 == 1) {\n            require(stor_7.code.size);\n            require(this ^ stor_7);\n            v4 = stor_7.burnFrom(msg.sender, varg0).gas(msg.gas);\n            require(v4);\n            require(MEM[448] >= varg0);\n            emit RemoveLiquidity(msg.sender, 0, 0, 0, 0, MEM[448] - varg0);\n            _exchange = 0;\n            exit;\n        }\n    }\n    revert();\n}\n\nfunction remove_liquidity_imbalance() public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(!stor_f);\n    MEM[320] = 0;\n    MEM[352] = 0;\n    MEM[384] = 1;\n    MEM[416] = 1;\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    require(MEM[576] > 0);\n    require(((_fee << 1) / _fee == 2) | !_fee);\n    require(4);\n    MEM[608] = _fee << 1 >> 2;\n    MEM[640] = _admin_fee;\n    while (352 < 736) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v1);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction commit_new_parameters(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(!_admin_actions_deadline);\n    require(varg2 <= 0x12a05f200);\n    require(varg1 <= 0x12a05f200);\n    require(varg0 <= 0xf4240);\n    require(block.timestamp + 0x3f480 >= block.timestamp);\n    _admin_actions_deadline = block.timestamp + 0x3f480;\n    _future_A = varg0;\n    _future_fee = varg1;\n    _future_admin_fee = varg2;\n    emit CommitNewParameters(block.timestamp + 0x3f480, varg0, varg1, varg2);\n}\n\nfunction apply_new_parameters() public nonPayable { \n    require(msg.sender == _owner);\n    require((_admin_actions_deadline <= block.timestamp) & (_admin_actions_deadline > 0));\n    _admin_actions_deadline = 0;\n    _a = _future_A;\n    _fee = _future_fee;\n    _admin_fee = _future_admin_fee;\n    emit NewParameters(_future_A, _future_fee, _future_admin_fee);\n}\n\nfunction revert_new_parameters() public nonPayable { \n    require(msg.sender == _owner);\n    _admin_actions_deadline = 0;\n}\n\nfunction commit_transfer_ownership(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    require(!_transfer_ownership_deadline);\n    require(block.timestamp + 0x3f480 >= block.timestamp);\n    _transfer_ownership_deadline = block.timestamp + 0x3f480;\n    _future_owner = varg0;\n    emit CommitNewAdmin(block.timestamp + 0x3f480, varg0);\n}\n\nfunction apply_transfer_ownership() public nonPayable { \n    require(msg.sender == _owner);\n    require((block.timestamp >= _transfer_ownership_deadline) & (_transfer_ownership_deadline > 0));\n    _transfer_ownership_deadline = 0;\n    _owner = _future_owner;\n    emit NewAdmin(_future_owner);\n}\n\nfunction revert_transfer_ownership() public nonPayable { \n    require(msg.sender == _owner);\n    _transfer_ownership_deadline = 0;\n}\n\nfunction withdraw_admin_fees() public nonPayable { \n    require(msg.sender == _owner);\n    MEM[320] = 1;\n    MEM[352] = 0xe8d4a51000;\n    MEM[384] = 0;\n    MEM[416] = 0;\n    MEM[448] = 1;\n    MEM[480] = 1;\n    while (0 >= 2) {\n        require((_coins[0]).code.size);\n        require(this ^ _coins[0]);\n        v0 = _coins[0].balanceOf(this).gas(msg.gas);\n        require(v0);\n        require(0 < 2);\n        require(MEM[736] >= _balances[0]);\n        if (MEM[736] - _balances[0] > 0) {\n            require(MEM[512] < 2);\n            require(MEM[512] < 2);\n            if (!(MEM[(MEM[512] << 5) + 384] & !MEM[(MEM[512] << 5) + 448])) {\n                require((_coins[0]).code.size);\n                require(this ^ _coins[0]);\n                v1 = _coins[0].transfer(msg.sender, MEM[736] - _balances[0]).gas(msg.gas);\n                require(v1);\n                require(MEM[928]);\n            } else {\n                require((_coins[0]).code.size);\n                require(this ^ _coins[0]);\n                v2 = _coins[0].transfer(msg.sender, MEM[736] - _balances[0]).gas(msg.gas);\n                require(v2);\n            }\n        }\n        MEM[512] = 1;\n        if (2 == 1) {\n            exit;\n        }\n    }\n    revert();\n}\n\nfunction kill_me() public nonPayable { \n    require(msg.sender == _owner);\n    require(stor_e > block.timestamp);\n    stor_f = 1;\n}\n\nfunction unkill_me() public nonPayable { \n    require(msg.sender == _owner);\n    stor_f = 0;\n}\n\nfunction coins(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _coins[varg0];\n}\n\nfunction underlying_coins(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _underlying_coins[varg0];\n}\n\nfunction balances(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _balances[varg0];\n}\n\nfunction A() public nonPayable { \n    return _a;\n}\n\nfunction fee() public nonPayable { \n    return _fee;\n}\n\nfunction admin_fee() public nonPayable { \n    return _admin_fee;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction admin_actions_deadline() public nonPayable { \n    return _admin_actions_deadline;\n}\n\nfunction transfer_ownership_deadline() public nonPayable { \n    return _transfer_ownership_deadline;\n}\n\nfunction future_A() public nonPayable { \n    return _future_A;\n}\n\nfunction future_fee() public nonPayable { \n    return _future_fee;\n}\n\nfunction future_admin_fee() public nonPayable { \n    return _future_admin_fee;\n}\n\nfunction future_owner() public nonPayable { \n    return _future_owner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = int128.min;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (!0) {\n            if (!0) {\n                if (!0) {\n                    if (!0) {\n                        if (!0) {\n                            if (!0) {\n                                if (function_selector != 0xbb7b8b80) {\n                                    if (function_selector != 0xed8e84f3) {\n                                        if (function_selector != 0xb4c7e4d) {\n                                            if (!0) {\n                                                if (function_selector != 0x5e0d443f) {\n                                                    if (function_selector != 0x67df02ca) {\n                                                        if (function_selector != 0x7211ef7) {\n                                                            if (function_selector != 0xe71d1b9) {\n                                                                if (!0) {\n                                                                    if (function_selector != 0x3df02124) {\n                                                                        if (function_selector != 0xa6417ed6) {\n                                                                            if (function_selector != 0x5b36389c) {\n                                                                                if (function_selector != 0xe3103273) {\n                                                                                    if (function_selector != 0xee11f5b6) {\n                                                                                        if (function_selector != 0x2a7dd7cd) {\n                                                                                            if (function_selector != 0x226840fb) {\n                                                                                                if (function_selector != 0x6b441a40) {\n                                                                                                    if (function_selector != 0x6a1c05ae) {\n                                                                                                        if (function_selector != 0x86fbf193) {\n                                                                                                            if (function_selector != 0x30c54085) {\n                                                                                                                if (function_selector != 0xe3698853) {\n                                                                                                                    if (function_selector != 0x3046f972) {\n                                                                                                                        if (function_selector != 0x23746eb8) {\n                                                                                                                            if (function_selector != 0xb739953e) {\n                                                                                                                                if (function_selector != 0x65a80d8) {\n                                                                                                                                    if (function_selector != 0xf446c1d0) {\n                                                                                                                                        if (function_selector != 0xddca3f43) {\n                                                                                                                                            if (function_selector != 0xfee3f7f9) {\n                                                                                                                                                if (function_selector != 0x8da5cb5b) {\n                                                                                                                                                    if (function_selector != 0x405e28f8) {\n                                                                                                                                                        if (function_selector != 0xe0a0b586) {\n                                                                                                                                                            if (function_selector != 0xb4b577ad) {\n                                                                                                                                                                if (function_selector != 0x58680d0b) {\n                                                                                                                                                                    if (function_selector != 0xe3824462) {\n                                                                                                                                                                        if (function_selector == 0x1ec0cdc1) {\n                                                                                                                                                                            future_owner();\n                                                                                                                                                                        }\n                                                                                                                                                                    } else {\n                                                                                                                                                                        future_admin_fee();\n                                                                                                                                                                    }\n                                                                                                                                                                } else {\n                                                                                                                                                                    future_fee();\n                                                                                                                                                                }\n                                                                                                                                                            } else {\n                                                                                                                                                                future_A();\n                                                                                                                                                            }\n                                                                                                                                                        } else {\n                                                                                                                                                            transfer_ownership_deadline();\n                                                                                                                                                        }\n                                                                                                                                                    } else {\n                                                                                                                                                        admin_actions_deadline();\n                                                                                                                                                    }\n                                                                                                                                                } else {\n                                                                                                                                                    owner();\n                                                                                                                                                }\n                                                                                                                                            } else {\n                                                                                                                                                admin_fee();\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            fee();\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        A();\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    balances(int128);\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                underlying_coins(int128);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            coins(int128);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        unkill_me();\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    kill_me();\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                withdraw_admin_fees();\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            revert_transfer_ownership();\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        apply_transfer_ownership();\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    commit_transfer_ownership(address);\n                                                                                                }\n                                                                                            } else {\n                                                                                                revert_new_parameters();\n                                                                                            }\n                                                                                        } else {\n                                                                                            apply_new_parameters();\n                                                                                        }\n                                                                                    } else {\n                                                                                        commit_new_parameters(uint256,uint256,uint256);\n                                                                                    }\n                                                                                } else {\n                                                                                    remove_liquidity_imbalance(uint256[2],uint256);\n                                                                                }\n                                                                            } else {\n                                                                                remove_liquidity(uint256,uint256[2]);\n                                                                            }\n                                                                        } else {\n                                                                            exchange_underlying(int128,int128,uint256,uint256);\n                                                                        }\n                                                                    } else {\n                                                                        exchange(int128,int128,uint256,uint256);\n                                                                    }\n                                                                } else {\n                                                                    require(!stor_f);\n                                                                    MEM[608] = 0x96b414ec;\n                                                                }\n                                                            } else {\n                                                                get_dx_underlying(int128,int128,uint256);\n                                                            }\n                                                        } else {\n                                                            get_dy_underlying(int128,int128,uint256);\n                                                        }\n                                                    } else {\n                                                        get_dx(int128,int128,uint256);\n                                                    }\n                                                } else {\n                                                    get_dy(int128,int128,uint256);\n                                                }\n                                            } else {\n                                                require((MEM[352] < 2) & ((MEM[320] < 2) & ((MEM[352] >= 0) & ((MEM[320] != MEM[352]) & (MEM[320] >= 0)))));\n                                                MEM[576] = 0x7b08bb90;\n                                            }\n                                        } else {\n                                            add_liquidity(uint256[2],uint256);\n                                        }\n                                    } else {\n                                        calc_token_amount(uint256[2],bool);\n                                    }\n                                } else {\n                                    get_virtual_price();\n                                }\n                            } else {\n                                while (352 < 1120) {\n                                }\n                                MEM[1152] = 0x7b08bb90;\n                                while (352 < 800) {\n                                }\n                                MEM[832] = 0x575e285f;\n                            }\n                        }\n                        MEM[320] = MEM[416];\n                        MEM[352] = MEM[448];\n                        while (0 + MEM[320] < 0) {\n                            MEM[480] = 1;\n                            if (2 == 1) {\n                                if (bool(0 + MEM[320])) {\n                                    MEM[544] = 0;\n                                    require(((_a << 1) / _a == 2) | !_a);\n                                    while (1) {\n                                        while (!((v0 * v0 / v0 == v0) | !v0)) {\n                                            require(((MEM[320] << 1) / MEM[320] == 2) | !MEM[320]);\n                                            require((MEM[320] << 1) + 1 >= MEM[320] << 1);\n                                            require((MEM[320] << 1) + 1);\n                                            v1 = v0 * v0 / ((MEM[320] << 1) + 1);\n                                            MEM[736] = 1;\n                                            if (2 == 1) {\n                                                v2 = (_a << 1) * (0 + MEM[320]);\n                                                require((v2 / (_a << 1) == 0 + MEM[320]) | !(_a << 1));\n                                                require(((v1 << 1) / v1 == 2) | !v1);\n                                                require(v2 + (v1 << 1) >= v2);\n                                                require(((v2 + (v1 << 1)) * v0 / (v2 + (v1 << 1)) == v0) | !(v2 + (v1 << 1)));\n                                                require(_a << 1 >= 1);\n                                                require((((_a << 1) - 1) * v0 / ((_a << 1) - 1) == v0) | !((_a << 1) - 1));\n                                                require((3 * v1 / 3 == v1) | !0x3);\n                                                require(((_a << 1) - 1) * v0 + 3 * v1 >= ((_a << 1) - 1) * v0);\n                                                require(((_a << 1) - 1) * v0 + 3 * v1);\n                                                v3 = (v2 + (v1 << 1)) * v0 / (((_a << 1) - 1) * v0 + 3 * v1);\n                                                if (v3 <= v0) {\n                                                    require(v0 >= v3);\n                                                    if (!bool(v0 - v3 > 1)) {\n                                                        // Unknown jump to Block 0xa67. Refer to 3-address code (TAC);\n                                                    }\n                                                } else {\n                                                    require(v3 >= v0);\n                                                    if (!bool(v3 - v0 > 1)) {\n                                                    }\n                                                }\n                                                MEM[640] = 1;\n                                                if (uint8.max != 1) {\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    revert();\n                                }\n                            }\n                        }\n                        revert();\n                    }\n                    MEM[384] = MEM[384];\n                    MEM[416] = MEM[416];\n                    MEM[480] = MEM[320];\n                    MEM[512] = MEM[352];\n                    while (0 >= 2) {\n                        require(0 < 2);\n                        require((MEM[480] * MEM[384] / MEM[480] == MEM[384]) | !MEM[480]);\n                        require(0xde0b6b3a7640000);\n                        require(0 < 2);\n                        MEM[480] = MEM[480] * MEM[384] / 0xde0b6b3a7640000;\n                        MEM[544] = 1;\n                        if (2 == 1) {\n                            while (!bool(64 > 0)) {\n                                MEM[576] = 32;\n                            }\n                        }\n                    }\n                    revert();\n                }\n                MEM[416] = MEM[416];\n                MEM[448] = MEM[448];\n                while (0 >= 2) {\n                    require(0 < 2);\n                    require((MEM[416] * _balances[0] / MEM[416] == _balances[0]) | !MEM[416]);\n                    require(0xde0b6b3a7640000);\n                    require(0 < 2);\n                    MEM[416] = MEM[416] * _balances[0] / 0xde0b6b3a7640000;\n                    MEM[480] = 1;\n                    if (2 == 1) {\n                        while (!bool(64 > 0)) {\n                            MEM[512] = 32;\n                        }\n                    }\n                }\n                revert();\n            } else {\n                MEM[352] = 1;\n                MEM[384] = 0xe8d4a51000;\n                MEM[416] = 1;\n                MEM[448] = 1;\n                while (1) {\n                    MEM[512] = 0xde0b6b3a7640000;\n                    if (0 < 2) {\n                        break;\n                    }\n                    if (MEM[416]) {\n                        require(MEM[480] < 2);\n                        require((_coins[MEM[480]]).code.size);\n                        require(MEM[480] < 2);\n                        require(this ^ _coins[MEM[480]]);\n                        require(MEM[480] < 2);\n                        v4 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n                        require(v4);\n                        MEM[512] = MEM[640];\n                    }\n                    require(0 < 2);\n                    require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n                    MEM[352] = MEM[352] * MEM[512];\n                    MEM[480] = 1;\n                    if (2 == 1) {\n                        while (!bool(64 > 0)) {\n                            MEM[672] = 32;\n                        }\n                    }\n                }\n                revert();\n            }\n        } else {\n            MEM[352] = 1;\n            MEM[384] = 0xe8d4a51000;\n            MEM[416] = 1;\n            MEM[448] = 1;\n            while (1) {\n                MEM[512] = 0xde0b6b3a7640000;\n                if (0 < 2) {\n                    break;\n                }\n                if (MEM[416]) {\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v5 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n                    require(v5);\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v6 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n                    require(v6);\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v7 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n                    require(v7);\n                    require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n                    require(block.number >= MEM[960]);\n                    require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n                    require(0xde0b6b3a7640000);\n                    require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n                    MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n                }\n                require(0 < 2);\n                require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n                MEM[352] = MEM[352] * MEM[512];\n                MEM[480] = 1;\n                if (2 == 1) {\n                    while (!bool(64 > 0)) {\n                        MEM[992] = 32;\n                    }\n                }\n            }\n            revert();\n        }\n    }\n    revert();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.10.11 02:04 UTC\n// Warning: 57.99999999999999% of the contract's code is inferred to be dead code.\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _coins; // STORAGE[0x0]\nuint256[] _underlying_coins; // STORAGE[0x1]\nuint256[] _balances; // STORAGE[0x2]\nuint256 _a; // STORAGE[0x3]\nuint256 _fee; // STORAGE[0x4]\nuint256 _admin_fee; // STORAGE[0x5]\nuint256 _owner; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _admin_actions_deadline; // STORAGE[0x8]\nuint256 _transfer_ownership_deadline; // STORAGE[0x9]\nuint256 _future_A; // STORAGE[0xa]\nuint256 _future_fee; // STORAGE[0xb]\nuint256 _future_admin_fee; // STORAGE[0xc]\nuint256 _future_owner; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 _exchange; // STORAGE[0xffffff]\n\n\n// Events\nRemoveLiquidity(address, uint256[2], uint256[2], uint256);\nCommitNewParameters(uint256, uint256, uint256, uint256);\nNewParameters(uint256, uint256, uint256);\nCommitNewAdmin(uint256, address);\nNewAdmin(address);\n\nfunction get_virtual_price() public nonPayable { \n    while (352 < 1248) {\n    }\n    MEM[1280] = 0x7b08bb90;\n    while (352 < 992) {\n    }\n    MEM[1024] = 0x96b414ec;\n    while (352 < 896) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction calc_token_amount(uint256[2] varg0) public nonPayable { \n    require(varg0 < 2);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction add_liquidity() public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(!stor_f);\n    MEM[320] = 0;\n    MEM[352] = 0;\n    MEM[384] = 1;\n    MEM[416] = 1;\n    MEM[448] = 0;\n    MEM[480] = 0;\n    require(((_fee << 1) / _fee == 2) | !_fee);\n    require(4);\n    MEM[512] = _fee << 1 >> 2;\n    MEM[544] = _admin_fee;\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    MEM[576] = MEM[704];\n    while (352 < 800) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v1);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dy(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dx(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dy_underlying(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dx_underlying(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction exchange(int128 varg0, int128 varg1) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v0);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction exchange_underlying(int128 varg0, int128 varg1) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v0);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction remove_liquidity(uint256 varg0) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    MEM[608] = 0;\n    MEM[640] = 0;\n    MEM[672] = 1;\n    MEM[704] = 1;\n    while (0 >= 2) {\n        require((_balances[0] * varg0 / _balances[0] == varg0) | !_balances[0]);\n        require(MEM[448]);\n        v1 = _balances[0] * varg0 / MEM[448];\n        require(0 < 2);\n        require(v1 >= msg.data[36], Error(32, 48, 'Withdrawal resulted in fewer coi', 'ns than expected'));\n        require(0 < 2);\n        require(_balances[0] >= v1);\n        _balances[0] = _balances[0] - v1;\n        require(0 < 2);\n        MEM[480] = v1;\n        require(0 < 2);\n        require(0 < 2);\n        if (!(MEM[0x260] & !MEM[0x2a0])) {\n            require(MEM[736] < 2);\n            require((_coins[MEM[736]]).code.size);\n            require(MEM[736] < 2);\n            require(this ^ _coins[MEM[736]]);\n            require(MEM[736] < 2);\n            v2 = _coins[MEM[736]].transfer(msg.sender, v1).gas(msg.gas);\n            require(v2);\n            require(0x7b08bb90);\n        } else {\n            require(MEM[736] < 2);\n            require((_coins[MEM[736]]).code.size);\n            require(MEM[736] < 2);\n            require(this ^ _coins[MEM[736]]);\n            require(MEM[736] < 2);\n            v3 = _coins[MEM[736]].transfer(msg.sender, v1).gas(msg.gas);\n            require(v3);\n        }\n        MEM[736] = 1;\n        if (2 == 1) {\n            require(stor_7.code.size);\n            require(this ^ stor_7);\n            v4 = stor_7.burnFrom(msg.sender, varg0).gas(msg.gas);\n            require(v4);\n            require(MEM[448] >= varg0);\n            emit RemoveLiquidity(msg.sender, 0, 0, 0, 0, MEM[448] - varg0);\n            _exchange = 0;\n            exit;\n        }\n    }\n    revert();\n}\n\nfunction remove_liquidity_imbalance() public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(!stor_f);\n    MEM[320] = 0;\n    MEM[352] = 0;\n    MEM[384] = 1;\n    MEM[416] = 1;\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    require(MEM[576] > 0);\n    require(((_fee << 1) / _fee == 2) | !_fee);\n    require(4);\n    MEM[608] = _fee << 1 >> 2;\n    MEM[640] = _admin_fee;\n    while (352 < 736) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v1);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction commit_new_parameters(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(!_admin_actions_deadline);\n    require(varg2 <= 0x12a05f200);\n    require(varg1 <= 0x12a05f200);\n    require(varg0 <= 0xf4240);\n    require(block.timestamp + 0x3f480 >= block.timestamp);\n    _admin_actions_deadline = block.timestamp + 0x3f480;\n    _future_A = varg0;\n    _future_fee = varg1;\n    _future_admin_fee = varg2;\n    emit CommitNewParameters(block.timestamp + 0x3f480, varg0, varg1, varg2);\n}\n\nfunction apply_new_parameters() public nonPayable { \n    require(msg.sender == _owner);\n    require((_admin_actions_deadline <= block.timestamp) & (_admin_actions_deadline > 0));\n    _admin_actions_deadline = 0;\n    _a = _future_A;\n    _fee = _future_fee;\n    _admin_fee = _future_admin_fee;\n    emit NewParameters(_future_A, _future_fee, _future_admin_fee);\n}\n\nfunction revert_new_parameters() public nonPayable { \n    require(msg.sender == _owner);\n    _admin_actions_deadline = 0;\n}\n\nfunction commit_transfer_ownership(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    require(!_transfer_ownership_deadline);\n    require(block.timestamp + 0x3f480 >= block.timestamp);\n    _transfer_ownership_deadline = block.timestamp + 0x3f480;\n    _future_owner = varg0;\n    emit CommitNewAdmin(block.timestamp + 0x3f480, varg0);\n}\n\nfunction apply_transfer_ownership() public nonPayable { \n    require(msg.sender == _owner);\n    require((block.timestamp >= _transfer_ownership_deadline) & (_transfer_ownership_deadline > 0));\n    _transfer_ownership_deadline = 0;\n    _owner = _future_owner;\n    emit NewAdmin(_future_owner);\n}\n\nfunction revert_transfer_ownership() public nonPayable { \n    require(msg.sender == _owner);\n    _transfer_ownership_deadline = 0;\n}\n\nfunction withdraw_admin_fees() public nonPayable { \n    require(msg.sender == _owner);\n    MEM[320] = 1;\n    MEM[352] = 0xe8d4a51000;\n    MEM[384] = 0;\n    MEM[416] = 0;\n    MEM[448] = 1;\n    MEM[480] = 1;\n    while (0 >= 2) {\n        require((_coins[0]).code.size);\n        require(this ^ _coins[0]);\n        v0 = _coins[0].balanceOf(this).gas(msg.gas);\n        require(v0);\n        require(0 < 2);\n        require(MEM[736] >= _balances[0]);\n        if (MEM[736] - _balances[0] > 0) {\n            require(MEM[512] < 2);\n            require(MEM[512] < 2);\n            if (!(MEM[(MEM[512] << 5) + 384] & !MEM[(MEM[512] << 5) + 448])) {\n                require((_coins[0]).code.size);\n                require(this ^ _coins[0]);\n                v1 = _coins[0].transfer(msg.sender, MEM[736] - _balances[0]).gas(msg.gas);\n                require(v1);\n                require(MEM[928]);\n            } else {\n                require((_coins[0]).code.size);\n                require(this ^ _coins[0]);\n                v2 = _coins[0].transfer(msg.sender, MEM[736] - _balances[0]).gas(msg.gas);\n                require(v2);\n            }\n        }\n        MEM[512] = 1;\n        if (2 == 1) {\n            exit;\n        }\n    }\n    revert();\n}\n\nfunction kill_me() public nonPayable { \n    require(msg.sender == _owner);\n    require(stor_e > block.timestamp);\n    stor_f = 1;\n}\n\nfunction unkill_me() public nonPayable { \n    require(msg.sender == _owner);\n    stor_f = 0;\n}\n\nfunction coins(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _coins[varg0];\n}\n\nfunction underlying_coins(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _underlying_coins[varg0];\n}\n\nfunction balances(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _balances[varg0];\n}\n\nfunction A() public nonPayable { \n    return _a;\n}\n\nfunction fee() public nonPayable { \n    return _fee;\n}\n\nfunction admin_fee() public nonPayable { \n    return _admin_fee;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction admin_actions_deadline() public nonPayable { \n    return _admin_actions_deadline;\n}\n\nfunction transfer_ownership_deadline() public nonPayable { \n    return _transfer_ownership_deadline;\n}\n\nfunction future_A() public nonPayable { \n    return _future_A;\n}\n\nfunction future_fee() public nonPayable { \n    return _future_fee;\n}\n\nfunction future_admin_fee() public nonPayable { \n    return _future_admin_fee;\n}\n\nfunction future_owner() public nonPayable { \n    return _future_owner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = int128.min;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (!0) {\n            if (!0) {\n                if (!0) {\n                    if (!0) {\n                        if (!0) {\n                            if (!0) {\n                                if (function_selector != 0xbb7b8b80) {\n                                    if (function_selector != 0xed8e84f3) {\n                                        if (function_selector != 0xb4c7e4d) {\n                                            if (!0) {\n                                                if (function_selector != 0x5e0d443f) {\n                                                    if (function_selector != 0x67df02ca) {\n                                                        if (function_selector != 0x7211ef7) {\n                                                            if (function_selector != 0xe71d1b9) {\n                                                                if (!0) {\n                                                                    if (function_selector != 0x3df02124) {\n                                                                        if (function_selector != 0xa6417ed6) {\n                                                                            if (function_selector != 0x5b36389c) {\n                                                                                if (function_selector != 0xe3103273) {\n                                                                                    if (function_selector != 0xee11f5b6) {\n                                                                                        if (function_selector != 0x2a7dd7cd) {\n                                                                                            if (function_selector != 0x226840fb) {\n                                                                                                if (function_selector != 0x6b441a40) {\n                                                                                                    if (function_selector != 0x6a1c05ae) {\n                                                                                                        if (function_selector != 0x86fbf193) {\n                                                                                                            if (function_selector != 0x30c54085) {\n                                                                                                                if (function_selector != 0xe3698853) {\n                                                                                                                    if (function_selector != 0x3046f972) {\n                                                                                                                        if (function_selector != 0x23746eb8) {\n                                                                                                                            if (function_selector != 0xb739953e) {\n                                                                                                                                if (function_selector != 0x65a80d8) {\n                                                                                                                                    if (function_selector != 0xf446c1d0) {\n                                                                                                                                        if (function_selector != 0xddca3f43) {\n                                                                                                                                            if (function_selector != 0xfee3f7f9) {\n                                                                                                                                                if (function_selector != 0x8da5cb5b) {\n                                                                                                                                                    if (function_selector != 0x405e28f8) {\n                                                                                                                                                        if (function_selector != 0xe0a0b586) {\n                                                                                                                                                            if (function_selector != 0xb4b577ad) {\n                                                                                                                                                                if (function_selector != 0x58680d0b) {\n                                                                                                                                                                    if (function_selector != 0xe3824462) {\n                                                                                                                                                                        if (function_selector == 0x1ec0cdc1) {\n                                                                                                                                                                            future_owner();\n                                                                                                                                                                        }\n                                                                                                                                                                    } else {\n                                                                                                                                                                        future_admin_fee();\n                                                                                                                                                                    }\n                                                                                                                                                                } else {\n                                                                                                                                                                    future_fee();\n                                                                                                                                                                }\n                                                                                                                                                            } else {\n                                                                                                                                                                future_A();\n                                                                                                                                                            }\n                                                                                                                                                        } else {\n                                                                                                                                                            transfer_ownership_deadline();\n                                                                                                                                                        }\n                                                                                                                                                    } else {\n                                                                                                                                                        admin_actions_deadline();\n                                                                                                                                                    }\n                                                                                                                                                } else {\n                                                                                                                                                    owner();\n                                                                                                                                                }\n                                                                                                                                            } else {\n                                                                                                                                                admin_fee();\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            fee();\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        A();\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    balances(int128);\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                underlying_coins(int128);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            coins(int128);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        unkill_me();\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    kill_me();\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                withdraw_admin_fees();\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            revert_transfer_ownership();\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        apply_transfer_ownership();\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    commit_transfer_ownership(address);\n                                                                                                }\n                                                                                            } else {\n                                                                                                revert_new_parameters();\n                                                                                            }\n                                                                                        } else {\n                                                                                            apply_new_parameters();\n                                                                                        }\n                                                                                    } else {\n                                                                                        commit_new_parameters(uint256,uint256,uint256);\n                                                                                    }\n                                                                                } else {\n                                                                                    remove_liquidity_imbalance(uint256[2],uint256);\n                                                                                }\n                                                                            } else {\n                                                                                remove_liquidity(uint256,uint256[2]);\n                                                                            }\n                                                                        } else {\n                                                                            exchange_underlying(int128,int128,uint256,uint256);\n                                                                        }\n                                                                    } else {\n                                                                        exchange(int128,int128,uint256,uint256);\n                                                                    }\n                                                                } else {\n                                                                    require(!stor_f);\n                                                                    MEM[608] = 0x96b414ec;\n                                                                }\n                                                            } else {\n                                                                get_dx_underlying(int128,int128,uint256);\n                                                            }\n                                                        } else {\n                                                            get_dy_underlying(int128,int128,uint256);\n                                                        }\n                                                    } else {\n                                                        get_dx(int128,int128,uint256);\n                                                    }\n                                                } else {\n                                                    get_dy(int128,int128,uint256);\n                                                }\n                                            } else {\n                                                require((MEM[352] < 2) & ((MEM[320] < 2) & ((MEM[352] >= 0) & ((MEM[320] != MEM[352]) & (MEM[320] >= 0)))));\n                                                MEM[576] = 0x7b08bb90;\n                                            }\n                                        } else {\n                                            add_liquidity(uint256[2],uint256);\n                                        }\n                                    } else {\n                                        calc_token_amount(uint256[2],bool);\n                                    }\n                                } else {\n                                    get_virtual_price();\n                                }\n                            } else {\n                                while (352 < 1120) {\n                                }\n                                MEM[1152] = 0x7b08bb90;\n                                while (352 < 800) {\n                                }\n                                MEM[832] = 0x575e285f;\n                            }\n                        }\n                        MEM[320] = MEM[416];\n                        MEM[352] = MEM[448];\n                        while (0 + MEM[320] < 0) {\n                            MEM[480] = 1;\n                            if (2 == 1) {\n                                if (bool(0 + MEM[320])) {\n                                    MEM[544] = 0;\n                                    require(((_a << 1) / _a == 2) | !_a);\n                                    while (1) {\n                                        while (!((v0 * v0 / v0 == v0) | !v0)) {\n                                            require(((MEM[320] << 1) / MEM[320] == 2) | !MEM[320]);\n                                            require((MEM[320] << 1) + 1 >= MEM[320] << 1);\n                                            require((MEM[320] << 1) + 1);\n                                            v1 = v0 * v0 / ((MEM[320] << 1) + 1);\n                                            MEM[736] = 1;\n                                            if (2 == 1) {\n                                                v2 = (_a << 1) * (0 + MEM[320]);\n                                                require((v2 / (_a << 1) == 0 + MEM[320]) | !(_a << 1));\n                                                require(((v1 << 1) / v1 == 2) | !v1);\n                                                require(v2 + (v1 << 1) >= v2);\n                                                require(((v2 + (v1 << 1)) * v0 / (v2 + (v1 << 1)) == v0) | !(v2 + (v1 << 1)));\n                                                require(_a << 1 >= 1);\n                                                require((((_a << 1) - 1) * v0 / ((_a << 1) - 1) == v0) | !((_a << 1) - 1));\n                                                require((3 * v1 / 3 == v1) | !0x3);\n                                                require(((_a << 1) - 1) * v0 + 3 * v1 >= ((_a << 1) - 1) * v0);\n                                                require(((_a << 1) - 1) * v0 + 3 * v1);\n                                                v3 = (v2 + (v1 << 1)) * v0 / (((_a << 1) - 1) * v0 + 3 * v1);\n                                                if (v3 <= v0) {\n                                                    require(v0 >= v3);\n                                                    if (!bool(v0 - v3 > 1)) {\n                                                        // Unknown jump to Block 0xa67. Refer to 3-address code (TAC);\n                                                    }\n                                                } else {\n                                                    require(v3 >= v0);\n                                                    if (!bool(v3 - v0 > 1)) {\n                                                    }\n                                                }\n                                                MEM[640] = 1;\n                                                if (uint8.max != 1) {\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    revert();\n                                }\n                            }\n                        }\n                        revert();\n                    }\n                    MEM[384] = MEM[384];\n                    MEM[416] = MEM[416];\n                    MEM[480] = MEM[320];\n                    MEM[512] = MEM[352];\n                    while (0 >= 2) {\n                        require(0 < 2);\n                        require((MEM[480] * MEM[384] / MEM[480] == MEM[384]) | !MEM[480]);\n                        require(0xde0b6b3a7640000);\n                        require(0 < 2);\n                        MEM[480] = MEM[480] * MEM[384] / 0xde0b6b3a7640000;\n                        MEM[544] = 1;\n                        if (2 == 1) {\n                            while (!bool(64 > 0)) {\n                                MEM[576] = 32;\n                            }\n                        }\n                    }\n                    revert();\n                }\n                MEM[416] = MEM[416];\n                MEM[448] = MEM[448];\n                while (0 >= 2) {\n                    require(0 < 2);\n                    require((MEM[416] * _balances[0] / MEM[416] == _balances[0]) | !MEM[416]);\n                    require(0xde0b6b3a7640000);\n                    require(0 < 2);\n                    MEM[416] = MEM[416] * _balances[0] / 0xde0b6b3a7640000;\n                    MEM[480] = 1;\n                    if (2 == 1) {\n                        while (!bool(64 > 0)) {\n                            MEM[512] = 32;\n                        }\n                    }\n                }\n                revert();\n            } else {\n                MEM[352] = 1;\n                MEM[384] = 0xe8d4a51000;\n                MEM[416] = 1;\n                MEM[448] = 1;\n                while (1) {\n                    MEM[512] = 0xde0b6b3a7640000;\n                    if (0 < 2) {\n                        break;\n                    }\n                    if (MEM[416]) {\n                        require(MEM[480] < 2);\n                        require((_coins[MEM[480]]).code.size);\n                        require(MEM[480] < 2);\n                        require(this ^ _coins[MEM[480]]);\n                        require(MEM[480] < 2);\n                        v4 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n                        require(v4);\n                        MEM[512] = MEM[640];\n                    }\n                    require(0 < 2);\n                    require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n                    MEM[352] = MEM[352] * MEM[512];\n                    MEM[480] = 1;\n                    if (2 == 1) {\n                        while (!bool(64 > 0)) {\n                            MEM[672] = 32;\n                        }\n                    }\n                }\n                revert();\n            }\n        } else {\n            MEM[352] = 1;\n            MEM[384] = 0xe8d4a51000;\n            MEM[416] = 1;\n            MEM[448] = 1;\n            while (1) {\n                MEM[512] = 0xde0b6b3a7640000;\n                if (0 < 2) {\n                    break;\n                }\n                if (MEM[416]) {\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v5 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n                    require(v5);\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v6 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n                    require(v6);\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v7 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n                    require(v7);\n                    require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n                    require(block.number >= MEM[960]);\n                    require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n                    require(0xde0b6b3a7640000);\n                    require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n                    MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n                }\n                require(0 < 2);\n                require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n                MEM[352] = MEM[352] * MEM[512];\n                MEM[480] = 1;\n                if (2 == 1) {\n                    while (!bool(64 > 0)) {\n                        MEM[992] = 32;\n                    }\n                }\n            }\n            revert();\n        }\n    }\n    revert();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.10.11 02:04 UTC\n// Warning: 57.99999999999999% of the contract's code is inferred to be dead code.\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _coins; // STORAGE[0x0]\nuint256[] _underlying_coins; // STORAGE[0x1]\nuint256[] _balances; // STORAGE[0x2]\nuint256 _a; // STORAGE[0x3]\nuint256 _fee; // STORAGE[0x4]\nuint256 _admin_fee; // STORAGE[0x5]\nuint256 _owner; // STORAGE[0x6]\nuint256 stor_7; // STORAGE[0x7]\nuint256 _admin_actions_deadline; // STORAGE[0x8]\nuint256 _transfer_ownership_deadline; // STORAGE[0x9]\nuint256 _future_A; // STORAGE[0xa]\nuint256 _future_fee; // STORAGE[0xb]\nuint256 _future_admin_fee; // STORAGE[0xc]\nuint256 _future_owner; // STORAGE[0xd]\nuint256 stor_e; // STORAGE[0xe]\nuint256 stor_f; // STORAGE[0xf]\nuint256 _exchange; // STORAGE[0xffffff]\n\n\n// Events\nRemoveLiquidity(address, uint256[2], uint256[2], uint256);\nCommitNewParameters(uint256, uint256, uint256, uint256);\nNewParameters(uint256, uint256, uint256);\nCommitNewAdmin(uint256, address);\nNewAdmin(address);\n\nfunction get_virtual_price() public nonPayable { \n    while (352 < 1248) {\n    }\n    MEM[1280] = 0x7b08bb90;\n    while (352 < 992) {\n    }\n    MEM[1024] = 0x96b414ec;\n    while (352 < 896) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction calc_token_amount(uint256[2] varg0) public nonPayable { \n    require(varg0 < 2);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction add_liquidity() public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(!stor_f);\n    MEM[320] = 0;\n    MEM[352] = 0;\n    MEM[384] = 1;\n    MEM[416] = 1;\n    MEM[448] = 0;\n    MEM[480] = 0;\n    require(((_fee << 1) / _fee == 2) | !_fee);\n    require(4);\n    MEM[512] = _fee << 1 >> 2;\n    MEM[544] = _admin_fee;\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    MEM[576] = MEM[704];\n    while (352 < 800) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v1);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dy(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dx(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dy_underlying(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction get_dx_underlying(int128 varg0, int128 varg1) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n            require(v0);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n            require(v1);\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v2 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n            require(v2);\n            require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n            require(block.number >= MEM[960]);\n            require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n            require(0xde0b6b3a7640000);\n            require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n            MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[992] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction exchange(int128 varg0, int128 varg1) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v0);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction exchange_underlying(int128 varg0, int128 varg1) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg1 <= MEM[64]);\n    require(varg1 >= MEM[96]);\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v0 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v0);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction remove_liquidity(uint256 varg0) public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    MEM[608] = 0;\n    MEM[640] = 0;\n    MEM[672] = 1;\n    MEM[704] = 1;\n    while (0 >= 2) {\n        require((_balances[0] * varg0 / _balances[0] == varg0) | !_balances[0]);\n        require(MEM[448]);\n        v1 = _balances[0] * varg0 / MEM[448];\n        require(0 < 2);\n        require(v1 >= msg.data[36], Error(32, 48, 'Withdrawal resulted in fewer coi', 'ns than expected'));\n        require(0 < 2);\n        require(_balances[0] >= v1);\n        _balances[0] = _balances[0] - v1;\n        require(0 < 2);\n        MEM[480] = v1;\n        require(0 < 2);\n        require(0 < 2);\n        if (!(MEM[0x260] & !MEM[0x2a0])) {\n            require(MEM[736] < 2);\n            require((_coins[MEM[736]]).code.size);\n            require(MEM[736] < 2);\n            require(this ^ _coins[MEM[736]]);\n            require(MEM[736] < 2);\n            v2 = _coins[MEM[736]].transfer(msg.sender, v1).gas(msg.gas);\n            require(v2);\n            require(0x7b08bb90);\n        } else {\n            require(MEM[736] < 2);\n            require((_coins[MEM[736]]).code.size);\n            require(MEM[736] < 2);\n            require(this ^ _coins[MEM[736]]);\n            require(MEM[736] < 2);\n            v3 = _coins[MEM[736]].transfer(msg.sender, v1).gas(msg.gas);\n            require(v3);\n        }\n        MEM[736] = 1;\n        if (2 == 1) {\n            require(stor_7.code.size);\n            require(this ^ stor_7);\n            v4 = stor_7.burnFrom(msg.sender, varg0).gas(msg.gas);\n            require(v4);\n            require(MEM[448] >= varg0);\n            emit RemoveLiquidity(msg.sender, 0, 0, 0, 0, MEM[448] - varg0);\n            _exchange = 0;\n            exit;\n        }\n    }\n    revert();\n}\n\nfunction remove_liquidity_imbalance() public payable { \n    require(!_exchange);\n    _exchange = 1;\n    require(!msg.value);\n    require(!stor_f);\n    MEM[320] = 0;\n    MEM[352] = 0;\n    MEM[384] = 1;\n    MEM[416] = 1;\n    require(stor_7.code.size);\n    require(this ^ stor_7);\n    v0 = stor_7.totalSupply().gas(msg.gas);\n    require(v0);\n    require(MEM[576] > 0);\n    require(((_fee << 1) / _fee == 2) | !_fee);\n    require(4);\n    MEM[608] = _fee << 1 >> 2;\n    MEM[640] = _admin_fee;\n    while (352 < 736) {\n    }\n    MEM[352] = 1;\n    MEM[384] = 0xe8d4a51000;\n    MEM[416] = 1;\n    MEM[448] = 1;\n    while (1) {\n        MEM[512] = 0xde0b6b3a7640000;\n        if (0 < 2) {\n            break;\n        }\n        if (MEM[416]) {\n            require(MEM[480] < 2);\n            require((_coins[MEM[480]]).code.size);\n            require(MEM[480] < 2);\n            require(this ^ _coins[MEM[480]]);\n            require(MEM[480] < 2);\n            v1 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n            require(v1);\n            MEM[512] = MEM[640];\n        }\n        require(0 < 2);\n        require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n        MEM[352] = MEM[352] * MEM[512];\n        MEM[480] = 1;\n        if (2 == 1) {\n            while (!bool(64 > 0)) {\n                MEM[672] = 32;\n            }\n        }\n    }\n    revert();\n}\n\nfunction commit_new_parameters(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(!_admin_actions_deadline);\n    require(varg2 <= 0x12a05f200);\n    require(varg1 <= 0x12a05f200);\n    require(varg0 <= 0xf4240);\n    require(block.timestamp + 0x3f480 >= block.timestamp);\n    _admin_actions_deadline = block.timestamp + 0x3f480;\n    _future_A = varg0;\n    _future_fee = varg1;\n    _future_admin_fee = varg2;\n    emit CommitNewParameters(block.timestamp + 0x3f480, varg0, varg1, varg2);\n}\n\nfunction apply_new_parameters() public nonPayable { \n    require(msg.sender == _owner);\n    require((_admin_actions_deadline <= block.timestamp) & (_admin_actions_deadline > 0));\n    _admin_actions_deadline = 0;\n    _a = _future_A;\n    _fee = _future_fee;\n    _admin_fee = _future_admin_fee;\n    emit NewParameters(_future_A, _future_fee, _future_admin_fee);\n}\n\nfunction revert_new_parameters() public nonPayable { \n    require(msg.sender == _owner);\n    _admin_actions_deadline = 0;\n}\n\nfunction commit_transfer_ownership(address varg0) public nonPayable { \n    require(varg0 < MEM[32]);\n    require(msg.sender == _owner);\n    require(!_transfer_ownership_deadline);\n    require(block.timestamp + 0x3f480 >= block.timestamp);\n    _transfer_ownership_deadline = block.timestamp + 0x3f480;\n    _future_owner = varg0;\n    emit CommitNewAdmin(block.timestamp + 0x3f480, varg0);\n}\n\nfunction apply_transfer_ownership() public nonPayable { \n    require(msg.sender == _owner);\n    require((block.timestamp >= _transfer_ownership_deadline) & (_transfer_ownership_deadline > 0));\n    _transfer_ownership_deadline = 0;\n    _owner = _future_owner;\n    emit NewAdmin(_future_owner);\n}\n\nfunction revert_transfer_ownership() public nonPayable { \n    require(msg.sender == _owner);\n    _transfer_ownership_deadline = 0;\n}\n\nfunction withdraw_admin_fees() public nonPayable { \n    require(msg.sender == _owner);\n    MEM[320] = 1;\n    MEM[352] = 0xe8d4a51000;\n    MEM[384] = 0;\n    MEM[416] = 0;\n    MEM[448] = 1;\n    MEM[480] = 1;\n    while (0 >= 2) {\n        require((_coins[0]).code.size);\n        require(this ^ _coins[0]);\n        v0 = _coins[0].balanceOf(this).gas(msg.gas);\n        require(v0);\n        require(0 < 2);\n        require(MEM[736] >= _balances[0]);\n        if (MEM[736] - _balances[0] > 0) {\n            require(MEM[512] < 2);\n            require(MEM[512] < 2);\n            if (!(MEM[(MEM[512] << 5) + 384] & !MEM[(MEM[512] << 5) + 448])) {\n                require((_coins[0]).code.size);\n                require(this ^ _coins[0]);\n                v1 = _coins[0].transfer(msg.sender, MEM[736] - _balances[0]).gas(msg.gas);\n                require(v1);\n                require(MEM[928]);\n            } else {\n                require((_coins[0]).code.size);\n                require(this ^ _coins[0]);\n                v2 = _coins[0].transfer(msg.sender, MEM[736] - _balances[0]).gas(msg.gas);\n                require(v2);\n            }\n        }\n        MEM[512] = 1;\n        if (2 == 1) {\n            exit;\n        }\n    }\n    revert();\n}\n\nfunction kill_me() public nonPayable { \n    require(msg.sender == _owner);\n    require(stor_e > block.timestamp);\n    stor_f = 1;\n}\n\nfunction unkill_me() public nonPayable { \n    require(msg.sender == _owner);\n    stor_f = 0;\n}\n\nfunction coins(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _coins[varg0];\n}\n\nfunction underlying_coins(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _underlying_coins[varg0];\n}\n\nfunction balances(int128 varg0) public nonPayable { \n    require(varg0 <= MEM[64]);\n    require(varg0 >= MEM[96]);\n    require(varg0 < 2);\n    return _balances[varg0];\n}\n\nfunction A() public nonPayable { \n    return _a;\n}\n\nfunction fee() public nonPayable { \n    return _fee;\n}\n\nfunction admin_fee() public nonPayable { \n    return _admin_fee;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction admin_actions_deadline() public nonPayable { \n    return _admin_actions_deadline;\n}\n\nfunction transfer_ownership_deadline() public nonPayable { \n    return _transfer_ownership_deadline;\n}\n\nfunction future_A() public nonPayable { \n    return _future_A;\n}\n\nfunction future_fee() public nonPayable { \n    return _future_fee;\n}\n\nfunction future_admin_fee() public nonPayable { \n    return _future_admin_fee;\n}\n\nfunction future_owner() public nonPayable { \n    return _future_owner;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    if (msg.data.length >= 4) {\n        MEM[32] = 0x10000000000000000000000000000000000000000;\n        MEM[96] = int128.min;\n        MEM[128] = 0x12a05f1fffffffffffffffffffffffffdabf41c00;\n        MEM[160] = 0xfffffffffffffffffffffffed5fa0e0000000000000000000000000000000000;\n        if (!0) {\n            if (!0) {\n                if (!0) {\n                    if (!0) {\n                        if (!0) {\n                            if (!0) {\n                                if (function_selector != 0xbb7b8b80) {\n                                    if (function_selector != 0xed8e84f3) {\n                                        if (function_selector != 0xb4c7e4d) {\n                                            if (!0) {\n                                                if (function_selector != 0x5e0d443f) {\n                                                    if (function_selector != 0x67df02ca) {\n                                                        if (function_selector != 0x7211ef7) {\n                                                            if (function_selector != 0xe71d1b9) {\n                                                                if (!0) {\n                                                                    if (function_selector != 0x3df02124) {\n                                                                        if (function_selector != 0xa6417ed6) {\n                                                                            if (function_selector != 0x5b36389c) {\n                                                                                if (function_selector != 0xe3103273) {\n                                                                                    if (function_selector != 0xee11f5b6) {\n                                                                                        if (function_selector != 0x2a7dd7cd) {\n                                                                                            if (function_selector != 0x226840fb) {\n                                                                                                if (function_selector != 0x6b441a40) {\n                                                                                                    if (function_selector != 0x6a1c05ae) {\n                                                                                                        if (function_selector != 0x86fbf193) {\n                                                                                                            if (function_selector != 0x30c54085) {\n                                                                                                                if (function_selector != 0xe3698853) {\n                                                                                                                    if (function_selector != 0x3046f972) {\n                                                                                                                        if (function_selector != 0x23746eb8) {\n                                                                                                                            if (function_selector != 0xb739953e) {\n                                                                                                                                if (function_selector != 0x65a80d8) {\n                                                                                                                                    if (function_selector != 0xf446c1d0) {\n                                                                                                                                        if (function_selector != 0xddca3f43) {\n                                                                                                                                            if (function_selector != 0xfee3f7f9) {\n                                                                                                                                                if (function_selector != 0x8da5cb5b) {\n                                                                                                                                                    if (function_selector != 0x405e28f8) {\n                                                                                                                                                        if (function_selector != 0xe0a0b586) {\n                                                                                                                                                            if (function_selector != 0xb4b577ad) {\n                                                                                                                                                                if (function_selector != 0x58680d0b) {\n                                                                                                                                                                    if (function_selector != 0xe3824462) {\n                                                                                                                                                                        if (function_selector == 0x1ec0cdc1) {\n                                                                                                                                                                            future_owner();\n                                                                                                                                                                        }\n                                                                                                                                                                    } else {\n                                                                                                                                                                        future_admin_fee();\n                                                                                                                                                                    }\n                                                                                                                                                                } else {\n                                                                                                                                                                    future_fee();\n                                                                                                                                                                }\n                                                                                                                                                            } else {\n                                                                                                                                                                future_A();\n                                                                                                                                                            }\n                                                                                                                                                        } else {\n                                                                                                                                                            transfer_ownership_deadline();\n                                                                                                                                                        }\n                                                                                                                                                    } else {\n                                                                                                                                                        admin_actions_deadline();\n                                                                                                                                                    }\n                                                                                                                                                } else {\n                                                                                                                                                    owner();\n                                                                                                                                                }\n                                                                                                                                            } else {\n                                                                                                                                                admin_fee();\n                                                                                                                                            }\n                                                                                                                                        } else {\n                                                                                                                                            fee();\n                                                                                                                                        }\n                                                                                                                                    } else {\n                                                                                                                                        A();\n                                                                                                                                    }\n                                                                                                                                } else {\n                                                                                                                                    balances(int128);\n                                                                                                                                }\n                                                                                                                            } else {\n                                                                                                                                underlying_coins(int128);\n                                                                                                                            }\n                                                                                                                        } else {\n                                                                                                                            coins(int128);\n                                                                                                                        }\n                                                                                                                    } else {\n                                                                                                                        unkill_me();\n                                                                                                                    }\n                                                                                                                } else {\n                                                                                                                    kill_me();\n                                                                                                                }\n                                                                                                            } else {\n                                                                                                                withdraw_admin_fees();\n                                                                                                            }\n                                                                                                        } else {\n                                                                                                            revert_transfer_ownership();\n                                                                                                        }\n                                                                                                    } else {\n                                                                                                        apply_transfer_ownership();\n                                                                                                    }\n                                                                                                } else {\n                                                                                                    commit_transfer_ownership(address);\n                                                                                                }\n                                                                                            } else {\n                                                                                                revert_new_parameters();\n                                                                                            }\n                                                                                        } else {\n                                                                                            apply_new_parameters();\n                                                                                        }\n                                                                                    } else {\n                                                                                        commit_new_parameters(uint256,uint256,uint256);\n                                                                                    }\n                                                                                } else {\n                                                                                    remove_liquidity_imbalance(uint256[2],uint256);\n                                                                                }\n                                                                            } else {\n                                                                                remove_liquidity(uint256,uint256[2]);\n                                                                            }\n                                                                        } else {\n                                                                            exchange_underlying(int128,int128,uint256,uint256);\n                                                                        }\n                                                                    } else {\n                                                                        exchange(int128,int128,uint256,uint256);\n                                                                    }\n                                                                } else {\n                                                                    require(!stor_f);\n                                                                    MEM[608] = 0x96b414ec;\n                                                                }\n                                                            } else {\n                                                                get_dx_underlying(int128,int128,uint256);\n                                                            }\n                                                        } else {\n                                                            get_dy_underlying(int128,int128,uint256);\n                                                        }\n                                                    } else {\n                                                        get_dx(int128,int128,uint256);\n                                                    }\n                                                } else {\n                                                    get_dy(int128,int128,uint256);\n                                                }\n                                            } else {\n                                                require((MEM[352] < 2) & ((MEM[320] < 2) & ((MEM[352] >= 0) & ((MEM[320] != MEM[352]) & (MEM[320] >= 0)))));\n                                                MEM[576] = 0x7b08bb90;\n                                            }\n                                        } else {\n                                            add_liquidity(uint256[2],uint256);\n                                        }\n                                    } else {\n                                        calc_token_amount(uint256[2],bool);\n                                    }\n                                } else {\n                                    get_virtual_price();\n                                }\n                            } else {\n                                while (352 < 1120) {\n                                }\n                                MEM[1152] = 0x7b08bb90;\n                                while (352 < 800) {\n                                }\n                                MEM[832] = 0x575e285f;\n                            }\n                        }\n                        MEM[320] = MEM[416];\n                        MEM[352] = MEM[448];\n                        while (0 + MEM[320] < 0) {\n                            MEM[480] = 1;\n                            if (2 == 1) {\n                                if (bool(0 + MEM[320])) {\n                                    MEM[544] = 0;\n                                    require(((_a << 1) / _a == 2) | !_a);\n                                    while (1) {\n                                        while (!((v0 * v0 / v0 == v0) | !v0)) {\n                                            require(((MEM[320] << 1) / MEM[320] == 2) | !MEM[320]);\n                                            require((MEM[320] << 1) + 1 >= MEM[320] << 1);\n                                            require((MEM[320] << 1) + 1);\n                                            v1 = v0 * v0 / ((MEM[320] << 1) + 1);\n                                            MEM[736] = 1;\n                                            if (2 == 1) {\n                                                v2 = (_a << 1) * (0 + MEM[320]);\n                                                require((v2 / (_a << 1) == 0 + MEM[320]) | !(_a << 1));\n                                                require(((v1 << 1) / v1 == 2) | !v1);\n                                                require(v2 + (v1 << 1) >= v2);\n                                                require(((v2 + (v1 << 1)) * v0 / (v2 + (v1 << 1)) == v0) | !(v2 + (v1 << 1)));\n                                                require(_a << 1 >= 1);\n                                                require((((_a << 1) - 1) * v0 / ((_a << 1) - 1) == v0) | !((_a << 1) - 1));\n                                                require((3 * v1 / 3 == v1) | !0x3);\n                                                require(((_a << 1) - 1) * v0 + 3 * v1 >= ((_a << 1) - 1) * v0);\n                                                require(((_a << 1) - 1) * v0 + 3 * v1);\n                                                v3 = (v2 + (v1 << 1)) * v0 / (((_a << 1) - 1) * v0 + 3 * v1);\n                                                if (v3 <= v0) {\n                                                    require(v0 >= v3);\n                                                    if (!bool(v0 - v3 > 1)) {\n                                                        // Unknown jump to Block 0xa67. Refer to 3-address code (TAC);\n                                                    }\n                                                } else {\n                                                    require(v3 >= v0);\n                                                    if (!bool(v3 - v0 > 1)) {\n                                                    }\n                                                }\n                                                MEM[640] = 1;\n                                                if (uint8.max != 1) {\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    revert();\n                                }\n                            }\n                        }\n                        revert();\n                    }\n                    MEM[384] = MEM[384];\n                    MEM[416] = MEM[416];\n                    MEM[480] = MEM[320];\n                    MEM[512] = MEM[352];\n                    while (0 >= 2) {\n                        require(0 < 2);\n                        require((MEM[480] * MEM[384] / MEM[480] == MEM[384]) | !MEM[480]);\n                        require(0xde0b6b3a7640000);\n                        require(0 < 2);\n                        MEM[480] = MEM[480] * MEM[384] / 0xde0b6b3a7640000;\n                        MEM[544] = 1;\n                        if (2 == 1) {\n                            while (!bool(64 > 0)) {\n                                MEM[576] = 32;\n                            }\n                        }\n                    }\n                    revert();\n                }\n                MEM[416] = MEM[416];\n                MEM[448] = MEM[448];\n                while (0 >= 2) {\n                    require(0 < 2);\n                    require((MEM[416] * _balances[0] / MEM[416] == _balances[0]) | !MEM[416]);\n                    require(0xde0b6b3a7640000);\n                    require(0 < 2);\n                    MEM[416] = MEM[416] * _balances[0] / 0xde0b6b3a7640000;\n                    MEM[480] = 1;\n                    if (2 == 1) {\n                        while (!bool(64 > 0)) {\n                            MEM[512] = 32;\n                        }\n                    }\n                }\n                revert();\n            } else {\n                MEM[352] = 1;\n                MEM[384] = 0xe8d4a51000;\n                MEM[416] = 1;\n                MEM[448] = 1;\n                while (1) {\n                    MEM[512] = 0xde0b6b3a7640000;\n                    if (0 < 2) {\n                        break;\n                    }\n                    if (MEM[416]) {\n                        require(MEM[480] < 2);\n                        require((_coins[MEM[480]]).code.size);\n                        require(MEM[480] < 2);\n                        require(this ^ _coins[MEM[480]]);\n                        require(MEM[480] < 2);\n                        v4 = _coins[MEM[480]].exchangeRateCurrent().gas(msg.gas);\n                        require(v4);\n                        MEM[512] = MEM[640];\n                    }\n                    require(0 < 2);\n                    require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n                    MEM[352] = MEM[352] * MEM[512];\n                    MEM[480] = 1;\n                    if (2 == 1) {\n                        while (!bool(64 > 0)) {\n                            MEM[672] = 32;\n                        }\n                    }\n                }\n                revert();\n            }\n        } else {\n            MEM[352] = 1;\n            MEM[384] = 0xe8d4a51000;\n            MEM[416] = 1;\n            MEM[448] = 1;\n            while (1) {\n                MEM[512] = 0xde0b6b3a7640000;\n                if (0 < 2) {\n                    break;\n                }\n                if (MEM[416]) {\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v5 = _coins[MEM[480]].exchangeRateStored().gas(msg.gas);\n                    require(v5);\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v6 = _coins[MEM[480]].supplyRatePerBlock().gas(msg.gas);\n                    require(v6);\n                    require(MEM[480] < 2);\n                    require((_coins[MEM[480]]).code.size);\n                    require(MEM[480] < 2);\n                    require(this ^ _coins[MEM[480]]);\n                    require(MEM[480] < 2);\n                    v7 = _coins[MEM[480]].accrualBlockNumber().gas(msg.gas);\n                    require(v7);\n                    require((MEM[640] * MEM[800] / MEM[640] == MEM[800]) | !MEM[640]);\n                    require(block.number >= MEM[960]);\n                    require((MEM[640] * MEM[800] * (block.number - MEM[960]) / (MEM[640] * MEM[800]) == block.number - MEM[960]) | !(MEM[640] * MEM[800]));\n                    require(0xde0b6b3a7640000);\n                    require(MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000 >= MEM[640]);\n                    MEM[512] = MEM[640] + MEM[640] * MEM[800] * (block.number - MEM[960]) / 0xde0b6b3a7640000;\n                }\n                require(0 < 2);\n                require((MEM[352] * MEM[512] / MEM[352] == MEM[512]) | !MEM[352]);\n                MEM[352] = MEM[352] * MEM[512];\n                MEM[480] = 1;\n                if (2 == 1) {\n                    while (!bool(64 > 0)) {\n                        MEM[992] = 32;\n                    }\n                }\n            }\n            revert();\n        }\n    }\n    revert();\n}\n.",
	"status": "1",
	"time_cost": 86.5064024925232,
	"usage": {
		"completion_tokens": 1411,
		"prompt_tokens": 11375,
		"total_tokens": 12786
	}
}