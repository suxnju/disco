{
	"address": "0x5bafed0caa396408b7650dc774a10cfb2a921399",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code for the given decompiled EVM Bytecode.\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract ProxyContract {\n    address public stor3608;\n    address public storB531;\n\n    constructor(address _stor3608, address _storB531) {\n        stor3608 = _stor3608;\n        storB531 = _storB531;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == storB531);\n        _;\n    }\n\n    function admin() external view onlyOwner returns (address) {\n        return storB531;\n    }\n\n    function implementation() external view onlyOwner returns (address) {\n        return stor3608;\n    }\n\n    fallback() external payable {\n        require(msg.sender != storB531, 'TransparentUpgradeableProxy: admin cannot fallback to proxy target');\n        (bool success,) = stor3608.delegatecall(msg.data);\n        require(success);\n    }\n\n    function upgradeTo(address _implementation) external onlyOwner {\n        require(_implementation != address(0), 'ERC1967: new implementation is not a contract');\n        stor3608 = _implementation;\n        emit Upgraded(_implementation);\n    }\n\n    function changeAdmin(address _admin) external onlyOwner {\n        require(_admin != address(0), 'ERC1967: new admin is the zero address');\n        emit AdminChanged(storB531, _admin);\n        storB531 = _admin;\n    }\n\n    function upgradeToAndCall(address _implementation, bytes memory _data) external payable onlyOwner {\n        require(_implementation != address(0), 'ERC1967: new implementation is not a contract');\n        stor3608 = _implementation;\n        emit Upgraded(_implementation);\n        (bool success,) = _implementation.delegatecall(_data);\n        require(success, 'Address: delegate call to non-contract');\n    }\n    \n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n}\n```\n\nNote that the original decompiled code was quite complex and made use of low-level opcodes. The above Solidity code is a high-level approximation of the same logic. It may not behave exactly the same as the original contract in all edge cases, particularly in terms of gas costs and error handling.",
				"role": "assistant"
			}
		}
	],
	"created": 1700631782,
	"id": "chatcmpl-8NaIoCHVl2Zd01RcXKA5cMrhwoCiX",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n\ndef storage:\n  stor3608 is addr at storage 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n  storB531 is addr at storage 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\n\ndef admin(): # not payable\n  if caller == storB531:\n      return storB531\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef implementation(): # not payable\n  if caller == storB531:\n      return stor3608\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef _fallback() payable: # default function\n  if caller == storB531:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  'TransparentUpgradeableProxy: admin cannot fallback to proxy target'\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef upgradeTo(address _implementation): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require _implementation == _implementation\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  if not ext_code.size(_implementation):\n      revert with 0, 'ERC1967: new implementation is not a contract'\n  stor3608 = _implementation\n  log Upgraded(address nextVersion=_implementation)\n\ndef changeAdmin(address _admin): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require _admin_ == _admin_\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  log AdminChanged(\n        address from=storB531,\n        address to=_admin_)\n  if not _admin_:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1967: new admin is the zero address'\n  storB531 = _admin_\n\ndef upgradeToAndCall(address _implementation, bytes _data) payable: \n  require calldata.size - 4 >=\u2032 64\n  require _implementation == _implementation\n  require _data <= 18446744073709551615\n  require _data + 35 <\u2032 calldata.size\n  require _data.length <= 18446744073709551615\n  require _data + _data.length + 36 <= calldata.size\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  mem[128 len _data.length] = _data[all]\n  mem[_data.length + 128] = 0\n  if not ext_code.size(_implementation):\n      revert with 0, 'ERC1967: new implementation is not a contract'\n  stor3608 = _implementation\n  log Upgraded(address nextVersion=_implementation)\n  mem[ceil32(_data.length) + 128] = 39\n  mem[ceil32(_data.length) + 160 len 39] = 0xfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c65\n  if not ext_code.size(_implementation):\n      revert with 0, 'Address: delegate call to non-contract'\n  mem[ceil32(_data.length) + 224 len ceil32(_data.length)] = _data[all], mem[_data.length + 128 len ceil32(_data.length) - _data.length]\n  if ceil32(_data.length) > _data.length:\n      mem[_data.length + ceil32(_data.length) + 224] = 0\n  delegate _implementation.mem[ceil32(_data.length) + 224 len 4] with:\n       gas gas_remaining wei\n      args mem[ceil32(_data.length) + 228 len _data.length - 4]\n  if not return_data.size:\n      if delegate.return_code:\n          stop\n      if _data.length:\n          revert with _data[all]\n      mem[ceil32(_data.length) + 224] = 0x8c379a000000000000000000000000000000000000000000000000000000000\n      mem[ceil32(_data.length) + 228] = 32\n      mem[ceil32(_data.length) + 260] = Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]\n      mem[ceil32(_data.length) + 292 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])] = mem[ceil32(_data.length) + 160 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])]\n      if ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) > Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]:\n          mem[Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)] + ceil32(_data.length) + 292] = 0\n      revert with memory\n        from ceil32(_data.length) + 224\n         len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) + 68\n  mem[ceil32(_data.length) + 224] = return_data.size\n  mem[ceil32(_data.length) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]\n  if delegate.return_code:\n      stop\n  if return_data.size:\n      revert with ext_call.return_data[0 len return_data.size]\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 225] = 0x8c379a000000000000000000000000000000000000000000000000000000000\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 229] = 32\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 261] = Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 293 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])] = mem[ceil32(_data.length) + 160 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])]\n  if ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) > Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]:\n      mem[Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)] + ceil32(_data.length) + ceil32(return_data.size) + 293] = 0\n  revert with memory\n    from ceil32(_data.length) + ceil32(return_data.size) + 225\n     len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) + 68\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor3608 is addr at storage 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n  storB531 is addr at storage 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\n\ndef admin(): # not payable\n  if caller == storB531:\n      return storB531\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef implementation(): # not payable\n  if caller == storB531:\n      return stor3608\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef _fallback() payable: # default function\n  if caller == storB531:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  'TransparentUpgradeableProxy: admin cannot fallback to proxy target'\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef upgradeTo(address _implementation): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require _implementation == _implementation\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  if not ext_code.size(_implementation):\n      revert with 0, 'ERC1967: new implementation is not a contract'\n  stor3608 = _implementation\n  log Upgraded(address nextVersion=_implementation)\n\ndef changeAdmin(address _admin): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require _admin_ == _admin_\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  log AdminChanged(\n        address from=storB531,\n        address to=_admin_)\n  if not _admin_:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1967: new admin is the zero address'\n  storB531 = _admin_\n\ndef upgradeToAndCall(address _implementation, bytes _data) payable: \n  require calldata.size - 4 >=\u2032 64\n  require _implementation == _implementation\n  require _data <= 18446744073709551615\n  require _data + 35 <\u2032 calldata.size\n  require _data.length <= 18446744073709551615\n  require _data + _data.length + 36 <= calldata.size\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  mem[128 len _data.length] = _data[all]\n  mem[_data.length + 128] = 0\n  if not ext_code.size(_implementation):\n      revert with 0, 'ERC1967: new implementation is not a contract'\n  stor3608 = _implementation\n  log Upgraded(address nextVersion=_implementation)\n  mem[ceil32(_data.length) + 128] = 39\n  mem[ceil32(_data.length) + 160 len 39] = 0xfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c65\n  if not ext_code.size(_implementation):\n      revert with 0, 'Address: delegate call to non-contract'\n  mem[ceil32(_data.length) + 224 len ceil32(_data.length)] = _data[all], mem[_data.length + 128 len ceil32(_data.length) - _data.length]\n  if ceil32(_data.length) > _data.length:\n      mem[_data.length + ceil32(_data.length) + 224] = 0\n  delegate _implementation.mem[ceil32(_data.length) + 224 len 4] with:\n       gas gas_remaining wei\n      args mem[ceil32(_data.length) + 228 len _data.length - 4]\n  if not return_data.size:\n      if delegate.return_code:\n          stop\n      if _data.length:\n          revert with _data[all]\n      mem[ceil32(_data.length) + 224] = 0x8c379a000000000000000000000000000000000000000000000000000000000\n      mem[ceil32(_data.length) + 228] = 32\n      mem[ceil32(_data.length) + 260] = Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]\n      mem[ceil32(_data.length) + 292 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])] = mem[ceil32(_data.length) + 160 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])]\n      if ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) > Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]:\n          mem[Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)] + ceil32(_data.length) + 292] = 0\n      revert with memory\n        from ceil32(_data.length) + 224\n         len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) + 68\n  mem[ceil32(_data.length) + 224] = return_data.size\n  mem[ceil32(_data.length) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]\n  if delegate.return_code:\n      stop\n  if return_data.size:\n      revert with ext_call.return_data[0 len return_data.size]\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 225] = 0x8c379a000000000000000000000000000000000000000000000000000000000\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 229] = 32\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 261] = Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 293 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])] = mem[ceil32(_data.length) + 160 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])]\n  if ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) > Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]:\n      mem[Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)] + ceil32(_data.length) + ceil32(return_data.size) + 293] = 0\n  revert with memory\n    from ceil32(_data.length) + ceil32(return_data.size) + 225\n     len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) + 68\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n\ndef storage:\n  stor3608 is addr at storage 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n  storB531 is addr at storage 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\n\ndef admin(): # not payable\n  if caller == storB531:\n      return storB531\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef implementation(): # not payable\n  if caller == storB531:\n      return stor3608\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef _fallback() payable: # default function\n  if caller == storB531:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, \n                  'TransparentUpgradeableProxy: admin cannot fallback to proxy target'\n  delegate stor3608 with:\n     funct call.data[0 len 4]\n       gas gas_remaining wei\n      args call.data[4 len calldata.size - 4]\n  if not delegate.return_code:\n      revert with ext_call.return_data[0 len return_data.size]\n  return ext_call.return_data[0 len return_data.size]\n\ndef upgradeTo(address _implementation): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require _implementation == _implementation\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  if not ext_code.size(_implementation):\n      revert with 0, 'ERC1967: new implementation is not a contract'\n  stor3608 = _implementation\n  log Upgraded(address nextVersion=_implementation)\n\ndef changeAdmin(address _admin): # not payable\n  require calldata.size - 4 >=\u2032 32\n  require _admin_ == _admin_\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  log AdminChanged(\n        address from=storB531,\n        address to=_admin_)\n  if not _admin_:\n      revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC1967: new admin is the zero address'\n  storB531 = _admin_\n\ndef upgradeToAndCall(address _implementation, bytes _data) payable: \n  require calldata.size - 4 >=\u2032 64\n  require _implementation == _implementation\n  require _data <= 18446744073709551615\n  require _data + 35 <\u2032 calldata.size\n  require _data.length <= 18446744073709551615\n  require _data + _data.length + 36 <= calldata.size\n  if storB531 != caller:\n      delegate stor3608 with:\n         funct call.data[0 len 4]\n           gas gas_remaining wei\n          args call.data[4 len calldata.size - 4]\n      if not delegate.return_code:\n          revert with ext_call.return_data[0 len return_data.size]\n      return ext_call.return_data[0 len return_data.size]\n  mem[128 len _data.length] = _data[all]\n  mem[_data.length + 128] = 0\n  if not ext_code.size(_implementation):\n      revert with 0, 'ERC1967: new implementation is not a contract'\n  stor3608 = _implementation\n  log Upgraded(address nextVersion=_implementation)\n  mem[ceil32(_data.length) + 128] = 39\n  mem[ceil32(_data.length) + 160 len 39] = 0xfe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c65\n  if not ext_code.size(_implementation):\n      revert with 0, 'Address: delegate call to non-contract'\n  mem[ceil32(_data.length) + 224 len ceil32(_data.length)] = _data[all], mem[_data.length + 128 len ceil32(_data.length) - _data.length]\n  if ceil32(_data.length) > _data.length:\n      mem[_data.length + ceil32(_data.length) + 224] = 0\n  delegate _implementation.mem[ceil32(_data.length) + 224 len 4] with:\n       gas gas_remaining wei\n      args mem[ceil32(_data.length) + 228 len _data.length - 4]\n  if not return_data.size:\n      if delegate.return_code:\n          stop\n      if _data.length:\n          revert with _data[all]\n      mem[ceil32(_data.length) + 224] = 0x8c379a000000000000000000000000000000000000000000000000000000000\n      mem[ceil32(_data.length) + 228] = 32\n      mem[ceil32(_data.length) + 260] = Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]\n      mem[ceil32(_data.length) + 292 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])] = mem[ceil32(_data.length) + 160 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])]\n      if ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) > Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]:\n          mem[Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)] + ceil32(_data.length) + 292] = 0\n      revert with memory\n        from ceil32(_data.length) + 224\n         len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) + 68\n  mem[ceil32(_data.length) + 224] = return_data.size\n  mem[ceil32(_data.length) + 256 len return_data.size] = ext_call.return_data[0 len return_data.size]\n  if delegate.return_code:\n      stop\n  if return_data.size:\n      revert with ext_call.return_data[0 len return_data.size]\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 225] = 0x8c379a000000000000000000000000000000000000000000000000000000000\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 229] = 32\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 261] = Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]\n  mem[ceil32(_data.length) + ceil32(return_data.size) + 293 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])] = mem[ceil32(_data.length) + 160 len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)])]\n  if ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) > Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]:\n      mem[Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)] + ceil32(_data.length) + ceil32(return_data.size) + 293] = 0\n  revert with memory\n    from ceil32(_data.length) + ceil32(return_data.size) + 225\n     len ceil32(Mask(8 * -ceil32(_data.length) + _data.length + 32, 0, 0), mem[_data.length + 160 len -_data.length + ceil32(_data.length)]) + 68\n\n.",
	"status": "1",
	"time_cost": 35.27539801597595,
	"usage": {
		"completion_tokens": 469,
		"prompt_tokens": 2372,
		"total_tokens": 2841
	}
}