{
	"address": "0x5bafed0caa396408b7650dc774a10cfb2a921399",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Given the complexity of the decompiled code, I'll provide a high-level Solidity contract that implements the main functionality inferred from the code above. It is important to note that the actual Solidity contract may have more functionalities than what are inferred from the decompiled code. \n\nPlease note that the decompiled code is not a perfect representation of the original Solidity code and certain syntax or features may not be exactly translatable. Here is a basic implementation for the contract:\n\n```solidity\npragma solidity ^0.8.2;\n\ncontract MyContract {\n    address private _upgradeTo;\n    address private stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19;\n    \n    event Upgraded(address indexed newAddress);\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\n\n    modifier onlyUpgradeTo() {\n        require(msg.sender == _upgradeTo, \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        _;\n    }\n\n    function upgradeTo(address newAddress) public onlyUpgradeTo {\n        require(newAddress != address(0), \"ERC1967: new implementation is not a contract\");\n        stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19 = newAddress;\n        emit Upgraded(newAddress);\n    }\n\n    function upgradeToAndCall(address newAddress, bytes memory data) public payable onlyUpgradeTo {\n        upgradeTo(newAddress);\n        (bool success,) = newAddress.delegatecall(data);\n        require(success, \"Address: delegate call to non-contract\");\n    }\n\n    function changeAdmin(address newAdmin) public onlyUpgradeTo {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        emit AdminChanged(_upgradeTo, newAdmin);\n        _upgradeTo = newAdmin;\n    }\n\n    function implementation() public view returns (address) {\n        return stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19;\n    }\n\n    function admin() public view returns (address) {\n        return _upgradeTo;\n    }\n\n    fallback() external payable {\n        require(msg.sender != _upgradeTo, \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        address target = implementation();\n        require(target != address(0), \"Target address cannot be 0x0\");\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), target, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n```\nThe functions `upgradeTo`, `upgradeToAndCall`, `changeAdmin`, `implementation`, and `admin` match the functionality described in the decompiled code. The `fallback` function is used to allow the contract to receive Ether and to delegate arbitrary calls to the implementation contract.",
				"role": "assistant"
			}
		}
	],
	"created": 1701485891,
	"id": "chatcmpl-8RAUlijMKA2EZz8tum2KuaagUYfJX",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2022.11.23 16:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc] bytes 0 to 19\nuint256 _upgradeTo; // STORAGE[0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103] bytes 0 to 19\n\n// Events\nUpgraded(address);\nAdminChanged(address, address);\n\nfunction 0x1d0() private { \n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return ;\n    } else {\n        v2 = 0x331();\n        return v2;\n    }\n}\n\nfunction 0x235() private { \n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _upgradeTo;\n    }\n}\n\nfunction 0x292() private { \n    require(msg.sender != _upgradeTo, Error('TransparentUpgradeableProxy: admin cannot fallback to proxy target'));\n    return ;\n}\n\nfunction 0x331() private { \n    return stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19;\n}\n\nfunction 0x392(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg2.code.size, Error('ERC1967: new implementation is not a contract'));\n    stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19 = varg2;\n    emit Upgraded(address(varg2));\n    varg0 = v0 = varg1.word0 > 0;\n    if (!varg0) {\n        return ;\n    } else {\n        require(varg2.code.size, Error('Address: delegate call to non-contract'));\n        v1 = v2 = 0;\n        while (v1 < varg1.word0) {\n            MEM[v1 + v3.data] = varg1[v1];\n            v1 += 32;\n        }\n        if (v1 > varg1.word0) {\n            MEM[varg1.word0 + v3.data] = 0;\n            goto 0x7a6B0x260B0x3e2;\n        }\n        v4, v5, v6 = address(varg2).delegatecall(v3.data).gas(msg.gas);\n        if (RETURNDATASIZE() == 0) {\n            v7 = v8 = 96;\n        } else {\n            v7 = v9 = new bytes[](RETURNDATASIZE());\n            RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n        }\n        if (!v4) {\n            require(!MEM[v7]v6, MEM[v7]);\n            v10 = new array[](v11.length);\n            v12 = v13 = 0;\n            while (v12 < v11.length) {\n                v10[v12] = v11[v12];\n                v12 += 32;\n            }\n            if (v12 > v11.length) {\n                v10[v11.length] = 0;\n                goto 0x7cfB0x4ffB0x260B0x3e2;\n            }\n            revert(Error(v10));\n        } else {\n            return ;\n        }\n    }\n}\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        v2 = new struct(1);\n        v2.word0 = 0;\n        0x392(0, v2, varg0);\n    }\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 <= 0xffffffffffffffff);\n    require(4 + varg1 + 31 < msg.data.length);\n    require(varg1.length <= 0xffffffffffffffff);\n    require(4 + varg1 + varg1.length + 32 <= msg.data.length);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        v2 = new bytes[](varg1.length);\n        CALLDATACOPY(v2.data, 4 + varg1 + 32, varg1.length);\n        v2[varg1.length] = 0;\n        0x392(1, v2, varg0);\n    }\n}\n\nfunction () public payable { \n    0x292();\n    v0 = 0x331();\n    v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n\nfunction implementation() public nonPayable { \n    v0 = 0x1d0();\n    return address(v0);\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        emit AdminChanged(_upgradeTo, varg0);\n        require(varg0, Error('ERC1967: new admin is the zero address'));\n        _upgradeTo = varg0;\n        goto 0x5b0xc9;\n    }\n}\n\nfunction admin() public nonPayable { \n    v0 = 0x235();\n    return address(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        if (!msg.data.length) {\n            ();\n        }\n    } else if (0x3659cfe6 == function_selector >> 224) {\n        upgradeTo(address);\n    } else if (0x4f1ef286 == function_selector >> 224) {\n        upgradeToAndCall(address,bytes);\n    } else if (0x5c60da1b == function_selector >> 224) {\n        implementation();\n    } else if (0x8f283970 == function_selector >> 224) {\n        changeAdmin(address);\n    } else if (0xf851a440 == function_selector >> 224) {\n        admin();\n    }\n    0x292();\n    v0 = 0x331();\n    v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.23 16:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc] bytes 0 to 19\nuint256 _upgradeTo; // STORAGE[0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103] bytes 0 to 19\n\n// Events\nUpgraded(address);\nAdminChanged(address, address);\n\nfunction 0x1d0() private { \n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return ;\n    } else {\n        v2 = 0x331();\n        return v2;\n    }\n}\n\nfunction 0x235() private { \n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _upgradeTo;\n    }\n}\n\nfunction 0x292() private { \n    require(msg.sender != _upgradeTo, Error('TransparentUpgradeableProxy: admin cannot fallback to proxy target'));\n    return ;\n}\n\nfunction 0x331() private { \n    return stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19;\n}\n\nfunction 0x392(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg2.code.size, Error('ERC1967: new implementation is not a contract'));\n    stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19 = varg2;\n    emit Upgraded(address(varg2));\n    varg0 = v0 = varg1.word0 > 0;\n    if (!varg0) {\n        return ;\n    } else {\n        require(varg2.code.size, Error('Address: delegate call to non-contract'));\n        v1 = v2 = 0;\n        while (v1 < varg1.word0) {\n            MEM[v1 + v3.data] = varg1[v1];\n            v1 += 32;\n        }\n        if (v1 > varg1.word0) {\n            MEM[varg1.word0 + v3.data] = 0;\n            goto 0x7a6B0x260B0x3e2;\n        }\n        v4, v5, v6 = address(varg2).delegatecall(v3.data).gas(msg.gas);\n        if (RETURNDATASIZE() == 0) {\n            v7 = v8 = 96;\n        } else {\n            v7 = v9 = new bytes[](RETURNDATASIZE());\n            RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n        }\n        if (!v4) {\n            require(!MEM[v7]v6, MEM[v7]);\n            v10 = new array[](v11.length);\n            v12 = v13 = 0;\n            while (v12 < v11.length) {\n                v10[v12] = v11[v12];\n                v12 += 32;\n            }\n            if (v12 > v11.length) {\n                v10[v11.length] = 0;\n                goto 0x7cfB0x4ffB0x260B0x3e2;\n            }\n            revert(Error(v10));\n        } else {\n            return ;\n        }\n    }\n}\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        v2 = new struct(1);\n        v2.word0 = 0;\n        0x392(0, v2, varg0);\n    }\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 <= 0xffffffffffffffff);\n    require(4 + varg1 + 31 < msg.data.length);\n    require(varg1.length <= 0xffffffffffffffff);\n    require(4 + varg1 + varg1.length + 32 <= msg.data.length);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        v2 = new bytes[](varg1.length);\n        CALLDATACOPY(v2.data, 4 + varg1 + 32, varg1.length);\n        v2[varg1.length] = 0;\n        0x392(1, v2, varg0);\n    }\n}\n\nfunction () public payable { \n    0x292();\n    v0 = 0x331();\n    v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n\nfunction implementation() public nonPayable { \n    v0 = 0x1d0();\n    return address(v0);\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        emit AdminChanged(_upgradeTo, varg0);\n        require(varg0, Error('ERC1967: new admin is the zero address'));\n        _upgradeTo = varg0;\n        goto 0x5b0xc9;\n    }\n}\n\nfunction admin() public nonPayable { \n    v0 = 0x235();\n    return address(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        if (!msg.data.length) {\n            ();\n        }\n    } else if (0x3659cfe6 == function_selector >> 224) {\n        upgradeTo(address);\n    } else if (0x4f1ef286 == function_selector >> 224) {\n        upgradeToAndCall(address,bytes);\n    } else if (0x5c60da1b == function_selector >> 224) {\n        implementation();\n    } else if (0x8f283970 == function_selector >> 224) {\n        changeAdmin(address);\n    } else if (0xf851a440 == function_selector >> 224) {\n        admin();\n    }\n    0x292();\n    v0 = 0x331();\n    v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2022.11.23 16:36 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19; // STORAGE[0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc] bytes 0 to 19\nuint256 _upgradeTo; // STORAGE[0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103] bytes 0 to 19\n\n// Events\nUpgraded(address);\nAdminChanged(address, address);\n\nfunction 0x1d0() private { \n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return ;\n    } else {\n        v2 = 0x331();\n        return v2;\n    }\n}\n\nfunction 0x235() private { \n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return ;\n    } else {\n        return _upgradeTo;\n    }\n}\n\nfunction 0x292() private { \n    require(msg.sender != _upgradeTo, Error('TransparentUpgradeableProxy: admin cannot fallback to proxy target'));\n    return ;\n}\n\nfunction 0x331() private { \n    return stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19;\n}\n\nfunction 0x392(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(varg2.code.size, Error('ERC1967: new implementation is not a contract'));\n    stor_360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc_0_19 = varg2;\n    emit Upgraded(address(varg2));\n    varg0 = v0 = varg1.word0 > 0;\n    if (!varg0) {\n        return ;\n    } else {\n        require(varg2.code.size, Error('Address: delegate call to non-contract'));\n        v1 = v2 = 0;\n        while (v1 < varg1.word0) {\n            MEM[v1 + v3.data] = varg1[v1];\n            v1 += 32;\n        }\n        if (v1 > varg1.word0) {\n            MEM[varg1.word0 + v3.data] = 0;\n            goto 0x7a6B0x260B0x3e2;\n        }\n        v4, v5, v6 = address(varg2).delegatecall(v3.data).gas(msg.gas);\n        if (RETURNDATASIZE() == 0) {\n            v7 = v8 = 96;\n        } else {\n            v7 = v9 = new bytes[](RETURNDATASIZE());\n            RETURNDATACOPY(v9.data, 0, RETURNDATASIZE());\n        }\n        if (!v4) {\n            require(!MEM[v7]v6, MEM[v7]);\n            v10 = new array[](v11.length);\n            v12 = v13 = 0;\n            while (v12 < v11.length) {\n                v10[v12] = v11[v12];\n                v12 += 32;\n            }\n            if (v12 > v11.length) {\n                v10[v11.length] = 0;\n                goto 0x7cfB0x4ffB0x260B0x3e2;\n            }\n            revert(Error(v10));\n        } else {\n            return ;\n        }\n    }\n}\n\nfunction upgradeTo(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        v2 = new struct(1);\n        v2.word0 = 0;\n        0x392(0, v2, varg0);\n    }\n}\n\nfunction upgradeToAndCall(address varg0, bytes varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(varg0 == varg0);\n    require(varg1 <= 0xffffffffffffffff);\n    require(4 + varg1 + 31 < msg.data.length);\n    require(varg1.length <= 0xffffffffffffffff);\n    require(4 + varg1 + varg1.length + 32 <= msg.data.length);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        v2 = new bytes[](varg1.length);\n        CALLDATACOPY(v2.data, 4 + varg1 + 32, varg1.length);\n        v2[varg1.length] = 0;\n        0x392(1, v2, varg0);\n    }\n}\n\nfunction () public payable { \n    0x292();\n    v0 = 0x331();\n    v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n\nfunction implementation() public nonPayable { \n    v0 = 0x1d0();\n    return address(v0);\n}\n\nfunction changeAdmin(address varg0) public nonPayable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 == varg0);\n    if (msg.sender != _upgradeTo) {\n        0x292();\n        v0 = 0x331();\n        v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n        require(v1); // checks call status, propagates error data on error\n        return MEM[0 len (RETURNDATASIZE())];\n    } else {\n        emit AdminChanged(_upgradeTo, varg0);\n        require(varg0, Error('ERC1967: new admin is the zero address'));\n        _upgradeTo = varg0;\n        goto 0x5b0xc9;\n    }\n}\n\nfunction admin() public nonPayable { \n    v0 = 0x235();\n    return address(v0);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length < 4) {\n        if (!msg.data.length) {\n            ();\n        }\n    } else if (0x3659cfe6 == function_selector >> 224) {\n        upgradeTo(address);\n    } else if (0x4f1ef286 == function_selector >> 224) {\n        upgradeToAndCall(address,bytes);\n    } else if (0x5c60da1b == function_selector >> 224) {\n        implementation();\n    } else if (0x8f283970 == function_selector >> 224) {\n        changeAdmin(address);\n    } else if (0xf851a440 == function_selector >> 224) {\n        admin();\n    }\n    0x292();\n    v0 = 0x331();\n    v1 = v0.delegatecall(MEM[0 len msg.data.length], MEM[0 len 0]).gas(msg.gas);\n    require(v1); // checks call status, propagates error data on error\n    return MEM[0 len (RETURNDATASIZE())];\n}\n.",
	"status": "1",
	"time_cost": 25.871629238128662,
	"usage": {
		"completion_tokens": 703,
		"prompt_tokens": 2036,
		"total_tokens": 2739
	}
}