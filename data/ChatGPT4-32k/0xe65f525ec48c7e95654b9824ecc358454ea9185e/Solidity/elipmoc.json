{
	"address": "0xe65f525ec48c7e95654b9824ecc358454ea9185e",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The decompiled EVM Bytecode is quite complex to understand. Here is the thought process and an attempt to reconstruct the original Solidity code:\n\n1. There are a few public functions like `name()`, `totalSupply()`, `withdraw()`, `buyPrice()`, `sellPrice()`, etc. They are simply returning the values of some state variables or calling other internal functions.\n2. There are some private functions like `0x12bb()`, `0x835(uint256, uint256)`, `0x870(uint256, uint256)`, etc. These functions are performing some calculations and are being called by other functions.\n3. There are some events like `onTokenPurchase()`, `onWithdraw()`, `Transfer()`, etc. These events are emitted when certain actions are performed in the contract.\n4. Some functions check for certain conditions and revert the transaction if the conditions are not met.\n5. Some functions update the state variables of the contract.\n\nHere is a simplified interpretation of the contract in Solidity:\n\n```solidity\npragma solidity ^0.4.24;\n\ncontract TokenContract {\n    address private _owner;\n    uint256 private _totalSupply;\n    mapping (address => uint256) private _balances;\n    mapping (address => uint256) private _dividendsOf;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event onTokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n    event onWithdraw(address indexed withdrawer, uint256 value);\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _addr) public view returns (uint256) {\n        return _balances[_addr];\n    }\n\n    function dividendsOf(address _addr) public view returns (uint256) {\n        return _dividendsOf[_addr];\n    }\n\n    function buy() public payable {\n        uint256 amount = msg.value; // to be calculated based on some logic\n        _balances[msg.sender] += amount;\n        _totalSupply += amount;\n        emit onTokenPurchase(msg.sender, msg.value, amount);\n    }\n\n    function sell(uint256 amount) public {\n        require(_balances[msg.sender] >= amount);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        msg.sender.transfer(amount); // amount to be calculated based on some logic\n    }\n\n    function withdraw() public {\n        uint256 amount = _dividendsOf[msg.sender];\n        require(amount > 0);\n        _dividendsOf[msg.sender] = 0;\n        msg.sender.transfer(amount);\n        emit onWithdraw(msg.sender, amount);\n    }\n\n    // More functions to be added based on the decompiled code\n}\n```\n\nPlease note that this is a simplified version and may not fully represent the original contract. The original contract has a complex mathematical logic in some of its functions, which is not covered here. Furthermore, the original contract uses low-level calls and manipulations with the EVM memory, which are also omitted in this simplified version.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039399,
	"id": "chatcmpl-8ChuBupOzo5e4rYUvfNELgp0Htb42",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.25 12:49 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _interestPool_; // STORAGE[0x3]\nuint256 _stakingRequirement; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _fallback; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nonTokenPurchase(address, uint256, uint256, address, uint256, uint256);\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x11e7(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (stor_9 * _dividendsOf[msg.sender] - _dividendsOf[msg.sender] >> 64) + owner_6[msg.sender];\n    } else {\n        v0 = stor_9 * _dividendsOf[msg.sender] - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x12bb() private { \n    if (_totalSupply != 0) {\n        v0 = 0x1e40(0xde0b6b3a7640000);\n        v1 = 0x835(29, v0);\n        assert(100);\n        v2 = 0x835(5, v0);\n        assert(100);\n        assert(v0 + v1 / 100 >= v0);\n        v3 = v0 + v1 / 100 + v2 / 100;\n        assert(v3 >= v0 + v1 / 100);\n    } else {\n        v3 = v4 = 0x199c82cc00;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    assert(100);\n    v0 = 0x835(15, msg.value / 100);\n    assert(10);\n    v1 = _fallback.call().value(v0 / 10).gas(!(v0 / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    assert(100);\n    v2 = 0x835(35, msg.value / 100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v2 / 10;\n    v3 = 0x870(0, msg.value);\n}\n\nfunction 0x174c(uint256 varg0) private { \n    require(_exit[msg.sender] > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v0 = 0x1e40(varg0);\n    v1 = 0x835(24, v0);\n    assert(100);\n    v2 = 0x835(5, v0);\n    assert(100);\n    assert(v1 / 100 <= v0);\n    assert(v2 / 100 <= v0 - v1 / 100);\n    v3 = 0x835(15, v0);\n    assert(100);\n    assert(10);\n    v4 = 0x835(35, v0);\n    assert(100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v4 / 100 / 10;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v5 = _fallback.call().value(v3 / 100 / 10).gas(!(v3 / 100 / 10) * 2300);\n    require(v5); // checks call status, propagates error data on error\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - (stor_9 * varg0 + (v0 - v1 / 100 - v2 / 100 << 64));\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert(stor_9 + (v1 / 100 << 64) / _totalSupply >= stor_9);\n        stor_9 = stor_9 + (v1 / 100 << 64) / _totalSupply;\n    }\n    v6 = 0x12bb();\n    emit onTokenSell(msg.sender, varg0, v0 - v1 / 100 - v2 / 100, block.timestamp, v6);\n    return ;\n}\n\nfunction 0x1d95(uint256 varg0) private { \n    v0 = v1 = 0x197d4df19d605767337e9f14d3eec8920e400000000000000 + 0x409f9cbc7c4a04c220000000 * (varg0 * 0xde0b6b3a7640000) + 0x56bc75e2d63100000 * _totalSupply ** 2 + 0x5e0a1fd2712875988becaad0000000000 * _totalSupply;\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x1431e0fae6d7217caa0000000 <= v0);\n    assert(0x2540be400);\n    return (v0 - 0x1431e0fae6d7217caa0000000) / 0x2540be400 - _totalSupply;\n}\n\nfunction 0x1e40(uint256 varg0) private { \n    v0 = varg0 + 0xde0b6b3a7640000;\n    assert(2);\n    assert(0x2540be400 * ((v0 ** 2 - v0) / 0xde0b6b3a7640000) >> 1 <= (0x174876e800 + 0x2540be400 * ((_totalSupply + 0xde0b6b3a7640000) / 0xde0b6b3a7640000) - 0x2540be400) * (v0 - 0xde0b6b3a7640000));\n    assert(0xde0b6b3a7640000);\n    return ((0x174876e800 + 0x2540be400 * ((_totalSupply + 0xde0b6b3a7640000) / 0xde0b6b3a7640000) - 0x2540be400) * (v0 - 0xde0b6b3a7640000) - (0x2540be400 * ((v0 ** 2 - v0) / 0xde0b6b3a7640000) >> 1)) / 0xde0b6b3a7640000;\n}\n\nfunction 0x1eeb(uint256 varg0, uint256 varg1) private { \n    v0 = 0x835(100, varg1);\n    assert(100);\n    v1 = 0x835(8, v0 / 100);\n    assert(100);\n    assert(v1 / 100 <= v0 / 100);\n    v2 = v3 = v0 / 100 - v1 / 100;\n    assert(v0 / 100 <= varg1);\n    v4 = 0x1d95(varg1 - v0 / 100);\n    v5 = v6 = v3 << 64;\n    v7 = v8 = v4 >= 0;\n    if (v8) {\n        assert(v4 + _totalSupply >= v4);\n        v7 = v9 = v4 + _totalSupply >= _totalSupply;\n    }\n    require(v7);\n    v10 = v11 = address(varg0) != 0;\n    if (v11) {\n        v10 = v12 = address(varg0) != msg.sender;\n    }\n    if (v10) {\n        v13 = address(varg0);\n        v10 = v14 = _exit[v13] >= _stakingRequirement;\n    }\n    if (!v10) {\n        v2 = v3 + v1 / 100;\n        assert(v2 >= v3);\n        v5 = v15 = v2 << 64;\n    } else {\n        v16 = address(varg0);\n        assert(owner_6[v16] + v1 / 100 >= owner_6[v16]);\n        v17 = address(varg0);\n        owner_6[v17] = owner_6[v16] + v1 / 100;\n    }\n    if (_totalSupply <= 0) {\n        _totalSupply = v4;\n    } else {\n        assert(_totalSupply + v4 >= _totalSupply);\n        _totalSupply = _totalSupply + v4;\n        assert(_totalSupply);\n        stor_9 = stor_9 + (v2 << 64) / _totalSupply;\n        assert(_totalSupply);\n        v5 = v18 = v5 - (v5 - v4 * ((v2 << 64) / _totalSupply));\n    }\n    assert(_exit[msg.sender] + v4 >= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] + v4;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v4 - v5);\n    v19 = 0x12bb();\n    emit onTokenPurchase(msg.sender, address(varg0), varg1, v4, block.timestamp, v19);\n    return v4;\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return stor_9 * _dividendsOf[varg0] - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x835(29, varg0);\n    assert(100);\n    v1 = 0x835(5, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    assert(v1 / 100 <= varg0 - v0 / 100);\n    v2 = 0x1d95(varg0 - v0 / 100 - v1 / 100);\n    return v2;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x1e40(varg0);\n    v1 = 0x835(24, v0);\n    assert(100);\n    v2 = 0x835(5, v0);\n    assert(100);\n    assert(v1 / 100 <= v0);\n    assert(v2 / 100 <= v0 - v1 / 100);\n    return v0 - v1 / 100 - v2 / 100;\n}\n\nfunction IDD() public nonPayable { \n    require(msg.sender == _owner);\n    assert(_interestPool_ <= (address(this)).balance);\n    v0 = 0x835(1, (address(this)).balance - _interestPool_);\n    assert(100);\n    assert(10);\n    _interestPool_ = _interestPool_ - v0 / 100 / 10;\n    v1 = 0x1eeb(0, v0 / 100 / 10);\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0xf8d();\n}\n\nfunction sellPrice() public nonPayable { \n    if (_totalSupply != 0) {\n        v0 = 0x1e40(0xde0b6b3a7640000);\n        v1 = 0x835(24, v0);\n        assert(100);\n        v2 = 0x835(5, v0);\n        assert(100);\n        assert(v1 / 100 <= v0);\n        assert(v2 / 100 <= v0 - v1 / 100);\n        v3 = v0 - v1 / 100 - v2 / 100;\n    } else {\n        v3 = v4 = 0x14f46b0400;\n    }\n    return v3;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction DivsAddon() public payable { \n    v0 = 0x1eeb(0, msg.value);\n    return 0;\n}\n\nfunction exitFee() public nonPayable { \n    return 24;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x11e7(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    v0 = 0x12bb();\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction InterestPool_() public nonPayable { \n    return _interestPool_;\n}\n\nfunction myTokens() public nonPayable { \n    return _exit[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_exit[msg.sender] > 0);\n    require(varg1 <= _exit[msg.sender]);\n    v0 = 0x11e7(1);\n    if (v0 > 0) {\n        0xf8d();\n    }\n    v1 = 0x835(1, varg1);\n    assert(100);\n    assert(v1 / 100 <= varg1);\n    v2 = 0x1e40(v1 / 100);\n    assert(v1 / 100 <= _totalSupply);\n    _totalSupply = _totalSupply - v1 / 100;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(_exit[varg0] + (varg1 - v1 / 100) >= _exit[varg0]);\n    _exit[varg0] = _exit[varg0] + (varg1 - v1 / 100);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - stor_9 * varg1;\n    _dividendsOf[varg0] = _dividendsOf[varg0] + stor_9 * (varg1 - v1 / 100);\n    assert(_totalSupply);\n    assert(stor_9 + (v2 << 64) / _totalSupply >= stor_9);\n    stor_9 = stor_9 + (v2 << 64) / _totalSupply;\n    emit Transfer(msg.sender, varg0, varg1 - v1 / 100);\n    return 1;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x174c(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x174c(_exit[msg.sender]);\n    }\n    0xf8d();\n}\n\nfunction buy(address varg0) public payable { \n    assert(100);\n    v0 = 0x835(15, msg.value / 100);\n    assert(10);\n    v1 = _fallback.call().value(v0 / 10).gas(!(v0 / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    assert(100);\n    v2 = 0x835(35, msg.value / 100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v2 / 10;\n    v3 = 0x870(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x11e7(1);\n    require(v0 > 0);\n    v1 = 0x11e7(0);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (v1 << 64);\n    owner_6[msg.sender] = 0;\n    v2 = 0x870(0, v1 + owner_6[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + owner_6[msg.sender], v2);\n}\n\nfunction 0x835(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x870(uint256 varg0, uint256 varg1) private { \n    v0 = 0x835(29, varg1);\n    assert(100);\n    v1 = 0x835(8, v0 / 100);\n    assert(100);\n    v2 = 0x835(5, varg1);\n    assert(100);\n    assert(v1 / 100 <= v0 / 100);\n    assert(v2 / 100 <= v0 / 100 - v1 / 100);\n    v3 = v4 = v0 / 100 - v1 / 100 - v2 / 100;\n    assert(v0 / 100 <= varg1);\n    v5 = 0x1d95(varg1 - v0 / 100);\n    v6 = v7 = v4 << 64;\n    v8 = v9 = v5 > 0;\n    if (v9) {\n        assert(v5 + _totalSupply >= v5);\n        v8 = v10 = v5 + _totalSupply > _totalSupply;\n    }\n    require(v8);\n    v11 = v12 = address(varg0) != 0;\n    if (v12) {\n        v11 = v13 = address(varg0) != msg.sender;\n    }\n    if (v11) {\n        v14 = address(varg0);\n        v11 = v15 = _exit[v14] >= _stakingRequirement;\n    }\n    if (!v11) {\n        v3 = v4 + v1 / 100;\n        assert(v3 >= v4);\n        v6 = v16 = v3 << 64;\n    } else {\n        v17 = address(varg0);\n        assert(owner_6[v17] + v1 / 100 >= owner_6[v17]);\n        v18 = address(varg0);\n        owner_6[v18] = owner_6[v17] + v1 / 100;\n    }\n    if (_totalSupply <= 0) {\n        _totalSupply = v5;\n    } else {\n        assert(_totalSupply + v5 >= _totalSupply);\n        _totalSupply = _totalSupply + v5;\n        assert(_totalSupply);\n        stor_9 = stor_9 + (v3 << 64) / _totalSupply;\n        assert(_totalSupply);\n        v6 = v19 = v6 - (v6 - v5 * ((v3 << 64) / _totalSupply));\n    }\n    assert(_exit[msg.sender] + v5 >= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] + v5;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v5 - v6);\n    v20 = 0x12bb();\n    emit onTokenPurchase(msg.sender, address(varg0), varg1, v5, block.timestamp, v20);\n    return v5;\n}\n\nfunction 0xf8d() private { \n    v0 = 0x11e7(1);\n    require(v0 > 0);\n    v1 = 0x11e7(0);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (v1 << 64);\n    owner_6[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + owner_6[msg.sender]).gas(!(v1 + owner_6[msg.sender]) * 2300);\n    require(v2); // checks call status, propagates error data on error\n    emit onWithdraw(msg.sender, v1 + owner_6[msg.sender]);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x65318b == function_selector) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x2858507f == function_selector) {\n            IDD();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x56d5938f == function_selector) {\n            DivsAddon();\n        } else if (0x6284ae41 == function_selector) {\n            exitFee();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x92f8def2 == function_selector) {\n            InterestPool_();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 12:49 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _interestPool_; // STORAGE[0x3]\nuint256 _stakingRequirement; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _fallback; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nonTokenPurchase(address, uint256, uint256, address, uint256, uint256);\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x11e7(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (stor_9 * _dividendsOf[msg.sender] - _dividendsOf[msg.sender] >> 64) + owner_6[msg.sender];\n    } else {\n        v0 = stor_9 * _dividendsOf[msg.sender] - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x12bb() private { \n    if (_totalSupply != 0) {\n        v0 = 0x1e40(0xde0b6b3a7640000);\n        v1 = 0x835(29, v0);\n        assert(100);\n        v2 = 0x835(5, v0);\n        assert(100);\n        assert(v0 + v1 / 100 >= v0);\n        v3 = v0 + v1 / 100 + v2 / 100;\n        assert(v3 >= v0 + v1 / 100);\n    } else {\n        v3 = v4 = 0x199c82cc00;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    assert(100);\n    v0 = 0x835(15, msg.value / 100);\n    assert(10);\n    v1 = _fallback.call().value(v0 / 10).gas(!(v0 / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    assert(100);\n    v2 = 0x835(35, msg.value / 100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v2 / 10;\n    v3 = 0x870(0, msg.value);\n}\n\nfunction 0x174c(uint256 varg0) private { \n    require(_exit[msg.sender] > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v0 = 0x1e40(varg0);\n    v1 = 0x835(24, v0);\n    assert(100);\n    v2 = 0x835(5, v0);\n    assert(100);\n    assert(v1 / 100 <= v0);\n    assert(v2 / 100 <= v0 - v1 / 100);\n    v3 = 0x835(15, v0);\n    assert(100);\n    assert(10);\n    v4 = 0x835(35, v0);\n    assert(100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v4 / 100 / 10;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v5 = _fallback.call().value(v3 / 100 / 10).gas(!(v3 / 100 / 10) * 2300);\n    require(v5); // checks call status, propagates error data on error\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - (stor_9 * varg0 + (v0 - v1 / 100 - v2 / 100 << 64));\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert(stor_9 + (v1 / 100 << 64) / _totalSupply >= stor_9);\n        stor_9 = stor_9 + (v1 / 100 << 64) / _totalSupply;\n    }\n    v6 = 0x12bb();\n    emit onTokenSell(msg.sender, varg0, v0 - v1 / 100 - v2 / 100, block.timestamp, v6);\n    return ;\n}\n\nfunction 0x1d95(uint256 varg0) private { \n    v0 = v1 = 0x197d4df19d605767337e9f14d3eec8920e400000000000000 + 0x409f9cbc7c4a04c220000000 * (varg0 * 0xde0b6b3a7640000) + 0x56bc75e2d63100000 * _totalSupply ** 2 + 0x5e0a1fd2712875988becaad0000000000 * _totalSupply;\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x1431e0fae6d7217caa0000000 <= v0);\n    assert(0x2540be400);\n    return (v0 - 0x1431e0fae6d7217caa0000000) / 0x2540be400 - _totalSupply;\n}\n\nfunction 0x1e40(uint256 varg0) private { \n    v0 = varg0 + 0xde0b6b3a7640000;\n    assert(2);\n    assert(0x2540be400 * ((v0 ** 2 - v0) / 0xde0b6b3a7640000) >> 1 <= (0x174876e800 + 0x2540be400 * ((_totalSupply + 0xde0b6b3a7640000) / 0xde0b6b3a7640000) - 0x2540be400) * (v0 - 0xde0b6b3a7640000));\n    assert(0xde0b6b3a7640000);\n    return ((0x174876e800 + 0x2540be400 * ((_totalSupply + 0xde0b6b3a7640000) / 0xde0b6b3a7640000) - 0x2540be400) * (v0 - 0xde0b6b3a7640000) - (0x2540be400 * ((v0 ** 2 - v0) / 0xde0b6b3a7640000) >> 1)) / 0xde0b6b3a7640000;\n}\n\nfunction 0x1eeb(uint256 varg0, uint256 varg1) private { \n    v0 = 0x835(100, varg1);\n    assert(100);\n    v1 = 0x835(8, v0 / 100);\n    assert(100);\n    assert(v1 / 100 <= v0 / 100);\n    v2 = v3 = v0 / 100 - v1 / 100;\n    assert(v0 / 100 <= varg1);\n    v4 = 0x1d95(varg1 - v0 / 100);\n    v5 = v6 = v3 << 64;\n    v7 = v8 = v4 >= 0;\n    if (v8) {\n        assert(v4 + _totalSupply >= v4);\n        v7 = v9 = v4 + _totalSupply >= _totalSupply;\n    }\n    require(v7);\n    v10 = v11 = address(varg0) != 0;\n    if (v11) {\n        v10 = v12 = address(varg0) != msg.sender;\n    }\n    if (v10) {\n        v13 = address(varg0);\n        v10 = v14 = _exit[v13] >= _stakingRequirement;\n    }\n    if (!v10) {\n        v2 = v3 + v1 / 100;\n        assert(v2 >= v3);\n        v5 = v15 = v2 << 64;\n    } else {\n        v16 = address(varg0);\n        assert(owner_6[v16] + v1 / 100 >= owner_6[v16]);\n        v17 = address(varg0);\n        owner_6[v17] = owner_6[v16] + v1 / 100;\n    }\n    if (_totalSupply <= 0) {\n        _totalSupply = v4;\n    } else {\n        assert(_totalSupply + v4 >= _totalSupply);\n        _totalSupply = _totalSupply + v4;\n        assert(_totalSupply);\n        stor_9 = stor_9 + (v2 << 64) / _totalSupply;\n        assert(_totalSupply);\n        v5 = v18 = v5 - (v5 - v4 * ((v2 << 64) / _totalSupply));\n    }\n    assert(_exit[msg.sender] + v4 >= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] + v4;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v4 - v5);\n    v19 = 0x12bb();\n    emit onTokenPurchase(msg.sender, address(varg0), varg1, v4, block.timestamp, v19);\n    return v4;\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return stor_9 * _dividendsOf[varg0] - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x835(29, varg0);\n    assert(100);\n    v1 = 0x835(5, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    assert(v1 / 100 <= varg0 - v0 / 100);\n    v2 = 0x1d95(varg0 - v0 / 100 - v1 / 100);\n    return v2;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x1e40(varg0);\n    v1 = 0x835(24, v0);\n    assert(100);\n    v2 = 0x835(5, v0);\n    assert(100);\n    assert(v1 / 100 <= v0);\n    assert(v2 / 100 <= v0 - v1 / 100);\n    return v0 - v1 / 100 - v2 / 100;\n}\n\nfunction IDD() public nonPayable { \n    require(msg.sender == _owner);\n    assert(_interestPool_ <= (address(this)).balance);\n    v0 = 0x835(1, (address(this)).balance - _interestPool_);\n    assert(100);\n    assert(10);\n    _interestPool_ = _interestPool_ - v0 / 100 / 10;\n    v1 = 0x1eeb(0, v0 / 100 / 10);\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0xf8d();\n}\n\nfunction sellPrice() public nonPayable { \n    if (_totalSupply != 0) {\n        v0 = 0x1e40(0xde0b6b3a7640000);\n        v1 = 0x835(24, v0);\n        assert(100);\n        v2 = 0x835(5, v0);\n        assert(100);\n        assert(v1 / 100 <= v0);\n        assert(v2 / 100 <= v0 - v1 / 100);\n        v3 = v0 - v1 / 100 - v2 / 100;\n    } else {\n        v3 = v4 = 0x14f46b0400;\n    }\n    return v3;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction DivsAddon() public payable { \n    v0 = 0x1eeb(0, msg.value);\n    return 0;\n}\n\nfunction exitFee() public nonPayable { \n    return 24;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x11e7(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    v0 = 0x12bb();\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction InterestPool_() public nonPayable { \n    return _interestPool_;\n}\n\nfunction myTokens() public nonPayable { \n    return _exit[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_exit[msg.sender] > 0);\n    require(varg1 <= _exit[msg.sender]);\n    v0 = 0x11e7(1);\n    if (v0 > 0) {\n        0xf8d();\n    }\n    v1 = 0x835(1, varg1);\n    assert(100);\n    assert(v1 / 100 <= varg1);\n    v2 = 0x1e40(v1 / 100);\n    assert(v1 / 100 <= _totalSupply);\n    _totalSupply = _totalSupply - v1 / 100;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(_exit[varg0] + (varg1 - v1 / 100) >= _exit[varg0]);\n    _exit[varg0] = _exit[varg0] + (varg1 - v1 / 100);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - stor_9 * varg1;\n    _dividendsOf[varg0] = _dividendsOf[varg0] + stor_9 * (varg1 - v1 / 100);\n    assert(_totalSupply);\n    assert(stor_9 + (v2 << 64) / _totalSupply >= stor_9);\n    stor_9 = stor_9 + (v2 << 64) / _totalSupply;\n    emit Transfer(msg.sender, varg0, varg1 - v1 / 100);\n    return 1;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x174c(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x174c(_exit[msg.sender]);\n    }\n    0xf8d();\n}\n\nfunction buy(address varg0) public payable { \n    assert(100);\n    v0 = 0x835(15, msg.value / 100);\n    assert(10);\n    v1 = _fallback.call().value(v0 / 10).gas(!(v0 / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    assert(100);\n    v2 = 0x835(35, msg.value / 100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v2 / 10;\n    v3 = 0x870(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x11e7(1);\n    require(v0 > 0);\n    v1 = 0x11e7(0);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (v1 << 64);\n    owner_6[msg.sender] = 0;\n    v2 = 0x870(0, v1 + owner_6[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + owner_6[msg.sender], v2);\n}\n\nfunction 0x835(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x870(uint256 varg0, uint256 varg1) private { \n    v0 = 0x835(29, varg1);\n    assert(100);\n    v1 = 0x835(8, v0 / 100);\n    assert(100);\n    v2 = 0x835(5, varg1);\n    assert(100);\n    assert(v1 / 100 <= v0 / 100);\n    assert(v2 / 100 <= v0 / 100 - v1 / 100);\n    v3 = v4 = v0 / 100 - v1 / 100 - v2 / 100;\n    assert(v0 / 100 <= varg1);\n    v5 = 0x1d95(varg1 - v0 / 100);\n    v6 = v7 = v4 << 64;\n    v8 = v9 = v5 > 0;\n    if (v9) {\n        assert(v5 + _totalSupply >= v5);\n        v8 = v10 = v5 + _totalSupply > _totalSupply;\n    }\n    require(v8);\n    v11 = v12 = address(varg0) != 0;\n    if (v12) {\n        v11 = v13 = address(varg0) != msg.sender;\n    }\n    if (v11) {\n        v14 = address(varg0);\n        v11 = v15 = _exit[v14] >= _stakingRequirement;\n    }\n    if (!v11) {\n        v3 = v4 + v1 / 100;\n        assert(v3 >= v4);\n        v6 = v16 = v3 << 64;\n    } else {\n        v17 = address(varg0);\n        assert(owner_6[v17] + v1 / 100 >= owner_6[v17]);\n        v18 = address(varg0);\n        owner_6[v18] = owner_6[v17] + v1 / 100;\n    }\n    if (_totalSupply <= 0) {\n        _totalSupply = v5;\n    } else {\n        assert(_totalSupply + v5 >= _totalSupply);\n        _totalSupply = _totalSupply + v5;\n        assert(_totalSupply);\n        stor_9 = stor_9 + (v3 << 64) / _totalSupply;\n        assert(_totalSupply);\n        v6 = v19 = v6 - (v6 - v5 * ((v3 << 64) / _totalSupply));\n    }\n    assert(_exit[msg.sender] + v5 >= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] + v5;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v5 - v6);\n    v20 = 0x12bb();\n    emit onTokenPurchase(msg.sender, address(varg0), varg1, v5, block.timestamp, v20);\n    return v5;\n}\n\nfunction 0xf8d() private { \n    v0 = 0x11e7(1);\n    require(v0 > 0);\n    v1 = 0x11e7(0);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (v1 << 64);\n    owner_6[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + owner_6[msg.sender]).gas(!(v1 + owner_6[msg.sender]) * 2300);\n    require(v2); // checks call status, propagates error data on error\n    emit onWithdraw(msg.sender, v1 + owner_6[msg.sender]);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x65318b == function_selector) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x2858507f == function_selector) {\n            IDD();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x56d5938f == function_selector) {\n            DivsAddon();\n        } else if (0x6284ae41 == function_selector) {\n            exitFee();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x92f8def2 == function_selector) {\n            InterestPool_();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.25 12:49 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256[] _name; // STORAGE[0x1]\nuint256[] _symbol; // STORAGE[0x2]\nuint256 _interestPool_; // STORAGE[0x3]\nuint256 _stakingRequirement; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _exit; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\nmapping (uint256 => [uint256]) _dividendsOf; // STORAGE[0x7]\nuint256 _totalSupply; // STORAGE[0x8]\nuint256 stor_9; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _fallback; // STORAGE[0xa] bytes 0 to 19\n\n// Events\nonTokenPurchase(address, uint256, uint256, address, uint256, uint256);\nonWithdraw(address, uint256);\nTransfer(address, address, uint256);\nonTokenSell(address, uint256, uint256, uint256, uint256);\nonReinvestment(address, uint256, uint256);\n\nfunction 0x11e7(uint256 varg0) private { \n    if (varg0) {\n        v0 = v1 = (stor_9 * _dividendsOf[msg.sender] - _dividendsOf[msg.sender] >> 64) + owner_6[msg.sender];\n    } else {\n        v0 = stor_9 * _dividendsOf[msg.sender] - _dividendsOf[msg.sender] >> 64;\n    }\n    return v0;\n}\n\nfunction 0x12bb() private { \n    if (_totalSupply != 0) {\n        v0 = 0x1e40(0xde0b6b3a7640000);\n        v1 = 0x835(29, v0);\n        assert(100);\n        v2 = 0x835(5, v0);\n        assert(100);\n        assert(v0 + v1 / 100 >= v0);\n        v3 = v0 + v1 / 100 + v2 / 100;\n        assert(v3 >= v0 + v1 / 100);\n    } else {\n        v3 = v4 = 0x199c82cc00;\n    }\n    return v3;\n}\n\nfunction fallback() public payable { \n    assert(100);\n    v0 = 0x835(15, msg.value / 100);\n    assert(10);\n    v1 = _fallback.call().value(v0 / 10).gas(!(v0 / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    assert(100);\n    v2 = 0x835(35, msg.value / 100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v2 / 10;\n    v3 = 0x870(0, msg.value);\n}\n\nfunction 0x174c(uint256 varg0) private { \n    require(_exit[msg.sender] > 0);\n    require(varg0 <= _exit[msg.sender]);\n    v0 = 0x1e40(varg0);\n    v1 = 0x835(24, v0);\n    assert(100);\n    v2 = 0x835(5, v0);\n    assert(100);\n    assert(v1 / 100 <= v0);\n    assert(v2 / 100 <= v0 - v1 / 100);\n    v3 = 0x835(15, v0);\n    assert(100);\n    assert(10);\n    v4 = 0x835(35, v0);\n    assert(100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v4 / 100 / 10;\n    assert(varg0 <= _totalSupply);\n    _totalSupply = _totalSupply - varg0;\n    assert(varg0 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg0;\n    v5 = _fallback.call().value(v3 / 100 / 10).gas(!(v3 / 100 / 10) * 2300);\n    require(v5); // checks call status, propagates error data on error\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - (stor_9 * varg0 + (v0 - v1 / 100 - v2 / 100 << 64));\n    if (_totalSupply > 0) {\n        assert(_totalSupply);\n        assert(stor_9 + (v1 / 100 << 64) / _totalSupply >= stor_9);\n        stor_9 = stor_9 + (v1 / 100 << 64) / _totalSupply;\n    }\n    v6 = 0x12bb();\n    emit onTokenSell(msg.sender, varg0, v0 - v1 / 100 - v2 / 100, block.timestamp, v6);\n    return ;\n}\n\nfunction 0x1d95(uint256 varg0) private { \n    v0 = v1 = 0x197d4df19d605767337e9f14d3eec8920e400000000000000 + 0x409f9cbc7c4a04c220000000 * (varg0 * 0xde0b6b3a7640000) + 0x56bc75e2d63100000 * _totalSupply ** 2 + 0x5e0a1fd2712875988becaad0000000000 * _totalSupply;\n    v0 = v2 = v1 + 1 >> 1;\n    while (v0 < v0) {\n        assert(v0);\n        assert(2);\n        v0 = v1 / v0 + v0 >> 1;\n    }\n    assert(0x1431e0fae6d7217caa0000000 <= v0);\n    assert(0x2540be400);\n    return (v0 - 0x1431e0fae6d7217caa0000000) / 0x2540be400 - _totalSupply;\n}\n\nfunction 0x1e40(uint256 varg0) private { \n    v0 = varg0 + 0xde0b6b3a7640000;\n    assert(2);\n    assert(0x2540be400 * ((v0 ** 2 - v0) / 0xde0b6b3a7640000) >> 1 <= (0x174876e800 + 0x2540be400 * ((_totalSupply + 0xde0b6b3a7640000) / 0xde0b6b3a7640000) - 0x2540be400) * (v0 - 0xde0b6b3a7640000));\n    assert(0xde0b6b3a7640000);\n    return ((0x174876e800 + 0x2540be400 * ((_totalSupply + 0xde0b6b3a7640000) / 0xde0b6b3a7640000) - 0x2540be400) * (v0 - 0xde0b6b3a7640000) - (0x2540be400 * ((v0 ** 2 - v0) / 0xde0b6b3a7640000) >> 1)) / 0xde0b6b3a7640000;\n}\n\nfunction 0x1eeb(uint256 varg0, uint256 varg1) private { \n    v0 = 0x835(100, varg1);\n    assert(100);\n    v1 = 0x835(8, v0 / 100);\n    assert(100);\n    assert(v1 / 100 <= v0 / 100);\n    v2 = v3 = v0 / 100 - v1 / 100;\n    assert(v0 / 100 <= varg1);\n    v4 = 0x1d95(varg1 - v0 / 100);\n    v5 = v6 = v3 << 64;\n    v7 = v8 = v4 >= 0;\n    if (v8) {\n        assert(v4 + _totalSupply >= v4);\n        v7 = v9 = v4 + _totalSupply >= _totalSupply;\n    }\n    require(v7);\n    v10 = v11 = address(varg0) != 0;\n    if (v11) {\n        v10 = v12 = address(varg0) != msg.sender;\n    }\n    if (v10) {\n        v13 = address(varg0);\n        v10 = v14 = _exit[v13] >= _stakingRequirement;\n    }\n    if (!v10) {\n        v2 = v3 + v1 / 100;\n        assert(v2 >= v3);\n        v5 = v15 = v2 << 64;\n    } else {\n        v16 = address(varg0);\n        assert(owner_6[v16] + v1 / 100 >= owner_6[v16]);\n        v17 = address(varg0);\n        owner_6[v17] = owner_6[v16] + v1 / 100;\n    }\n    if (_totalSupply <= 0) {\n        _totalSupply = v4;\n    } else {\n        assert(_totalSupply + v4 >= _totalSupply);\n        _totalSupply = _totalSupply + v4;\n        assert(_totalSupply);\n        stor_9 = stor_9 + (v2 << 64) / _totalSupply;\n        assert(_totalSupply);\n        v5 = v18 = v5 - (v5 - v4 * ((v2 << 64) / _totalSupply));\n    }\n    assert(_exit[msg.sender] + v4 >= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] + v4;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v4 - v5);\n    v19 = 0x12bb();\n    emit onTokenPurchase(msg.sender, address(varg0), varg1, v4, block.timestamp, v19);\n    return v4;\n}\n\nfunction dividendsOf(address varg0) public nonPayable { \n    return stor_9 * _dividendsOf[varg0] - _dividendsOf[varg0] >> 64;\n}\n\nfunction name() public nonPayable { \n    v0 = new bytes[](_name.length);\n    v1 = v2 = v0.data;\n    if (_name.length) {\n        if (31 < _name.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _name.length <= v1);\n        } else {\n            MEM[v2] = _name.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction calculateTokensReceived(uint256 varg0) public nonPayable { \n    v0 = 0x835(29, varg0);\n    assert(100);\n    v1 = 0x835(5, varg0);\n    assert(100);\n    assert(v0 / 100 <= varg0);\n    assert(v1 / 100 <= varg0 - v0 / 100);\n    v2 = 0x1d95(varg0 - v0 / 100 - v1 / 100);\n    return v2;\n}\n\nfunction totalSupply() public nonPayable { \n    return _totalSupply;\n}\n\nfunction calculateEthereumReceived(uint256 varg0) public nonPayable { \n    require(varg0 <= _totalSupply);\n    v0 = 0x1e40(varg0);\n    v1 = 0x835(24, v0);\n    assert(100);\n    v2 = 0x835(5, v0);\n    assert(100);\n    assert(v1 / 100 <= v0);\n    assert(v2 / 100 <= v0 - v1 / 100);\n    return v0 - v1 / 100 - v2 / 100;\n}\n\nfunction IDD() public nonPayable { \n    require(msg.sender == _owner);\n    assert(_interestPool_ <= (address(this)).balance);\n    v0 = 0x835(1, (address(this)).balance - _interestPool_);\n    assert(100);\n    assert(10);\n    _interestPool_ = _interestPool_ - v0 / 100 / 10;\n    v1 = 0x1eeb(0, v0 / 100 / 10);\n}\n\nfunction decimals() public nonPayable { \n    return 18;\n}\n\nfunction withdraw() public nonPayable { \n    0xf8d();\n}\n\nfunction sellPrice() public nonPayable { \n    if (_totalSupply != 0) {\n        v0 = 0x1e40(0xde0b6b3a7640000);\n        v1 = 0x835(24, v0);\n        assert(100);\n        v2 = 0x835(5, v0);\n        assert(100);\n        assert(v1 / 100 <= v0);\n        assert(v2 / 100 <= v0 - v1 / 100);\n        v3 = v0 - v1 / 100 - v2 / 100;\n    } else {\n        v3 = v4 = 0x14f46b0400;\n    }\n    return v3;\n}\n\nfunction stakingRequirement() public nonPayable { \n    return _stakingRequirement;\n}\n\nfunction DivsAddon() public payable { \n    v0 = 0x1eeb(0, msg.value);\n    return 0;\n}\n\nfunction exitFee() public nonPayable { \n    return 24;\n}\n\nfunction myDividends(bool varg0) public nonPayable { \n    v0 = 0x11e7(varg0);\n    return v0;\n}\n\nfunction totalEthereumBalance() public nonPayable { \n    return (address(this)).balance;\n}\n\nfunction balanceOf(address varg0) public nonPayable { \n    return _exit[varg0];\n}\n\nfunction buyPrice() public nonPayable { \n    v0 = 0x12bb();\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction InterestPool_() public nonPayable { \n    return _interestPool_;\n}\n\nfunction myTokens() public nonPayable { \n    return _exit[msg.sender];\n}\n\nfunction symbol() public nonPayable { \n    v0 = new bytes[](_symbol.length);\n    v1 = v2 = v0.data;\n    if (_symbol.length) {\n        if (31 < _symbol.length) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + _symbol.length <= v1);\n        } else {\n            MEM[v2] = _symbol.length >> 8 << 8;\n        }\n    }\n    v4 = new array[](v0.length);\n    v5 = v6 = 0;\n    while (v5 < v0.length) {\n        MEM[v4.data + v5] = MEM[v0.data + v5];\n        v5 = v5 + 32;\n    }\n    v7 = v8 = v0.length + v4.data;\n    if (0x1f & v0.length) {\n        MEM[v8 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v8 - (0x1f & v0.length)];\n    }\n    return v4;\n}\n\nfunction transfer(address varg0, uint256 varg1) public nonPayable { \n    require(_exit[msg.sender] > 0);\n    require(varg1 <= _exit[msg.sender]);\n    v0 = 0x11e7(1);\n    if (v0 > 0) {\n        0xf8d();\n    }\n    v1 = 0x835(1, varg1);\n    assert(100);\n    assert(v1 / 100 <= varg1);\n    v2 = 0x1e40(v1 / 100);\n    assert(v1 / 100 <= _totalSupply);\n    _totalSupply = _totalSupply - v1 / 100;\n    assert(varg1 <= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] - varg1;\n    assert(_exit[varg0] + (varg1 - v1 / 100) >= _exit[varg0]);\n    _exit[varg0] = _exit[varg0] + (varg1 - v1 / 100);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] - stor_9 * varg1;\n    _dividendsOf[varg0] = _dividendsOf[varg0] + stor_9 * (varg1 - v1 / 100);\n    assert(_totalSupply);\n    assert(stor_9 + (v2 << 64) / _totalSupply >= stor_9);\n    stor_9 = stor_9 + (v2 << 64) / _totalSupply;\n    emit Transfer(msg.sender, varg0, varg1 - v1 / 100);\n    return 1;\n}\n\nfunction sell(uint256 varg0) public nonPayable { \n    0x174c(varg0);\n}\n\nfunction exit() public nonPayable { \n    if (_exit[msg.sender] > 0) {\n        0x174c(_exit[msg.sender]);\n    }\n    0xf8d();\n}\n\nfunction buy(address varg0) public payable { \n    assert(100);\n    v0 = 0x835(15, msg.value / 100);\n    assert(10);\n    v1 = _fallback.call().value(v0 / 10).gas(!(v0 / 10) * 2300);\n    require(v1); // checks call status, propagates error data on error\n    assert(100);\n    v2 = 0x835(35, msg.value / 100);\n    assert(10);\n    _interestPool_ = _interestPool_ + v2 / 10;\n    v3 = 0x870(varg0, msg.value);\n    return 0;\n}\n\nfunction reinvest() public nonPayable { \n    v0 = 0x11e7(1);\n    require(v0 > 0);\n    v1 = 0x11e7(0);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (v1 << 64);\n    owner_6[msg.sender] = 0;\n    v2 = 0x870(0, v1 + owner_6[msg.sender]);\n    emit onReinvestment(msg.sender, v1 + owner_6[msg.sender], v2);\n}\n\nfunction 0x835(uint256 varg0, uint256 varg1) private { \n    if (varg1 != 0) {\n        v0 = v1 = varg1 * varg0;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction 0x870(uint256 varg0, uint256 varg1) private { \n    v0 = 0x835(29, varg1);\n    assert(100);\n    v1 = 0x835(8, v0 / 100);\n    assert(100);\n    v2 = 0x835(5, varg1);\n    assert(100);\n    assert(v1 / 100 <= v0 / 100);\n    assert(v2 / 100 <= v0 / 100 - v1 / 100);\n    v3 = v4 = v0 / 100 - v1 / 100 - v2 / 100;\n    assert(v0 / 100 <= varg1);\n    v5 = 0x1d95(varg1 - v0 / 100);\n    v6 = v7 = v4 << 64;\n    v8 = v9 = v5 > 0;\n    if (v9) {\n        assert(v5 + _totalSupply >= v5);\n        v8 = v10 = v5 + _totalSupply > _totalSupply;\n    }\n    require(v8);\n    v11 = v12 = address(varg0) != 0;\n    if (v12) {\n        v11 = v13 = address(varg0) != msg.sender;\n    }\n    if (v11) {\n        v14 = address(varg0);\n        v11 = v15 = _exit[v14] >= _stakingRequirement;\n    }\n    if (!v11) {\n        v3 = v4 + v1 / 100;\n        assert(v3 >= v4);\n        v6 = v16 = v3 << 64;\n    } else {\n        v17 = address(varg0);\n        assert(owner_6[v17] + v1 / 100 >= owner_6[v17]);\n        v18 = address(varg0);\n        owner_6[v18] = owner_6[v17] + v1 / 100;\n    }\n    if (_totalSupply <= 0) {\n        _totalSupply = v5;\n    } else {\n        assert(_totalSupply + v5 >= _totalSupply);\n        _totalSupply = _totalSupply + v5;\n        assert(_totalSupply);\n        stor_9 = stor_9 + (v3 << 64) / _totalSupply;\n        assert(_totalSupply);\n        v6 = v19 = v6 - (v6 - v5 * ((v3 << 64) / _totalSupply));\n    }\n    assert(_exit[msg.sender] + v5 >= _exit[msg.sender]);\n    _exit[msg.sender] = _exit[msg.sender] + v5;\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (stor_9 * v5 - v6);\n    v20 = 0x12bb();\n    emit onTokenPurchase(msg.sender, address(varg0), varg1, v5, block.timestamp, v20);\n    return v5;\n}\n\nfunction 0xf8d() private { \n    v0 = 0x11e7(1);\n    require(v0 > 0);\n    v1 = 0x11e7(0);\n    _dividendsOf[msg.sender] = _dividendsOf[msg.sender] + (v1 << 64);\n    owner_6[msg.sender] = 0;\n    v2 = msg.sender.call().value(v1 + owner_6[msg.sender]).gas(!(v1 + owner_6[msg.sender]) * 2300);\n    require(v2); // checks call status, propagates error data on error\n    emit onWithdraw(msg.sender, v1 + owner_6[msg.sender]);\n    return ;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0x65318b == function_selector) {\n            dividendsOf(address);\n        } else if (0x6fdde03 == function_selector) {\n            name();\n        } else if (0x10d0ffdd == function_selector) {\n            calculateTokensReceived(uint256);\n        } else if (0x18160ddd == function_selector) {\n            totalSupply();\n        } else if (0x22609373 == function_selector) {\n            calculateEthereumReceived(uint256);\n        } else if (0x2858507f == function_selector) {\n            IDD();\n        } else if (0x313ce567 == function_selector) {\n            decimals();\n        } else if (0x3ccfd60b == function_selector) {\n            withdraw();\n        } else if (0x4b750334 == function_selector) {\n            sellPrice();\n        } else if (0x56d399e8 == function_selector) {\n            stakingRequirement();\n        } else if (0x56d5938f == function_selector) {\n            DivsAddon();\n        } else if (0x6284ae41 == function_selector) {\n            exitFee();\n        } else if (0x688abbf7 == function_selector) {\n            myDividends(bool);\n        } else if (0x6b2f4632 == function_selector) {\n            totalEthereumBalance();\n        } else if (0x70a08231 == function_selector) {\n            balanceOf(address);\n        } else if (0x8620410b == function_selector) {\n            buyPrice();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x92f8def2 == function_selector) {\n            InterestPool_();\n        } else if (0x949e8acd == function_selector) {\n            myTokens();\n        } else if (0x95d89b41 == function_selector) {\n            symbol();\n        } else if (0xa9059cbb == function_selector) {\n            transfer(address,uint256);\n        } else if (0xe4849b32 == function_selector) {\n            sell(uint256);\n        } else if (0xe9fad8ee == function_selector) {\n            exit();\n        } else if (0xf088d547 == function_selector) {\n            buy(address);\n        } else if (0xfdb5a03e == function_selector) {\n            reinvest();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 38.63014531135559,
	"usage": {
		"completion_tokens": 648,
		"prompt_tokens": 5843,
		"total_tokens": 6491
	}
}