{
	"address": "0x4d6ec066345e3466d9e970caad4732983ae4bc2c",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Due to the complexity of the decompiled code and the lack of specific context, I will provide a simplified version of a Smart Contract that incorporates many of the features mentioned in the decompiled code. It will include a mapping for names and addresses, ownership and authority, and name transfers. The contract will be written in Solidity, the most common language for Ethereum Smart Contracts.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract NameRegistry {\n    struct NameTransfer {\n        address from;\n        address to;\n        string name;\n    }\n    \n    uint256 public namePrice;\n    address public owner;\n    address public authority;\n    \n    mapping (address => string) public names;\n    mapping (string => address) private addresses;\n    mapping (address => NameTransfer) private pendingNameTransfers;\n    \n    event NameTransferRequested(address indexed from, address indexed to, string name);\n    event NameTransferAccepted(address indexed to, string name);\n    event NameSet(address indexed to, string name);\n    event NameUnset(address indexed from);\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    modifier onlyOwner {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        _;\n    }\n    \n    modifier onlyAuthority {\n        require(msg.sender == authority, \"Caller is not the authority\");\n        _;\n    }\n    \n    function setOwner(address newOwner) public onlyOwner {\n        owner = newOwner;\n    }\n    \n    function setAuthority(address newAuthority) public onlyOwner {\n        authority = newAuthority;\n    }\n    \n    function setNamePrice(uint256 newPrice) public onlyOwner {\n        namePrice = newPrice;\n    }\n    \n    function setMyName(string memory newName) public payable {\n        require(msg.value >= namePrice, \"Not enough Ether sent\");\n        require(addresses[newName] == address(0), \"Name is already taken\");\n        names[msg.sender] = newName;\n        addresses[newName] = msg.sender;\n        emit NameSet(msg.sender, newName);\n    }\n    \n    function unsetMyName() public {\n        string memory name = names[msg.sender];\n        delete addresses[name];\n        delete names[msg.sender];\n        emit NameUnset(msg.sender);\n    }\n    \n    function transferName(address to) public {\n        string memory name = names[msg.sender];\n        pendingNameTransfers[to] = NameTransfer(msg.sender, to, name);\n        emit NameTransferRequested(msg.sender, to, name);\n    }\n    \n    function acceptNameTransfer() public {\n        NameTransfer memory transfer = pendingNameTransfers[msg.sender];\n        require(transfer.to == msg.sender, \"No pending name transfer to this address\");\n        names[transfer.from] = \"\";\n        names[transfer.to] = transfer.name;\n        addresses[transfer.name] = transfer.to;\n        emit NameTransferAccepted(transfer.to, transfer.name);\n    }\n}\n```\nThis contract allows users to set and unset their names, as well as transfer names to other users. The `owner` of the contract can set the `authority` and the price for setting a name. Names are unique across the contract. \n\nPlease note that while this Smart Contract captures the essence of the decompiled code, it may not perfectly replicate the original contract due to the absence of specific context and the complexity of the decompiled code. It's also important to remember that all Solidity contracts should be thoroughly tested before deploying to a live network.",
				"role": "assistant"
			}
		}
	],
	"created": 1701460328,
	"id": "chatcmpl-8R3qSUO8jcC7lprC9Ik57hxUwYH4j",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.09.12 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _namePrice; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _hasName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addresses; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pendingNameTransfers; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\naddress _authority; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nLogSetOwner(address);\nNameTransferRequested(address, address, string);\nLogSetAuthority(address);\nNameTransferAccepted(address, string);\nNameSet(address, string);\nNameUnset(address);\n\nfunction pendingNameTransfers(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[varg0] & (!(_pendingNameTransfers[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (this != address(varg1)) {\n        if (_owner != address(varg1)) {\n            if (stor_0_0_0) {\n                v0 = address(varg1);\n                v1 = varg0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                require(_authority.code.size);\n                v2, v3 = _authority.canCall(v0, this, v1).gas(msg.gas);\n                require(v2); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                return v3;\n            } else {\n                v4 = v5 = 0;\n            }\n        } else {\n            v4 = v6 = 1;\n        }\n    } else {\n        v4 = v7 = 1;\n    }\n    return v4;\n}\n\nfunction 0x123b(uint256 varg0) private { \n    if (varg0.length) {\n        v0 = MEM[varg0.data];\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction transferMyName(address varg0) public payable { \n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    require((_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1 > 0, \"You don't have a name to transfer!\");\n    if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[varg0] = 1 + (((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v0 + (31 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v1) {\n                STORAGE[v2] = STORAGE[v1];\n                v1 += 1;\n                v2 += 1;\n            }\n        }\n    } else {\n        _hasName[varg0] = _hasName[msg.sender];\n    }\n    while (v3 + (31 + (((!(0x1 & _hasName[varg0]) << 8) - 1 & _hasName[varg0]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    v4 = new bytes[](v5);\n    v5 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v6 = v7 = v4.data;\n    if (v5) {\n        if (31 < v5) {\n            do {\n                MEM[v6] = STORAGE[v8];\n                v8 += 1;\n                v6 += 32;\n            } while (v7 + v5 <= v6);\n        }\n    }\n    if (v4.length) {\n        v9 = v4.data;\n        v10 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v10 = v11 = 0;\n    }\n    owner_6[v10] = 0x1 | ~0xff & owner_6[v10];\n    v12 = (_hasName[v10] & (!(_hasName[v10] & 0x1) << 8) + ~0) >> 1;\n    v13 = new array[](v12);\n    v14 = v15 = v13.data;\n    if (v12) {\n        if (31 < v12) {\n            do {\n                MEM[v14] = STORAGE[v16];\n                v16 += 1;\n                v14 += 32;\n            } while (v15 + v12 <= v14);\n        } else {\n            MEM[v15] = _hasName[v10] >> 8 << 8;\n        }\n    }\n    emit NameTransferRequested(msg.sender, varg0, v13);\n    v17 = v18 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[msg.sender] = 1;\n        if (0) {\n            while (v18 + 0 > v17) {\n                STORAGE[v19] = MEM[v17];\n                v17 += 32;\n                v19 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = 0x0 | ~0xff & varg0;\n    }\n    while (v20 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v19) {\n        STORAGE[v19] = 0;\n        v19 += 1;\n    }\n}\n\nfunction names(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[varg0] & (!(_hasName[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _hasName[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction setAuthority(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _authority = varg1;\n    emit LogSetAuthority(_authority);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction nameTaken(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x8c2(v0);\n    return v2;\n}\n\nfunction getMoney( function_selector) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    v1 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction acceptNameTranfer() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n        }\n    }\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    if (31 < (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[msg.sender] = 1 + (((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v5 + (31 + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v6) {\n                STORAGE[v7] = STORAGE[v6];\n                v6 += 1;\n                v7 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = _pendingNameTransfers[msg.sender];\n    }\n    while (v8 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v7) {\n        STORAGE[v7] = 0;\n        v7 += 1;\n    }\n    v9 = v10 = msg.sender;\n    v9 = v11 = 0;\n    v12 = v13 = new bytes[](v14);\n    v15 = v14 = (_pendingNameTransfers[v10] & (!(_pendingNameTransfers[v10] & 0x1) << 8) + ~0) >> 1;\n    v16 = v17 = 4;\n    v18 = v19 = 2931;\n    v20 = v21 = v13.data;\n    if (v14) {\n        if (31 >= v14) {\n            MEM[v21] = _pendingNameTransfers[v10] >> 8 << 8;\n        }\n    }\n    while (1) {\n        if (MEM[v12]) {\n            v22 = MEM[v12 + 32];\n        } else {\n            v22 = v23 = 0;\n        }\n        goto {'0xc1b', '0xb73'};\n        MEM[v9] = v22;\n        MEM[v9 + 32] = v16;\n        v9 = v24 = 0;\n        STORAGE[keccak256(MEM[v24 len (64 + v9)])] = address(v9) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(MEM[v24 len (64 + v9)])];\n        v12 = v25 = new bytes[](v26);\n        v15 = v26 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n        v16 = v27 = 6;\n        v18 = v28 = 3099;\n        v20 = v29 = v25.data;\n        if (v26) {\n            if (31 >= v26) {\n                MEM[v29] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n            }\n        }\n    }\n    MEM[v9] = v22;\n    MEM[v9 + 32] = v16;\n    STORAGE[keccak256(MEM[0 len (64 + v9)])] = v9 | ~0xff & STORAGE[keccak256(MEM[0 len (64 + v9)])];\n    v30 = v31 = 32 + MEM[64];\n    if (31 < 0) {\n        _pendingNameTransfers[msg.sender] = 1;\n        if (0) {\n            while (v31 + 0 > v30) {\n                STORAGE[v32] = MEM[v30];\n                v30 += 32;\n                v32 += 1;\n            }\n        }\n    } else {\n        _pendingNameTransfers[msg.sender] = 0x0 | ~0xff & MEM[v31];\n    }\n    while (v33 + (31 + (((!(0x1 & _pendingNameTransfers[msg.sender]) << 8) - 1 & _pendingNameTransfers[msg.sender]) >> 1) >> 5) > v32) {\n        STORAGE[v32] = 0;\n        v32 += 1;\n    }\n    v34 = new array[]((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1);\n    v35 = v36 = v34.data;\n    if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v35] = STORAGE[v37];\n                v37 += 1;\n                v35 += 32;\n            } while (v36 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) <= v35);\n        } else {\n            MEM[v36] = _hasName[msg.sender] >> 8 << 8;\n        }\n    }\n    emit NameTransferAccepted(msg.sender, v34);\n    exit;\n    do {\n        MEM[v20] = STORAGE[v38];\n        v38 += 1;\n        v20 += 32;\n    } while (v20 + v15 <= v20);\n}\n\nfunction hasName(address varg0) public nonPayable { \n    return (_hasName[varg0] & ~0 + (!(_hasName[varg0] & 0x1) << 8)) >> 1 > 0;\n}\n\nfunction namePrice() public nonPayable { \n    return _namePrice;\n}\n\nfunction addresses(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x123b(v0);\n    return address(_addresses[v2]);\n}\n\nfunction authority() public nonPayable { \n    return _authority;\n}\n\nfunction setMyName(string varg0) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x8c2(v0);\n    require(!v2, 'Name taken!');\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _hasName[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = 0x123b(v0);\n    _addresses[~0x0 & (~0x0 & v7)] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[~0x0 & (~0x0 & v7)];\n    v8 = new array[](v0.length);\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v9 + v8.data] = MEM[v9 + v0.data];\n        v9 += 32;\n    }\n    v11 = v12 = v0.length + v8.data;\n    if (0x1f & v0.length) {\n        MEM[v12 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v12 - (0x1f & v0.length)];\n    }\n    emit NameSet(msg.sender, v8);\n}\n\nfunction unsetMyName() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        }\n    }\n    if (v0.length) {\n        v5 = v0.data;\n        v6 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v6 = v7 = 0;\n    }\n    _addresses[v6] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[v6];\n    v8 = v9 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[v6] = 1;\n        if (0) {\n            while (v9 + 0 > v8) {\n                STORAGE[v10] = MEM[v8];\n                v8 += 32;\n                v10 += 1;\n            }\n        }\n    } else {\n        _hasName[v6] = 0x0 | ~0xff & MEM[v9];\n    }\n    while (v11 + (31 + (((!(0x1 & _hasName[v6]) << 8) - 1 & _hasName[v6]) >> 1) >> 5) > v10) {\n        STORAGE[v10] = 0;\n        v10 += 1;\n    }\n    emit NameUnset(msg.sender);\n}\n\nfunction 0x8c2(uint256 varg0) private { \n    v0 = 0x123b(varg0);\n    v1 = v2 = address(_addresses[v0]) != 0;\n    if (address(_addresses[v0]) == 0) {\n        v3 = 0x123b(varg0);\n        v1 = v4 = 0xff & owner_6[v3];\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction setOwner(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _owner = varg1;\n    emit LogSetOwner(_owner);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x13af4035) {\n            setOwner(address);\n        } else if (0x40a73fb4 == function_selector) {\n            pendingNameTransfers(address);\n        } else if (0x562bde28 == function_selector) {\n            transferMyName(address);\n        } else if (0x5cf3d346 == function_selector) {\n            names(address);\n        } else if (0x7a9e5e4b == function_selector) {\n            setAuthority(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91fc437e == function_selector) {\n            nameTaken(string);\n        } else if (0x98e1b410 == function_selector) {\n            getMoney();\n        } else if (0xacdfa0ac == function_selector) {\n            acceptNameTranfer();\n        } else if (0xaeda352b == function_selector) {\n            hasName(address);\n        } else if (0xb22073b6 == function_selector) {\n            namePrice();\n        } else if (0xbdfe7d47 == function_selector) {\n            addresses(string);\n        } else if (0xbf7e214f == function_selector) {\n            authority();\n        } else if (0xc7857d27 == function_selector) {\n            setMyName(string);\n        } else if (0xfdb473b1 == function_selector) {\n            unsetMyName();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _namePrice; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _hasName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addresses; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pendingNameTransfers; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\naddress _authority; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nLogSetOwner(address);\nNameTransferRequested(address, address, string);\nLogSetAuthority(address);\nNameTransferAccepted(address, string);\nNameSet(address, string);\nNameUnset(address);\n\nfunction pendingNameTransfers(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[varg0] & (!(_pendingNameTransfers[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (this != address(varg1)) {\n        if (_owner != address(varg1)) {\n            if (stor_0_0_0) {\n                v0 = address(varg1);\n                v1 = varg0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                require(_authority.code.size);\n                v2, v3 = _authority.canCall(v0, this, v1).gas(msg.gas);\n                require(v2); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                return v3;\n            } else {\n                v4 = v5 = 0;\n            }\n        } else {\n            v4 = v6 = 1;\n        }\n    } else {\n        v4 = v7 = 1;\n    }\n    return v4;\n}\n\nfunction 0x123b(uint256 varg0) private { \n    if (varg0.length) {\n        v0 = MEM[varg0.data];\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction transferMyName(address varg0) public payable { \n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    require((_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1 > 0, \"You don't have a name to transfer!\");\n    if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[varg0] = 1 + (((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v0 + (31 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v1) {\n                STORAGE[v2] = STORAGE[v1];\n                v1 += 1;\n                v2 += 1;\n            }\n        }\n    } else {\n        _hasName[varg0] = _hasName[msg.sender];\n    }\n    while (v3 + (31 + (((!(0x1 & _hasName[varg0]) << 8) - 1 & _hasName[varg0]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    v4 = new bytes[](v5);\n    v5 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v6 = v7 = v4.data;\n    if (v5) {\n        if (31 < v5) {\n            do {\n                MEM[v6] = STORAGE[v8];\n                v8 += 1;\n                v6 += 32;\n            } while (v7 + v5 <= v6);\n        }\n    }\n    if (v4.length) {\n        v9 = v4.data;\n        v10 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v10 = v11 = 0;\n    }\n    owner_6[v10] = 0x1 | ~0xff & owner_6[v10];\n    v12 = (_hasName[v10] & (!(_hasName[v10] & 0x1) << 8) + ~0) >> 1;\n    v13 = new array[](v12);\n    v14 = v15 = v13.data;\n    if (v12) {\n        if (31 < v12) {\n            do {\n                MEM[v14] = STORAGE[v16];\n                v16 += 1;\n                v14 += 32;\n            } while (v15 + v12 <= v14);\n        } else {\n            MEM[v15] = _hasName[v10] >> 8 << 8;\n        }\n    }\n    emit NameTransferRequested(msg.sender, varg0, v13);\n    v17 = v18 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[msg.sender] = 1;\n        if (0) {\n            while (v18 + 0 > v17) {\n                STORAGE[v19] = MEM[v17];\n                v17 += 32;\n                v19 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = 0x0 | ~0xff & varg0;\n    }\n    while (v20 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v19) {\n        STORAGE[v19] = 0;\n        v19 += 1;\n    }\n}\n\nfunction names(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[varg0] & (!(_hasName[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _hasName[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction setAuthority(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _authority = varg1;\n    emit LogSetAuthority(_authority);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction nameTaken(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x8c2(v0);\n    return v2;\n}\n\nfunction getMoney( function_selector) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    v1 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction acceptNameTranfer() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n        }\n    }\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    if (31 < (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[msg.sender] = 1 + (((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v5 + (31 + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v6) {\n                STORAGE[v7] = STORAGE[v6];\n                v6 += 1;\n                v7 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = _pendingNameTransfers[msg.sender];\n    }\n    while (v8 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v7) {\n        STORAGE[v7] = 0;\n        v7 += 1;\n    }\n    v9 = v10 = msg.sender;\n    v9 = v11 = 0;\n    v12 = v13 = new bytes[](v14);\n    v15 = v14 = (_pendingNameTransfers[v10] & (!(_pendingNameTransfers[v10] & 0x1) << 8) + ~0) >> 1;\n    v16 = v17 = 4;\n    v18 = v19 = 2931;\n    v20 = v21 = v13.data;\n    if (v14) {\n        if (31 >= v14) {\n            MEM[v21] = _pendingNameTransfers[v10] >> 8 << 8;\n        }\n    }\n    while (1) {\n        if (MEM[v12]) {\n            v22 = MEM[v12 + 32];\n        } else {\n            v22 = v23 = 0;\n        }\n        goto {'0xc1b', '0xb73'};\n        MEM[v9] = v22;\n        MEM[v9 + 32] = v16;\n        v9 = v24 = 0;\n        STORAGE[keccak256(MEM[v24 len (64 + v9)])] = address(v9) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(MEM[v24 len (64 + v9)])];\n        v12 = v25 = new bytes[](v26);\n        v15 = v26 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n        v16 = v27 = 6;\n        v18 = v28 = 3099;\n        v20 = v29 = v25.data;\n        if (v26) {\n            if (31 >= v26) {\n                MEM[v29] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n            }\n        }\n    }\n    MEM[v9] = v22;\n    MEM[v9 + 32] = v16;\n    STORAGE[keccak256(MEM[0 len (64 + v9)])] = v9 | ~0xff & STORAGE[keccak256(MEM[0 len (64 + v9)])];\n    v30 = v31 = 32 + MEM[64];\n    if (31 < 0) {\n        _pendingNameTransfers[msg.sender] = 1;\n        if (0) {\n            while (v31 + 0 > v30) {\n                STORAGE[v32] = MEM[v30];\n                v30 += 32;\n                v32 += 1;\n            }\n        }\n    } else {\n        _pendingNameTransfers[msg.sender] = 0x0 | ~0xff & MEM[v31];\n    }\n    while (v33 + (31 + (((!(0x1 & _pendingNameTransfers[msg.sender]) << 8) - 1 & _pendingNameTransfers[msg.sender]) >> 1) >> 5) > v32) {\n        STORAGE[v32] = 0;\n        v32 += 1;\n    }\n    v34 = new array[]((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1);\n    v35 = v36 = v34.data;\n    if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v35] = STORAGE[v37];\n                v37 += 1;\n                v35 += 32;\n            } while (v36 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) <= v35);\n        } else {\n            MEM[v36] = _hasName[msg.sender] >> 8 << 8;\n        }\n    }\n    emit NameTransferAccepted(msg.sender, v34);\n    exit;\n    do {\n        MEM[v20] = STORAGE[v38];\n        v38 += 1;\n        v20 += 32;\n    } while (v20 + v15 <= v20);\n}\n\nfunction hasName(address varg0) public nonPayable { \n    return (_hasName[varg0] & ~0 + (!(_hasName[varg0] & 0x1) << 8)) >> 1 > 0;\n}\n\nfunction namePrice() public nonPayable { \n    return _namePrice;\n}\n\nfunction addresses(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x123b(v0);\n    return address(_addresses[v2]);\n}\n\nfunction authority() public nonPayable { \n    return _authority;\n}\n\nfunction setMyName(string varg0) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x8c2(v0);\n    require(!v2, 'Name taken!');\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _hasName[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = 0x123b(v0);\n    _addresses[~0x0 & (~0x0 & v7)] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[~0x0 & (~0x0 & v7)];\n    v8 = new array[](v0.length);\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v9 + v8.data] = MEM[v9 + v0.data];\n        v9 += 32;\n    }\n    v11 = v12 = v0.length + v8.data;\n    if (0x1f & v0.length) {\n        MEM[v12 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v12 - (0x1f & v0.length)];\n    }\n    emit NameSet(msg.sender, v8);\n}\n\nfunction unsetMyName() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        }\n    }\n    if (v0.length) {\n        v5 = v0.data;\n        v6 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v6 = v7 = 0;\n    }\n    _addresses[v6] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[v6];\n    v8 = v9 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[v6] = 1;\n        if (0) {\n            while (v9 + 0 > v8) {\n                STORAGE[v10] = MEM[v8];\n                v8 += 32;\n                v10 += 1;\n            }\n        }\n    } else {\n        _hasName[v6] = 0x0 | ~0xff & MEM[v9];\n    }\n    while (v11 + (31 + (((!(0x1 & _hasName[v6]) << 8) - 1 & _hasName[v6]) >> 1) >> 5) > v10) {\n        STORAGE[v10] = 0;\n        v10 += 1;\n    }\n    emit NameUnset(msg.sender);\n}\n\nfunction 0x8c2(uint256 varg0) private { \n    v0 = 0x123b(varg0);\n    v1 = v2 = address(_addresses[v0]) != 0;\n    if (address(_addresses[v0]) == 0) {\n        v3 = 0x123b(varg0);\n        v1 = v4 = 0xff & owner_6[v3];\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction setOwner(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _owner = varg1;\n    emit LogSetOwner(_owner);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x13af4035) {\n            setOwner(address);\n        } else if (0x40a73fb4 == function_selector) {\n            pendingNameTransfers(address);\n        } else if (0x562bde28 == function_selector) {\n            transferMyName(address);\n        } else if (0x5cf3d346 == function_selector) {\n            names(address);\n        } else if (0x7a9e5e4b == function_selector) {\n            setAuthority(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91fc437e == function_selector) {\n            nameTaken(string);\n        } else if (0x98e1b410 == function_selector) {\n            getMoney();\n        } else if (0xacdfa0ac == function_selector) {\n            acceptNameTranfer();\n        } else if (0xaeda352b == function_selector) {\n            hasName(address);\n        } else if (0xb22073b6 == function_selector) {\n            namePrice();\n        } else if (0xbdfe7d47 == function_selector) {\n            addresses(string);\n        } else if (0xbf7e214f == function_selector) {\n            authority();\n        } else if (0xc7857d27 == function_selector) {\n            setMyName(string);\n        } else if (0xfdb473b1 == function_selector) {\n            unsetMyName();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.09.12 19:13 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint8 stor_0_0_0; // STORAGE[0x0] bytes 0 to 0\nuint256 _namePrice; // STORAGE[0x2]\nmapping (uint256 => [uint256]) _hasName; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _addresses; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _pendingNameTransfers; // STORAGE[0x5]\nmapping (uint256 => [uint256]) owner_6; // STORAGE[0x6]\naddress _authority; // STORAGE[0x0] bytes 0 to 19\naddress _owner; // STORAGE[0x1] bytes 0 to 19\n\n// Events\nLogSetOwner(address);\nNameTransferRequested(address, address, string);\nLogSetAuthority(address);\nNameTransferAccepted(address, string);\nNameSet(address, string);\nNameUnset(address);\n\nfunction pendingNameTransfers(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[varg0] & (!(_pendingNameTransfers[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction 0x1134(uint256 varg0, uint256 varg1) private { \n    if (this != address(varg1)) {\n        if (_owner != address(varg1)) {\n            if (stor_0_0_0) {\n                v0 = address(varg1);\n                v1 = varg0 & ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n                require(_authority.code.size);\n                v2, v3 = _authority.canCall(v0, this, v1).gas(msg.gas);\n                require(v2); // checks call status, propagates error data on error\n                require(RETURNDATASIZE() >= 32);\n                return v3;\n            } else {\n                v4 = v5 = 0;\n            }\n        } else {\n            v4 = v6 = 1;\n        }\n    } else {\n        v4 = v7 = 1;\n    }\n    return v4;\n}\n\nfunction 0x123b(uint256 varg0) private { \n    if (varg0.length) {\n        v0 = MEM[varg0.data];\n    } else {\n        v0 = v1 = 0;\n    }\n    return v0;\n}\n\nfunction transferMyName(address varg0) public payable { \n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    require((_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1 > 0, \"You don't have a name to transfer!\");\n    if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[varg0] = 1 + (((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v0 + (31 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v1) {\n                STORAGE[v2] = STORAGE[v1];\n                v1 += 1;\n                v2 += 1;\n            }\n        }\n    } else {\n        _hasName[varg0] = _hasName[msg.sender];\n    }\n    while (v3 + (31 + (((!(0x1 & _hasName[varg0]) << 8) - 1 & _hasName[varg0]) >> 1) >> 5) > v2) {\n        STORAGE[v2] = 0;\n        v2 += 1;\n    }\n    v4 = new bytes[](v5);\n    v5 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v6 = v7 = v4.data;\n    if (v5) {\n        if (31 < v5) {\n            do {\n                MEM[v6] = STORAGE[v8];\n                v8 += 1;\n                v6 += 32;\n            } while (v7 + v5 <= v6);\n        }\n    }\n    if (v4.length) {\n        v9 = v4.data;\n        v10 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v10 = v11 = 0;\n    }\n    owner_6[v10] = 0x1 | ~0xff & owner_6[v10];\n    v12 = (_hasName[v10] & (!(_hasName[v10] & 0x1) << 8) + ~0) >> 1;\n    v13 = new array[](v12);\n    v14 = v15 = v13.data;\n    if (v12) {\n        if (31 < v12) {\n            do {\n                MEM[v14] = STORAGE[v16];\n                v16 += 1;\n                v14 += 32;\n            } while (v15 + v12 <= v14);\n        } else {\n            MEM[v15] = _hasName[v10] >> 8 << 8;\n        }\n    }\n    emit NameTransferRequested(msg.sender, varg0, v13);\n    v17 = v18 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[msg.sender] = 1;\n        if (0) {\n            while (v18 + 0 > v17) {\n                STORAGE[v19] = MEM[v17];\n                v17 += 32;\n                v19 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = 0x0 | ~0xff & varg0;\n    }\n    while (v20 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v19) {\n        STORAGE[v19] = 0;\n        v19 += 1;\n    }\n}\n\nfunction names(address varg0) public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[varg0] & (!(_hasName[varg0] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _hasName[varg0] >> 8 << 8;\n        }\n    }\n    v5 = new array[](v0.length);\n    v6 = v7 = 0;\n    while (v6 < v0.length) {\n        MEM[v6 + v5.data] = MEM[v6 + v0.data];\n        v6 += 32;\n    }\n    v8 = v9 = v0.length + v5.data;\n    if (0x1f & v0.length) {\n        MEM[v9 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v9 - (0x1f & v0.length)];\n    }\n    return v5;\n}\n\nfunction setAuthority(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _authority = varg1;\n    emit LogSetAuthority(_authority);\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction nameTaken(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x8c2(v0);\n    return v2;\n}\n\nfunction getMoney( function_selector) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    v1 = _owner.call().value(this.balance).gas(2300 * !this.balance);\n    require(v1); // checks call status, propagates error data on error\n}\n\nfunction acceptNameTranfer() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        } else {\n            MEM[v3] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n        }\n    }\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    if (31 < (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        _hasName[msg.sender] = 1 + (((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1));\n        if ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            while (v5 + (31 + ((_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1) >> 5) > v6) {\n                STORAGE[v7] = STORAGE[v6];\n                v6 += 1;\n                v7 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = _pendingNameTransfers[msg.sender];\n    }\n    while (v8 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v7) {\n        STORAGE[v7] = 0;\n        v7 += 1;\n    }\n    v9 = v10 = msg.sender;\n    v9 = v11 = 0;\n    v12 = v13 = new bytes[](v14);\n    v15 = v14 = (_pendingNameTransfers[v10] & (!(_pendingNameTransfers[v10] & 0x1) << 8) + ~0) >> 1;\n    v16 = v17 = 4;\n    v18 = v19 = 2931;\n    v20 = v21 = v13.data;\n    if (v14) {\n        if (31 >= v14) {\n            MEM[v21] = _pendingNameTransfers[v10] >> 8 << 8;\n        }\n    }\n    while (1) {\n        if (MEM[v12]) {\n            v22 = MEM[v12 + 32];\n        } else {\n            v22 = v23 = 0;\n        }\n        goto {'0xc1b', '0xb73'};\n        MEM[v9] = v22;\n        MEM[v9 + 32] = v16;\n        v9 = v24 = 0;\n        STORAGE[keccak256(MEM[v24 len (64 + v9)])] = address(v9) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[keccak256(MEM[v24 len (64 + v9)])];\n        v12 = v25 = new bytes[](v26);\n        v15 = v26 = (_pendingNameTransfers[msg.sender] & (!(_pendingNameTransfers[msg.sender] & 0x1) << 8) + ~0) >> 1;\n        v16 = v27 = 6;\n        v18 = v28 = 3099;\n        v20 = v29 = v25.data;\n        if (v26) {\n            if (31 >= v26) {\n                MEM[v29] = _pendingNameTransfers[msg.sender] >> 8 << 8;\n            }\n        }\n    }\n    MEM[v9] = v22;\n    MEM[v9 + 32] = v16;\n    STORAGE[keccak256(MEM[0 len (64 + v9)])] = v9 | ~0xff & STORAGE[keccak256(MEM[0 len (64 + v9)])];\n    v30 = v31 = 32 + MEM[64];\n    if (31 < 0) {\n        _pendingNameTransfers[msg.sender] = 1;\n        if (0) {\n            while (v31 + 0 > v30) {\n                STORAGE[v32] = MEM[v30];\n                v30 += 32;\n                v32 += 1;\n            }\n        }\n    } else {\n        _pendingNameTransfers[msg.sender] = 0x0 | ~0xff & MEM[v31];\n    }\n    while (v33 + (31 + (((!(0x1 & _pendingNameTransfers[msg.sender]) << 8) - 1 & _pendingNameTransfers[msg.sender]) >> 1) >> 5) > v32) {\n        STORAGE[v32] = 0;\n        v32 += 1;\n    }\n    v34 = new array[]((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1);\n    v35 = v36 = v34.data;\n    if ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n        if (31 < (_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) {\n            do {\n                MEM[v35] = STORAGE[v37];\n                v37 += 1;\n                v35 += 32;\n            } while (v36 + ((_hasName[msg.sender] & (!(_hasName[msg.sender] & 0x1) << 8) + ~0) >> 1) <= v35);\n        } else {\n            MEM[v36] = _hasName[msg.sender] >> 8 << 8;\n        }\n    }\n    emit NameTransferAccepted(msg.sender, v34);\n    exit;\n    do {\n        MEM[v20] = STORAGE[v38];\n        v38 += 1;\n        v20 += 32;\n    } while (v20 + v15 <= v20);\n}\n\nfunction hasName(address varg0) public nonPayable { \n    return (_hasName[varg0] & ~0 + (!(_hasName[varg0] & 0x1) << 8)) >> 1 > 0;\n}\n\nfunction namePrice() public nonPayable { \n    return _namePrice;\n}\n\nfunction addresses(string varg0) public nonPayable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x123b(v0);\n    return address(_addresses[v2]);\n}\n\nfunction authority() public nonPayable { \n    return _authority;\n}\n\nfunction setMyName(string varg0) public payable { \n    v0 = new bytes[]((?).length);\n    v1 = msg.data.length;\n    CALLDATACOPY(v0.data, 36 + varg0, (?).length);\n    v2 = 0x8c2(v0);\n    require(!v2, 'Name taken!');\n    require(v0.length <= 32, 'Name too long!');\n    require(1 <= v0.length, 'Name too short!');\n    require(msg.value >= _namePrice, 'Not enough value sent!');\n    v3 = v4 = v0.data;\n    if (31 < v0.length) {\n        _hasName[msg.sender] = 1 + (v0.length + v0.length);\n        if (v0.length) {\n            while (v4 + v0.length > v3) {\n                STORAGE[v5] = MEM[v3];\n                v3 += 32;\n                v5 += 1;\n            }\n        }\n    } else {\n        _hasName[msg.sender] = v0.length + v0.length | ~0xff & MEM[v4];\n    }\n    while (v6 + (31 + (((!(0x1 & _hasName[msg.sender]) << 8) - 1 & _hasName[msg.sender]) >> 1) >> 5) > v5) {\n        STORAGE[v5] = 0;\n        v5 += 1;\n    }\n    v7 = 0x123b(v0);\n    _addresses[~0x0 & (~0x0 & v7)] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[~0x0 & (~0x0 & v7)];\n    v8 = new array[](v0.length);\n    v9 = v10 = 0;\n    while (v9 < v0.length) {\n        MEM[v9 + v8.data] = MEM[v9 + v0.data];\n        v9 += 32;\n    }\n    v11 = v12 = v0.length + v8.data;\n    if (0x1f & v0.length) {\n        MEM[v12 - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v12 - (0x1f & v0.length)];\n    }\n    emit NameSet(msg.sender, v8);\n}\n\nfunction unsetMyName() public nonPayable { \n    v0 = new bytes[](v1);\n    v1 = (_hasName[msg.sender] & ~0 + (!(_hasName[msg.sender] & 0x1) << 8)) >> 1;\n    v2 = v3 = v0.data;\n    if (v1) {\n        if (31 < v1) {\n            do {\n                MEM[v2] = STORAGE[v4];\n                v4 += 1;\n                v2 += 32;\n            } while (v3 + v1 <= v2);\n        }\n    }\n    if (v0.length) {\n        v5 = v0.data;\n        v6 = _hasName[msg.sender] >> 8 << 8;\n    } else {\n        v6 = v7 = 0;\n    }\n    _addresses[v6] = 0x0 | ~0xffffffffffffffffffffffffffffffffffffffff & _addresses[v6];\n    v8 = v9 = 32 + MEM[64];\n    if (31 < 0) {\n        _hasName[v6] = 1;\n        if (0) {\n            while (v9 + 0 > v8) {\n                STORAGE[v10] = MEM[v8];\n                v8 += 32;\n                v10 += 1;\n            }\n        }\n    } else {\n        _hasName[v6] = 0x0 | ~0xff & MEM[v9];\n    }\n    while (v11 + (31 + (((!(0x1 & _hasName[v6]) << 8) - 1 & _hasName[v6]) >> 1) >> 5) > v10) {\n        STORAGE[v10] = 0;\n        v10 += 1;\n    }\n    emit NameUnset(msg.sender);\n}\n\nfunction 0x8c2(uint256 varg0) private { \n    v0 = 0x123b(varg0);\n    v1 = v2 = address(_addresses[v0]) != 0;\n    if (address(_addresses[v0]) == 0) {\n        v3 = 0x123b(varg0);\n        v1 = v4 = 0xff & owner_6[v3];\n    }\n    return v1;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\nfunction setOwner(uint256 function_selector, address varg1) public nonPayable { \n    v0 = 0x1134(~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & function_selector, msg.sender);\n    require(v0);\n    _owner = varg1;\n    emit LogSetOwner(_owner);\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (function_selector == 0x13af4035) {\n            setOwner(address);\n        } else if (0x40a73fb4 == function_selector) {\n            pendingNameTransfers(address);\n        } else if (0x562bde28 == function_selector) {\n            transferMyName(address);\n        } else if (0x5cf3d346 == function_selector) {\n            names(address);\n        } else if (0x7a9e5e4b == function_selector) {\n            setAuthority(address);\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0x91fc437e == function_selector) {\n            nameTaken(string);\n        } else if (0x98e1b410 == function_selector) {\n            getMoney();\n        } else if (0xacdfa0ac == function_selector) {\n            acceptNameTranfer();\n        } else if (0xaeda352b == function_selector) {\n            hasName(address);\n        } else if (0xb22073b6 == function_selector) {\n            namePrice();\n        } else if (0xbdfe7d47 == function_selector) {\n            addresses(string);\n        } else if (0xbf7e214f == function_selector) {\n            authority();\n        } else if (0xc7857d27 == function_selector) {\n            setMyName(string);\n        } else if (0xfdb473b1 == function_selector) {\n            unsetMyName();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 75.84220576286316,
	"usage": {
		"completion_tokens": 706,
		"prompt_tokens": 5376,
		"total_tokens": 6082
	}
}