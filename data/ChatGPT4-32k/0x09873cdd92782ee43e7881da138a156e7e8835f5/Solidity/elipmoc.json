{
	"address": "0x09873cdd92782ee43e7881da138a156e7e8835f5",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Here is a Solidity contract code that would be the equivalent of your decompiled code. Please note that as the decompiled code is quite low level, there might be certain aspects that might not be directly translatable into high level Solidity language. Also, there might be some potential security issues that need to be addressed in a real-world scenario.\n\n```solidity\npragma solidity ^0.5.16;\n\ncontract YourContract {\n\n    uint256 private _totalRise;\n    address private _owner;\n    address private _priceWithBonus;\n    address private _token;\n\n    // This is a placeholder for the actual token interface\n    interface IToken {\n        function balanceOf(address account) external view returns (uint256);\n        function transfer(address recipient, uint256 amount) external returns (bool);\n        function burn(uint256 amount) external;\n    }\n\n    // This is a placeholder for the actual priceWithBonus interface\n    interface IPriceWithBonus {\n        function getPriceWithBonus() external view returns (uint256);\n        function getPrice() external view returns (uint256);\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function totalRise() public view returns (uint256) {\n        return _totalRise;\n    }\n\n    function sendTokens(address recipient, uint256 amount) public {\n        require(_owner == msg.sender, \"Only owner can send tokens\");\n        IToken tokenContract = IToken(_token);\n        uint256 balance = tokenContract.balanceOf(address(this));\n        require(balance > amount, \"Not enough tokens to send\");\n        bool transferSuccessful = tokenContract.transfer(recipient, amount);\n        require(transferSuccessful, \"Token transfer failed\");\n        _totalRise += amount;\n    }\n\n    function tokensToSale() public view returns (uint256) {\n        IToken tokenContract = IToken(_token);\n        return tokenContract.balanceOf(address(this));\n    }\n\n    function withdraw() public {\n        require(_owner == msg.sender, \"Only owner can withdraw\");\n        _priceWithBonus.call.value(address(this).balance)(\"\");\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function price() public view returns (uint256) {\n        IPriceWithBonus priceContract = IPriceWithBonus(_priceWithBonus);\n        return priceContract.getPrice();\n    }\n\n    function burnUnsold() public {\n        require(_owner == msg.sender, \"Only owner can burn tokens\");\n        IToken tokenContract = IToken(_token);\n        uint256 balance = tokenContract.balanceOf(address(this));\n        tokenContract.burn(balance);\n    }\n\n    function transferOwnership(address newOwner) public {\n        require(_owner == msg.sender, \"Only owner can transfer ownership\");\n        require(newOwner != address(0), \"New owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    function token() public view returns (address) {\n        return _token;\n    }\n\n    function priceWithBonus() public view returns (uint256) {\n        IPriceWithBonus priceContract = IPriceWithBonus(_priceWithBonus);\n        return priceContract.getPriceWithBonus();\n    }\n\n    function() external payable {\n        // Code for the fallback function\n    }\n}\n```\nPlease note that the actual implementation of the `_priceWithBonus.call` in `withdraw()` function and the fallback function have not been provided in the original decompiled code.",
				"role": "assistant"
			}
		}
	],
	"created": 1701467310,
	"id": "chatcmpl-8R5f4wRn2jJyynmfU5fruJXONfd4k",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.16 01:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalRise; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _priceWithBonus; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction totalRise() public nonPayable { \n    return _totalRise;\n}\n\nfunction sendTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    assert(v1 > varg1);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v2);\n    v4 = 0x2e9();\n    v5 = 0x352(v4, varg1);\n    v6 = _SafeAdd(v5, _totalRise);\n    _totalRise = v6;\n}\n\nfunction tokensToSale() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _priceWithBonus.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction price() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPrice().gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction burnUnsold() public nonPayable { \n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    require(_token.code.size);\n    v2 = _token.burn(v1).gas(msg.gas - 710);\n    require(v2);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction priceWithBonus() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPriceWithBonus().gas(msg.gas - 710);\n    require(v0);\n    return MEM[MEM[64]];\n}\n\nfunction 0x2e9() private { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPriceWithBonus().gas(msg.gas - 710);\n    require(v0);\n    return MEM[MEM[64]];\n}\n\nfunction 0x352(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x2e9();\n    v1 = 0x352(0xde0b6b3a7640000, msg.value);\n    assert(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v2);\n    assert(v3 > v1 / v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v4, v5 = _token.transfer(msg.sender, v1 / v0).gas(msg.gas - 710);\n    require(v4);\n    v6 = _SafeAdd(msg.value, _totalRise);\n    _totalRise = v6;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x2099186) {\n            totalRise();\n        } else if (0x5ab421d == uint32(function_selector >> 224)) {\n            sendTokens(address,uint256);\n        } else if (0x1d211d74 == uint32(function_selector >> 224)) {\n            tokensToSale();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0xa035b1fe == uint32(function_selector >> 224)) {\n            price();\n        } else if (0xb52a5851 == uint32(function_selector >> 224)) {\n            burnUnsold();\n        } else if (0xf2fde38b == uint32(function_selector >> 224)) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == uint32(function_selector >> 224)) {\n            token();\n        } else if (0xfc3880ae == uint32(function_selector >> 224)) {\n            priceWithBonus();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 01:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalRise; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _priceWithBonus; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction totalRise() public nonPayable { \n    return _totalRise;\n}\n\nfunction sendTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    assert(v1 > varg1);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v2);\n    v4 = 0x2e9();\n    v5 = 0x352(v4, varg1);\n    v6 = _SafeAdd(v5, _totalRise);\n    _totalRise = v6;\n}\n\nfunction tokensToSale() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _priceWithBonus.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction price() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPrice().gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction burnUnsold() public nonPayable { \n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    require(_token.code.size);\n    v2 = _token.burn(v1).gas(msg.gas - 710);\n    require(v2);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction priceWithBonus() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPriceWithBonus().gas(msg.gas - 710);\n    require(v0);\n    return MEM[MEM[64]];\n}\n\nfunction 0x2e9() private { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPriceWithBonus().gas(msg.gas - 710);\n    require(v0);\n    return MEM[MEM[64]];\n}\n\nfunction 0x352(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x2e9();\n    v1 = 0x352(0xde0b6b3a7640000, msg.value);\n    assert(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v2);\n    assert(v3 > v1 / v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v4, v5 = _token.transfer(msg.sender, v1 / v0).gas(msg.gas - 710);\n    require(v4);\n    v6 = _SafeAdd(msg.value, _totalRise);\n    _totalRise = v6;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x2099186) {\n            totalRise();\n        } else if (0x5ab421d == uint32(function_selector >> 224)) {\n            sendTokens(address,uint256);\n        } else if (0x1d211d74 == uint32(function_selector >> 224)) {\n            tokensToSale();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0xa035b1fe == uint32(function_selector >> 224)) {\n            price();\n        } else if (0xb52a5851 == uint32(function_selector >> 224)) {\n            burnUnsold();\n        } else if (0xf2fde38b == uint32(function_selector >> 224)) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == uint32(function_selector >> 224)) {\n            token();\n        } else if (0xfc3880ae == uint32(function_selector >> 224)) {\n            priceWithBonus();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.16 01:52 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _totalRise; // STORAGE[0x3]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _priceWithBonus; // STORAGE[0x1] bytes 0 to 19\naddress _token; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nOwnershipTransferred(address, address);\n\nfunction totalRise() public nonPayable { \n    return _totalRise;\n}\n\nfunction sendTokens(address varg0, uint256 varg1) public nonPayable { \n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    assert(v1 > varg1);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.transfer(varg0, varg1).gas(msg.gas - 710);\n    require(v2);\n    v4 = 0x2e9();\n    v5 = 0x352(v4, varg1);\n    v6 = _SafeAdd(v5, _totalRise);\n    _totalRise = v6;\n}\n\nfunction tokensToSale() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction withdraw() public nonPayable { \n    require(_owner == msg.sender);\n    v0 = _priceWithBonus.call().value((address(this)).balance).gas(2300 * !(address(this)).balance);\n    return v0;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction price() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPrice().gas(msg.gas - 710);\n    require(v0);\n    return v1;\n}\n\nfunction burnUnsold() public nonPayable { \n    require(_owner == msg.sender);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v0, v1 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v0);\n    require(_token.code.size);\n    v2 = _token.burn(v1).gas(msg.gas - 710);\n    require(v2);\n    return v1;\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(_owner == msg.sender);\n    require(varg0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction token() public nonPayable { \n    return _token;\n}\n\nfunction priceWithBonus() public nonPayable { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPriceWithBonus().gas(msg.gas - 710);\n    require(v0);\n    return MEM[MEM[64]];\n}\n\nfunction 0x2e9() private { \n    MEM[32 + MEM[64]] = 0;\n    require(_priceWithBonus.code.size);\n    v0, v1 = _priceWithBonus.getPriceWithBonus().gas(msg.gas - 710);\n    require(v0);\n    return MEM[MEM[64]];\n}\n\nfunction 0x352(uint256 varg0, uint256 varg1) private { \n    if (varg1) {\n        v0 = v1 = varg0 * varg1;\n        assert(varg1);\n        assert(v1 / varg1 == varg0);\n    } else {\n        v0 = v2 = 0;\n    }\n    return v0;\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    v0 = varg0 + varg1;\n    assert(v0 >= varg1);\n    return v0;\n}\n\nfunction fallback() public payable { \n    v0 = 0x2e9();\n    v1 = 0x352(0xde0b6b3a7640000, msg.value);\n    assert(v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v2, v3 = _token.balanceOf(address(this)).gas(msg.gas - 710);\n    require(v2);\n    assert(v3 > v1 / v0);\n    MEM[32 + MEM[64]] = 0;\n    require(_token.code.size);\n    v4, v5 = _token.transfer(msg.sender, v1 / v0).gas(msg.gas - 710);\n    require(v4);\n    v6 = _SafeAdd(msg.value, _totalRise);\n    _totalRise = v6;\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint256 function_selector) public payable { \n    MEM[64] = 96;\n    if (msg.data.length >= 4) {\n        if (uint32(function_selector >> 224) == 0x2099186) {\n            totalRise();\n        } else if (0x5ab421d == uint32(function_selector >> 224)) {\n            sendTokens(address,uint256);\n        } else if (0x1d211d74 == uint32(function_selector >> 224)) {\n            tokensToSale();\n        } else if (0x3ccfd60b == uint32(function_selector >> 224)) {\n            withdraw();\n        } else if (0x8da5cb5b == uint32(function_selector >> 224)) {\n            owner();\n        } else if (0xa035b1fe == uint32(function_selector >> 224)) {\n            price();\n        } else if (0xb52a5851 == uint32(function_selector >> 224)) {\n            burnUnsold();\n        } else if (0xf2fde38b == uint32(function_selector >> 224)) {\n            transferOwnership(address);\n        } else if (0xfc0c546a == uint32(function_selector >> 224)) {\n            token();\n        } else if (0xfc3880ae == uint32(function_selector >> 224)) {\n            priceWithBonus();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 33.3216347694397,
	"usage": {
		"completion_tokens": 725,
		"prompt_tokens": 1512,
		"total_tokens": 2237
	}
}