{
	"address": "0x3935eaf11b29396f3067e45d7c68c400662be8b2",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "The following Solidity code represents the decompiled EVM Bytecode:\n\n```solidity\npragma solidity ^0.7.6;\n\ncontract ExampleContract {\n    uint256 private _slot0;\n    uint256 private _feeGrowthGlobal0X128;\n    uint256 private _feeGrowthGlobal1X128;\n    uint256 private _protocolFees;\n    uint256 private _liquidity;\n    uint256 private stor_8_0_3;\n    uint256 private stor_8_4_30;\n    uint256 private stor_8_31_31;\n    uint256 private stor_3_16_31;\n    \n    struct Struct_1262 {\n        uint256 field0;\n        uint256 field1;\n        uint256 field2;\n        uint256 field3;\n    }\n    \n    struct Struct_1263 {\n        uint256 field0;\n        uint256 field1;\n        uint256 field2;\n        uint256 field3;\n    }\n    \n    mapping (uint256 => Struct_1262) _ticks; \n    mapping (uint256 => uint256) _tickBitmap; \n    mapping (uint256 => Struct_1263) _positions; \n\n    event Swap(address, address, int256, int256, uint160, uint128, int24);\n    event IncreaseObservationCardinalityNext(uint16, uint16);\n    event Mint(address, address, int24, int24, uint128, uint256, uint256);\n    event Flash(address, address, uint256, uint256, uint256, uint256);\n    event Collect(address, address, int24, int24, uint128, uint128);\n    event SetFeeProtocol(uint8, uint8, uint8, uint8);\n    event CollectProtocol(address, address, uint128, uint128);\n    event Initialize(uint160, int24);\n\n    function token0() public payable {\n        return address(0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n\n    function swap(address varg0, bool varg1, int256 varg2, uint160 varg3, bytes memory varg4) public payable {\n        require(msg.data.length - 4 >= 160);\n        // ... omitted for brevity ...\n        return v19, v21;\n    }\n\n    function liquidity() public payable {\n        return _liquidity;\n    }\n\n    function protocolFees() public payable {\n        return _protocolFees, stor_3_16_31;\n    }\n\n    function increaseObservationCardinalityNext(uint16 varg0) public payable {\n        require(msg.data.length - 4 >= 32);\n        require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n        _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n        require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n        // ... omitted for brevity ...\n    }\n\n    function burn(int24 varg0, int24 varg1, uint128 varg2) public payable {\n        require(msg.data.length - 4 >= 96);\n        require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n        _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n        // ... omitted for brevity ...\n    }\n\n    function setFeeProtocol(uint8 varg0, uint8 varg1) public payable {\n        require(msg.data.length - 4 >= 64);\n        require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n        _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n        require(bool((address(0x1f98431c8ad98523631ae4a59f267346ea31f984)).code.size));\n        // ... omitted for brevity ...\n    }\n\n    function collectProtocol(address varg0, uint128 varg1, uint128 varg2) public payable {\n        require(msg.data.length - 4 >= 96);\n        // ... omitted for brevity ...\n        return uint128(v0), uint128(v2);\n    }\n}\n```\nThe above code represents a smart contract for a decentralized exchange or DEX. The smart contract includes functions for swapping tokens, adjusting liquidity, and managing protocol fees. The contract also includes events for minting, swapping, and collecting tokens.\n\nNote: The exact functionality of the smart contract depends on the specific implementation of each function. The above code is only a skeleton structure of the smart contract based on the decompiled EVM Bytecode.",
				"role": "assistant"
			}
		}
	],
	"created": 1700632514,
	"id": "chatcmpl-8NaUcRvFje6lm2QyCoygZkv9T0U9m",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled by library.dedaub.com\n// 2023.11.16 03:31 UTC\n// Compiled using the solidity compiler version 0.7.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _slot0; // STORAGE[0x0]\nuint256 _feeGrowthGlobal0X128; // STORAGE[0x1]\nuint256 _feeGrowthGlobal1X128; // STORAGE[0x2]\nmapping (uint256 => struct_1262) _ticks; // STORAGE[0x5]\nmapping (uint256 => uint256) _tickBitmap; // STORAGE[0x6]\nmapping (uint256 => struct_1263) _positions; // STORAGE[0x7]\nuint256 stor_8_0_3; // STORAGE[0x8] bytes 0 to 3\nuint256 _protocolFees; // STORAGE[0x3] bytes 0 to 15\nuint256 _liquidity; // STORAGE[0x4] bytes 0 to 15\nuint256 stor_8_4_30; // STORAGE[0x8] bytes 4 to 30\nuint256 stor_3_16_31; // STORAGE[0x3] bytes 16 to 31\nuint256 stor_8_31_31; // STORAGE[0x8] bytes 31 to 31\n\nstruct struct_1262 { uint256 field0; uint256 field1; uint256 field2; uint256 field3; };\nstruct struct_1263 { uint256 field0; uint256 field1; uint256 field2; uint256 field3; };\n\n// Events\nSwap(address, address, int256, int256, uint160, uint128, int24);\nIncreaseObservationCardinalityNext(uint16, uint16);\nMint(address, address, int24, int24, uint128, uint256, uint256);\nFlash(address, address, uint256, uint256, uint256, uint256);\nCollect(address, address, int24, int24, uint128, uint128);\nSetFeeProtocol(uint8, uint8, uint8, uint8);\nCollectProtocol(address, address, uint128, uint128);\nInitialize(uint160, int24);\n\nfunction token0() public payable { \n    return address(0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n}\n\nfunction swap(address varg0, bool varg1, int256 varg2, uint160 varg3, bytes varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    v0 = v1 = address(varg3);\n    require(varg4 <= 0x100000000);\n    require(varg4.data <= 4 + (msg.data.length - 4));\n    require(!((varg4.length > 0x100000000) | (varg4.data + varg4.length > 4 + (msg.data.length - 4))));\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    require(varg2, Error(16723));\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    require(bool(uint8(_slot0 >> 240)), Error(0x4c4f4b));\n    if (varg1) {\n        v2 = v3 = address(v1) < address(_slot0);\n        if (v3) {\n            v2 = v4 = address(v1) > 0x1000276a3;\n        }\n    } else {\n        v2 = v5 = address(v1) > address(_slot0);\n        if (v5) {\n            v2 = v6 = address(v1) < 0xfffd8963efd1fc6a506488495d951d5263988d26;\n        }\n    }\n    require(v2, Error(0x53504c));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    if (varg1) {\n        assert(16);\n        v7 = v8 = uint8(_slot0 >> 232) % 16;\n    } else {\n        v7 = v9 = uint8(_slot0 >> 232) >> 4;\n    }\n    MEM[96 + MEM[64]] = int56(0);\n    MEM[128 + MEM[64]] = address(0x0);\n    v10 = MEM[64];\n    MEM[32 + v10] = 0;\n    if (varg1) {\n        v11 = v12 = _feeGrowthGlobal0X128;\n    } else {\n        v11 = v13 = _feeGrowthGlobal1X128;\n    }\n    while (1) {\n        v14 = v15 = bool(varg2);\n        if (!varg2) {\n            // Unknown jump to Block 0xbd5. Refer to 3-address code (TAC);\n        }\n        v14 = v16 = address(MEM[64 + v10]) != address(v1);\n        if (!v14) {\n            if (int24(MEM[96 + v10]) == int24(_slot0 >> 160)) {\n                _slot0 = address(MEM[v10 + 64]) | bytes12(_slot0);\n            } else {\n                v17, v18 = 0x39d1(uint16(_slot0 >> 216), uint16(_slot0 >> 200), _liquidity, int24(_slot0 >> 160), uint32(block.timestamp), uint16(_slot0 >> 184), 8);\n                _slot0 = address(MEM[v10 + 64]) | bytes12(uint24(int24(MEM[v10 + 96])) << 160 | ~0xffffff0000000000000000000000000000000000000000 & (uint16(v18) << 184 | ~0xffff0000000000000000000000000000000000000000000000 & (uint16(v17) << 200 | ~0xffff00000000000000000000000000000000000000000000000000 & _slot0)));\n            }\n            if (uint128(_liquidity) != uint128(MEM[192 + v10])) {\n                _liquidity = MEM[v10 + 192];\n            }\n            if (bool(!varg1)) {\n                _feeGrowthGlobal1X128 = MEM[v10 + 128];\n                if (uint128(MEM[v10 + 160])) {\n                    stor_3_16_31 += MEM[v10 + 160];\n                }\n            } else {\n                _feeGrowthGlobal0X128 = MEM[v10 + 128];\n                if (uint128(MEM[v10 + 160])) {\n                    _protocolFees += MEM[v10 + 160];\n                }\n            }\n            if (varg1 == bool(varg2 > 0)) {\n                v19 = v20 = varg2 - MEM[0 + v10];\n                v21 = v22 = MEM[32 + v10];\n            } else {\n                v19 = v23 = MEM[v10 + 32];\n                v21 = v24 = varg2 - MEM[v10];\n            }\n            if (bool(!varg1)) {\n                if (v19 < 0) {\n                    0x3b86(0 - v19, varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n                }\n                v25 = 0x3e1d();\n                v26 = new bytes[](varg4.length);\n                CALLDATACOPY(v26.data, varg4.data, varg4.length);\n                v26[varg4.length] = 0;\n                require(bool((address(msg.sender)).code.size));\n                v27 = msg.sender.uniswapV3SwapCallback(v19, v21, v26).gas(msg.gas);\n                require(bool(v27), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v28 = 0x3e1d();\n                require(v25 + v21 >= v25);\n                require(v25 + v21 <= v28, Error(0x494941));\n            } else {\n                if (v21 < 0) {\n                    0x3b86(0 - v21, varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n                }\n                v29 = 0x3cd4();\n                v30 = new bytes[](varg4.length);\n                CALLDATACOPY(v30.data, varg4.data, varg4.length);\n                v30[varg4.length] = 0;\n                require(bool((address(msg.sender)).code.size));\n                v31 = msg.sender.uniswapV3SwapCallback(v19, v21, v30).gas(msg.gas);\n                require(bool(v31), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v32 = 0x3cd4();\n                require(v29 + v19 >= v29);\n                require(v29 + v19 <= v32, Error(0x494941));\n            }\n            emit Swap(msg.sender, varg0, v19, v21, address(MEM[v10 + 64]), uint128(MEM[v10 + 192]), int24(MEM[v10 + 96]));\n            _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n            return v19, v21;\n        } else {\n            v33 = MEM[64];\n            MEM[v33] = 0;\n            MEM[v33 + 32] = 0;\n            MEM[v33 + 64] = 0;\n            MEM[v33 + 96] = 0;\n            MEM[v33 + 128] = 0;\n            MEM[v33 + 160] = 0;\n            MEM[v33 + 192] = 0;\n            assert(int24(60));\n            v34 = v35 = int24(_slot0 >> 160) / int24(60);\n            v36 = v37 = int24(_slot0 >> 160) < 0;\n            if (v37) {\n                assert(int24(60));\n                v36 = bool(int24(int24(int24(int24(int24(int24(_slot0 >> 160))))) % int24(60)));\n            }\n            if (v36) {\n                v34 = v38 = ~0 + v35;\n            }\n            if (bool(!varg1)) {\n                v39 = 0 != _tickBitmap[int16(int24(1 + v34) >> 8)] & ~((1 << uint8(int24(1 + v34) % 256)) - 1);\n                if (v39) {\n                    v40 = 0x4568(_tickBitmap[int16(int24(1 + v34) >> 8)] & ~((1 << uint8(int24(1 + v34) % 256)) - 1));\n                    v41 = v42 = (1 + v34 + uint8(v40 - int24(1 + v34) % 256)) * 60;\n                } else {\n                    v41 = (1 + v34 + uint8(uint8.max - int24(1 + v34) % 256)) * 60;\n                }\n            } else {\n                v39 = v43 = bool(~0 + ((1 << uint8(int24(v34) % 256)) + (1 << uint8(int24(v34) % 256))) & _tickBitmap[int16(int24(v34) >> 8)]);\n                if (v43) {\n                    v44 = 0x44c8(~0 + ((1 << uint8(int24(v34) % 256)) + (1 << uint8(int24(v34) % 256))) & _tickBitmap[int16(int24(v34) >> 8)]);\n                    v41 = v45 = (v34 - uint8(int24(v34) % 256 - v44)) * 60;\n                } else {\n                    v41 = v46 = (v34 - uint8(int24(v34) % 256)) * 60;\n                }\n            }\n            MEM[v33 + 32] = int24(v41);\n            if (int24(v41) >= ~0xd89e7) {\n                if (int24(MEM[v33 + 32]) > 0xd89e8) {\n                    MEM[v33 + 32] = 0xd89e8;\n                }\n            } else {\n                MEM[v33 + 32] = ~0xd89e7;\n            }\n            v47 = 0x2d6d(MEM[32 + v33]);\n            if (varg1) {\n                v48 = v49 = address(v47) < address(v1);\n            } else {\n                v48 = v50 = address(v47) > address(v1);\n            }\n            if (!v48) {\n            }\n            v51 = v52 = 0;\n            v53 = v54 = varg2 >= v52;\n            if (varg2 < v52) {\n                if (address(v55) >= address(v0)) {\n                    v51 = v56 = 0x4652(0, v57, v55, v0);\n                } else {\n                    v51 = v58 = 0x46cd(0, v57, v0, v55);\n                }\n                if (0 - varg2 < v51) {\n                    require(address(v55) > 0);\n                    require(uint128(v57) > 0);\n                    if (address(v55) >= address(v0)) {\n                        v0 = v59 = 0x4d02(0, 0 - varg2, v57, v55);\n                    } else {\n                        v0 = v60 = 0x4de3(0, 0 - varg2, v57, v55);\n                    }\n                }\n            } else {\n                v61 = 0x32d9(0xf4240, uint24(0xf3688), varg2);\n                if (address(v55) >= address(v0)) {\n                    v51 = v62 = 0x46cd(1, v57, v55, v0);\n                } else {\n                    v51 = v63 = 0x4652(1, v57, v0, v55);\n                }\n                if (v61 < v51) {\n                    require(address(v55) > 0);\n                    require(uint128(v57) > 0);\n                    if (address(v55) >= address(v0)) {\n                        v0 = v64 = 0x4de3(1, v61, v57, v55);\n                    } else {\n                        v0 = v65 = 0x4d02(1, v61, v57, v55);\n                    }\n                }\n                // Unknown jump to Block 0x316e. Refer to 3-address code (TAC);\n            }\n            v53 = v66 = address(v0) == address(v0);\n            if (bool(address(v55) < address(v0))) {\n                if (!v53) {\n                    v51 = v67 = 0x4652(1, v57, v0, v55);\n                }\n                if (v66) {\n                    v53 = v68 = bool(varg2 < v52);\n                }\n                if (!v53) {\n                    v51 = v69 = 0x46cd(0, v57, v0, v55);\n                }\n            } else {\n                if (!v53) {\n                    v51 = v70 = 0x46cd(1, v57, v55, v0);\n                }\n                if (v66) {\n                    v53 = v71 = bool(varg2 < v52);\n                }\n                if (!v53) {\n                    v51 = v72 = 0x4652(0, v57, v55, v0);\n                }\n            }\n            v73 = v74 = varg2 < v52;\n            if (!bool(v54)) {\n                v73 = v75 = v51 > 0 - varg2;\n            }\n            if (v73) {\n                v51 = v76 = 0 - varg2;\n            }\n            if (!bool(varg2 < v52)) {\n                v53 = v77 = address(v0) != address(v0);\n            }\n            if (!v53) {\n                v78 = v79 = 0x41a9(uint24(0xf3688), uint24(3000), v51);\n            } else {\n                v78 = v80 = varg2 - v51;\n            }\n            if (varg2 <= 0) {\n                require(v51 < int256.min);\n                MEM[v10] = MEM[v10] + v51;\n                require(v51 + MEM[v33 + 192] < int256.min);\n                require(v51 + MEM[v33 + 192] >= 0 == v51 + MEM[v33 + 192] + MEM[v10 + 32] >= MEM[v10 + 32]);\n                MEM[v10 + 32] += v51 + MEM[v33 + 192];\n            } else {\n                require(v51 + MEM[192 + v33] < int256.min);\n                MEM[v10] = MEM[v10] - (v51 + MEM[192 + v33]);\n                require(v51 < int256.min);\n                require(v51 >= 0 == MEM[v10 + 32] - v51 <= MEM[v10 + 32]);\n                MEM[v10 + 32] = MEM[v10 + 32] - v51;\n            }\n            if (uint8(v7)) {\n                assert(uint8(v7));\n                MEM[v33 + 192] = v78 - v78 / uint8(v7);\n                MEM[v10 + 160] = uint128(v78 / uint8(v7) + uint128(0));\n            }\n            if (uint128(_liquidity)) {\n                v81 = 0x32d9(uint128(MEM[192 + v10]), 0x100000000000000000000000000000000, MEM[192 + v33]);\n                MEM[v10 + 128] = v81 + v11;\n            }\n            if (address(v0) != address(v47)) {\n                if (address(v0) != address(_slot0)) {\n                    v82 = 0x36a5(address(v0));\n                    MEM[v10 + 96] = int24(v82);\n                }\n            } else {\n                if (bool(v39)) {\n                    if (!bool(0)) {\n                        v83, v84 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, uint32(block.timestamp), 8);\n                        MEM[MEM[64] + 128] = address(v83);\n                        MEM[MEM[64] + 96] = int56(v84);\n                        MEM[MEM[64] + 160] = 1;\n                    }\n                    if (varg1) {\n                        v85 = v86 = MEM[128 + v10];\n                    } else {\n                        v85 = v87 = _feeGrowthGlobal0X128;\n                    }\n                    if (varg1) {\n                        v88 = v89 = _feeGrowthGlobal1X128;\n                    } else {\n                        v88 = v90 = MEM[128 + v10];\n                    }\n                    _ticks[int24(MEM[32 + v33])].field1 = v85 - _ticks[int24(MEM[32 + v33])].field1;\n                    _ticks[int24(MEM[32 + v33])].field2 = v88 - _ticks[int24(MEM[32 + v33])].field2;\n                    v91 = bytes25(_ticks[int24(int24(MEM[32 + v33]))].field3 & 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff | address(MEM[MEM[64] + 128] - address(_ticks[int24(int24(MEM[32 + v33]))].field3 >> 56)) << 56) | uint56(int56(MEM[MEM[64] + 96] - int56(_ticks[int24(int24(MEM[32 + v33]))].field3 & 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff | address(MEM[MEM[64] + 128] - address(_ticks[int24(int24(MEM[32 + v33]))].field3 >> 56)) << 56)));\n                    _ticks[int24(MEM[32 + v33])].field3 = v91 & ~0xffffffff000000000000000000000000000000000000000000000000000000 | uint32(uint32(block.timestamp) - uint32(v91 >> 216)) << 216;\n                    v92 = v93 = int128(_ticks[int24(int24(MEM[32 + v33]))].field0 >> 128);\n                    if (!bool(!varg1)) {\n                        v92 = v94 = 0 - v93;\n                    }\n                    v95 = _SafeAdd(v92, uint128(_liquidity));\n                    MEM[v10 + 192] = uint128(v95);\n                }\n                if (varg1) {\n                    v96 = v97 = MEM[32 + v33] - 1;\n                } else {\n                    v96 = v98 = MEM[32 + v33];\n                }\n                MEM[v10 + 96] = int24(v96);\n                // Unknown jump to Block 0xf99. Refer to 3-address code (TAC);\n            }\n        }\n    }\n}\n\nfunction liquidity() public payable { \n    return _liquidity;\n}\n\nfunction protocolFees() public payable { \n    return _protocolFees, stor_3_16_31;\n}\n\nfunction 0x2d6d(int24 varg0) private { \n    if (varg0 < 0) {\n        v0 = v1 = 0 - varg0;\n    } else {\n        v0 = v2 = varg0;\n    }\n    require(v0 <= 0xd89e8, Error(84));\n    if (v0 & 0x1) {\n        v3 = v4 = 0xfffcb933bd6fad37aa2d162d1a594001;\n    } else {\n        v3 = v5 = 0x100000000000000000000000000000000;\n    }\n    v6 = v7 = uint136(v3);\n    if (v0 & 0x2) {\n        v6 = v8 = 0xfff97272373d413259a46990580e213a * v7 >> 128;\n    }\n    if (v0 & 0x4) {\n        v6 = v9 = 0xfff2e50f5f656932ef12357cf3c7fdcc * v6 >> 128;\n    }\n    if (v0 & 0x8) {\n        v6 = v10 = 0xffe5caca7e10e4e61c3624eaa0941cd0 * v6 >> 128;\n    }\n    if (v0 & 0x10) {\n        v6 = v11 = 0xffcb9843d60f6159c9db58835c926644 * v6 >> 128;\n    }\n    if (v0 & 0x20) {\n        v6 = v12 = 0xff973b41fa98c081472e6896dfb254c0 * v6 >> 128;\n    }\n    if (v0 & 0x40) {\n        v6 = v13 = 0xff2ea16466c96a3843ec78b326b52861 * v6 >> 128;\n    }\n    if (v0 & 0x80) {\n        v6 = v14 = 0xfe5dee046a99a2a811c461f1969c3053 * v6 >> 128;\n    }\n    if (v0 & 0x100) {\n        v6 = v15 = 0xfcbe86c7900a88aedcffc83b479aa3a4 * v6 >> 128;\n    }\n    if (v0 & 0x200) {\n        v6 = v16 = 0xf987a7253ac413176f2b074cf7815e54 * v6 >> 128;\n    }\n    if (v0 & 0x400) {\n        v6 = v17 = 0xf3392b0822b70005940c7a398e4b70f3 * v6 >> 128;\n    }\n    if (v0 & 0x800) {\n        v6 = v18 = 0xe7159475a2c29b7443b29c7fa6e889d9 * v6 >> 128;\n    }\n    if (v0 & 0x1000) {\n        v6 = v19 = 0xd097f3bdfd2022b8845ad8f792aa5825 * v6 >> 128;\n    }\n    if (v0 & 0x2000) {\n        v6 = v20 = 0xa9f746462d870fdf8a65dc1f90e061e5 * v6 >> 128;\n    }\n    if (v0 & 0x4000) {\n        v6 = v21 = 0x70d869a156d2a1b890bb3df62baf32f7 * v6 >> 128;\n    }\n    if (v0 & 0x8000) {\n        v6 = v22 = 0x31be135f97d08fd981231505542fcfa6 * v6 >> 128;\n    }\n    if (v0 & 0x10000) {\n        v6 = v23 = 0x9aa508b5b7a84e1c677de54f3e99bc9 * v6 >> 128;\n    }\n    if (v0 & 0x20000) {\n        v6 = v24 = 0x5d6af8dedb81196699c329225ee604 * v6 >> 128;\n    }\n    if (v0 & 0x40000) {\n        v6 = v25 = 0x2216e584f5fa1ea926041bedfe98 * v6 >> 128;\n    }\n    if (v0 & 0x80000) {\n        v6 = v26 = 0x48a170391f7dc42444e8fa2 * v6 >> 128;\n    }\n    if (varg0 > 0) {\n        assert(v6);\n        v6 = v27 = ~0 / v6;\n    }\n    if (!(v6 % 0x100000000)) {\n        v28 = v29 = 0;\n    } else {\n        v28 = v30 = 1;\n    }\n    return (v6 >> 32) + uint8(v28);\n}\n\nfunction observations(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 < uint16.max);\n    return uint32(STORAGE[varg0 + 8]), int56(STORAGE[varg0 + 8] >> 32), address(STORAGE[varg0 + 8] >> 88), bool(uint8(STORAGE[varg0 + 8] >> 248));\n}\n\nfunction 0x32d9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg1 * varg2;\n    v1 = varg2 * varg1 % ~0 - v0 - (varg2 * varg1 % ~0 < v0);\n    if (v1) {\n        require(varg0 > v1);\n        v2 = varg2 * varg1 % varg0;\n        v3 = varg0 & 0 - varg0;\n        v4 = varg0 / v3;\n        v5 = (2 - v4 * ((2 - v4 * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3))) * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3)))) * ((2 - v4 * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3))) * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3)));\n        return ((v0 - v2) / v3 | (v1 - (v2 > v0)) * (1 + (0 - v3) / v3)) * ((2 - v4 * ((2 - v4 * ((2 - v4 * v5) * v5)) * ((2 - v4 * v5) * v5))) * ((2 - v4 * ((2 - v4 * v5) * v5)) * ((2 - v4 * v5) * v5)));\n    } else {\n        require(varg0 > 0);\n        return v0 / varg0;\n    }\n}\n\nfunction increaseObservationCardinalityNext(uint16 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    v0 = 0x3eb5(varg0, uint16(_slot0 >> 216), 8);\n    _slot0 = _slot0 & ~0xffff000000000000000000000000000000000000000000000000000000 | uint16(v0) << 216;\n    if (uint16(_slot0 >> 216) != uint16(v0)) {\n        emit IncreaseObservationCardinalityNext(uint16(_slot0 >> 216), uint16(v0));\n    }\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction 0x3389(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    if (uint32(varg4)) {\n        v0 = varg5 - varg4;\n        v1, v2 = 0x48d2(varg0, varg1, varg2, varg3, v0, varg5, varg6);\n        if (uint32(v0) != uint32(v2.word0)) {\n            if (uint32(v1.word0) != uint32(v0)) {\n                assert(uint32(v1.word0 - v2.word0));\n                assert(uint32(v1.word0 - v2.word0));\n                return v2.word2 + address(v1.word2 - v2.word2) * uint32(v0 - v2.word0) / uint32(v1.word0 - v2.word0), v2.word1 + int56(v1.word1 - v2.word1) / uint32(v1.word0 - v2.word0) * uint32(v0 - v2.word0);\n            } else {\n                return v1.word2, v1.word1;\n            }\n        } else {\n            return v2.word2, v2.word1;\n        }\n    } else {\n        assert(uint16(varg2) < uint16.max);\n        v3 = new struct(4);\n        v4 = STORAGE[varg6 + uint16(varg2)];\n        v3.word0 = uint32(v4);\n        v3.word1 = int56(v4 >> 32);\n        v3.word2 = address(v4 >> 88);\n        v3.word3 = bool(uint8(v4 >> 248));\n        if (uint32(varg5) != uint32(v4)) {\n            v3 = v5 = 0x4822(varg1, varg3, varg5, v3);\n        }\n        return MEM[64 + v3], MEM[32 + v3];\n    }\n}\n\nfunction slot0() public payable { \n    return address(_slot0), int24(_slot0 >> 160), uint16(_slot0 >> 184), uint16(_slot0 >> 200), uint16(_slot0 >> 216), uint8(_slot0 >> 232), bool(uint8(_slot0 >> 240));\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    if (int128(varg0) >= 0) {\n        require(uint128(varg1 + varg0) >= uint128(varg1), Error(19521));\n        return varg1 + varg0;\n    } else {\n        require(uint128(varg1 - (0 - varg0)) < uint128(varg1), Error(19539));\n        return varg1 - (0 - varg0);\n    }\n}\n\nfunction 0x36a5(uint256 varg0) private { \n    v0 = v1 = address(varg0) >= 0x1000276a3;\n    if (address(varg0) >= 0x1000276a3) {\n        v0 = v2 = address(varg0) < 0xfffd8963efd1fc6a506488495d951d5263988d26;\n    }\n    require(v0, Error(82));\n    v3 = ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7) > uint64.max) << 6;\n    v4 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7) >> v3;\n    v5 = (v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) >> ((v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) > 15) << 2;\n    v6 = v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) >> ((v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) >> v5;\n    v7 = v5 | ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4 | ((v4 > uint32.max) << 5 | (v3 | (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7)) | (v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) | (v6 > 3) << 1 | (v6 >> ((v6 > 3) << 1) > 1);\n    if (v7 < 128) {\n        v8 = v9 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) << int8.max - v7;\n    } else {\n        v8 = v10 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> v7 - int8.max;\n    }\n    v11 = (v8 * v8 >> int8.max >> (v8 * v8 >> uint8.max)) * (v8 * v8 >> int8.max >> (v8 * v8 >> uint8.max));\n    v12 = ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> int8.max >> ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> uint8.max)) * ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> int8.max >> ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> uint8.max));\n    v13 = ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> int8.max >> ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> uint8.max)) * ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> int8.max >> ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> uint8.max));\n    v14 = ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> int8.max >> ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> uint8.max)) * ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> int8.max >> ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> uint8.max));\n    v15 = ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> int8.max >> ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> uint8.max)) * ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> int8.max >> ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> uint8.max));\n    v16 = ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> int8.max >> ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> uint8.max)) * ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> int8.max >> ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> uint8.max));\n    v17 = ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> int8.max >> ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> uint8.max)) * ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> int8.max >> ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> uint8.max));\n    v18 = (0x4000000000000 & v17 >> 205 | (0x8000000000000 & (v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> 204 | (0x10000000000000 & v16 >> 203 | (0x20000000000000 & (v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> 202 | (0x40000000000000 & v15 >> 201 | (0x80000000000000 & (v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> 200 | (0x100000000000000 & v14 >> 199 | (0x200000000000000 & (v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> 198 | (0x400000000000000 & v13 >> 197 | (0x800000000000000 & (v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> 196 | (0x1000000000000000 & v12 >> 195 | (0x2000000000000000 & (v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> 194 | (0x4000000000000000 & v11 >> 193 | (0x8000000000000000 & v8 * v8 >> 192 | v7 + ~int8.max << 64)))))))))))))) * 0x3627a301d71055774c85;\n    v19 = v20 = v18 + ~0x28f6481ab7f045a5af012a19d003aa9 >> 128;\n    v19 = v21 = v18 + 0xdb2df09e81959a81455e260799a0632f >> 128;\n    if (int24(v20) != int24(v21)) {\n        v22 = 0x2d6d(v21);\n        if (address(v22) > address(varg0)) {\n        }\n        // Unknown jump to Block 0x39c4. Refer to 3-address code (TAC);\n    }\n    return v19;\n}\n\nfunction 0x39d1(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    assert(uint16(varg5) < uint16.max);\n    v0 = new struct(4);\n    v1 = STORAGE[varg6 + uint16(varg5)];\n    v0.word0 = uint32(v1);\n    v0.word1 = int56(v1 >> 32);\n    v0.word2 = address(v1 >> 88);\n    v0.word3 = bool(uint8(v1 >> 248));\n    if (uint32(varg4) != uint32(v1)) {\n        v2 = v3 = uint16(varg0) > uint16(varg1);\n        if (v3) {\n            v2 = v4 = uint16(varg5) == uint16(varg1 - 1);\n        }\n        if (v2) {\n        }\n        assert(uint16(varg0));\n        v5 = uint16(1 + varg5) % uint16(varg0);\n        v6 = 0x4822(varg2, varg3, varg4, v0);\n        assert(uint16(v5) < uint16.max);\n        STORAGE[varg6 + uint16(v5)] = uint248(((bytes28(STORAGE[varg6 + uint16(v5)]) | uint32(v6.word0)) & ~0xffffffffffffff00000000 | uint56(int56(v6.word1)) << 32) & 0xff0000000000000000000000000000000000000000ffffffffffffffffffffff | address(v6.word2) << 88) | bool(v6.word3) << 248;\n        return varg0, v5;\n    } else {\n        return varg1, varg5;\n    }\n}\n\nfunction mint(address varg0, int24 varg1, int24 varg2, uint128 varg3, bytes varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    require(varg4 <= 0x100000000);\n    require(varg4.data <= 4 + (msg.data.length - 4));\n    require(!((varg4.length > 0x100000000) | (varg4.data + varg4.length > 4 + (msg.data.length - 4))));\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(varg3);\n    v0 = new struct(4);\n    v0.word0 = varg0;\n    v0.word1 = varg1;\n    v0.word2 = varg2;\n    require(varg3 == int128(uint128(uint128(varg3))));\n    v0.word3 = int128(uint128(uint128(varg3)));\n    v1, v2, v3 = 0x3f69(v0);\n    v4 = v5 = 0;\n    if (v2 > 0) {\n        v4 = v6 = 0x3cd4();\n    }\n    if (v1) {\n        v4 = v7 = 0x3e1d();\n    }\n    v8 = new bytes[](varg4.length);\n    CALLDATACOPY(v8.data, varg4.data, varg4.length);\n    v8[varg4.length] = 0;\n    require(bool((address(msg.sender)).code.size));\n    v9 = msg.sender.uniswapV3MintCallback(v2, v1, v8).gas(msg.gas);\n    require(bool(v9), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v10 = 0x3cd4();\n        require(v4 + v2 >= v4);\n        require(v4 + v2 <= v10, Error(19760));\n    }\n    if (v1) {\n        v11 = 0x3e1d();\n        require(v4 + v1 >= v4);\n        require(v4 + v1 <= v11, Error(19761));\n    }\n    emit Mint(varg0, varg1, varg2, msg.sender, varg3, v2, v1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return v2, v1;\n}\n\nfunction 0x3b86(uint256 varg0, address varg1, address varg2) private { \n    MEM[64] = MEM[64] + 100;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5 = v6, /* uint256 */ v7, /* uint256 */ v8 = varg2.transfer(varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = v11 = new bytes[](RETURNDATASIZE());\n        v7 = v11.data;\n        RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n    }\n    if (v6) {\n        v5 = v12 = !MEM[v9];\n        if (MEM[v9]) {\n            require(MEM[v9] >= 32);\n            v5 = v13 = MEM[v8];\n        }\n    }\n    require(v5, Error(21574));\n    return ;\n}\n\nfunction 0x3cd4() private { \n    MEM[64] = MEM[64] + 68;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, /* uint256 */ v6, /* uint256 */ v7 = address(0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0).balanceOf(this).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v8 = v9 = 96;\n    } else {\n        v8 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v8.data, 0, RETURNDATASIZE());\n    }\n    if (v5) {\n        v5 = v10 = MEM[v8] >= 32;\n    }\n    require(v5);\n    require(MEM[v8] >= 32);\n    return MEM[32 + v8];\n}\n\nfunction 0x3e1d() private { \n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, /* uint256 */ v10, /* uint256 */ v11 = address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2).staticcall(this).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    if (v9) {\n        v9 = v14 = MEM[v12] >= 32;\n    }\n    require(v9);\n    require(MEM[v12] >= 32);\n    return MEM[32 + v12];\n}\n\nfunction 0x3eb5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(uint16(varg1) > 0, Error(73));\n    if (uint16(varg0) > uint16(varg1)) {\n        while (uint16(varg1) < uint16(varg0)) {\n            assert(uint16(varg1) < uint16.max);\n            STORAGE[uint16(varg1) + varg2] = uint32(1) | bytes28(STORAGE[uint16(varg1) + varg2]);\n            varg1 += 1;\n        }\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction 0x3f69(struct(4) varg0) private { \n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    0x43a1(varg0.word2, varg0.word1);\n    MEM[MEM[64] + 160] = uint8(_slot0 >> 232);\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    v0 = 0x4acf(int24(_slot0 >> 160), varg0.word3, varg0.word2, varg0.word1, varg0.word0);\n    if (0 == int128(varg0.word3)) {\n        return 0, 0, v0;\n    } else if (int24(_slot0 >> 160) >= int24(varg0.word1)) {\n        if (int24(_slot0 >> 160) >= int24(varg0.word2)) {\n            v1 = 0x2d6d(varg0.word1);\n            v2 = 0x2d6d(varg0.word2);\n            v3 = 0x4cc8(varg0.word3, v2, v1);\n            return v3, 0, v0;\n        } else {\n            v4, v5 = 0x39d1(uint16(_slot0 >> 216), uint16(_slot0 >> 200), _liquidity, int24(_slot0 >> 160), block.timestamp, uint16(_slot0 >> 184), 8);\n            _slot0 = uint16(v5) << 184 | ~0xffff0000000000000000000000000000000000000000000000 & (uint16(v4) << 200 | ~0xffff00000000000000000000000000000000000000000000000000 & _slot0);\n            v6 = 0x2d6d(varg0.word2);\n            v7 = 0x4c84(varg0.word3, v6, address(_slot0));\n            v8 = 0x2d6d(varg0.word1);\n            v9 = 0x4cc8(varg0.word3, address(_slot0), v8);\n            v10 = _SafeAdd(varg0.word3, _liquidity);\n            _liquidity = v10;\n            return v9, v7, v0;\n        }\n    } else {\n        v11 = 0x2d6d(varg0.word1);\n        v12 = 0x2d6d(varg0.word2);\n        v13 = 0x4c84(varg0.word3, v12, v11);\n        return 0, v13, v0;\n    }\n}\n\nfunction 0x41a9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x32d9(varg0, varg1, varg2);\n    assert(varg0);\n    if (varg2 * varg1 % varg0 <= 0) {\n        return v0;\n    } else {\n        require(v0 < ~0);\n        return 1 + v0;\n    }\n}\n\nfunction 0x43a1(int24 varg0, int24 varg1) private { \n    require(varg1 < varg0, Error(0x544c55));\n    require(varg1 >= ~0xd89e7, Error(0x544c4d));\n    require(varg0 <= 0xd89e8, Error(0x54554d));\n    return ;\n}\n\nfunction 0x44c8(uint256 varg0) private { \n    v0 = v1 = 0;\n    require(varg0 > v1);\n    if (varg0 >= 0x100000000000000000000000000000000) {\n        varg0 = v2 = varg0 >> 128;\n        v0 = v3 = 128;\n    }\n    if (varg0 >= 0x10000000000000000) {\n        varg0 = v4 = varg0 >> 64;\n        v0 = v5 = 64 + v0;\n    }\n    if (varg0 >= 0x100000000) {\n        varg0 = v6 = varg0 >> 32;\n        v0 = v7 = 32 + v0;\n    }\n    if (varg0 >= 0x10000) {\n        varg0 = v8 = varg0 >> 16;\n        v0 = v9 = 16 + v0;\n    }\n    if (varg0 >= 256) {\n        varg0 = v10 = varg0 >> 8;\n        v0 = v11 = 8 + v0;\n    }\n    if (varg0 >= 16) {\n        varg0 = v12 = varg0 >> 4;\n        v0 = v13 = 4 + v0;\n    }\n    if (varg0 >= 4) {\n        varg0 = v14 = varg0 >> 2;\n        v0 = v15 = 2 + v0;\n    }\n    if (varg0 < 2) {\n        return v0;\n    } else {\n        return 1 + v0;\n    }\n}\n\nfunction feeGrowthGlobal1X128() public payable { \n    return _feeGrowthGlobal1X128;\n}\n\nfunction 0x4568(uint256 varg0) private { \n    require(varg0 > 0);\n    v0 = v1 = uint8.max;\n    if (!uint128(varg0)) {\n        varg0 = v2 = varg0 >> 128;\n    } else {\n        v0 = v3 = int8.max;\n    }\n    if (!uint64(varg0)) {\n        varg0 = v4 = varg0 >> 64;\n    } else {\n        v0 = v5 = ~63 + v0;\n    }\n    if (!uint32(varg0)) {\n        varg0 = v6 = varg0 >> 32;\n    } else {\n        v0 = v7 = ~31 + v0;\n    }\n    if (!uint16(varg0)) {\n        varg0 = v8 = varg0 >> 16;\n    } else {\n        v0 = v9 = ~15 + v0;\n    }\n    if (!uint8(varg0)) {\n        varg0 = v10 = varg0 >> 8;\n    } else {\n        v0 = v11 = ~7 + v0;\n    }\n    if (!bool(varg0)) {\n        varg0 = v12 = varg0 >> 4;\n    } else {\n        v0 = v13 = ~3 + v0;\n    }\n    if (!(varg0 & 0x3)) {\n        varg0 = v14 = varg0 >> 2;\n    } else {\n        v0 = v15 = ~1 + v0;\n    }\n    if (!(varg0 & 0x1)) {\n        return v0;\n    } else {\n        return ~0 + v0;\n    }\n}\n\nfunction 0x4652(uint256 varg0, uint128 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg0) {\n        v0 = v1 = 0x41a9(0x1000000000000000000000000, address(varg3 - varg3), varg1);\n    } else {\n        v0 = v2 = 0x32d9(0x1000000000000000000000000, address(varg3 - varg3), varg1);\n    }\n    return v0;\n}\n\nfunction 0x46cd(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg3 - varg3);\n    require(address(varg3));\n    if (varg0) {\n        v1 = 0x41a9(address(varg3), v0, varg1 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000);\n        return bool(v1 % address(varg3)) + v1 / address(varg3);\n    } else {\n        v2 = 0x32d9(address(varg3), v0, varg1 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000);\n        assert(address(varg3));\n        return v2 / address(varg3);\n    }\n}\n\nfunction flash(address varg0, uint256 varg1, uint256 varg2, bytes varg3) public payable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(varg3.data <= 4 + (msg.data.length - 4));\n    require(!((varg3.length > 0x100000000) | (varg3.data + varg3.length > 4 + (msg.data.length - 4))));\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    require(_liquidity, Error(76));\n    v0 = 0x41a9(0xf4240, uint24(3000), varg1);\n    v1 = 0x41a9(0xf4240, uint24(3000), varg2);\n    v2 = 0x3cd4();\n    v3 = 0x3e1d();\n    if (varg1) {\n        0x3b86(varg1, varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (varg2) {\n        0x3b86(varg2, varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    v4 = new bytes[](varg3.length);\n    CALLDATACOPY(v4.data, varg3.data, varg3.length);\n    v4[varg3.length] = 0;\n    require(bool((address(msg.sender)).code.size));\n    v5 = msg.sender.uniswapV3FlashCallback(v0, v1, v4).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v6 = 0x3cd4();\n    v7 = 0x3e1d();\n    require(v2 + v0 >= v2);\n    require(v2 + v0 <= v6, Error(17968));\n    require(v3 + v1 >= v3);\n    require(v3 + v1 <= v7, Error(17969));\n    if (v6 - v2) {\n        if (!bool(_slot0 >> 232)) {\n            v8 = v9 = 0;\n        } else {\n            assert(uint8(bool(_slot0 >> 232)));\n            v8 = v10 = (v6 - v2) / uint8(bool(_slot0 >> 232));\n        }\n        if (uint128(v8)) {\n            _protocolFees += v8;\n        }\n        v11 = 0x32d9(_liquidity, 0x100000000000000000000000000000000, v6 - v2 - v8);\n        _feeGrowthGlobal0X128 += v11;\n    }\n    if (v7 - v3) {\n        if (!bool(_slot0 >> 232 >> 4)) {\n            v12 = v13 = 0;\n        } else {\n            assert(uint8(bool(_slot0 >> 232 >> 4)));\n            v12 = v14 = (v7 - v3) / uint8(bool(_slot0 >> 232 >> 4));\n        }\n        if (uint128(v12)) {\n            stor_3_16_31 += v12;\n        }\n        v15 = 0x32d9(_liquidity, 0x100000000000000000000000000000000, v7 - v3 - v12);\n        _feeGrowthGlobal1X128 += v15;\n    }\n    emit Flash(msg.sender, varg0, varg1, varg2, v6 - v2, v7 - v3);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction 0x4822(uint256 varg0, int24 varg1, uint256 varg2, struct(4) varg3) private { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 0;\n    v0 = new struct(4);\n    v0.word0 = uint32(varg2);\n    v0.word1 = int56(varg3.word1 + int24(varg1) * uint32(varg2 - varg3.word0));\n    if (uint128(varg0) <= 0) {\n        varg0 = v1 = 1;\n    }\n    assert(uint128(varg0));\n    v0.word2 = address(varg3.word2 + (varg2 - varg3.word0 << 128 & 0xffffffff00000000000000000000000000000000) / uint128(varg0));\n    v0.word3 = bool(1);\n    return v0;\n}\n\nfunction 0x48d2(uint16 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 0;\n    v0 = new struct(4);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    assert(uint16(varg2) < uint16.max);\n    v1 = new struct(4);\n    v2 = STORAGE[varg6 + uint16(varg2)];\n    v1.word0 = uint32(v2);\n    v1.word1 = int56(v2 >> 32);\n    v1.word2 = address(v2 >> 88);\n    v1.word3 = bool(uint8(v2 >> 248));\n    v3 = 0x4ed8(varg4, uint32(v2), varg5);\n    if (!v3) {\n        assert(varg0);\n        assert(uint16(uint16(1 + varg2) % uint16(varg0)) < uint16.max);\n        v4 = v5 = MEM[64];\n        MEM[64] = v5 + 128;\n        v6 = STORAGE[uint16(uint16(1 + varg2) % uint16(varg0)) + varg6];\n        MEM[v5] = uint32(v6);\n        MEM[v5 + 32] = int56(v6 >> 32);\n        MEM[v5 + 64] = address(v6 >> 88);\n        MEM[v5 + 96] = bool(uint8(v6 >> 248));\n        if (!bool(uint8(v6 >> 248))) {\n            v4 = v7 = MEM[64];\n            MEM[64] = v7 + 128;\n            MEM[v7] = uint32(STORAGE[varg6]);\n            MEM[v7 + 32] = int56(STORAGE[varg6] >> 32);\n            MEM[v7 + 64] = address(STORAGE[varg6] >> 88);\n            MEM[v7 + 96] = bool(uint8(STORAGE[varg6] >> 248));\n        }\n        v8 = 0x4ed8(varg4, MEM[0 + v4], varg5);\n        require(v8, Error(0x4f4c44));\n        MEM[64] = MEM[64] + 128;\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64] + 32] = 0;\n        MEM[MEM[64] + 64] = 0;\n        MEM[MEM[64] + 96] = 0;\n        MEM[64] = MEM[64] + 128;\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64] + 32] = 0;\n        MEM[MEM[64] + 64] = 0;\n        MEM[MEM[64] + 96] = 0;\n        assert(varg0);\n        v9 = v10 = uint16(uint16(1 + varg2) % uint16(varg0));\n        v11 = v12 = v10 + varg0 - 1;\n        while (!varg0) {\n            assert((v9 + v11 >> 1) % varg0 < uint16.max);\n            v13 = new struct(4);\n            v14 = STORAGE[(v9 + v11 >> 1) % varg0 + varg6];\n            v13.word0 = uint32(v14);\n            v13.word1 = int56(v14 >> 32);\n            v13.word2 = address(v14 >> 88);\n            v13.word3 = bool(uint8(v14 >> 248));\n            if (bool(uint8(v14 >> 248))) {\n                assert(varg0);\n                assert((1 + (v9 + v11 >> 1)) % varg0 < uint16.max);\n                v15 = new struct(4);\n                v16 = STORAGE[(1 + (v9 + v11 >> 1)) % varg0 + varg6];\n                v15.word0 = uint32(v16);\n                v15.word1 = int56(v16 >> 32);\n                v15.word2 = address(v16 >> 88);\n                v15.word3 = bool(uint8(v16 >> 248));\n                v17 = v18 = 0x4ed8(varg4, v13.word0, varg5);\n                if (v18) {\n                    v17 = 0x4ed8(v15.word0, varg4, varg5);\n                }\n                if (!v17) {\n                    if (v18) {\n                        v9 = 1 + (v9 + v11 >> 1);\n                    } else {\n                        v11 = (v9 + v11 >> 1) - 1;\n                    }\n                } else {\n                    return v15, v13;\n                }\n            } else {\n                v9 = 1 + (v9 + v11 >> 1);\n            }\n        }\n        throw();\n    } else if (uint32(v1.word0) != uint32(varg4)) {\n        v19 = 0x4822(varg1, varg3, varg4, v1);\n        return v19, v1;\n    } else {\n        return v0, v1;\n    }\n}\n\nfunction 0x4acf(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    MEM[64] = MEM[64] + 58;\n    v0 = keccak256(bytes20(varg4 << 96), int24(varg3), int24(varg2));\n    v1 = v2 = 0;\n    if (int128(varg1)) {\n        v3, v4 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, block.timestamp, 8);\n        v1 = v5 = 0x513b(0x23746e6a58dcb13d4af821b93f062, 0, block.timestamp, v4, v3, _feeGrowthGlobal1X128, _feeGrowthGlobal0X128, varg1, varg0, varg3, 5);\n        v1 = v6 = 0x513b(0x23746e6a58dcb13d4af821b93f062, 1, block.timestamp, v4, v3, _feeGrowthGlobal1X128, _feeGrowthGlobal0X128, varg1, varg0, varg2, 5);\n        if (v5) {\n            0x5325(60, varg3, 6);\n        }\n        if (v6) {\n            0x5325(60, varg2, 6);\n        }\n    }\n    v7 = int24(varg3);\n    v8 = int24(varg2);\n    if (int24(varg0) < int24(varg3)) {\n        v9 = v10 = _feeGrowthGlobal0X128 - _ticks[v7].field1;\n        v11 = v12 = _feeGrowthGlobal1X128 - _ticks[v7].field2;\n    } else {\n        v9 = v13 = _ticks[v7].field1;\n        v11 = v14 = _ticks[v7].field2;\n    }\n    if (int24(varg0) >= int24(varg2)) {\n        v15 = v16 = _feeGrowthGlobal0X128 - _ticks[v8].field1;\n        v17 = v18 = _feeGrowthGlobal1X128 - _ticks[v8].field2;\n    } else {\n        v15 = v19 = _ticks[v8].field1;\n        v17 = v20 = _ticks[v8].field2;\n    }\n    MEM[MEM[64] + 96] = uint128(_positions[v0].field3);\n    MEM[MEM[64] + 128] = uint128(_positions[v0].field3 >> 128);\n    if (int128(varg1)) {\n        v21 = v22 = _SafeAdd(varg1, uint128(_positions[v0].field0));\n    } else {\n        require(uint128(_positions[v0].field0), Error(20048));\n    }\n    v23 = 0x32d9(0x100000000000000000000000000000000, uint128(_positions[v0].field0), _feeGrowthGlobal0X128 - v9 - v15 - _positions[v0].field1);\n    v24 = 0x32d9(0x100000000000000000000000000000000, uint128(_positions[v0].field0), _feeGrowthGlobal1X128 - v11 - v17 - _positions[v0].field2);\n    if (0 != int128(varg1)) {\n        _positions[v0].field0 = uint128(v21) | bytes16(_positions[v0].field0);\n    }\n    _positions[v0].field1 = _feeGrowthGlobal0X128 - v9 - v15;\n    _positions[v0].field2 = _feeGrowthGlobal1X128 - v11 - v17;\n    v25 = v26 = bool(uint128(v23));\n    if (!v26) {\n        v25 = uint128(v24) > 0;\n    }\n    if (v25) {\n        _positions[v0].field3 = uint128(v24 + uint128((uint128(v23 + uint128(_positions[v0].field3)) | bytes16(_positions[v0].field3)) >> 128)) << 128 | uint128(uint128(v23 + uint128(_positions[v0].field3)) | bytes16(_positions[v0].field3));\n    }\n    if (int128(varg1) >= 0) {\n        return keccak256(v0, 7);\n    } else {\n        if (v1) {\n            v27 = int24(varg3);\n            _ticks[v27].field0 = 0;\n            _ticks[v27].field1 = 0;\n            _ticks[v27].field2 = 0;\n            _ticks[v27].field3 = 0;\n        }\n        if (!v1) {\n            return keccak256(v0, 7);\n        } else {\n            v28 = int24(varg2);\n            _ticks[v28].field0 = 0;\n            _ticks[v28].field1 = 0;\n            _ticks[v28].field2 = 0;\n            _ticks[v28].field3 = 0;\n            return keccak256(v0, 7);\n        }\n    }\n}\n\nfunction 0x4c84(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (int128(varg0) < 0) {\n        v0 = 0x46cd(0, 0 - varg0, varg1, varg2);\n        require(v0 < int256.min);\n        return 0 - v0;\n    } else {\n        v1 = 0x46cd(1, varg0, varg1, varg2);\n        require(v1 < int256.min);\n        return v1;\n    }\n}\n\nfunction 0x4cc8(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (int128(varg0) < 0) {\n        v0 = 0x4652(0, 0 - varg0, varg1, varg2);\n        require(v0 < int256.min);\n        return 0 - v0;\n    } else {\n        v1 = 0x4652(1, varg0, varg1, varg2);\n        require(v1 < int256.min);\n        return v1;\n    }\n}\n\nfunction 0x4d02(uint256 varg0, uint256 varg1, uint128 varg2, address varg3) private { \n    if (!varg0) {\n        if (varg1 <= uint160.max) {\n            v0 = bool((varg1 << 96) % uint128(varg2)) + (varg1 << 96) / varg2;\n            // Unknown jump to Block 0x4dba. Refer to 3-address code (TAC);\n        } else {\n            v0 = v1 = 0x41a9(varg2, 0x1000000000000000000000000, varg1);\n        }\n        require(varg3 > v0);\n        return varg3 - v0;\n    } else {\n        if (varg1 <= uint160.max) {\n            assert(varg2);\n            v2 = v3 = (varg1 << 96) / varg2;\n        } else {\n            v2 = v4 = 0x32d9(varg2, 0x1000000000000000000000000, varg1);\n        }\n        require(varg3 + v2 >= varg3);\n        require(varg3 + v2 == address(varg3 + v2));\n        return varg3 + v2;\n    }\n}\n\nfunction 0x4de3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg1) {\n        v0 = varg2 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000;\n        if (!varg0) {\n            v1 = address(varg3) * varg1;\n            assert(varg1);\n            v2 = v3 = v1 / varg1 == address(varg3);\n            if (v3) {\n                v2 = v4 = v0 > v1;\n            }\n            require(v2);\n            v5 = v6 = 0x41a9(v0 - v1, address(varg3), v0);\n            require(v6 == address(v6));\n            // Unknown jump to Block 0x4e56. Refer to 3-address code (TAC);\n        } else {\n            assert(varg1);\n            if (address(varg3) * varg1 / varg1 == address(varg3)) {\n                if (address(varg3) * varg1 + v0 >= v0) {\n                    v5 = v7 = 0x41a9(address(varg3) * varg1 + v0, address(varg3), v0);\n                }\n            }\n            assert(address(varg3));\n            require(v0 / address(varg3) + varg1 >= v0 / address(varg3));\n            return bool(v0 % (v0 / address(varg3) + varg1)) + v0 / (v0 / address(varg3) + varg1);\n        }\n        return v5;\n    } else {\n        return varg3;\n    }\n}\n\nfunction 0x4ed8(uint32 varg0, uint32 varg1, uint32 varg2) private { \n    v0 = v1 = varg1 <= varg2;\n    if (!bool(uint32(varg1) > uint32(varg2))) {\n        v0 = v2 = varg0 <= varg2;\n    }\n    if (!v0) {\n        if (varg1 > varg2) {\n            v3 = v4 = varg1;\n        } else {\n            v3 = v5 = 0x100000000 + varg1;\n        }\n        if (varg0 > varg2) {\n            v6 = v7 = varg0;\n        } else {\n            v6 = v8 = 0x100000000 + varg0;\n        }\n        return uint40(v3) <= uint40(v6);\n    } else {\n        return varg1 <= varg0;\n    }\n}\n\nfunction collect(address varg0, int24 varg1, int24 varg2, uint128 varg3, uint128 varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    v0 = v1 = varg3;\n    v2 = v3 = varg4;\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    MEM[64] = MEM[64] + 58;\n    v4 = keccak256(bytes20(msg.sender << 96), varg1, varg2);\n    if (uint128(v1) > uint128(_positions[v4].field3)) {\n        v0 = v5 = uint128(_positions[v4].field3);\n    }\n    if (uint128(v3) > uint128(_positions[v4].field3 >> 128)) {\n        v2 = v6 = uint128(_positions[v4].field3 >> 128);\n    }\n    if (uint128(v0)) {\n        _positions[v4].field3 = uint128(uint128(_positions[v4].field3) - v0) | bytes16(_positions[v4].field3);\n        0x3b86(uint128(v0), varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (uint128(v2)) {\n        _positions[v4].field3 = uint128(_positions[v4].field3) | uint128(uint128(_positions[v4].field3 >> 128) - v2) << 128;\n        0x3b86(uint128(v2), varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    emit Collect(msg.sender, varg1, varg2, varg0, uint128(v0), uint128(v2));\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return uint128(v0), uint128(v2);\n}\n\nfunction 0x513b(uint128 varg0, uint256 varg1, uint32 varg2, int56 varg3, address varg4, uint256 varg5, uint256 varg6, uint256 varg7, int24 varg8, int24 varg9, uint256 varg10) private { \n    v0 = _SafeAdd(varg7, uint128(STORAGE[v1]));\n    require(uint128(v0) <= varg0, Error(19535));\n    if (!bool(uint128(uint128(STORAGE[v1])))) {\n        if (varg9 <= varg8) {\n            STORAGE[v1 + 1] = varg6;\n            STORAGE[v1 + 2] = varg5;\n            STORAGE[v1 + 3] = varg2 << 216 | ~0xffffffff000000000000000000000000000000000000000000000000000000 & (uint56(int56(varg3)) | bytes25(address(varg4) << 56 | 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff & STORAGE[v1 + 3]));\n        }\n        STORAGE[v1 + 3] = 0x100000000000000000000000000000000000000000000000000000000000000 | uint248(STORAGE[v1 + 3]);\n    }\n    STORAGE[v1] = uint128(v0) | bytes16(STORAGE[v1]);\n    if (varg1) {\n        v2 = v3 = int128(STORAGE[v1] >> 128) - int128(varg7);\n        require(int128(varg7) >= 0 == v3 <= int128(STORAGE[v1] >> 128));\n        require(v3 == int128(v3));\n        // Unknown jump to Block 0x52f4. Refer to 3-address code (TAC);\n    } else {\n        v2 = int128(varg7) + int128(STORAGE[v1] >> 128);\n        require(int128(varg7) >= 0 == v2 >= int128(STORAGE[v1] >> 128));\n        require(v2 == int128(v2));\n    }\n    STORAGE[v1] = uint128(STORAGE[v1]) | uint128(int128(v2)) << 128;\n    return !uint128(STORAGE[v1]) != !uint128(v0);\n}\n\nfunction 0x5325(int24 varg0, int24 varg1, uint256 varg2) private { \n    assert(varg0);\n    require(!int24(int24(varg1) % int24(varg0)));\n    assert(varg0);\n    STORAGE[keccak256(int16(int24(int24(varg1) / int24(varg0)) >> 8), varg2)] = STORAGE[keccak256(int16(int24(int24(varg1) / int24(varg0)) >> 8), varg2)] ^ 1 << uint8(int24(int24(varg1) / int24(varg0)) % 256);\n    return ;\n}\n\nfunction positions(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return uint128(_positions[varg0].field0), _positions[varg0].field1, _positions[varg0].field2, uint128(_positions[varg0].field3), uint128(_positions[varg0].field3 >> 128);\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction tickBitmap(int16 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _tickBitmap[varg0];\n}\n\nfunction maxLiquidityPerTick() public payable { \n    return uint128(0x23746e6a58dcb13d4af821b93f062);\n}\n\nfunction setFeeProtocol(uint8 varg0, uint8 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(bool((address(0x1f98431c8ad98523631ae4a59f267346ea31f984)).code.size));\n    v0, /* address */ v1 = address(0x1f98431c8ad98523631ae4a59f267346ea31f984).owner().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(msg.sender == address(v1));\n    v2 = v3 = !varg0;\n    if (varg0) {\n        v2 = v4 = varg0 >= 4;\n        if (!bool(uint8(uint8(varg0)) < 4)) {\n            v2 = v5 = varg0 <= 10;\n        }\n    }\n    if (v2) {\n        v2 = v6 = !varg1;\n        if (varg1) {\n            v2 = v7 = varg1 >= 4;\n            if (!bool(uint8(uint8(varg1)) < 4)) {\n                v2 = v8 = varg1 <= 10;\n            }\n        }\n    }\n    require(v2);\n    _slot0 = _slot0 & 0xffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff | uint8(uint8(varg0) + (uint8(varg1) << 4 & 0xff0)) << 232;\n    emit SetFeeProtocol(uint8(uint8(_slot0 >> 232) % 16), bool(uint8(_slot0 >> 232) >> 4), varg0, varg1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction collectProtocol(address varg0, uint128 varg1, uint128 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg1;\n    v2 = v3 = varg2;\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(bool((address(0x1f98431c8ad98523631ae4a59f267346ea31f984)).code.size));\n    v4, /* address */ v5 = address(0x1f98431c8ad98523631ae4a59f267346ea31f984).owner().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(msg.sender == address(v5));\n    if (uint128(v1) > _protocolFees) {\n        v0 = v6 = _protocolFees;\n    }\n    if (uint128(v3) > stor_3_16_31) {\n        v2 = v7 = stor_3_16_31;\n    }\n    if (uint128(v0)) {\n        if (_protocolFees == uint128(v0)) {\n            v0 = v8 = v0 + ~0;\n        }\n        _protocolFees = _protocolFees - v0;\n        0x3b86(uint128(v0), varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (uint128(v2)) {\n        if (stor_3_16_31 == uint128(v2)) {\n            v2 = v9 = ~0 + v2;\n        }\n        stor_3_16_31 = stor_3_16_31 - v2;\n        0x3b86(uint128(v2), varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    emit CollectProtocol(msg.sender, varg0, uint128(v0), uint128(v2));\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return uint128(v0), uint128(v2);\n}\n\nfunction observe(uint32[] varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(varg0.data <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (varg0.data + (varg0.length << 5) > 4 + (msg.data.length - 4))));\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, varg0.data, varg0.length << 5);\n    v0[varg0.length] = 0;\n    require(uint16(_slot0 >> 200) > 0, Error(73));\n    require(v0.length <= uint64.max);\n    v1 = new uint256[](v0.length);\n    if (v0.length) {\n        CALLDATACOPY(v1.data, msg.data.length, v0.length << 5);\n    }\n    require(v0.length <= uint64.max);\n    v2 = new uint256[](v0.length);\n    if (v0.length) {\n        CALLDATACOPY(v2.data, msg.data.length, v0.length << 5);\n    }\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        assert(v3 < v0.length);\n        if (uint32(v0[v3])) {\n            v5, v6 = 0x48d2(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), block.timestamp - v0[v3], block.timestamp, 8);\n            if (uint32(block.timestamp - v0[v3]) != uint32(v6.word0)) {\n                if (uint32(v5.word0) != uint32(block.timestamp - v0[v3])) {\n                    assert(uint32(v5.word0 - v6.word0));\n                    v7 = v6.word1 + int56(v5.word1 - v6.word1) / uint32(v5.word0 - v6.word0) * uint32(block.timestamp - v0[v3] - v6.word0);\n                    assert(uint32(v5.word0 - v6.word0));\n                    v8 = v6.word2 + address(v5.word2 - v6.word2) * uint32(block.timestamp - v0[v3] - v6.word0) / uint32(v5.word0 - v6.word0);\n                } else {\n                    v7 = v9 = v5.word1;\n                    v8 = v10 = v5.word2;\n                }\n            } else {\n                v7 = v11 = v6.word1;\n                v8 = v12 = v6.word2;\n            }\n        } else {\n            assert(uint16(_slot0 >> 184) < uint16.max);\n            v13 = v14 = new struct(4);\n            v14.word0 = uint32(STORAGE[8 + uint16(uint16(_slot0 >> 184))]);\n            v14.word1 = int56(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 32);\n            v14.word2 = address(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 88);\n            v14.word3 = bool(uint8(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 248));\n            if (uint32(block.timestamp) != uint32(STORAGE[8 + uint16(uint16(_slot0 >> 184))])) {\n                v13 = v15 = 0x4822(_liquidity, int24(_slot0 >> 160), block.timestamp, v14);\n            }\n            v7 = v16 = MEM[32 + v13];\n            v8 = v17 = MEM[64 + v13];\n        }\n        assert(v3 < v1.length);\n        assert(v3 < v2.length);\n        v2[v3] = address(v8);\n        v1[v3] = int56(v7);\n        v3 += 1;\n    }\n    v18 = new uint256[](v1.length);\n    v19 = v20 = 0;\n    while (v19 < v1.length << 5) {\n        MEM[v19 + v18.data] = MEM[v19 + v1.data];\n        v19 += 32;\n    }\n    v21 = new uint256[](v2.length);\n    v18[v1.length] = v2.length;\n    v22 = v23 = 0;\n    while (v22 < v2.length << 5) {\n        MEM[v22 + v21.data] = MEM[v22 + v2.data];\n        v22 += 32;\n    }\n    return v18, v21;\n}\n\nfunction burn(int24 varg0, int24 varg1, uint128 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    v0 = new struct(4);\n    v0.word0 = msg.sender;\n    v0.word1 = varg0;\n    v0.word2 = varg1;\n    require(varg2 == int128(uint128(uint128(varg2))));\n    v0.word3 = int128(0 - uint128(uint128(varg2)));\n    v1, v2, v3 = 0x3f69(v0);\n    v4 = v5 = 0 - v2 > 0;\n    if (0 - v2 <= 0) {\n        v4 = v6 = 0 - v1 > 0;\n    }\n    if (v4) {\n        STORAGE[v3 + 3] = bytes16(uint128(STORAGE[v3 + 3]) | uint128(0 - v1 + uint128(STORAGE[v3 + 3] >> 128)) << 128) | uint128(0 - v2 + uint128(STORAGE[v3 + 3]));\n    }\n    emit 0xc396cd989a39f4459b5fa1aed6a9a8dcdbc45908acfd67e028cd568da98982c(msg.sender, varg0, varg1, varg2, 0 - v2, 0 - v1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return 0 - v2, 0 - v1;\n}\n\nfunction snapshotCumulativesInside(int24 varg0, int24 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    0x43a1(varg1, varg0);\n    require(uint8(_ticks[int24(int24(int24(varg0)))].field3 >> 248));\n    require(uint8(_ticks[int24(int24(int24(varg1)))].field3 >> 248));\n    MEM[MEM[64]] = address(_slot0);\n    MEM[MEM[64] + 128] = uint16(_slot0 >> 216);\n    MEM[MEM[64] + 160] = uint8(_slot0 >> 232);\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    if (int24(_slot0 >> 160) >= varg0) {\n        if (int24(_slot0 >> 160) >= varg1) {\n            v0 = v1 = int56(_ticks[int24(int24(int24(varg1)))].field3) - int56(_ticks[int24(int24(int24(varg0)))].field3);\n            v2 = v3 = address(_ticks[int24(int24(int24(varg1)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg0)))].field3 >> 56);\n            v4 = v5 = uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216);\n        } else {\n            v6, v7 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, block.timestamp, 8);\n            v0 = v8 = v7 - int56(_ticks[int24(int24(int24(varg0)))].field3) - int56(_ticks[int24(int24(int24(varg1)))].field3);\n            v2 = v9 = v6 - address(_ticks[int24(int24(int24(varg0)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg1)))].field3 >> 56);\n            v4 = v10 = block.timestamp - uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216);\n        }\n    } else {\n        v0 = v11 = int56(_ticks[int24(int24(int24(varg0)))].field3) - int56(_ticks[int24(int24(int24(varg1)))].field3);\n        v2 = v12 = address(_ticks[int24(int24(int24(varg0)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg1)))].field3 >> 56);\n        v4 = v13 = uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216);\n    }\n    return int56(v0), address(v2), uint32(v4);\n}\n\nfunction factory() public payable { \n    return address(0x1f98431c8ad98523631ae4a59f267346ea31f984);\n}\n\nfunction tickSpacing() public payable { \n    return int24(60);\n}\n\nfunction token1() public payable { \n    return address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n}\n\nfunction fee() public payable { \n    return uint24(3000);\n}\n\nfunction feeGrowthGlobal0X128() public payable { \n    return _feeGrowthGlobal0X128;\n}\n\nfunction ticks(int24 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return uint128(_ticks[int24(varg0)].field0), int128(_ticks[int24(varg0)].field0 >> 128), _ticks[varg0].field1, _ticks[varg0].field2, int56(_ticks[int24(varg0)].field3), address(_ticks[int24(varg0)].field3 >> 56), uint32(_ticks[int24(varg0)].field3 >> 216), bool(uint8(_ticks[int24(varg0)].field3 >> 248));\n}\n\nfunction initialize(uint160 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(!address(_slot0), Error(16713));\n    v0 = 0x36a5(address(varg0));\n    MEM[MEM[64]] = uint32(block.timestamp);\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 1;\n    stor_8_0_3 = block.timestamp;\n    stor_8_31_31 = 1;\n    stor_8_4_30 = 0;\n    MEM[64] = MEM[64] + 224;\n    MEM[MEM[64]] = address(varg0);\n    MEM[MEM[64] + 32] = int24(v0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[MEM[64] + 96] = uint16(1);\n    MEM[MEM[64] + 128] = uint16(1);\n    MEM[MEM[64] + 160] = 0;\n    MEM[MEM[64] + 192] = 1;\n    _slot0 = 0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x1000000000000000000000000000000000000000000000000000000 | ~0xffff000000000000000000000000000000000000000000000000000000 & (0x100000000000000000000000000000000000000000000000000 | 0xffffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffff & (uint24(int24(int24(v0))) << 160 | ~0xffffff0000000000000000000000000000000000000000 & (address(varg0) | bytes12(_slot0))))) | 0x1000000000000000000000000000000000000000000000000000000000000;\n    emit Initialize(address(varg0), int24(v0));\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x70cf754a > v0) {\n            if (0x3850c7bd > v0) {\n                if (0x1ad8b03b > v0) {\n                    if (0xdfe1681 == v0) {\n                        token0();\n                    } else if (0x128acb08 == v0) {\n                        swap(address,bool,int256,uint160,bytes);\n                    } else {\n                        require(0x1a686502 == v0);\n                        liquidity();\n                    }\n                } else if (0x1ad8b03b == v0) {\n                    protocolFees();\n                } else if (0x252c09d7 == v0) {\n                    observations(uint256);\n                } else {\n                    require(0x32148f67 == v0);\n                    increaseObservationCardinalityNext(uint16);\n                }\n            } else if (0x490e6cbc > v0) {\n                if (0x3850c7bd == v0) {\n                    slot0();\n                } else if (0x3c8a7d8d == v0) {\n                    mint(address,int24,int24,uint128,bytes);\n                } else {\n                    require(0x46141319 == v0);\n                    feeGrowthGlobal1X128();\n                }\n            } else if (0x490e6cbc == v0) {\n                flash(address,uint256,uint256,bytes);\n            } else if (0x4f1eb3d8 == v0) {\n                collect(address,int24,int24,uint128,uint128);\n            } else if (0x514ea4bf == v0) {\n                positions(bytes32);\n            } else {\n                require(0x5339c296 == v0);\n                tickBitmap(int16);\n            }\n        } else if (0xc45a0155 > v0) {\n            if (0x883bdbfd > v0) {\n                if (0x70cf754a == v0) {\n                    maxLiquidityPerTick();\n                } else if (0x8206a4d1 == v0) {\n                    setFeeProtocol(uint8,uint8);\n                } else {\n                    require(0x85b66729 == v0);\n                    collectProtocol(address,uint128,uint128);\n                }\n            } else if (0x883bdbfd == v0) {\n                observe(uint32[]);\n            } else if (0xa34123a7 == v0) {\n                burn(int24,int24,uint128);\n            } else {\n                require(0xa38807f2 == v0);\n                snapshotCumulativesInside(int24,int24);\n            }\n        } else if (0xddca3f43 > v0) {\n            if (0xc45a0155 == v0) {\n                factory();\n            } else if (0xd0c93a7c == v0) {\n                tickSpacing();\n            } else {\n                require(0xd21220a7 == v0);\n                token1();\n            }\n        } else if (0xddca3f43 == v0) {\n            fee();\n        } else if (0xf3058399 == v0) {\n            feeGrowthGlobal0X128();\n        } else if (0xf30dba93 == v0) {\n            ticks(int24);\n        } else {\n            require(0xf637731d == v0);\n            initialize(uint160);\n        }\n    }\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.16 03:31 UTC\n// Compiled using the solidity compiler version 0.7.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _slot0; // STORAGE[0x0]\nuint256 _feeGrowthGlobal0X128; // STORAGE[0x1]\nuint256 _feeGrowthGlobal1X128; // STORAGE[0x2]\nmapping (uint256 => struct_1262) _ticks; // STORAGE[0x5]\nmapping (uint256 => uint256) _tickBitmap; // STORAGE[0x6]\nmapping (uint256 => struct_1263) _positions; // STORAGE[0x7]\nuint256 stor_8_0_3; // STORAGE[0x8] bytes 0 to 3\nuint256 _protocolFees; // STORAGE[0x3] bytes 0 to 15\nuint256 _liquidity; // STORAGE[0x4] bytes 0 to 15\nuint256 stor_8_4_30; // STORAGE[0x8] bytes 4 to 30\nuint256 stor_3_16_31; // STORAGE[0x3] bytes 16 to 31\nuint256 stor_8_31_31; // STORAGE[0x8] bytes 31 to 31\n\nstruct struct_1262 { uint256 field0; uint256 field1; uint256 field2; uint256 field3; };\nstruct struct_1263 { uint256 field0; uint256 field1; uint256 field2; uint256 field3; };\n\n// Events\nSwap(address, address, int256, int256, uint160, uint128, int24);\nIncreaseObservationCardinalityNext(uint16, uint16);\nMint(address, address, int24, int24, uint128, uint256, uint256);\nFlash(address, address, uint256, uint256, uint256, uint256);\nCollect(address, address, int24, int24, uint128, uint128);\nSetFeeProtocol(uint8, uint8, uint8, uint8);\nCollectProtocol(address, address, uint128, uint128);\nInitialize(uint160, int24);\n\nfunction token0() public payable { \n    return address(0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n}\n\nfunction swap(address varg0, bool varg1, int256 varg2, uint160 varg3, bytes varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    v0 = v1 = address(varg3);\n    require(varg4 <= 0x100000000);\n    require(varg4.data <= 4 + (msg.data.length - 4));\n    require(!((varg4.length > 0x100000000) | (varg4.data + varg4.length > 4 + (msg.data.length - 4))));\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    require(varg2, Error(16723));\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    require(bool(uint8(_slot0 >> 240)), Error(0x4c4f4b));\n    if (varg1) {\n        v2 = v3 = address(v1) < address(_slot0);\n        if (v3) {\n            v2 = v4 = address(v1) > 0x1000276a3;\n        }\n    } else {\n        v2 = v5 = address(v1) > address(_slot0);\n        if (v5) {\n            v2 = v6 = address(v1) < 0xfffd8963efd1fc6a506488495d951d5263988d26;\n        }\n    }\n    require(v2, Error(0x53504c));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    if (varg1) {\n        assert(16);\n        v7 = v8 = uint8(_slot0 >> 232) % 16;\n    } else {\n        v7 = v9 = uint8(_slot0 >> 232) >> 4;\n    }\n    MEM[96 + MEM[64]] = int56(0);\n    MEM[128 + MEM[64]] = address(0x0);\n    v10 = MEM[64];\n    MEM[32 + v10] = 0;\n    if (varg1) {\n        v11 = v12 = _feeGrowthGlobal0X128;\n    } else {\n        v11 = v13 = _feeGrowthGlobal1X128;\n    }\n    while (1) {\n        v14 = v15 = bool(varg2);\n        if (!varg2) {\n            // Unknown jump to Block 0xbd5. Refer to 3-address code (TAC);\n        }\n        v14 = v16 = address(MEM[64 + v10]) != address(v1);\n        if (!v14) {\n            if (int24(MEM[96 + v10]) == int24(_slot0 >> 160)) {\n                _slot0 = address(MEM[v10 + 64]) | bytes12(_slot0);\n            } else {\n                v17, v18 = 0x39d1(uint16(_slot0 >> 216), uint16(_slot0 >> 200), _liquidity, int24(_slot0 >> 160), uint32(block.timestamp), uint16(_slot0 >> 184), 8);\n                _slot0 = address(MEM[v10 + 64]) | bytes12(uint24(int24(MEM[v10 + 96])) << 160 | ~0xffffff0000000000000000000000000000000000000000 & (uint16(v18) << 184 | ~0xffff0000000000000000000000000000000000000000000000 & (uint16(v17) << 200 | ~0xffff00000000000000000000000000000000000000000000000000 & _slot0)));\n            }\n            if (uint128(_liquidity) != uint128(MEM[192 + v10])) {\n                _liquidity = MEM[v10 + 192];\n            }\n            if (bool(!varg1)) {\n                _feeGrowthGlobal1X128 = MEM[v10 + 128];\n                if (uint128(MEM[v10 + 160])) {\n                    stor_3_16_31 += MEM[v10 + 160];\n                }\n            } else {\n                _feeGrowthGlobal0X128 = MEM[v10 + 128];\n                if (uint128(MEM[v10 + 160])) {\n                    _protocolFees += MEM[v10 + 160];\n                }\n            }\n            if (varg1 == bool(varg2 > 0)) {\n                v19 = v20 = varg2 - MEM[0 + v10];\n                v21 = v22 = MEM[32 + v10];\n            } else {\n                v19 = v23 = MEM[v10 + 32];\n                v21 = v24 = varg2 - MEM[v10];\n            }\n            if (bool(!varg1)) {\n                if (v19 < 0) {\n                    0x3b86(0 - v19, varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n                }\n                v25 = 0x3e1d();\n                v26 = new bytes[](varg4.length);\n                CALLDATACOPY(v26.data, varg4.data, varg4.length);\n                v26[varg4.length] = 0;\n                require(bool((address(msg.sender)).code.size));\n                v27 = msg.sender.uniswapV3SwapCallback(v19, v21, v26).gas(msg.gas);\n                require(bool(v27), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v28 = 0x3e1d();\n                require(v25 + v21 >= v25);\n                require(v25 + v21 <= v28, Error(0x494941));\n            } else {\n                if (v21 < 0) {\n                    0x3b86(0 - v21, varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n                }\n                v29 = 0x3cd4();\n                v30 = new bytes[](varg4.length);\n                CALLDATACOPY(v30.data, varg4.data, varg4.length);\n                v30[varg4.length] = 0;\n                require(bool((address(msg.sender)).code.size));\n                v31 = msg.sender.uniswapV3SwapCallback(v19, v21, v30).gas(msg.gas);\n                require(bool(v31), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v32 = 0x3cd4();\n                require(v29 + v19 >= v29);\n                require(v29 + v19 <= v32, Error(0x494941));\n            }\n            emit Swap(msg.sender, varg0, v19, v21, address(MEM[v10 + 64]), uint128(MEM[v10 + 192]), int24(MEM[v10 + 96]));\n            _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n            return v19, v21;\n        } else {\n            v33 = MEM[64];\n            MEM[v33] = 0;\n            MEM[v33 + 32] = 0;\n            MEM[v33 + 64] = 0;\n            MEM[v33 + 96] = 0;\n            MEM[v33 + 128] = 0;\n            MEM[v33 + 160] = 0;\n            MEM[v33 + 192] = 0;\n            assert(int24(60));\n            v34 = v35 = int24(_slot0 >> 160) / int24(60);\n            v36 = v37 = int24(_slot0 >> 160) < 0;\n            if (v37) {\n                assert(int24(60));\n                v36 = bool(int24(int24(int24(int24(int24(int24(_slot0 >> 160))))) % int24(60)));\n            }\n            if (v36) {\n                v34 = v38 = ~0 + v35;\n            }\n            if (bool(!varg1)) {\n                v39 = 0 != _tickBitmap[int16(int24(1 + v34) >> 8)] & ~((1 << uint8(int24(1 + v34) % 256)) - 1);\n                if (v39) {\n                    v40 = 0x4568(_tickBitmap[int16(int24(1 + v34) >> 8)] & ~((1 << uint8(int24(1 + v34) % 256)) - 1));\n                    v41 = v42 = (1 + v34 + uint8(v40 - int24(1 + v34) % 256)) * 60;\n                } else {\n                    v41 = (1 + v34 + uint8(uint8.max - int24(1 + v34) % 256)) * 60;\n                }\n            } else {\n                v39 = v43 = bool(~0 + ((1 << uint8(int24(v34) % 256)) + (1 << uint8(int24(v34) % 256))) & _tickBitmap[int16(int24(v34) >> 8)]);\n                if (v43) {\n                    v44 = 0x44c8(~0 + ((1 << uint8(int24(v34) % 256)) + (1 << uint8(int24(v34) % 256))) & _tickBitmap[int16(int24(v34) >> 8)]);\n                    v41 = v45 = (v34 - uint8(int24(v34) % 256 - v44)) * 60;\n                } else {\n                    v41 = v46 = (v34 - uint8(int24(v34) % 256)) * 60;\n                }\n            }\n            MEM[v33 + 32] = int24(v41);\n            if (int24(v41) >= ~0xd89e7) {\n                if (int24(MEM[v33 + 32]) > 0xd89e8) {\n                    MEM[v33 + 32] = 0xd89e8;\n                }\n            } else {\n                MEM[v33 + 32] = ~0xd89e7;\n            }\n            v47 = 0x2d6d(MEM[32 + v33]);\n            if (varg1) {\n                v48 = v49 = address(v47) < address(v1);\n            } else {\n                v48 = v50 = address(v47) > address(v1);\n            }\n            if (!v48) {\n            }\n            v51 = v52 = 0;\n            v53 = v54 = varg2 >= v52;\n            if (varg2 < v52) {\n                if (address(v55) >= address(v0)) {\n                    v51 = v56 = 0x4652(0, v57, v55, v0);\n                } else {\n                    v51 = v58 = 0x46cd(0, v57, v0, v55);\n                }\n                if (0 - varg2 < v51) {\n                    require(address(v55) > 0);\n                    require(uint128(v57) > 0);\n                    if (address(v55) >= address(v0)) {\n                        v0 = v59 = 0x4d02(0, 0 - varg2, v57, v55);\n                    } else {\n                        v0 = v60 = 0x4de3(0, 0 - varg2, v57, v55);\n                    }\n                }\n            } else {\n                v61 = 0x32d9(0xf4240, uint24(0xf3688), varg2);\n                if (address(v55) >= address(v0)) {\n                    v51 = v62 = 0x46cd(1, v57, v55, v0);\n                } else {\n                    v51 = v63 = 0x4652(1, v57, v0, v55);\n                }\n                if (v61 < v51) {\n                    require(address(v55) > 0);\n                    require(uint128(v57) > 0);\n                    if (address(v55) >= address(v0)) {\n                        v0 = v64 = 0x4de3(1, v61, v57, v55);\n                    } else {\n                        v0 = v65 = 0x4d02(1, v61, v57, v55);\n                    }\n                }\n                // Unknown jump to Block 0x316e. Refer to 3-address code (TAC);\n            }\n            v53 = v66 = address(v0) == address(v0);\n            if (bool(address(v55) < address(v0))) {\n                if (!v53) {\n                    v51 = v67 = 0x4652(1, v57, v0, v55);\n                }\n                if (v66) {\n                    v53 = v68 = bool(varg2 < v52);\n                }\n                if (!v53) {\n                    v51 = v69 = 0x46cd(0, v57, v0, v55);\n                }\n            } else {\n                if (!v53) {\n                    v51 = v70 = 0x46cd(1, v57, v55, v0);\n                }\n                if (v66) {\n                    v53 = v71 = bool(varg2 < v52);\n                }\n                if (!v53) {\n                    v51 = v72 = 0x4652(0, v57, v55, v0);\n                }\n            }\n            v73 = v74 = varg2 < v52;\n            if (!bool(v54)) {\n                v73 = v75 = v51 > 0 - varg2;\n            }\n            if (v73) {\n                v51 = v76 = 0 - varg2;\n            }\n            if (!bool(varg2 < v52)) {\n                v53 = v77 = address(v0) != address(v0);\n            }\n            if (!v53) {\n                v78 = v79 = 0x41a9(uint24(0xf3688), uint24(3000), v51);\n            } else {\n                v78 = v80 = varg2 - v51;\n            }\n            if (varg2 <= 0) {\n                require(v51 < int256.min);\n                MEM[v10] = MEM[v10] + v51;\n                require(v51 + MEM[v33 + 192] < int256.min);\n                require(v51 + MEM[v33 + 192] >= 0 == v51 + MEM[v33 + 192] + MEM[v10 + 32] >= MEM[v10 + 32]);\n                MEM[v10 + 32] += v51 + MEM[v33 + 192];\n            } else {\n                require(v51 + MEM[192 + v33] < int256.min);\n                MEM[v10] = MEM[v10] - (v51 + MEM[192 + v33]);\n                require(v51 < int256.min);\n                require(v51 >= 0 == MEM[v10 + 32] - v51 <= MEM[v10 + 32]);\n                MEM[v10 + 32] = MEM[v10 + 32] - v51;\n            }\n            if (uint8(v7)) {\n                assert(uint8(v7));\n                MEM[v33 + 192] = v78 - v78 / uint8(v7);\n                MEM[v10 + 160] = uint128(v78 / uint8(v7) + uint128(0));\n            }\n            if (uint128(_liquidity)) {\n                v81 = 0x32d9(uint128(MEM[192 + v10]), 0x100000000000000000000000000000000, MEM[192 + v33]);\n                MEM[v10 + 128] = v81 + v11;\n            }\n            if (address(v0) != address(v47)) {\n                if (address(v0) != address(_slot0)) {\n                    v82 = 0x36a5(address(v0));\n                    MEM[v10 + 96] = int24(v82);\n                }\n            } else {\n                if (bool(v39)) {\n                    if (!bool(0)) {\n                        v83, v84 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, uint32(block.timestamp), 8);\n                        MEM[MEM[64] + 128] = address(v83);\n                        MEM[MEM[64] + 96] = int56(v84);\n                        MEM[MEM[64] + 160] = 1;\n                    }\n                    if (varg1) {\n                        v85 = v86 = MEM[128 + v10];\n                    } else {\n                        v85 = v87 = _feeGrowthGlobal0X128;\n                    }\n                    if (varg1) {\n                        v88 = v89 = _feeGrowthGlobal1X128;\n                    } else {\n                        v88 = v90 = MEM[128 + v10];\n                    }\n                    _ticks[int24(MEM[32 + v33])].field1 = v85 - _ticks[int24(MEM[32 + v33])].field1;\n                    _ticks[int24(MEM[32 + v33])].field2 = v88 - _ticks[int24(MEM[32 + v33])].field2;\n                    v91 = bytes25(_ticks[int24(int24(MEM[32 + v33]))].field3 & 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff | address(MEM[MEM[64] + 128] - address(_ticks[int24(int24(MEM[32 + v33]))].field3 >> 56)) << 56) | uint56(int56(MEM[MEM[64] + 96] - int56(_ticks[int24(int24(MEM[32 + v33]))].field3 & 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff | address(MEM[MEM[64] + 128] - address(_ticks[int24(int24(MEM[32 + v33]))].field3 >> 56)) << 56)));\n                    _ticks[int24(MEM[32 + v33])].field3 = v91 & ~0xffffffff000000000000000000000000000000000000000000000000000000 | uint32(uint32(block.timestamp) - uint32(v91 >> 216)) << 216;\n                    v92 = v93 = int128(_ticks[int24(int24(MEM[32 + v33]))].field0 >> 128);\n                    if (!bool(!varg1)) {\n                        v92 = v94 = 0 - v93;\n                    }\n                    v95 = _SafeAdd(v92, uint128(_liquidity));\n                    MEM[v10 + 192] = uint128(v95);\n                }\n                if (varg1) {\n                    v96 = v97 = MEM[32 + v33] - 1;\n                } else {\n                    v96 = v98 = MEM[32 + v33];\n                }\n                MEM[v10 + 96] = int24(v96);\n                // Unknown jump to Block 0xf99. Refer to 3-address code (TAC);\n            }\n        }\n    }\n}\n\nfunction liquidity() public payable { \n    return _liquidity;\n}\n\nfunction protocolFees() public payable { \n    return _protocolFees, stor_3_16_31;\n}\n\nfunction 0x2d6d(int24 varg0) private { \n    if (varg0 < 0) {\n        v0 = v1 = 0 - varg0;\n    } else {\n        v0 = v2 = varg0;\n    }\n    require(v0 <= 0xd89e8, Error(84));\n    if (v0 & 0x1) {\n        v3 = v4 = 0xfffcb933bd6fad37aa2d162d1a594001;\n    } else {\n        v3 = v5 = 0x100000000000000000000000000000000;\n    }\n    v6 = v7 = uint136(v3);\n    if (v0 & 0x2) {\n        v6 = v8 = 0xfff97272373d413259a46990580e213a * v7 >> 128;\n    }\n    if (v0 & 0x4) {\n        v6 = v9 = 0xfff2e50f5f656932ef12357cf3c7fdcc * v6 >> 128;\n    }\n    if (v0 & 0x8) {\n        v6 = v10 = 0xffe5caca7e10e4e61c3624eaa0941cd0 * v6 >> 128;\n    }\n    if (v0 & 0x10) {\n        v6 = v11 = 0xffcb9843d60f6159c9db58835c926644 * v6 >> 128;\n    }\n    if (v0 & 0x20) {\n        v6 = v12 = 0xff973b41fa98c081472e6896dfb254c0 * v6 >> 128;\n    }\n    if (v0 & 0x40) {\n        v6 = v13 = 0xff2ea16466c96a3843ec78b326b52861 * v6 >> 128;\n    }\n    if (v0 & 0x80) {\n        v6 = v14 = 0xfe5dee046a99a2a811c461f1969c3053 * v6 >> 128;\n    }\n    if (v0 & 0x100) {\n        v6 = v15 = 0xfcbe86c7900a88aedcffc83b479aa3a4 * v6 >> 128;\n    }\n    if (v0 & 0x200) {\n        v6 = v16 = 0xf987a7253ac413176f2b074cf7815e54 * v6 >> 128;\n    }\n    if (v0 & 0x400) {\n        v6 = v17 = 0xf3392b0822b70005940c7a398e4b70f3 * v6 >> 128;\n    }\n    if (v0 & 0x800) {\n        v6 = v18 = 0xe7159475a2c29b7443b29c7fa6e889d9 * v6 >> 128;\n    }\n    if (v0 & 0x1000) {\n        v6 = v19 = 0xd097f3bdfd2022b8845ad8f792aa5825 * v6 >> 128;\n    }\n    if (v0 & 0x2000) {\n        v6 = v20 = 0xa9f746462d870fdf8a65dc1f90e061e5 * v6 >> 128;\n    }\n    if (v0 & 0x4000) {\n        v6 = v21 = 0x70d869a156d2a1b890bb3df62baf32f7 * v6 >> 128;\n    }\n    if (v0 & 0x8000) {\n        v6 = v22 = 0x31be135f97d08fd981231505542fcfa6 * v6 >> 128;\n    }\n    if (v0 & 0x10000) {\n        v6 = v23 = 0x9aa508b5b7a84e1c677de54f3e99bc9 * v6 >> 128;\n    }\n    if (v0 & 0x20000) {\n        v6 = v24 = 0x5d6af8dedb81196699c329225ee604 * v6 >> 128;\n    }\n    if (v0 & 0x40000) {\n        v6 = v25 = 0x2216e584f5fa1ea926041bedfe98 * v6 >> 128;\n    }\n    if (v0 & 0x80000) {\n        v6 = v26 = 0x48a170391f7dc42444e8fa2 * v6 >> 128;\n    }\n    if (varg0 > 0) {\n        assert(v6);\n        v6 = v27 = ~0 / v6;\n    }\n    if (!(v6 % 0x100000000)) {\n        v28 = v29 = 0;\n    } else {\n        v28 = v30 = 1;\n    }\n    return (v6 >> 32) + uint8(v28);\n}\n\nfunction observations(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 < uint16.max);\n    return uint32(STORAGE[varg0 + 8]), int56(STORAGE[varg0 + 8] >> 32), address(STORAGE[varg0 + 8] >> 88), bool(uint8(STORAGE[varg0 + 8] >> 248));\n}\n\nfunction 0x32d9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg1 * varg2;\n    v1 = varg2 * varg1 % ~0 - v0 - (varg2 * varg1 % ~0 < v0);\n    if (v1) {\n        require(varg0 > v1);\n        v2 = varg2 * varg1 % varg0;\n        v3 = varg0 & 0 - varg0;\n        v4 = varg0 / v3;\n        v5 = (2 - v4 * ((2 - v4 * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3))) * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3)))) * ((2 - v4 * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3))) * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3)));\n        return ((v0 - v2) / v3 | (v1 - (v2 > v0)) * (1 + (0 - v3) / v3)) * ((2 - v4 * ((2 - v4 * ((2 - v4 * v5) * v5)) * ((2 - v4 * v5) * v5))) * ((2 - v4 * ((2 - v4 * v5) * v5)) * ((2 - v4 * v5) * v5)));\n    } else {\n        require(varg0 > 0);\n        return v0 / varg0;\n    }\n}\n\nfunction increaseObservationCardinalityNext(uint16 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    v0 = 0x3eb5(varg0, uint16(_slot0 >> 216), 8);\n    _slot0 = _slot0 & ~0xffff000000000000000000000000000000000000000000000000000000 | uint16(v0) << 216;\n    if (uint16(_slot0 >> 216) != uint16(v0)) {\n        emit IncreaseObservationCardinalityNext(uint16(_slot0 >> 216), uint16(v0));\n    }\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction 0x3389(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    if (uint32(varg4)) {\n        v0 = varg5 - varg4;\n        v1, v2 = 0x48d2(varg0, varg1, varg2, varg3, v0, varg5, varg6);\n        if (uint32(v0) != uint32(v2.word0)) {\n            if (uint32(v1.word0) != uint32(v0)) {\n                assert(uint32(v1.word0 - v2.word0));\n                assert(uint32(v1.word0 - v2.word0));\n                return v2.word2 + address(v1.word2 - v2.word2) * uint32(v0 - v2.word0) / uint32(v1.word0 - v2.word0), v2.word1 + int56(v1.word1 - v2.word1) / uint32(v1.word0 - v2.word0) * uint32(v0 - v2.word0);\n            } else {\n                return v1.word2, v1.word1;\n            }\n        } else {\n            return v2.word2, v2.word1;\n        }\n    } else {\n        assert(uint16(varg2) < uint16.max);\n        v3 = new struct(4);\n        v4 = STORAGE[varg6 + uint16(varg2)];\n        v3.word0 = uint32(v4);\n        v3.word1 = int56(v4 >> 32);\n        v3.word2 = address(v4 >> 88);\n        v3.word3 = bool(uint8(v4 >> 248));\n        if (uint32(varg5) != uint32(v4)) {\n            v3 = v5 = 0x4822(varg1, varg3, varg5, v3);\n        }\n        return MEM[64 + v3], MEM[32 + v3];\n    }\n}\n\nfunction slot0() public payable { \n    return address(_slot0), int24(_slot0 >> 160), uint16(_slot0 >> 184), uint16(_slot0 >> 200), uint16(_slot0 >> 216), uint8(_slot0 >> 232), bool(uint8(_slot0 >> 240));\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    if (int128(varg0) >= 0) {\n        require(uint128(varg1 + varg0) >= uint128(varg1), Error(19521));\n        return varg1 + varg0;\n    } else {\n        require(uint128(varg1 - (0 - varg0)) < uint128(varg1), Error(19539));\n        return varg1 - (0 - varg0);\n    }\n}\n\nfunction 0x36a5(uint256 varg0) private { \n    v0 = v1 = address(varg0) >= 0x1000276a3;\n    if (address(varg0) >= 0x1000276a3) {\n        v0 = v2 = address(varg0) < 0xfffd8963efd1fc6a506488495d951d5263988d26;\n    }\n    require(v0, Error(82));\n    v3 = ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7) > uint64.max) << 6;\n    v4 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7) >> v3;\n    v5 = (v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) >> ((v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) > 15) << 2;\n    v6 = v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) >> ((v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) >> v5;\n    v7 = v5 | ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4 | ((v4 > uint32.max) << 5 | (v3 | (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7)) | (v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) | (v6 > 3) << 1 | (v6 >> ((v6 > 3) << 1) > 1);\n    if (v7 < 128) {\n        v8 = v9 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) << int8.max - v7;\n    } else {\n        v8 = v10 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> v7 - int8.max;\n    }\n    v11 = (v8 * v8 >> int8.max >> (v8 * v8 >> uint8.max)) * (v8 * v8 >> int8.max >> (v8 * v8 >> uint8.max));\n    v12 = ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> int8.max >> ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> uint8.max)) * ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> int8.max >> ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> uint8.max));\n    v13 = ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> int8.max >> ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> uint8.max)) * ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> int8.max >> ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> uint8.max));\n    v14 = ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> int8.max >> ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> uint8.max)) * ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> int8.max >> ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> uint8.max));\n    v15 = ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> int8.max >> ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> uint8.max)) * ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> int8.max >> ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> uint8.max));\n    v16 = ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> int8.max >> ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> uint8.max)) * ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> int8.max >> ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> uint8.max));\n    v17 = ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> int8.max >> ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> uint8.max)) * ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> int8.max >> ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> uint8.max));\n    v18 = (0x4000000000000 & v17 >> 205 | (0x8000000000000 & (v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> 204 | (0x10000000000000 & v16 >> 203 | (0x20000000000000 & (v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> 202 | (0x40000000000000 & v15 >> 201 | (0x80000000000000 & (v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> 200 | (0x100000000000000 & v14 >> 199 | (0x200000000000000 & (v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> 198 | (0x400000000000000 & v13 >> 197 | (0x800000000000000 & (v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> 196 | (0x1000000000000000 & v12 >> 195 | (0x2000000000000000 & (v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> 194 | (0x4000000000000000 & v11 >> 193 | (0x8000000000000000 & v8 * v8 >> 192 | v7 + ~int8.max << 64)))))))))))))) * 0x3627a301d71055774c85;\n    v19 = v20 = v18 + ~0x28f6481ab7f045a5af012a19d003aa9 >> 128;\n    v19 = v21 = v18 + 0xdb2df09e81959a81455e260799a0632f >> 128;\n    if (int24(v20) != int24(v21)) {\n        v22 = 0x2d6d(v21);\n        if (address(v22) > address(varg0)) {\n        }\n        // Unknown jump to Block 0x39c4. Refer to 3-address code (TAC);\n    }\n    return v19;\n}\n\nfunction 0x39d1(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    assert(uint16(varg5) < uint16.max);\n    v0 = new struct(4);\n    v1 = STORAGE[varg6 + uint16(varg5)];\n    v0.word0 = uint32(v1);\n    v0.word1 = int56(v1 >> 32);\n    v0.word2 = address(v1 >> 88);\n    v0.word3 = bool(uint8(v1 >> 248));\n    if (uint32(varg4) != uint32(v1)) {\n        v2 = v3 = uint16(varg0) > uint16(varg1);\n        if (v3) {\n            v2 = v4 = uint16(varg5) == uint16(varg1 - 1);\n        }\n        if (v2) {\n        }\n        assert(uint16(varg0));\n        v5 = uint16(1 + varg5) % uint16(varg0);\n        v6 = 0x4822(varg2, varg3, varg4, v0);\n        assert(uint16(v5) < uint16.max);\n        STORAGE[varg6 + uint16(v5)] = uint248(((bytes28(STORAGE[varg6 + uint16(v5)]) | uint32(v6.word0)) & ~0xffffffffffffff00000000 | uint56(int56(v6.word1)) << 32) & 0xff0000000000000000000000000000000000000000ffffffffffffffffffffff | address(v6.word2) << 88) | bool(v6.word3) << 248;\n        return varg0, v5;\n    } else {\n        return varg1, varg5;\n    }\n}\n\nfunction mint(address varg0, int24 varg1, int24 varg2, uint128 varg3, bytes varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    require(varg4 <= 0x100000000);\n    require(varg4.data <= 4 + (msg.data.length - 4));\n    require(!((varg4.length > 0x100000000) | (varg4.data + varg4.length > 4 + (msg.data.length - 4))));\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(varg3);\n    v0 = new struct(4);\n    v0.word0 = varg0;\n    v0.word1 = varg1;\n    v0.word2 = varg2;\n    require(varg3 == int128(uint128(uint128(varg3))));\n    v0.word3 = int128(uint128(uint128(varg3)));\n    v1, v2, v3 = 0x3f69(v0);\n    v4 = v5 = 0;\n    if (v2 > 0) {\n        v4 = v6 = 0x3cd4();\n    }\n    if (v1) {\n        v4 = v7 = 0x3e1d();\n    }\n    v8 = new bytes[](varg4.length);\n    CALLDATACOPY(v8.data, varg4.data, varg4.length);\n    v8[varg4.length] = 0;\n    require(bool((address(msg.sender)).code.size));\n    v9 = msg.sender.uniswapV3MintCallback(v2, v1, v8).gas(msg.gas);\n    require(bool(v9), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v10 = 0x3cd4();\n        require(v4 + v2 >= v4);\n        require(v4 + v2 <= v10, Error(19760));\n    }\n    if (v1) {\n        v11 = 0x3e1d();\n        require(v4 + v1 >= v4);\n        require(v4 + v1 <= v11, Error(19761));\n    }\n    emit Mint(varg0, varg1, varg2, msg.sender, varg3, v2, v1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return v2, v1;\n}\n\nfunction 0x3b86(uint256 varg0, address varg1, address varg2) private { \n    MEM[64] = MEM[64] + 100;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5 = v6, /* uint256 */ v7, /* uint256 */ v8 = varg2.transfer(varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = v11 = new bytes[](RETURNDATASIZE());\n        v7 = v11.data;\n        RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n    }\n    if (v6) {\n        v5 = v12 = !MEM[v9];\n        if (MEM[v9]) {\n            require(MEM[v9] >= 32);\n            v5 = v13 = MEM[v8];\n        }\n    }\n    require(v5, Error(21574));\n    return ;\n}\n\nfunction 0x3cd4() private { \n    MEM[64] = MEM[64] + 68;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, /* uint256 */ v6, /* uint256 */ v7 = address(0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0).balanceOf(this).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v8 = v9 = 96;\n    } else {\n        v8 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v8.data, 0, RETURNDATASIZE());\n    }\n    if (v5) {\n        v5 = v10 = MEM[v8] >= 32;\n    }\n    require(v5);\n    require(MEM[v8] >= 32);\n    return MEM[32 + v8];\n}\n\nfunction 0x3e1d() private { \n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, /* uint256 */ v10, /* uint256 */ v11 = address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2).staticcall(this).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    if (v9) {\n        v9 = v14 = MEM[v12] >= 32;\n    }\n    require(v9);\n    require(MEM[v12] >= 32);\n    return MEM[32 + v12];\n}\n\nfunction 0x3eb5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(uint16(varg1) > 0, Error(73));\n    if (uint16(varg0) > uint16(varg1)) {\n        while (uint16(varg1) < uint16(varg0)) {\n            assert(uint16(varg1) < uint16.max);\n            STORAGE[uint16(varg1) + varg2] = uint32(1) | bytes28(STORAGE[uint16(varg1) + varg2]);\n            varg1 += 1;\n        }\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction 0x3f69(struct(4) varg0) private { \n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    0x43a1(varg0.word2, varg0.word1);\n    MEM[MEM[64] + 160] = uint8(_slot0 >> 232);\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    v0 = 0x4acf(int24(_slot0 >> 160), varg0.word3, varg0.word2, varg0.word1, varg0.word0);\n    if (0 == int128(varg0.word3)) {\n        return 0, 0, v0;\n    } else if (int24(_slot0 >> 160) >= int24(varg0.word1)) {\n        if (int24(_slot0 >> 160) >= int24(varg0.word2)) {\n            v1 = 0x2d6d(varg0.word1);\n            v2 = 0x2d6d(varg0.word2);\n            v3 = 0x4cc8(varg0.word3, v2, v1);\n            return v3, 0, v0;\n        } else {\n            v4, v5 = 0x39d1(uint16(_slot0 >> 216), uint16(_slot0 >> 200), _liquidity, int24(_slot0 >> 160), block.timestamp, uint16(_slot0 >> 184), 8);\n            _slot0 = uint16(v5) << 184 | ~0xffff0000000000000000000000000000000000000000000000 & (uint16(v4) << 200 | ~0xffff00000000000000000000000000000000000000000000000000 & _slot0);\n            v6 = 0x2d6d(varg0.word2);\n            v7 = 0x4c84(varg0.word3, v6, address(_slot0));\n            v8 = 0x2d6d(varg0.word1);\n            v9 = 0x4cc8(varg0.word3, address(_slot0), v8);\n            v10 = _SafeAdd(varg0.word3, _liquidity);\n            _liquidity = v10;\n            return v9, v7, v0;\n        }\n    } else {\n        v11 = 0x2d6d(varg0.word1);\n        v12 = 0x2d6d(varg0.word2);\n        v13 = 0x4c84(varg0.word3, v12, v11);\n        return 0, v13, v0;\n    }\n}\n\nfunction 0x41a9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x32d9(varg0, varg1, varg2);\n    assert(varg0);\n    if (varg2 * varg1 % varg0 <= 0) {\n        return v0;\n    } else {\n        require(v0 < ~0);\n        return 1 + v0;\n    }\n}\n\nfunction 0x43a1(int24 varg0, int24 varg1) private { \n    require(varg1 < varg0, Error(0x544c55));\n    require(varg1 >= ~0xd89e7, Error(0x544c4d));\n    require(varg0 <= 0xd89e8, Error(0x54554d));\n    return ;\n}\n\nfunction 0x44c8(uint256 varg0) private { \n    v0 = v1 = 0;\n    require(varg0 > v1);\n    if (varg0 >= 0x100000000000000000000000000000000) {\n        varg0 = v2 = varg0 >> 128;\n        v0 = v3 = 128;\n    }\n    if (varg0 >= 0x10000000000000000) {\n        varg0 = v4 = varg0 >> 64;\n        v0 = v5 = 64 + v0;\n    }\n    if (varg0 >= 0x100000000) {\n        varg0 = v6 = varg0 >> 32;\n        v0 = v7 = 32 + v0;\n    }\n    if (varg0 >= 0x10000) {\n        varg0 = v8 = varg0 >> 16;\n        v0 = v9 = 16 + v0;\n    }\n    if (varg0 >= 256) {\n        varg0 = v10 = varg0 >> 8;\n        v0 = v11 = 8 + v0;\n    }\n    if (varg0 >= 16) {\n        varg0 = v12 = varg0 >> 4;\n        v0 = v13 = 4 + v0;\n    }\n    if (varg0 >= 4) {\n        varg0 = v14 = varg0 >> 2;\n        v0 = v15 = 2 + v0;\n    }\n    if (varg0 < 2) {\n        return v0;\n    } else {\n        return 1 + v0;\n    }\n}\n\nfunction feeGrowthGlobal1X128() public payable { \n    return _feeGrowthGlobal1X128;\n}\n\nfunction 0x4568(uint256 varg0) private { \n    require(varg0 > 0);\n    v0 = v1 = uint8.max;\n    if (!uint128(varg0)) {\n        varg0 = v2 = varg0 >> 128;\n    } else {\n        v0 = v3 = int8.max;\n    }\n    if (!uint64(varg0)) {\n        varg0 = v4 = varg0 >> 64;\n    } else {\n        v0 = v5 = ~63 + v0;\n    }\n    if (!uint32(varg0)) {\n        varg0 = v6 = varg0 >> 32;\n    } else {\n        v0 = v7 = ~31 + v0;\n    }\n    if (!uint16(varg0)) {\n        varg0 = v8 = varg0 >> 16;\n    } else {\n        v0 = v9 = ~15 + v0;\n    }\n    if (!uint8(varg0)) {\n        varg0 = v10 = varg0 >> 8;\n    } else {\n        v0 = v11 = ~7 + v0;\n    }\n    if (!bool(varg0)) {\n        varg0 = v12 = varg0 >> 4;\n    } else {\n        v0 = v13 = ~3 + v0;\n    }\n    if (!(varg0 & 0x3)) {\n        varg0 = v14 = varg0 >> 2;\n    } else {\n        v0 = v15 = ~1 + v0;\n    }\n    if (!(varg0 & 0x1)) {\n        return v0;\n    } else {\n        return ~0 + v0;\n    }\n}\n\nfunction 0x4652(uint256 varg0, uint128 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg0) {\n        v0 = v1 = 0x41a9(0x1000000000000000000000000, address(varg3 - varg3), varg1);\n    } else {\n        v0 = v2 = 0x32d9(0x1000000000000000000000000, address(varg3 - varg3), varg1);\n    }\n    return v0;\n}\n\nfunction 0x46cd(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg3 - varg3);\n    require(address(varg3));\n    if (varg0) {\n        v1 = 0x41a9(address(varg3), v0, varg1 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000);\n        return bool(v1 % address(varg3)) + v1 / address(varg3);\n    } else {\n        v2 = 0x32d9(address(varg3), v0, varg1 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000);\n        assert(address(varg3));\n        return v2 / address(varg3);\n    }\n}\n\nfunction flash(address varg0, uint256 varg1, uint256 varg2, bytes varg3) public payable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(varg3.data <= 4 + (msg.data.length - 4));\n    require(!((varg3.length > 0x100000000) | (varg3.data + varg3.length > 4 + (msg.data.length - 4))));\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    require(_liquidity, Error(76));\n    v0 = 0x41a9(0xf4240, uint24(3000), varg1);\n    v1 = 0x41a9(0xf4240, uint24(3000), varg2);\n    v2 = 0x3cd4();\n    v3 = 0x3e1d();\n    if (varg1) {\n        0x3b86(varg1, varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (varg2) {\n        0x3b86(varg2, varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    v4 = new bytes[](varg3.length);\n    CALLDATACOPY(v4.data, varg3.data, varg3.length);\n    v4[varg3.length] = 0;\n    require(bool((address(msg.sender)).code.size));\n    v5 = msg.sender.uniswapV3FlashCallback(v0, v1, v4).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v6 = 0x3cd4();\n    v7 = 0x3e1d();\n    require(v2 + v0 >= v2);\n    require(v2 + v0 <= v6, Error(17968));\n    require(v3 + v1 >= v3);\n    require(v3 + v1 <= v7, Error(17969));\n    if (v6 - v2) {\n        if (!bool(_slot0 >> 232)) {\n            v8 = v9 = 0;\n        } else {\n            assert(uint8(bool(_slot0 >> 232)));\n            v8 = v10 = (v6 - v2) / uint8(bool(_slot0 >> 232));\n        }\n        if (uint128(v8)) {\n            _protocolFees += v8;\n        }\n        v11 = 0x32d9(_liquidity, 0x100000000000000000000000000000000, v6 - v2 - v8);\n        _feeGrowthGlobal0X128 += v11;\n    }\n    if (v7 - v3) {\n        if (!bool(_slot0 >> 232 >> 4)) {\n            v12 = v13 = 0;\n        } else {\n            assert(uint8(bool(_slot0 >> 232 >> 4)));\n            v12 = v14 = (v7 - v3) / uint8(bool(_slot0 >> 232 >> 4));\n        }\n        if (uint128(v12)) {\n            stor_3_16_31 += v12;\n        }\n        v15 = 0x32d9(_liquidity, 0x100000000000000000000000000000000, v7 - v3 - v12);\n        _feeGrowthGlobal1X128 += v15;\n    }\n    emit Flash(msg.sender, varg0, varg1, varg2, v6 - v2, v7 - v3);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction 0x4822(uint256 varg0, int24 varg1, uint256 varg2, struct(4) varg3) private { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 0;\n    v0 = new struct(4);\n    v0.word0 = uint32(varg2);\n    v0.word1 = int56(varg3.word1 + int24(varg1) * uint32(varg2 - varg3.word0));\n    if (uint128(varg0) <= 0) {\n        varg0 = v1 = 1;\n    }\n    assert(uint128(varg0));\n    v0.word2 = address(varg3.word2 + (varg2 - varg3.word0 << 128 & 0xffffffff00000000000000000000000000000000) / uint128(varg0));\n    v0.word3 = bool(1);\n    return v0;\n}\n\nfunction 0x48d2(uint16 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 0;\n    v0 = new struct(4);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    assert(uint16(varg2) < uint16.max);\n    v1 = new struct(4);\n    v2 = STORAGE[varg6 + uint16(varg2)];\n    v1.word0 = uint32(v2);\n    v1.word1 = int56(v2 >> 32);\n    v1.word2 = address(v2 >> 88);\n    v1.word3 = bool(uint8(v2 >> 248));\n    v3 = 0x4ed8(varg4, uint32(v2), varg5);\n    if (!v3) {\n        assert(varg0);\n        assert(uint16(uint16(1 + varg2) % uint16(varg0)) < uint16.max);\n        v4 = v5 = MEM[64];\n        MEM[64] = v5 + 128;\n        v6 = STORAGE[uint16(uint16(1 + varg2) % uint16(varg0)) + varg6];\n        MEM[v5] = uint32(v6);\n        MEM[v5 + 32] = int56(v6 >> 32);\n        MEM[v5 + 64] = address(v6 >> 88);\n        MEM[v5 + 96] = bool(uint8(v6 >> 248));\n        if (!bool(uint8(v6 >> 248))) {\n            v4 = v7 = MEM[64];\n            MEM[64] = v7 + 128;\n            MEM[v7] = uint32(STORAGE[varg6]);\n            MEM[v7 + 32] = int56(STORAGE[varg6] >> 32);\n            MEM[v7 + 64] = address(STORAGE[varg6] >> 88);\n            MEM[v7 + 96] = bool(uint8(STORAGE[varg6] >> 248));\n        }\n        v8 = 0x4ed8(varg4, MEM[0 + v4], varg5);\n        require(v8, Error(0x4f4c44));\n        MEM[64] = MEM[64] + 128;\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64] + 32] = 0;\n        MEM[MEM[64] + 64] = 0;\n        MEM[MEM[64] + 96] = 0;\n        MEM[64] = MEM[64] + 128;\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64] + 32] = 0;\n        MEM[MEM[64] + 64] = 0;\n        MEM[MEM[64] + 96] = 0;\n        assert(varg0);\n        v9 = v10 = uint16(uint16(1 + varg2) % uint16(varg0));\n        v11 = v12 = v10 + varg0 - 1;\n        while (!varg0) {\n            assert((v9 + v11 >> 1) % varg0 < uint16.max);\n            v13 = new struct(4);\n            v14 = STORAGE[(v9 + v11 >> 1) % varg0 + varg6];\n            v13.word0 = uint32(v14);\n            v13.word1 = int56(v14 >> 32);\n            v13.word2 = address(v14 >> 88);\n            v13.word3 = bool(uint8(v14 >> 248));\n            if (bool(uint8(v14 >> 248))) {\n                assert(varg0);\n                assert((1 + (v9 + v11 >> 1)) % varg0 < uint16.max);\n                v15 = new struct(4);\n                v16 = STORAGE[(1 + (v9 + v11 >> 1)) % varg0 + varg6];\n                v15.word0 = uint32(v16);\n                v15.word1 = int56(v16 >> 32);\n                v15.word2 = address(v16 >> 88);\n                v15.word3 = bool(uint8(v16 >> 248));\n                v17 = v18 = 0x4ed8(varg4, v13.word0, varg5);\n                if (v18) {\n                    v17 = 0x4ed8(v15.word0, varg4, varg5);\n                }\n                if (!v17) {\n                    if (v18) {\n                        v9 = 1 + (v9 + v11 >> 1);\n                    } else {\n                        v11 = (v9 + v11 >> 1) - 1;\n                    }\n                } else {\n                    return v15, v13;\n                }\n            } else {\n                v9 = 1 + (v9 + v11 >> 1);\n            }\n        }\n        throw();\n    } else if (uint32(v1.word0) != uint32(varg4)) {\n        v19 = 0x4822(varg1, varg3, varg4, v1);\n        return v19, v1;\n    } else {\n        return v0, v1;\n    }\n}\n\nfunction 0x4acf(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    MEM[64] = MEM[64] + 58;\n    v0 = keccak256(bytes20(varg4 << 96), int24(varg3), int24(varg2));\n    v1 = v2 = 0;\n    if (int128(varg1)) {\n        v3, v4 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, block.timestamp, 8);\n        v1 = v5 = 0x513b(0x23746e6a58dcb13d4af821b93f062, 0, block.timestamp, v4, v3, _feeGrowthGlobal1X128, _feeGrowthGlobal0X128, varg1, varg0, varg3, 5);\n        v1 = v6 = 0x513b(0x23746e6a58dcb13d4af821b93f062, 1, block.timestamp, v4, v3, _feeGrowthGlobal1X128, _feeGrowthGlobal0X128, varg1, varg0, varg2, 5);\n        if (v5) {\n            0x5325(60, varg3, 6);\n        }\n        if (v6) {\n            0x5325(60, varg2, 6);\n        }\n    }\n    v7 = int24(varg3);\n    v8 = int24(varg2);\n    if (int24(varg0) < int24(varg3)) {\n        v9 = v10 = _feeGrowthGlobal0X128 - _ticks[v7].field1;\n        v11 = v12 = _feeGrowthGlobal1X128 - _ticks[v7].field2;\n    } else {\n        v9 = v13 = _ticks[v7].field1;\n        v11 = v14 = _ticks[v7].field2;\n    }\n    if (int24(varg0) >= int24(varg2)) {\n        v15 = v16 = _feeGrowthGlobal0X128 - _ticks[v8].field1;\n        v17 = v18 = _feeGrowthGlobal1X128 - _ticks[v8].field2;\n    } else {\n        v15 = v19 = _ticks[v8].field1;\n        v17 = v20 = _ticks[v8].field2;\n    }\n    MEM[MEM[64] + 96] = uint128(_positions[v0].field3);\n    MEM[MEM[64] + 128] = uint128(_positions[v0].field3 >> 128);\n    if (int128(varg1)) {\n        v21 = v22 = _SafeAdd(varg1, uint128(_positions[v0].field0));\n    } else {\n        require(uint128(_positions[v0].field0), Error(20048));\n    }\n    v23 = 0x32d9(0x100000000000000000000000000000000, uint128(_positions[v0].field0), _feeGrowthGlobal0X128 - v9 - v15 - _positions[v0].field1);\n    v24 = 0x32d9(0x100000000000000000000000000000000, uint128(_positions[v0].field0), _feeGrowthGlobal1X128 - v11 - v17 - _positions[v0].field2);\n    if (0 != int128(varg1)) {\n        _positions[v0].field0 = uint128(v21) | bytes16(_positions[v0].field0);\n    }\n    _positions[v0].field1 = _feeGrowthGlobal0X128 - v9 - v15;\n    _positions[v0].field2 = _feeGrowthGlobal1X128 - v11 - v17;\n    v25 = v26 = bool(uint128(v23));\n    if (!v26) {\n        v25 = uint128(v24) > 0;\n    }\n    if (v25) {\n        _positions[v0].field3 = uint128(v24 + uint128((uint128(v23 + uint128(_positions[v0].field3)) | bytes16(_positions[v0].field3)) >> 128)) << 128 | uint128(uint128(v23 + uint128(_positions[v0].field3)) | bytes16(_positions[v0].field3));\n    }\n    if (int128(varg1) >= 0) {\n        return keccak256(v0, 7);\n    } else {\n        if (v1) {\n            v27 = int24(varg3);\n            _ticks[v27].field0 = 0;\n            _ticks[v27].field1 = 0;\n            _ticks[v27].field2 = 0;\n            _ticks[v27].field3 = 0;\n        }\n        if (!v1) {\n            return keccak256(v0, 7);\n        } else {\n            v28 = int24(varg2);\n            _ticks[v28].field0 = 0;\n            _ticks[v28].field1 = 0;\n            _ticks[v28].field2 = 0;\n            _ticks[v28].field3 = 0;\n            return keccak256(v0, 7);\n        }\n    }\n}\n\nfunction 0x4c84(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (int128(varg0) < 0) {\n        v0 = 0x46cd(0, 0 - varg0, varg1, varg2);\n        require(v0 < int256.min);\n        return 0 - v0;\n    } else {\n        v1 = 0x46cd(1, varg0, varg1, varg2);\n        require(v1 < int256.min);\n        return v1;\n    }\n}\n\nfunction 0x4cc8(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (int128(varg0) < 0) {\n        v0 = 0x4652(0, 0 - varg0, varg1, varg2);\n        require(v0 < int256.min);\n        return 0 - v0;\n    } else {\n        v1 = 0x4652(1, varg0, varg1, varg2);\n        require(v1 < int256.min);\n        return v1;\n    }\n}\n\nfunction 0x4d02(uint256 varg0, uint256 varg1, uint128 varg2, address varg3) private { \n    if (!varg0) {\n        if (varg1 <= uint160.max) {\n            v0 = bool((varg1 << 96) % uint128(varg2)) + (varg1 << 96) / varg2;\n            // Unknown jump to Block 0x4dba. Refer to 3-address code (TAC);\n        } else {\n            v0 = v1 = 0x41a9(varg2, 0x1000000000000000000000000, varg1);\n        }\n        require(varg3 > v0);\n        return varg3 - v0;\n    } else {\n        if (varg1 <= uint160.max) {\n            assert(varg2);\n            v2 = v3 = (varg1 << 96) / varg2;\n        } else {\n            v2 = v4 = 0x32d9(varg2, 0x1000000000000000000000000, varg1);\n        }\n        require(varg3 + v2 >= varg3);\n        require(varg3 + v2 == address(varg3 + v2));\n        return varg3 + v2;\n    }\n}\n\nfunction 0x4de3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg1) {\n        v0 = varg2 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000;\n        if (!varg0) {\n            v1 = address(varg3) * varg1;\n            assert(varg1);\n            v2 = v3 = v1 / varg1 == address(varg3);\n            if (v3) {\n                v2 = v4 = v0 > v1;\n            }\n            require(v2);\n            v5 = v6 = 0x41a9(v0 - v1, address(varg3), v0);\n            require(v6 == address(v6));\n            // Unknown jump to Block 0x4e56. Refer to 3-address code (TAC);\n        } else {\n            assert(varg1);\n            if (address(varg3) * varg1 / varg1 == address(varg3)) {\n                if (address(varg3) * varg1 + v0 >= v0) {\n                    v5 = v7 = 0x41a9(address(varg3) * varg1 + v0, address(varg3), v0);\n                }\n            }\n            assert(address(varg3));\n            require(v0 / address(varg3) + varg1 >= v0 / address(varg3));\n            return bool(v0 % (v0 / address(varg3) + varg1)) + v0 / (v0 / address(varg3) + varg1);\n        }\n        return v5;\n    } else {\n        return varg3;\n    }\n}\n\nfunction 0x4ed8(uint32 varg0, uint32 varg1, uint32 varg2) private { \n    v0 = v1 = varg1 <= varg2;\n    if (!bool(uint32(varg1) > uint32(varg2))) {\n        v0 = v2 = varg0 <= varg2;\n    }\n    if (!v0) {\n        if (varg1 > varg2) {\n            v3 = v4 = varg1;\n        } else {\n            v3 = v5 = 0x100000000 + varg1;\n        }\n        if (varg0 > varg2) {\n            v6 = v7 = varg0;\n        } else {\n            v6 = v8 = 0x100000000 + varg0;\n        }\n        return uint40(v3) <= uint40(v6);\n    } else {\n        return varg1 <= varg0;\n    }\n}\n\nfunction collect(address varg0, int24 varg1, int24 varg2, uint128 varg3, uint128 varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    v0 = v1 = varg3;\n    v2 = v3 = varg4;\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    MEM[64] = MEM[64] + 58;\n    v4 = keccak256(bytes20(msg.sender << 96), varg1, varg2);\n    if (uint128(v1) > uint128(_positions[v4].field3)) {\n        v0 = v5 = uint128(_positions[v4].field3);\n    }\n    if (uint128(v3) > uint128(_positions[v4].field3 >> 128)) {\n        v2 = v6 = uint128(_positions[v4].field3 >> 128);\n    }\n    if (uint128(v0)) {\n        _positions[v4].field3 = uint128(uint128(_positions[v4].field3) - v0) | bytes16(_positions[v4].field3);\n        0x3b86(uint128(v0), varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (uint128(v2)) {\n        _positions[v4].field3 = uint128(_positions[v4].field3) | uint128(uint128(_positions[v4].field3 >> 128) - v2) << 128;\n        0x3b86(uint128(v2), varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    emit Collect(msg.sender, varg1, varg2, varg0, uint128(v0), uint128(v2));\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return uint128(v0), uint128(v2);\n}\n\nfunction 0x513b(uint128 varg0, uint256 varg1, uint32 varg2, int56 varg3, address varg4, uint256 varg5, uint256 varg6, uint256 varg7, int24 varg8, int24 varg9, uint256 varg10) private { \n    v0 = _SafeAdd(varg7, uint128(STORAGE[v1]));\n    require(uint128(v0) <= varg0, Error(19535));\n    if (!bool(uint128(uint128(STORAGE[v1])))) {\n        if (varg9 <= varg8) {\n            STORAGE[v1 + 1] = varg6;\n            STORAGE[v1 + 2] = varg5;\n            STORAGE[v1 + 3] = varg2 << 216 | ~0xffffffff000000000000000000000000000000000000000000000000000000 & (uint56(int56(varg3)) | bytes25(address(varg4) << 56 | 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff & STORAGE[v1 + 3]));\n        }\n        STORAGE[v1 + 3] = 0x100000000000000000000000000000000000000000000000000000000000000 | uint248(STORAGE[v1 + 3]);\n    }\n    STORAGE[v1] = uint128(v0) | bytes16(STORAGE[v1]);\n    if (varg1) {\n        v2 = v3 = int128(STORAGE[v1] >> 128) - int128(varg7);\n        require(int128(varg7) >= 0 == v3 <= int128(STORAGE[v1] >> 128));\n        require(v3 == int128(v3));\n        // Unknown jump to Block 0x52f4. Refer to 3-address code (TAC);\n    } else {\n        v2 = int128(varg7) + int128(STORAGE[v1] >> 128);\n        require(int128(varg7) >= 0 == v2 >= int128(STORAGE[v1] >> 128));\n        require(v2 == int128(v2));\n    }\n    STORAGE[v1] = uint128(STORAGE[v1]) | uint128(int128(v2)) << 128;\n    return !uint128(STORAGE[v1]) != !uint128(v0);\n}\n\nfunction 0x5325(int24 varg0, int24 varg1, uint256 varg2) private { \n    assert(varg0);\n    require(!int24(int24(varg1) % int24(varg0)));\n    assert(varg0);\n    STORAGE[keccak256(int16(int24(int24(varg1) / int24(varg0)) >> 8), varg2)] = STORAGE[keccak256(int16(int24(int24(varg1) / int24(varg0)) >> 8), varg2)] ^ 1 << uint8(int24(int24(varg1) / int24(varg0)) % 256);\n    return ;\n}\n\nfunction positions(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return uint128(_positions[varg0].field0), _positions[varg0].field1, _positions[varg0].field2, uint128(_positions[varg0].field3), uint128(_positions[varg0].field3 >> 128);\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction tickBitmap(int16 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _tickBitmap[varg0];\n}\n\nfunction maxLiquidityPerTick() public payable { \n    return uint128(0x23746e6a58dcb13d4af821b93f062);\n}\n\nfunction setFeeProtocol(uint8 varg0, uint8 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(bool((address(0x1f98431c8ad98523631ae4a59f267346ea31f984)).code.size));\n    v0, /* address */ v1 = address(0x1f98431c8ad98523631ae4a59f267346ea31f984).owner().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(msg.sender == address(v1));\n    v2 = v3 = !varg0;\n    if (varg0) {\n        v2 = v4 = varg0 >= 4;\n        if (!bool(uint8(uint8(varg0)) < 4)) {\n            v2 = v5 = varg0 <= 10;\n        }\n    }\n    if (v2) {\n        v2 = v6 = !varg1;\n        if (varg1) {\n            v2 = v7 = varg1 >= 4;\n            if (!bool(uint8(uint8(varg1)) < 4)) {\n                v2 = v8 = varg1 <= 10;\n            }\n        }\n    }\n    require(v2);\n    _slot0 = _slot0 & 0xffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff | uint8(uint8(varg0) + (uint8(varg1) << 4 & 0xff0)) << 232;\n    emit SetFeeProtocol(uint8(uint8(_slot0 >> 232) % 16), bool(uint8(_slot0 >> 232) >> 4), varg0, varg1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction collectProtocol(address varg0, uint128 varg1, uint128 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg1;\n    v2 = v3 = varg2;\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(bool((address(0x1f98431c8ad98523631ae4a59f267346ea31f984)).code.size));\n    v4, /* address */ v5 = address(0x1f98431c8ad98523631ae4a59f267346ea31f984).owner().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(msg.sender == address(v5));\n    if (uint128(v1) > _protocolFees) {\n        v0 = v6 = _protocolFees;\n    }\n    if (uint128(v3) > stor_3_16_31) {\n        v2 = v7 = stor_3_16_31;\n    }\n    if (uint128(v0)) {\n        if (_protocolFees == uint128(v0)) {\n            v0 = v8 = v0 + ~0;\n        }\n        _protocolFees = _protocolFees - v0;\n        0x3b86(uint128(v0), varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (uint128(v2)) {\n        if (stor_3_16_31 == uint128(v2)) {\n            v2 = v9 = ~0 + v2;\n        }\n        stor_3_16_31 = stor_3_16_31 - v2;\n        0x3b86(uint128(v2), varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    emit CollectProtocol(msg.sender, varg0, uint128(v0), uint128(v2));\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return uint128(v0), uint128(v2);\n}\n\nfunction observe(uint32[] varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(varg0.data <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (varg0.data + (varg0.length << 5) > 4 + (msg.data.length - 4))));\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, varg0.data, varg0.length << 5);\n    v0[varg0.length] = 0;\n    require(uint16(_slot0 >> 200) > 0, Error(73));\n    require(v0.length <= uint64.max);\n    v1 = new uint256[](v0.length);\n    if (v0.length) {\n        CALLDATACOPY(v1.data, msg.data.length, v0.length << 5);\n    }\n    require(v0.length <= uint64.max);\n    v2 = new uint256[](v0.length);\n    if (v0.length) {\n        CALLDATACOPY(v2.data, msg.data.length, v0.length << 5);\n    }\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        assert(v3 < v0.length);\n        if (uint32(v0[v3])) {\n            v5, v6 = 0x48d2(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), block.timestamp - v0[v3], block.timestamp, 8);\n            if (uint32(block.timestamp - v0[v3]) != uint32(v6.word0)) {\n                if (uint32(v5.word0) != uint32(block.timestamp - v0[v3])) {\n                    assert(uint32(v5.word0 - v6.word0));\n                    v7 = v6.word1 + int56(v5.word1 - v6.word1) / uint32(v5.word0 - v6.word0) * uint32(block.timestamp - v0[v3] - v6.word0);\n                    assert(uint32(v5.word0 - v6.word0));\n                    v8 = v6.word2 + address(v5.word2 - v6.word2) * uint32(block.timestamp - v0[v3] - v6.word0) / uint32(v5.word0 - v6.word0);\n                } else {\n                    v7 = v9 = v5.word1;\n                    v8 = v10 = v5.word2;\n                }\n            } else {\n                v7 = v11 = v6.word1;\n                v8 = v12 = v6.word2;\n            }\n        } else {\n            assert(uint16(_slot0 >> 184) < uint16.max);\n            v13 = v14 = new struct(4);\n            v14.word0 = uint32(STORAGE[8 + uint16(uint16(_slot0 >> 184))]);\n            v14.word1 = int56(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 32);\n            v14.word2 = address(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 88);\n            v14.word3 = bool(uint8(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 248));\n            if (uint32(block.timestamp) != uint32(STORAGE[8 + uint16(uint16(_slot0 >> 184))])) {\n                v13 = v15 = 0x4822(_liquidity, int24(_slot0 >> 160), block.timestamp, v14);\n            }\n            v7 = v16 = MEM[32 + v13];\n            v8 = v17 = MEM[64 + v13];\n        }\n        assert(v3 < v1.length);\n        assert(v3 < v2.length);\n        v2[v3] = address(v8);\n        v1[v3] = int56(v7);\n        v3 += 1;\n    }\n    v18 = new uint256[](v1.length);\n    v19 = v20 = 0;\n    while (v19 < v1.length << 5) {\n        MEM[v19 + v18.data] = MEM[v19 + v1.data];\n        v19 += 32;\n    }\n    v21 = new uint256[](v2.length);\n    v18[v1.length] = v2.length;\n    v22 = v23 = 0;\n    while (v22 < v2.length << 5) {\n        MEM[v22 + v21.data] = MEM[v22 + v2.data];\n        v22 += 32;\n    }\n    return v18, v21;\n}\n\nfunction burn(int24 varg0, int24 varg1, uint128 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    v0 = new struct(4);\n    v0.word0 = msg.sender;\n    v0.word1 = varg0;\n    v0.word2 = varg1;\n    require(varg2 == int128(uint128(uint128(varg2))));\n    v0.word3 = int128(0 - uint128(uint128(varg2)));\n    v1, v2, v3 = 0x3f69(v0);\n    v4 = v5 = 0 - v2 > 0;\n    if (0 - v2 <= 0) {\n        v4 = v6 = 0 - v1 > 0;\n    }\n    if (v4) {\n        STORAGE[v3 + 3] = bytes16(uint128(STORAGE[v3 + 3]) | uint128(0 - v1 + uint128(STORAGE[v3 + 3] >> 128)) << 128) | uint128(0 - v2 + uint128(STORAGE[v3 + 3]));\n    }\n    emit 0xc396cd989a39f4459b5fa1aed6a9a8dcdbc45908acfd67e028cd568da98982c(msg.sender, varg0, varg1, varg2, 0 - v2, 0 - v1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return 0 - v2, 0 - v1;\n}\n\nfunction snapshotCumulativesInside(int24 varg0, int24 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    0x43a1(varg1, varg0);\n    require(uint8(_ticks[int24(int24(int24(varg0)))].field3 >> 248));\n    require(uint8(_ticks[int24(int24(int24(varg1)))].field3 >> 248));\n    MEM[MEM[64]] = address(_slot0);\n    MEM[MEM[64] + 128] = uint16(_slot0 >> 216);\n    MEM[MEM[64] + 160] = uint8(_slot0 >> 232);\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    if (int24(_slot0 >> 160) >= varg0) {\n        if (int24(_slot0 >> 160) >= varg1) {\n            v0 = v1 = int56(_ticks[int24(int24(int24(varg1)))].field3) - int56(_ticks[int24(int24(int24(varg0)))].field3);\n            v2 = v3 = address(_ticks[int24(int24(int24(varg1)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg0)))].field3 >> 56);\n            v4 = v5 = uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216);\n        } else {\n            v6, v7 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, block.timestamp, 8);\n            v0 = v8 = v7 - int56(_ticks[int24(int24(int24(varg0)))].field3) - int56(_ticks[int24(int24(int24(varg1)))].field3);\n            v2 = v9 = v6 - address(_ticks[int24(int24(int24(varg0)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg1)))].field3 >> 56);\n            v4 = v10 = block.timestamp - uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216);\n        }\n    } else {\n        v0 = v11 = int56(_ticks[int24(int24(int24(varg0)))].field3) - int56(_ticks[int24(int24(int24(varg1)))].field3);\n        v2 = v12 = address(_ticks[int24(int24(int24(varg0)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg1)))].field3 >> 56);\n        v4 = v13 = uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216);\n    }\n    return int56(v0), address(v2), uint32(v4);\n}\n\nfunction factory() public payable { \n    return address(0x1f98431c8ad98523631ae4a59f267346ea31f984);\n}\n\nfunction tickSpacing() public payable { \n    return int24(60);\n}\n\nfunction token1() public payable { \n    return address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n}\n\nfunction fee() public payable { \n    return uint24(3000);\n}\n\nfunction feeGrowthGlobal0X128() public payable { \n    return _feeGrowthGlobal0X128;\n}\n\nfunction ticks(int24 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return uint128(_ticks[int24(varg0)].field0), int128(_ticks[int24(varg0)].field0 >> 128), _ticks[varg0].field1, _ticks[varg0].field2, int56(_ticks[int24(varg0)].field3), address(_ticks[int24(varg0)].field3 >> 56), uint32(_ticks[int24(varg0)].field3 >> 216), bool(uint8(_ticks[int24(varg0)].field3 >> 248));\n}\n\nfunction initialize(uint160 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(!address(_slot0), Error(16713));\n    v0 = 0x36a5(address(varg0));\n    MEM[MEM[64]] = uint32(block.timestamp);\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 1;\n    stor_8_0_3 = block.timestamp;\n    stor_8_31_31 = 1;\n    stor_8_4_30 = 0;\n    MEM[64] = MEM[64] + 224;\n    MEM[MEM[64]] = address(varg0);\n    MEM[MEM[64] + 32] = int24(v0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[MEM[64] + 96] = uint16(1);\n    MEM[MEM[64] + 128] = uint16(1);\n    MEM[MEM[64] + 160] = 0;\n    MEM[MEM[64] + 192] = 1;\n    _slot0 = 0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x1000000000000000000000000000000000000000000000000000000 | ~0xffff000000000000000000000000000000000000000000000000000000 & (0x100000000000000000000000000000000000000000000000000 | 0xffffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffff & (uint24(int24(int24(v0))) << 160 | ~0xffffff0000000000000000000000000000000000000000 & (address(varg0) | bytes12(_slot0))))) | 0x1000000000000000000000000000000000000000000000000000000000000;\n    emit Initialize(address(varg0), int24(v0));\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x70cf754a > v0) {\n            if (0x3850c7bd > v0) {\n                if (0x1ad8b03b > v0) {\n                    if (0xdfe1681 == v0) {\n                        token0();\n                    } else if (0x128acb08 == v0) {\n                        swap(address,bool,int256,uint160,bytes);\n                    } else {\n                        require(0x1a686502 == v0);\n                        liquidity();\n                    }\n                } else if (0x1ad8b03b == v0) {\n                    protocolFees();\n                } else if (0x252c09d7 == v0) {\n                    observations(uint256);\n                } else {\n                    require(0x32148f67 == v0);\n                    increaseObservationCardinalityNext(uint16);\n                }\n            } else if (0x490e6cbc > v0) {\n                if (0x3850c7bd == v0) {\n                    slot0();\n                } else if (0x3c8a7d8d == v0) {\n                    mint(address,int24,int24,uint128,bytes);\n                } else {\n                    require(0x46141319 == v0);\n                    feeGrowthGlobal1X128();\n                }\n            } else if (0x490e6cbc == v0) {\n                flash(address,uint256,uint256,bytes);\n            } else if (0x4f1eb3d8 == v0) {\n                collect(address,int24,int24,uint128,uint128);\n            } else if (0x514ea4bf == v0) {\n                positions(bytes32);\n            } else {\n                require(0x5339c296 == v0);\n                tickBitmap(int16);\n            }\n        } else if (0xc45a0155 > v0) {\n            if (0x883bdbfd > v0) {\n                if (0x70cf754a == v0) {\n                    maxLiquidityPerTick();\n                } else if (0x8206a4d1 == v0) {\n                    setFeeProtocol(uint8,uint8);\n                } else {\n                    require(0x85b66729 == v0);\n                    collectProtocol(address,uint128,uint128);\n                }\n            } else if (0x883bdbfd == v0) {\n                observe(uint32[]);\n            } else if (0xa34123a7 == v0) {\n                burn(int24,int24,uint128);\n            } else {\n                require(0xa38807f2 == v0);\n                snapshotCumulativesInside(int24,int24);\n            }\n        } else if (0xddca3f43 > v0) {\n            if (0xc45a0155 == v0) {\n                factory();\n            } else if (0xd0c93a7c == v0) {\n                tickSpacing();\n            } else {\n                require(0xd21220a7 == v0);\n                token1();\n            }\n        } else if (0xddca3f43 == v0) {\n            fee();\n        } else if (0xf3058399 == v0) {\n            feeGrowthGlobal0X128();\n        } else if (0xf30dba93 == v0) {\n            ticks(int24);\n        } else {\n            require(0xf637731d == v0);\n            initialize(uint160);\n        }\n    }\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled by library.dedaub.com\n// 2023.11.16 03:31 UTC\n// Compiled using the solidity compiler version 0.7.6\n\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _slot0; // STORAGE[0x0]\nuint256 _feeGrowthGlobal0X128; // STORAGE[0x1]\nuint256 _feeGrowthGlobal1X128; // STORAGE[0x2]\nmapping (uint256 => struct_1262) _ticks; // STORAGE[0x5]\nmapping (uint256 => uint256) _tickBitmap; // STORAGE[0x6]\nmapping (uint256 => struct_1263) _positions; // STORAGE[0x7]\nuint256 stor_8_0_3; // STORAGE[0x8] bytes 0 to 3\nuint256 _protocolFees; // STORAGE[0x3] bytes 0 to 15\nuint256 _liquidity; // STORAGE[0x4] bytes 0 to 15\nuint256 stor_8_4_30; // STORAGE[0x8] bytes 4 to 30\nuint256 stor_3_16_31; // STORAGE[0x3] bytes 16 to 31\nuint256 stor_8_31_31; // STORAGE[0x8] bytes 31 to 31\n\nstruct struct_1262 { uint256 field0; uint256 field1; uint256 field2; uint256 field3; };\nstruct struct_1263 { uint256 field0; uint256 field1; uint256 field2; uint256 field3; };\n\n// Events\nSwap(address, address, int256, int256, uint160, uint128, int24);\nIncreaseObservationCardinalityNext(uint16, uint16);\nMint(address, address, int24, int24, uint128, uint256, uint256);\nFlash(address, address, uint256, uint256, uint256, uint256);\nCollect(address, address, int24, int24, uint128, uint128);\nSetFeeProtocol(uint8, uint8, uint8, uint8);\nCollectProtocol(address, address, uint128, uint128);\nInitialize(uint160, int24);\n\nfunction token0() public payable { \n    return address(0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n}\n\nfunction swap(address varg0, bool varg1, int256 varg2, uint160 varg3, bytes varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    v0 = v1 = address(varg3);\n    require(varg4 <= 0x100000000);\n    require(varg4.data <= 4 + (msg.data.length - 4));\n    require(!((varg4.length > 0x100000000) | (varg4.data + varg4.length > 4 + (msg.data.length - 4))));\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    require(varg2, Error(16723));\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    require(bool(uint8(_slot0 >> 240)), Error(0x4c4f4b));\n    if (varg1) {\n        v2 = v3 = address(v1) < address(_slot0);\n        if (v3) {\n            v2 = v4 = address(v1) > 0x1000276a3;\n        }\n    } else {\n        v2 = v5 = address(v1) > address(_slot0);\n        if (v5) {\n            v2 = v6 = address(v1) < 0xfffd8963efd1fc6a506488495d951d5263988d26;\n        }\n    }\n    require(v2, Error(0x53504c));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    if (varg1) {\n        assert(16);\n        v7 = v8 = uint8(_slot0 >> 232) % 16;\n    } else {\n        v7 = v9 = uint8(_slot0 >> 232) >> 4;\n    }\n    MEM[96 + MEM[64]] = int56(0);\n    MEM[128 + MEM[64]] = address(0x0);\n    v10 = MEM[64];\n    MEM[32 + v10] = 0;\n    if (varg1) {\n        v11 = v12 = _feeGrowthGlobal0X128;\n    } else {\n        v11 = v13 = _feeGrowthGlobal1X128;\n    }\n    while (1) {\n        v14 = v15 = bool(varg2);\n        if (!varg2) {\n            // Unknown jump to Block 0xbd5. Refer to 3-address code (TAC);\n        }\n        v14 = v16 = address(MEM[64 + v10]) != address(v1);\n        if (!v14) {\n            if (int24(MEM[96 + v10]) == int24(_slot0 >> 160)) {\n                _slot0 = address(MEM[v10 + 64]) | bytes12(_slot0);\n            } else {\n                v17, v18 = 0x39d1(uint16(_slot0 >> 216), uint16(_slot0 >> 200), _liquidity, int24(_slot0 >> 160), uint32(block.timestamp), uint16(_slot0 >> 184), 8);\n                _slot0 = address(MEM[v10 + 64]) | bytes12(uint24(int24(MEM[v10 + 96])) << 160 | ~0xffffff0000000000000000000000000000000000000000 & (uint16(v18) << 184 | ~0xffff0000000000000000000000000000000000000000000000 & (uint16(v17) << 200 | ~0xffff00000000000000000000000000000000000000000000000000 & _slot0)));\n            }\n            if (uint128(_liquidity) != uint128(MEM[192 + v10])) {\n                _liquidity = MEM[v10 + 192];\n            }\n            if (bool(!varg1)) {\n                _feeGrowthGlobal1X128 = MEM[v10 + 128];\n                if (uint128(MEM[v10 + 160])) {\n                    stor_3_16_31 += MEM[v10 + 160];\n                }\n            } else {\n                _feeGrowthGlobal0X128 = MEM[v10 + 128];\n                if (uint128(MEM[v10 + 160])) {\n                    _protocolFees += MEM[v10 + 160];\n                }\n            }\n            if (varg1 == bool(varg2 > 0)) {\n                v19 = v20 = varg2 - MEM[0 + v10];\n                v21 = v22 = MEM[32 + v10];\n            } else {\n                v19 = v23 = MEM[v10 + 32];\n                v21 = v24 = varg2 - MEM[v10];\n            }\n            if (bool(!varg1)) {\n                if (v19 < 0) {\n                    0x3b86(0 - v19, varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n                }\n                v25 = 0x3e1d();\n                v26 = new bytes[](varg4.length);\n                CALLDATACOPY(v26.data, varg4.data, varg4.length);\n                v26[varg4.length] = 0;\n                require(bool((address(msg.sender)).code.size));\n                v27 = msg.sender.uniswapV3SwapCallback(v19, v21, v26).gas(msg.gas);\n                require(bool(v27), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v28 = 0x3e1d();\n                require(v25 + v21 >= v25);\n                require(v25 + v21 <= v28, Error(0x494941));\n            } else {\n                if (v21 < 0) {\n                    0x3b86(0 - v21, varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n                }\n                v29 = 0x3cd4();\n                v30 = new bytes[](varg4.length);\n                CALLDATACOPY(v30.data, varg4.data, varg4.length);\n                v30[varg4.length] = 0;\n                require(bool((address(msg.sender)).code.size));\n                v31 = msg.sender.uniswapV3SwapCallback(v19, v21, v30).gas(msg.gas);\n                require(bool(v31), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n                v32 = 0x3cd4();\n                require(v29 + v19 >= v29);\n                require(v29 + v19 <= v32, Error(0x494941));\n            }\n            emit Swap(msg.sender, varg0, v19, v21, address(MEM[v10 + 64]), uint128(MEM[v10 + 192]), int24(MEM[v10 + 96]));\n            _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n            return v19, v21;\n        } else {\n            v33 = MEM[64];\n            MEM[v33] = 0;\n            MEM[v33 + 32] = 0;\n            MEM[v33 + 64] = 0;\n            MEM[v33 + 96] = 0;\n            MEM[v33 + 128] = 0;\n            MEM[v33 + 160] = 0;\n            MEM[v33 + 192] = 0;\n            assert(int24(60));\n            v34 = v35 = int24(_slot0 >> 160) / int24(60);\n            v36 = v37 = int24(_slot0 >> 160) < 0;\n            if (v37) {\n                assert(int24(60));\n                v36 = bool(int24(int24(int24(int24(int24(int24(_slot0 >> 160))))) % int24(60)));\n            }\n            if (v36) {\n                v34 = v38 = ~0 + v35;\n            }\n            if (bool(!varg1)) {\n                v39 = 0 != _tickBitmap[int16(int24(1 + v34) >> 8)] & ~((1 << uint8(int24(1 + v34) % 256)) - 1);\n                if (v39) {\n                    v40 = 0x4568(_tickBitmap[int16(int24(1 + v34) >> 8)] & ~((1 << uint8(int24(1 + v34) % 256)) - 1));\n                    v41 = v42 = (1 + v34 + uint8(v40 - int24(1 + v34) % 256)) * 60;\n                } else {\n                    v41 = (1 + v34 + uint8(uint8.max - int24(1 + v34) % 256)) * 60;\n                }\n            } else {\n                v39 = v43 = bool(~0 + ((1 << uint8(int24(v34) % 256)) + (1 << uint8(int24(v34) % 256))) & _tickBitmap[int16(int24(v34) >> 8)]);\n                if (v43) {\n                    v44 = 0x44c8(~0 + ((1 << uint8(int24(v34) % 256)) + (1 << uint8(int24(v34) % 256))) & _tickBitmap[int16(int24(v34) >> 8)]);\n                    v41 = v45 = (v34 - uint8(int24(v34) % 256 - v44)) * 60;\n                } else {\n                    v41 = v46 = (v34 - uint8(int24(v34) % 256)) * 60;\n                }\n            }\n            MEM[v33 + 32] = int24(v41);\n            if (int24(v41) >= ~0xd89e7) {\n                if (int24(MEM[v33 + 32]) > 0xd89e8) {\n                    MEM[v33 + 32] = 0xd89e8;\n                }\n            } else {\n                MEM[v33 + 32] = ~0xd89e7;\n            }\n            v47 = 0x2d6d(MEM[32 + v33]);\n            if (varg1) {\n                v48 = v49 = address(v47) < address(v1);\n            } else {\n                v48 = v50 = address(v47) > address(v1);\n            }\n            if (!v48) {\n            }\n            v51 = v52 = 0;\n            v53 = v54 = varg2 >= v52;\n            if (varg2 < v52) {\n                if (address(v55) >= address(v0)) {\n                    v51 = v56 = 0x4652(0, v57, v55, v0);\n                } else {\n                    v51 = v58 = 0x46cd(0, v57, v0, v55);\n                }\n                if (0 - varg2 < v51) {\n                    require(address(v55) > 0);\n                    require(uint128(v57) > 0);\n                    if (address(v55) >= address(v0)) {\n                        v0 = v59 = 0x4d02(0, 0 - varg2, v57, v55);\n                    } else {\n                        v0 = v60 = 0x4de3(0, 0 - varg2, v57, v55);\n                    }\n                }\n            } else {\n                v61 = 0x32d9(0xf4240, uint24(0xf3688), varg2);\n                if (address(v55) >= address(v0)) {\n                    v51 = v62 = 0x46cd(1, v57, v55, v0);\n                } else {\n                    v51 = v63 = 0x4652(1, v57, v0, v55);\n                }\n                if (v61 < v51) {\n                    require(address(v55) > 0);\n                    require(uint128(v57) > 0);\n                    if (address(v55) >= address(v0)) {\n                        v0 = v64 = 0x4de3(1, v61, v57, v55);\n                    } else {\n                        v0 = v65 = 0x4d02(1, v61, v57, v55);\n                    }\n                }\n                // Unknown jump to Block 0x316e. Refer to 3-address code (TAC);\n            }\n            v53 = v66 = address(v0) == address(v0);\n            if (bool(address(v55) < address(v0))) {\n                if (!v53) {\n                    v51 = v67 = 0x4652(1, v57, v0, v55);\n                }\n                if (v66) {\n                    v53 = v68 = bool(varg2 < v52);\n                }\n                if (!v53) {\n                    v51 = v69 = 0x46cd(0, v57, v0, v55);\n                }\n            } else {\n                if (!v53) {\n                    v51 = v70 = 0x46cd(1, v57, v55, v0);\n                }\n                if (v66) {\n                    v53 = v71 = bool(varg2 < v52);\n                }\n                if (!v53) {\n                    v51 = v72 = 0x4652(0, v57, v55, v0);\n                }\n            }\n            v73 = v74 = varg2 < v52;\n            if (!bool(v54)) {\n                v73 = v75 = v51 > 0 - varg2;\n            }\n            if (v73) {\n                v51 = v76 = 0 - varg2;\n            }\n            if (!bool(varg2 < v52)) {\n                v53 = v77 = address(v0) != address(v0);\n            }\n            if (!v53) {\n                v78 = v79 = 0x41a9(uint24(0xf3688), uint24(3000), v51);\n            } else {\n                v78 = v80 = varg2 - v51;\n            }\n            if (varg2 <= 0) {\n                require(v51 < int256.min);\n                MEM[v10] = MEM[v10] + v51;\n                require(v51 + MEM[v33 + 192] < int256.min);\n                require(v51 + MEM[v33 + 192] >= 0 == v51 + MEM[v33 + 192] + MEM[v10 + 32] >= MEM[v10 + 32]);\n                MEM[v10 + 32] += v51 + MEM[v33 + 192];\n            } else {\n                require(v51 + MEM[192 + v33] < int256.min);\n                MEM[v10] = MEM[v10] - (v51 + MEM[192 + v33]);\n                require(v51 < int256.min);\n                require(v51 >= 0 == MEM[v10 + 32] - v51 <= MEM[v10 + 32]);\n                MEM[v10 + 32] = MEM[v10 + 32] - v51;\n            }\n            if (uint8(v7)) {\n                assert(uint8(v7));\n                MEM[v33 + 192] = v78 - v78 / uint8(v7);\n                MEM[v10 + 160] = uint128(v78 / uint8(v7) + uint128(0));\n            }\n            if (uint128(_liquidity)) {\n                v81 = 0x32d9(uint128(MEM[192 + v10]), 0x100000000000000000000000000000000, MEM[192 + v33]);\n                MEM[v10 + 128] = v81 + v11;\n            }\n            if (address(v0) != address(v47)) {\n                if (address(v0) != address(_slot0)) {\n                    v82 = 0x36a5(address(v0));\n                    MEM[v10 + 96] = int24(v82);\n                }\n            } else {\n                if (bool(v39)) {\n                    if (!bool(0)) {\n                        v83, v84 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, uint32(block.timestamp), 8);\n                        MEM[MEM[64] + 128] = address(v83);\n                        MEM[MEM[64] + 96] = int56(v84);\n                        MEM[MEM[64] + 160] = 1;\n                    }\n                    if (varg1) {\n                        v85 = v86 = MEM[128 + v10];\n                    } else {\n                        v85 = v87 = _feeGrowthGlobal0X128;\n                    }\n                    if (varg1) {\n                        v88 = v89 = _feeGrowthGlobal1X128;\n                    } else {\n                        v88 = v90 = MEM[128 + v10];\n                    }\n                    _ticks[int24(MEM[32 + v33])].field1 = v85 - _ticks[int24(MEM[32 + v33])].field1;\n                    _ticks[int24(MEM[32 + v33])].field2 = v88 - _ticks[int24(MEM[32 + v33])].field2;\n                    v91 = bytes25(_ticks[int24(int24(MEM[32 + v33]))].field3 & 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff | address(MEM[MEM[64] + 128] - address(_ticks[int24(int24(MEM[32 + v33]))].field3 >> 56)) << 56) | uint56(int56(MEM[MEM[64] + 96] - int56(_ticks[int24(int24(MEM[32 + v33]))].field3 & 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff | address(MEM[MEM[64] + 128] - address(_ticks[int24(int24(MEM[32 + v33]))].field3 >> 56)) << 56)));\n                    _ticks[int24(MEM[32 + v33])].field3 = v91 & ~0xffffffff000000000000000000000000000000000000000000000000000000 | uint32(uint32(block.timestamp) - uint32(v91 >> 216)) << 216;\n                    v92 = v93 = int128(_ticks[int24(int24(MEM[32 + v33]))].field0 >> 128);\n                    if (!bool(!varg1)) {\n                        v92 = v94 = 0 - v93;\n                    }\n                    v95 = _SafeAdd(v92, uint128(_liquidity));\n                    MEM[v10 + 192] = uint128(v95);\n                }\n                if (varg1) {\n                    v96 = v97 = MEM[32 + v33] - 1;\n                } else {\n                    v96 = v98 = MEM[32 + v33];\n                }\n                MEM[v10 + 96] = int24(v96);\n                // Unknown jump to Block 0xf99. Refer to 3-address code (TAC);\n            }\n        }\n    }\n}\n\nfunction liquidity() public payable { \n    return _liquidity;\n}\n\nfunction protocolFees() public payable { \n    return _protocolFees, stor_3_16_31;\n}\n\nfunction 0x2d6d(int24 varg0) private { \n    if (varg0 < 0) {\n        v0 = v1 = 0 - varg0;\n    } else {\n        v0 = v2 = varg0;\n    }\n    require(v0 <= 0xd89e8, Error(84));\n    if (v0 & 0x1) {\n        v3 = v4 = 0xfffcb933bd6fad37aa2d162d1a594001;\n    } else {\n        v3 = v5 = 0x100000000000000000000000000000000;\n    }\n    v6 = v7 = uint136(v3);\n    if (v0 & 0x2) {\n        v6 = v8 = 0xfff97272373d413259a46990580e213a * v7 >> 128;\n    }\n    if (v0 & 0x4) {\n        v6 = v9 = 0xfff2e50f5f656932ef12357cf3c7fdcc * v6 >> 128;\n    }\n    if (v0 & 0x8) {\n        v6 = v10 = 0xffe5caca7e10e4e61c3624eaa0941cd0 * v6 >> 128;\n    }\n    if (v0 & 0x10) {\n        v6 = v11 = 0xffcb9843d60f6159c9db58835c926644 * v6 >> 128;\n    }\n    if (v0 & 0x20) {\n        v6 = v12 = 0xff973b41fa98c081472e6896dfb254c0 * v6 >> 128;\n    }\n    if (v0 & 0x40) {\n        v6 = v13 = 0xff2ea16466c96a3843ec78b326b52861 * v6 >> 128;\n    }\n    if (v0 & 0x80) {\n        v6 = v14 = 0xfe5dee046a99a2a811c461f1969c3053 * v6 >> 128;\n    }\n    if (v0 & 0x100) {\n        v6 = v15 = 0xfcbe86c7900a88aedcffc83b479aa3a4 * v6 >> 128;\n    }\n    if (v0 & 0x200) {\n        v6 = v16 = 0xf987a7253ac413176f2b074cf7815e54 * v6 >> 128;\n    }\n    if (v0 & 0x400) {\n        v6 = v17 = 0xf3392b0822b70005940c7a398e4b70f3 * v6 >> 128;\n    }\n    if (v0 & 0x800) {\n        v6 = v18 = 0xe7159475a2c29b7443b29c7fa6e889d9 * v6 >> 128;\n    }\n    if (v0 & 0x1000) {\n        v6 = v19 = 0xd097f3bdfd2022b8845ad8f792aa5825 * v6 >> 128;\n    }\n    if (v0 & 0x2000) {\n        v6 = v20 = 0xa9f746462d870fdf8a65dc1f90e061e5 * v6 >> 128;\n    }\n    if (v0 & 0x4000) {\n        v6 = v21 = 0x70d869a156d2a1b890bb3df62baf32f7 * v6 >> 128;\n    }\n    if (v0 & 0x8000) {\n        v6 = v22 = 0x31be135f97d08fd981231505542fcfa6 * v6 >> 128;\n    }\n    if (v0 & 0x10000) {\n        v6 = v23 = 0x9aa508b5b7a84e1c677de54f3e99bc9 * v6 >> 128;\n    }\n    if (v0 & 0x20000) {\n        v6 = v24 = 0x5d6af8dedb81196699c329225ee604 * v6 >> 128;\n    }\n    if (v0 & 0x40000) {\n        v6 = v25 = 0x2216e584f5fa1ea926041bedfe98 * v6 >> 128;\n    }\n    if (v0 & 0x80000) {\n        v6 = v26 = 0x48a170391f7dc42444e8fa2 * v6 >> 128;\n    }\n    if (varg0 > 0) {\n        assert(v6);\n        v6 = v27 = ~0 / v6;\n    }\n    if (!(v6 % 0x100000000)) {\n        v28 = v29 = 0;\n    } else {\n        v28 = v30 = 1;\n    }\n    return (v6 >> 32) + uint8(v28);\n}\n\nfunction observations(uint256 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 < uint16.max);\n    return uint32(STORAGE[varg0 + 8]), int56(STORAGE[varg0 + 8] >> 32), address(STORAGE[varg0 + 8] >> 88), bool(uint8(STORAGE[varg0 + 8] >> 248));\n}\n\nfunction 0x32d9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = varg1 * varg2;\n    v1 = varg2 * varg1 % ~0 - v0 - (varg2 * varg1 % ~0 < v0);\n    if (v1) {\n        require(varg0 > v1);\n        v2 = varg2 * varg1 % varg0;\n        v3 = varg0 & 0 - varg0;\n        v4 = varg0 / v3;\n        v5 = (2 - v4 * ((2 - v4 * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3))) * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3)))) * ((2 - v4 * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3))) * ((2 - v4 * (0x2 ^ v4 * 3)) * (0x2 ^ v4 * 3)));\n        return ((v0 - v2) / v3 | (v1 - (v2 > v0)) * (1 + (0 - v3) / v3)) * ((2 - v4 * ((2 - v4 * ((2 - v4 * v5) * v5)) * ((2 - v4 * v5) * v5))) * ((2 - v4 * ((2 - v4 * v5) * v5)) * ((2 - v4 * v5) * v5)));\n    } else {\n        require(varg0 > 0);\n        return v0 / varg0;\n    }\n}\n\nfunction increaseObservationCardinalityNext(uint16 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    v0 = 0x3eb5(varg0, uint16(_slot0 >> 216), 8);\n    _slot0 = _slot0 & ~0xffff000000000000000000000000000000000000000000000000000000 | uint16(v0) << 216;\n    if (uint16(_slot0 >> 216) != uint16(v0)) {\n        emit IncreaseObservationCardinalityNext(uint16(_slot0 >> 216), uint16(v0));\n    }\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction 0x3389(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    if (uint32(varg4)) {\n        v0 = varg5 - varg4;\n        v1, v2 = 0x48d2(varg0, varg1, varg2, varg3, v0, varg5, varg6);\n        if (uint32(v0) != uint32(v2.word0)) {\n            if (uint32(v1.word0) != uint32(v0)) {\n                assert(uint32(v1.word0 - v2.word0));\n                assert(uint32(v1.word0 - v2.word0));\n                return v2.word2 + address(v1.word2 - v2.word2) * uint32(v0 - v2.word0) / uint32(v1.word0 - v2.word0), v2.word1 + int56(v1.word1 - v2.word1) / uint32(v1.word0 - v2.word0) * uint32(v0 - v2.word0);\n            } else {\n                return v1.word2, v1.word1;\n            }\n        } else {\n            return v2.word2, v2.word1;\n        }\n    } else {\n        assert(uint16(varg2) < uint16.max);\n        v3 = new struct(4);\n        v4 = STORAGE[varg6 + uint16(varg2)];\n        v3.word0 = uint32(v4);\n        v3.word1 = int56(v4 >> 32);\n        v3.word2 = address(v4 >> 88);\n        v3.word3 = bool(uint8(v4 >> 248));\n        if (uint32(varg5) != uint32(v4)) {\n            v3 = v5 = 0x4822(varg1, varg3, varg5, v3);\n        }\n        return MEM[64 + v3], MEM[32 + v3];\n    }\n}\n\nfunction slot0() public payable { \n    return address(_slot0), int24(_slot0 >> 160), uint16(_slot0 >> 184), uint16(_slot0 >> 200), uint16(_slot0 >> 216), uint8(_slot0 >> 232), bool(uint8(_slot0 >> 240));\n}\n\nfunction _SafeAdd(uint256 varg0, uint256 varg1) private { \n    if (int128(varg0) >= 0) {\n        require(uint128(varg1 + varg0) >= uint128(varg1), Error(19521));\n        return varg1 + varg0;\n    } else {\n        require(uint128(varg1 - (0 - varg0)) < uint128(varg1), Error(19539));\n        return varg1 - (0 - varg0);\n    }\n}\n\nfunction 0x36a5(uint256 varg0) private { \n    v0 = v1 = address(varg0) >= 0x1000276a3;\n    if (address(varg0) >= 0x1000276a3) {\n        v0 = v2 = address(varg0) < 0xfffd8963efd1fc6a506488495d951d5263988d26;\n    }\n    require(v0, Error(82));\n    v3 = ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7) > uint64.max) << 6;\n    v4 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> ((varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7) >> v3;\n    v5 = (v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) >> ((v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) > 15) << 2;\n    v6 = v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) >> ((v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) >> v5;\n    v7 = v5 | ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4 | ((v4 > uint32.max) << 5 | (v3 | (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000 > uint128.max) << 7)) | (v4 >> ((v4 > uint32.max) << 5) >> ((v4 >> ((v4 > uint32.max) << 5) > uint16.max) << 4) > uint8.max) << 3) | (v6 > 3) << 1 | (v6 >> ((v6 > 3) << 1) > 1);\n    if (v7 < 128) {\n        v8 = v9 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) << int8.max - v7;\n    } else {\n        v8 = v10 = (varg0 << 32 & 0xffffffffffffffffffffffffffffffffffffffff00000000) >> v7 - int8.max;\n    }\n    v11 = (v8 * v8 >> int8.max >> (v8 * v8 >> uint8.max)) * (v8 * v8 >> int8.max >> (v8 * v8 >> uint8.max));\n    v12 = ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> int8.max >> ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> uint8.max)) * ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> int8.max >> ((v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> uint8.max));\n    v13 = ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> int8.max >> ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> uint8.max)) * ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> int8.max >> ((v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> uint8.max));\n    v14 = ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> int8.max >> ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> uint8.max)) * ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> int8.max >> ((v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> uint8.max));\n    v15 = ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> int8.max >> ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> uint8.max)) * ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> int8.max >> ((v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> uint8.max));\n    v16 = ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> int8.max >> ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> uint8.max)) * ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> int8.max >> ((v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> uint8.max));\n    v17 = ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> int8.max >> ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> uint8.max)) * ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> int8.max >> ((v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> uint8.max));\n    v18 = (0x4000000000000 & v17 >> 205 | (0x8000000000000 & (v16 >> int8.max >> (v16 >> uint8.max)) * (v16 >> int8.max >> (v16 >> uint8.max)) >> 204 | (0x10000000000000 & v16 >> 203 | (0x20000000000000 & (v15 >> int8.max >> (v15 >> uint8.max)) * (v15 >> int8.max >> (v15 >> uint8.max)) >> 202 | (0x40000000000000 & v15 >> 201 | (0x80000000000000 & (v14 >> int8.max >> (v14 >> uint8.max)) * (v14 >> int8.max >> (v14 >> uint8.max)) >> 200 | (0x100000000000000 & v14 >> 199 | (0x200000000000000 & (v13 >> int8.max >> (v13 >> uint8.max)) * (v13 >> int8.max >> (v13 >> uint8.max)) >> 198 | (0x400000000000000 & v13 >> 197 | (0x800000000000000 & (v12 >> int8.max >> (v12 >> uint8.max)) * (v12 >> int8.max >> (v12 >> uint8.max)) >> 196 | (0x1000000000000000 & v12 >> 195 | (0x2000000000000000 & (v11 >> int8.max >> (v11 >> uint8.max)) * (v11 >> int8.max >> (v11 >> uint8.max)) >> 194 | (0x4000000000000000 & v11 >> 193 | (0x8000000000000000 & v8 * v8 >> 192 | v7 + ~int8.max << 64)))))))))))))) * 0x3627a301d71055774c85;\n    v19 = v20 = v18 + ~0x28f6481ab7f045a5af012a19d003aa9 >> 128;\n    v19 = v21 = v18 + 0xdb2df09e81959a81455e260799a0632f >> 128;\n    if (int24(v20) != int24(v21)) {\n        v22 = 0x2d6d(v21);\n        if (address(v22) > address(varg0)) {\n        }\n        // Unknown jump to Block 0x39c4. Refer to 3-address code (TAC);\n    }\n    return v19;\n}\n\nfunction 0x39d1(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    assert(uint16(varg5) < uint16.max);\n    v0 = new struct(4);\n    v1 = STORAGE[varg6 + uint16(varg5)];\n    v0.word0 = uint32(v1);\n    v0.word1 = int56(v1 >> 32);\n    v0.word2 = address(v1 >> 88);\n    v0.word3 = bool(uint8(v1 >> 248));\n    if (uint32(varg4) != uint32(v1)) {\n        v2 = v3 = uint16(varg0) > uint16(varg1);\n        if (v3) {\n            v2 = v4 = uint16(varg5) == uint16(varg1 - 1);\n        }\n        if (v2) {\n        }\n        assert(uint16(varg0));\n        v5 = uint16(1 + varg5) % uint16(varg0);\n        v6 = 0x4822(varg2, varg3, varg4, v0);\n        assert(uint16(v5) < uint16.max);\n        STORAGE[varg6 + uint16(v5)] = uint248(((bytes28(STORAGE[varg6 + uint16(v5)]) | uint32(v6.word0)) & ~0xffffffffffffff00000000 | uint56(int56(v6.word1)) << 32) & 0xff0000000000000000000000000000000000000000ffffffffffffffffffffff | address(v6.word2) << 88) | bool(v6.word3) << 248;\n        return varg0, v5;\n    } else {\n        return varg1, varg5;\n    }\n}\n\nfunction mint(address varg0, int24 varg1, int24 varg2, uint128 varg3, bytes varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    require(varg4 <= 0x100000000);\n    require(varg4.data <= 4 + (msg.data.length - 4));\n    require(!((varg4.length > 0x100000000) | (varg4.data + varg4.length > 4 + (msg.data.length - 4))));\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(varg3);\n    v0 = new struct(4);\n    v0.word0 = varg0;\n    v0.word1 = varg1;\n    v0.word2 = varg2;\n    require(varg3 == int128(uint128(uint128(varg3))));\n    v0.word3 = int128(uint128(uint128(varg3)));\n    v1, v2, v3 = 0x3f69(v0);\n    v4 = v5 = 0;\n    if (v2 > 0) {\n        v4 = v6 = 0x3cd4();\n    }\n    if (v1) {\n        v4 = v7 = 0x3e1d();\n    }\n    v8 = new bytes[](varg4.length);\n    CALLDATACOPY(v8.data, varg4.data, varg4.length);\n    v8[varg4.length] = 0;\n    require(bool((address(msg.sender)).code.size));\n    v9 = msg.sender.uniswapV3MintCallback(v2, v1, v8).gas(msg.gas);\n    require(bool(v9), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    if (v2 > 0) {\n        v10 = 0x3cd4();\n        require(v4 + v2 >= v4);\n        require(v4 + v2 <= v10, Error(19760));\n    }\n    if (v1) {\n        v11 = 0x3e1d();\n        require(v4 + v1 >= v4);\n        require(v4 + v1 <= v11, Error(19761));\n    }\n    emit Mint(varg0, varg1, varg2, msg.sender, varg3, v2, v1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return v2, v1;\n}\n\nfunction 0x3b86(uint256 varg0, address varg1, address varg2) private { \n    MEM[64] = MEM[64] + 100;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5 = v6, /* uint256 */ v7, /* uint256 */ v8 = varg2.transfer(varg1, varg0).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v9 = v10 = 96;\n    } else {\n        v9 = v11 = new bytes[](RETURNDATASIZE());\n        v7 = v11.data;\n        RETURNDATACOPY(v7, 0, RETURNDATASIZE());\n    }\n    if (v6) {\n        v5 = v12 = !MEM[v9];\n        if (MEM[v9]) {\n            require(MEM[v9] >= 32);\n            v5 = v13 = MEM[v8];\n        }\n    }\n    require(v5, Error(21574));\n    return ;\n}\n\nfunction 0x3cd4() private { \n    MEM[64] = MEM[64] + 68;\n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    while (v4 >= 32) {\n        MEM[v2] = MEM[v0];\n        v4 = v4 + ~31;\n        v2 += 32;\n        v0 += 32;\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v4) - 1) | MEM[v2] & 256 ** (32 - v4) - 1;\n    v5, /* uint256 */ v6, /* uint256 */ v7 = address(0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0).balanceOf(this).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v8 = v9 = 96;\n    } else {\n        v8 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v8.data, 0, RETURNDATASIZE());\n    }\n    if (v5) {\n        v5 = v10 = MEM[v8] >= 32;\n    }\n    require(v5);\n    require(MEM[v8] >= 32);\n    return MEM[32 + v8];\n}\n\nfunction 0x3e1d() private { \n    v0 = v1 = MEM[64] + 32;\n    v2 = v3 = MEM[64];\n    if (v4 >= 32) {\n        v5 = v6 = 4;\n        v2 = v7 = 32 + v3;\n        v0 = v8 = 32 + v1;\n        while (v5 >= 32) {\n            MEM[v2] = MEM[v0];\n            v5 = v5 + ~31;\n            v2 += 32;\n            v0 += 32;\n        }\n    }\n    MEM[v2] = MEM[v0] & ~(256 ** (32 - v5) - 1) | MEM[v2] & 256 ** (32 - v5) - 1;\n    v9, /* uint256 */ v10, /* uint256 */ v11 = address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2).staticcall(this).gas(msg.gas);\n    if (RETURNDATASIZE() == 0) {\n        v12 = v13 = 96;\n    } else {\n        v12 = new bytes[](RETURNDATASIZE());\n        RETURNDATACOPY(v12.data, 0, RETURNDATASIZE());\n    }\n    if (v9) {\n        v9 = v14 = MEM[v12] >= 32;\n    }\n    require(v9);\n    require(MEM[v12] >= 32);\n    return MEM[32 + v12];\n}\n\nfunction 0x3eb5(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    require(uint16(varg1) > 0, Error(73));\n    if (uint16(varg0) > uint16(varg1)) {\n        while (uint16(varg1) < uint16(varg0)) {\n            assert(uint16(varg1) < uint16.max);\n            STORAGE[uint16(varg1) + varg2] = uint32(1) | bytes28(STORAGE[uint16(varg1) + varg2]);\n            varg1 += 1;\n        }\n        return varg0;\n    } else {\n        return varg1;\n    }\n}\n\nfunction 0x3f69(struct(4) varg0) private { \n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    0x43a1(varg0.word2, varg0.word1);\n    MEM[MEM[64] + 160] = uint8(_slot0 >> 232);\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    v0 = 0x4acf(int24(_slot0 >> 160), varg0.word3, varg0.word2, varg0.word1, varg0.word0);\n    if (0 == int128(varg0.word3)) {\n        return 0, 0, v0;\n    } else if (int24(_slot0 >> 160) >= int24(varg0.word1)) {\n        if (int24(_slot0 >> 160) >= int24(varg0.word2)) {\n            v1 = 0x2d6d(varg0.word1);\n            v2 = 0x2d6d(varg0.word2);\n            v3 = 0x4cc8(varg0.word3, v2, v1);\n            return v3, 0, v0;\n        } else {\n            v4, v5 = 0x39d1(uint16(_slot0 >> 216), uint16(_slot0 >> 200), _liquidity, int24(_slot0 >> 160), block.timestamp, uint16(_slot0 >> 184), 8);\n            _slot0 = uint16(v5) << 184 | ~0xffff0000000000000000000000000000000000000000000000 & (uint16(v4) << 200 | ~0xffff00000000000000000000000000000000000000000000000000 & _slot0);\n            v6 = 0x2d6d(varg0.word2);\n            v7 = 0x4c84(varg0.word3, v6, address(_slot0));\n            v8 = 0x2d6d(varg0.word1);\n            v9 = 0x4cc8(varg0.word3, address(_slot0), v8);\n            v10 = _SafeAdd(varg0.word3, _liquidity);\n            _liquidity = v10;\n            return v9, v7, v0;\n        }\n    } else {\n        v11 = 0x2d6d(varg0.word1);\n        v12 = 0x2d6d(varg0.word2);\n        v13 = 0x4c84(varg0.word3, v12, v11);\n        return 0, v13, v0;\n    }\n}\n\nfunction 0x41a9(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    v0 = 0x32d9(varg0, varg1, varg2);\n    assert(varg0);\n    if (varg2 * varg1 % varg0 <= 0) {\n        return v0;\n    } else {\n        require(v0 < ~0);\n        return 1 + v0;\n    }\n}\n\nfunction 0x43a1(int24 varg0, int24 varg1) private { \n    require(varg1 < varg0, Error(0x544c55));\n    require(varg1 >= ~0xd89e7, Error(0x544c4d));\n    require(varg0 <= 0xd89e8, Error(0x54554d));\n    return ;\n}\n\nfunction 0x44c8(uint256 varg0) private { \n    v0 = v1 = 0;\n    require(varg0 > v1);\n    if (varg0 >= 0x100000000000000000000000000000000) {\n        varg0 = v2 = varg0 >> 128;\n        v0 = v3 = 128;\n    }\n    if (varg0 >= 0x10000000000000000) {\n        varg0 = v4 = varg0 >> 64;\n        v0 = v5 = 64 + v0;\n    }\n    if (varg0 >= 0x100000000) {\n        varg0 = v6 = varg0 >> 32;\n        v0 = v7 = 32 + v0;\n    }\n    if (varg0 >= 0x10000) {\n        varg0 = v8 = varg0 >> 16;\n        v0 = v9 = 16 + v0;\n    }\n    if (varg0 >= 256) {\n        varg0 = v10 = varg0 >> 8;\n        v0 = v11 = 8 + v0;\n    }\n    if (varg0 >= 16) {\n        varg0 = v12 = varg0 >> 4;\n        v0 = v13 = 4 + v0;\n    }\n    if (varg0 >= 4) {\n        varg0 = v14 = varg0 >> 2;\n        v0 = v15 = 2 + v0;\n    }\n    if (varg0 < 2) {\n        return v0;\n    } else {\n        return 1 + v0;\n    }\n}\n\nfunction feeGrowthGlobal1X128() public payable { \n    return _feeGrowthGlobal1X128;\n}\n\nfunction 0x4568(uint256 varg0) private { \n    require(varg0 > 0);\n    v0 = v1 = uint8.max;\n    if (!uint128(varg0)) {\n        varg0 = v2 = varg0 >> 128;\n    } else {\n        v0 = v3 = int8.max;\n    }\n    if (!uint64(varg0)) {\n        varg0 = v4 = varg0 >> 64;\n    } else {\n        v0 = v5 = ~63 + v0;\n    }\n    if (!uint32(varg0)) {\n        varg0 = v6 = varg0 >> 32;\n    } else {\n        v0 = v7 = ~31 + v0;\n    }\n    if (!uint16(varg0)) {\n        varg0 = v8 = varg0 >> 16;\n    } else {\n        v0 = v9 = ~15 + v0;\n    }\n    if (!uint8(varg0)) {\n        varg0 = v10 = varg0 >> 8;\n    } else {\n        v0 = v11 = ~7 + v0;\n    }\n    if (!bool(varg0)) {\n        varg0 = v12 = varg0 >> 4;\n    } else {\n        v0 = v13 = ~3 + v0;\n    }\n    if (!(varg0 & 0x3)) {\n        varg0 = v14 = varg0 >> 2;\n    } else {\n        v0 = v15 = ~1 + v0;\n    }\n    if (!(varg0 & 0x1)) {\n        return v0;\n    } else {\n        return ~0 + v0;\n    }\n}\n\nfunction 0x4652(uint256 varg0, uint128 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg0) {\n        v0 = v1 = 0x41a9(0x1000000000000000000000000, address(varg3 - varg3), varg1);\n    } else {\n        v0 = v2 = 0x32d9(0x1000000000000000000000000, address(varg3 - varg3), varg1);\n    }\n    return v0;\n}\n\nfunction 0x46cd(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    v0 = address(varg3 - varg3);\n    require(address(varg3));\n    if (varg0) {\n        v1 = 0x41a9(address(varg3), v0, varg1 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000);\n        return bool(v1 % address(varg3)) + v1 / address(varg3);\n    } else {\n        v2 = 0x32d9(address(varg3), v0, varg1 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000);\n        assert(address(varg3));\n        return v2 / address(varg3);\n    }\n}\n\nfunction flash(address varg0, uint256 varg1, uint256 varg2, bytes varg3) public payable { \n    require(msg.data.length - 4 >= 128);\n    require(varg3 <= 0x100000000);\n    require(varg3.data <= 4 + (msg.data.length - 4));\n    require(!((varg3.length > 0x100000000) | (varg3.data + varg3.length > 4 + (msg.data.length - 4))));\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    require(_liquidity, Error(76));\n    v0 = 0x41a9(0xf4240, uint24(3000), varg1);\n    v1 = 0x41a9(0xf4240, uint24(3000), varg2);\n    v2 = 0x3cd4();\n    v3 = 0x3e1d();\n    if (varg1) {\n        0x3b86(varg1, varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (varg2) {\n        0x3b86(varg2, varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    v4 = new bytes[](varg3.length);\n    CALLDATACOPY(v4.data, varg3.data, varg3.length);\n    v4[varg3.length] = 0;\n    require(bool((address(msg.sender)).code.size));\n    v5 = msg.sender.uniswapV3FlashCallback(v0, v1, v4).gas(msg.gas);\n    require(bool(v5), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    v6 = 0x3cd4();\n    v7 = 0x3e1d();\n    require(v2 + v0 >= v2);\n    require(v2 + v0 <= v6, Error(17968));\n    require(v3 + v1 >= v3);\n    require(v3 + v1 <= v7, Error(17969));\n    if (v6 - v2) {\n        if (!bool(_slot0 >> 232)) {\n            v8 = v9 = 0;\n        } else {\n            assert(uint8(bool(_slot0 >> 232)));\n            v8 = v10 = (v6 - v2) / uint8(bool(_slot0 >> 232));\n        }\n        if (uint128(v8)) {\n            _protocolFees += v8;\n        }\n        v11 = 0x32d9(_liquidity, 0x100000000000000000000000000000000, v6 - v2 - v8);\n        _feeGrowthGlobal0X128 += v11;\n    }\n    if (v7 - v3) {\n        if (!bool(_slot0 >> 232 >> 4)) {\n            v12 = v13 = 0;\n        } else {\n            assert(uint8(bool(_slot0 >> 232 >> 4)));\n            v12 = v14 = (v7 - v3) / uint8(bool(_slot0 >> 232 >> 4));\n        }\n        if (uint128(v12)) {\n            stor_3_16_31 += v12;\n        }\n        v15 = 0x32d9(_liquidity, 0x100000000000000000000000000000000, v7 - v3 - v12);\n        _feeGrowthGlobal1X128 += v15;\n    }\n    emit Flash(msg.sender, varg0, varg1, varg2, v6 - v2, v7 - v3);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction 0x4822(uint256 varg0, int24 varg1, uint256 varg2, struct(4) varg3) private { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 0;\n    v0 = new struct(4);\n    v0.word0 = uint32(varg2);\n    v0.word1 = int56(varg3.word1 + int24(varg1) * uint32(varg2 - varg3.word0));\n    if (uint128(varg0) <= 0) {\n        varg0 = v1 = 1;\n    }\n    assert(uint128(varg0));\n    v0.word2 = address(varg3.word2 + (varg2 - varg3.word0 << 128 & 0xffffffff00000000000000000000000000000000) / uint128(varg0));\n    v0.word3 = bool(1);\n    return v0;\n}\n\nfunction 0x48d2(uint16 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4, uint256 varg5, uint256 varg6) private { \n    MEM[MEM[64]] = 0;\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 0;\n    v0 = new struct(4);\n    v0.word0 = 0;\n    v0.word1 = 0;\n    v0.word2 = 0;\n    v0.word3 = 0;\n    assert(uint16(varg2) < uint16.max);\n    v1 = new struct(4);\n    v2 = STORAGE[varg6 + uint16(varg2)];\n    v1.word0 = uint32(v2);\n    v1.word1 = int56(v2 >> 32);\n    v1.word2 = address(v2 >> 88);\n    v1.word3 = bool(uint8(v2 >> 248));\n    v3 = 0x4ed8(varg4, uint32(v2), varg5);\n    if (!v3) {\n        assert(varg0);\n        assert(uint16(uint16(1 + varg2) % uint16(varg0)) < uint16.max);\n        v4 = v5 = MEM[64];\n        MEM[64] = v5 + 128;\n        v6 = STORAGE[uint16(uint16(1 + varg2) % uint16(varg0)) + varg6];\n        MEM[v5] = uint32(v6);\n        MEM[v5 + 32] = int56(v6 >> 32);\n        MEM[v5 + 64] = address(v6 >> 88);\n        MEM[v5 + 96] = bool(uint8(v6 >> 248));\n        if (!bool(uint8(v6 >> 248))) {\n            v4 = v7 = MEM[64];\n            MEM[64] = v7 + 128;\n            MEM[v7] = uint32(STORAGE[varg6]);\n            MEM[v7 + 32] = int56(STORAGE[varg6] >> 32);\n            MEM[v7 + 64] = address(STORAGE[varg6] >> 88);\n            MEM[v7 + 96] = bool(uint8(STORAGE[varg6] >> 248));\n        }\n        v8 = 0x4ed8(varg4, MEM[0 + v4], varg5);\n        require(v8, Error(0x4f4c44));\n        MEM[64] = MEM[64] + 128;\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64] + 32] = 0;\n        MEM[MEM[64] + 64] = 0;\n        MEM[MEM[64] + 96] = 0;\n        MEM[64] = MEM[64] + 128;\n        MEM[MEM[64]] = 0;\n        MEM[MEM[64] + 32] = 0;\n        MEM[MEM[64] + 64] = 0;\n        MEM[MEM[64] + 96] = 0;\n        assert(varg0);\n        v9 = v10 = uint16(uint16(1 + varg2) % uint16(varg0));\n        v11 = v12 = v10 + varg0 - 1;\n        while (!varg0) {\n            assert((v9 + v11 >> 1) % varg0 < uint16.max);\n            v13 = new struct(4);\n            v14 = STORAGE[(v9 + v11 >> 1) % varg0 + varg6];\n            v13.word0 = uint32(v14);\n            v13.word1 = int56(v14 >> 32);\n            v13.word2 = address(v14 >> 88);\n            v13.word3 = bool(uint8(v14 >> 248));\n            if (bool(uint8(v14 >> 248))) {\n                assert(varg0);\n                assert((1 + (v9 + v11 >> 1)) % varg0 < uint16.max);\n                v15 = new struct(4);\n                v16 = STORAGE[(1 + (v9 + v11 >> 1)) % varg0 + varg6];\n                v15.word0 = uint32(v16);\n                v15.word1 = int56(v16 >> 32);\n                v15.word2 = address(v16 >> 88);\n                v15.word3 = bool(uint8(v16 >> 248));\n                v17 = v18 = 0x4ed8(varg4, v13.word0, varg5);\n                if (v18) {\n                    v17 = 0x4ed8(v15.word0, varg4, varg5);\n                }\n                if (!v17) {\n                    if (v18) {\n                        v9 = 1 + (v9 + v11 >> 1);\n                    } else {\n                        v11 = (v9 + v11 >> 1) - 1;\n                    }\n                } else {\n                    return v15, v13;\n                }\n            } else {\n                v9 = 1 + (v9 + v11 >> 1);\n            }\n        }\n        throw();\n    } else if (uint32(v1.word0) != uint32(varg4)) {\n        v19 = 0x4822(varg1, varg3, varg4, v1);\n        return v19, v1;\n    } else {\n        return v0, v1;\n    }\n}\n\nfunction 0x4acf(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) private { \n    MEM[64] = MEM[64] + 58;\n    v0 = keccak256(bytes20(varg4 << 96), int24(varg3), int24(varg2));\n    v1 = v2 = 0;\n    if (int128(varg1)) {\n        v3, v4 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, block.timestamp, 8);\n        v1 = v5 = 0x513b(0x23746e6a58dcb13d4af821b93f062, 0, block.timestamp, v4, v3, _feeGrowthGlobal1X128, _feeGrowthGlobal0X128, varg1, varg0, varg3, 5);\n        v1 = v6 = 0x513b(0x23746e6a58dcb13d4af821b93f062, 1, block.timestamp, v4, v3, _feeGrowthGlobal1X128, _feeGrowthGlobal0X128, varg1, varg0, varg2, 5);\n        if (v5) {\n            0x5325(60, varg3, 6);\n        }\n        if (v6) {\n            0x5325(60, varg2, 6);\n        }\n    }\n    v7 = int24(varg3);\n    v8 = int24(varg2);\n    if (int24(varg0) < int24(varg3)) {\n        v9 = v10 = _feeGrowthGlobal0X128 - _ticks[v7].field1;\n        v11 = v12 = _feeGrowthGlobal1X128 - _ticks[v7].field2;\n    } else {\n        v9 = v13 = _ticks[v7].field1;\n        v11 = v14 = _ticks[v7].field2;\n    }\n    if (int24(varg0) >= int24(varg2)) {\n        v15 = v16 = _feeGrowthGlobal0X128 - _ticks[v8].field1;\n        v17 = v18 = _feeGrowthGlobal1X128 - _ticks[v8].field2;\n    } else {\n        v15 = v19 = _ticks[v8].field1;\n        v17 = v20 = _ticks[v8].field2;\n    }\n    MEM[MEM[64] + 96] = uint128(_positions[v0].field3);\n    MEM[MEM[64] + 128] = uint128(_positions[v0].field3 >> 128);\n    if (int128(varg1)) {\n        v21 = v22 = _SafeAdd(varg1, uint128(_positions[v0].field0));\n    } else {\n        require(uint128(_positions[v0].field0), Error(20048));\n    }\n    v23 = 0x32d9(0x100000000000000000000000000000000, uint128(_positions[v0].field0), _feeGrowthGlobal0X128 - v9 - v15 - _positions[v0].field1);\n    v24 = 0x32d9(0x100000000000000000000000000000000, uint128(_positions[v0].field0), _feeGrowthGlobal1X128 - v11 - v17 - _positions[v0].field2);\n    if (0 != int128(varg1)) {\n        _positions[v0].field0 = uint128(v21) | bytes16(_positions[v0].field0);\n    }\n    _positions[v0].field1 = _feeGrowthGlobal0X128 - v9 - v15;\n    _positions[v0].field2 = _feeGrowthGlobal1X128 - v11 - v17;\n    v25 = v26 = bool(uint128(v23));\n    if (!v26) {\n        v25 = uint128(v24) > 0;\n    }\n    if (v25) {\n        _positions[v0].field3 = uint128(v24 + uint128((uint128(v23 + uint128(_positions[v0].field3)) | bytes16(_positions[v0].field3)) >> 128)) << 128 | uint128(uint128(v23 + uint128(_positions[v0].field3)) | bytes16(_positions[v0].field3));\n    }\n    if (int128(varg1) >= 0) {\n        return keccak256(v0, 7);\n    } else {\n        if (v1) {\n            v27 = int24(varg3);\n            _ticks[v27].field0 = 0;\n            _ticks[v27].field1 = 0;\n            _ticks[v27].field2 = 0;\n            _ticks[v27].field3 = 0;\n        }\n        if (!v1) {\n            return keccak256(v0, 7);\n        } else {\n            v28 = int24(varg2);\n            _ticks[v28].field0 = 0;\n            _ticks[v28].field1 = 0;\n            _ticks[v28].field2 = 0;\n            _ticks[v28].field3 = 0;\n            return keccak256(v0, 7);\n        }\n    }\n}\n\nfunction 0x4c84(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (int128(varg0) < 0) {\n        v0 = 0x46cd(0, 0 - varg0, varg1, varg2);\n        require(v0 < int256.min);\n        return 0 - v0;\n    } else {\n        v1 = 0x46cd(1, varg0, varg1, varg2);\n        require(v1 < int256.min);\n        return v1;\n    }\n}\n\nfunction 0x4cc8(uint256 varg0, uint256 varg1, uint256 varg2) private { \n    if (int128(varg0) < 0) {\n        v0 = 0x4652(0, 0 - varg0, varg1, varg2);\n        require(v0 < int256.min);\n        return 0 - v0;\n    } else {\n        v1 = 0x4652(1, varg0, varg1, varg2);\n        require(v1 < int256.min);\n        return v1;\n    }\n}\n\nfunction 0x4d02(uint256 varg0, uint256 varg1, uint128 varg2, address varg3) private { \n    if (!varg0) {\n        if (varg1 <= uint160.max) {\n            v0 = bool((varg1 << 96) % uint128(varg2)) + (varg1 << 96) / varg2;\n            // Unknown jump to Block 0x4dba. Refer to 3-address code (TAC);\n        } else {\n            v0 = v1 = 0x41a9(varg2, 0x1000000000000000000000000, varg1);\n        }\n        require(varg3 > v0);\n        return varg3 - v0;\n    } else {\n        if (varg1 <= uint160.max) {\n            assert(varg2);\n            v2 = v3 = (varg1 << 96) / varg2;\n        } else {\n            v2 = v4 = 0x32d9(varg2, 0x1000000000000000000000000, varg1);\n        }\n        require(varg3 + v2 >= varg3);\n        require(varg3 + v2 == address(varg3 + v2));\n        return varg3 + v2;\n    }\n}\n\nfunction 0x4de3(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { \n    if (varg1) {\n        v0 = varg2 << 96 & 0xffffffffffffffffffffffffffffffff000000000000000000000000;\n        if (!varg0) {\n            v1 = address(varg3) * varg1;\n            assert(varg1);\n            v2 = v3 = v1 / varg1 == address(varg3);\n            if (v3) {\n                v2 = v4 = v0 > v1;\n            }\n            require(v2);\n            v5 = v6 = 0x41a9(v0 - v1, address(varg3), v0);\n            require(v6 == address(v6));\n            // Unknown jump to Block 0x4e56. Refer to 3-address code (TAC);\n        } else {\n            assert(varg1);\n            if (address(varg3) * varg1 / varg1 == address(varg3)) {\n                if (address(varg3) * varg1 + v0 >= v0) {\n                    v5 = v7 = 0x41a9(address(varg3) * varg1 + v0, address(varg3), v0);\n                }\n            }\n            assert(address(varg3));\n            require(v0 / address(varg3) + varg1 >= v0 / address(varg3));\n            return bool(v0 % (v0 / address(varg3) + varg1)) + v0 / (v0 / address(varg3) + varg1);\n        }\n        return v5;\n    } else {\n        return varg3;\n    }\n}\n\nfunction 0x4ed8(uint32 varg0, uint32 varg1, uint32 varg2) private { \n    v0 = v1 = varg1 <= varg2;\n    if (!bool(uint32(varg1) > uint32(varg2))) {\n        v0 = v2 = varg0 <= varg2;\n    }\n    if (!v0) {\n        if (varg1 > varg2) {\n            v3 = v4 = varg1;\n        } else {\n            v3 = v5 = 0x100000000 + varg1;\n        }\n        if (varg0 > varg2) {\n            v6 = v7 = varg0;\n        } else {\n            v6 = v8 = 0x100000000 + varg0;\n        }\n        return uint40(v3) <= uint40(v6);\n    } else {\n        return varg1 <= varg0;\n    }\n}\n\nfunction collect(address varg0, int24 varg1, int24 varg2, uint128 varg3, uint128 varg4) public payable { \n    require(msg.data.length - 4 >= 160);\n    v0 = v1 = varg3;\n    v2 = v3 = varg4;\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    MEM[64] = MEM[64] + 58;\n    v4 = keccak256(bytes20(msg.sender << 96), varg1, varg2);\n    if (uint128(v1) > uint128(_positions[v4].field3)) {\n        v0 = v5 = uint128(_positions[v4].field3);\n    }\n    if (uint128(v3) > uint128(_positions[v4].field3 >> 128)) {\n        v2 = v6 = uint128(_positions[v4].field3 >> 128);\n    }\n    if (uint128(v0)) {\n        _positions[v4].field3 = uint128(uint128(_positions[v4].field3) - v0) | bytes16(_positions[v4].field3);\n        0x3b86(uint128(v0), varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (uint128(v2)) {\n        _positions[v4].field3 = uint128(_positions[v4].field3) | uint128(uint128(_positions[v4].field3 >> 128) - v2) << 128;\n        0x3b86(uint128(v2), varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    emit Collect(msg.sender, varg1, varg2, varg0, uint128(v0), uint128(v2));\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return uint128(v0), uint128(v2);\n}\n\nfunction 0x513b(uint128 varg0, uint256 varg1, uint32 varg2, int56 varg3, address varg4, uint256 varg5, uint256 varg6, uint256 varg7, int24 varg8, int24 varg9, uint256 varg10) private { \n    v0 = _SafeAdd(varg7, uint128(STORAGE[v1]));\n    require(uint128(v0) <= varg0, Error(19535));\n    if (!bool(uint128(uint128(STORAGE[v1])))) {\n        if (varg9 <= varg8) {\n            STORAGE[v1 + 1] = varg6;\n            STORAGE[v1 + 2] = varg5;\n            STORAGE[v1 + 3] = varg2 << 216 | ~0xffffffff000000000000000000000000000000000000000000000000000000 & (uint56(int56(varg3)) | bytes25(address(varg4) << 56 | 0xffffffffff0000000000000000000000000000000000000000ffffffffffffff & STORAGE[v1 + 3]));\n        }\n        STORAGE[v1 + 3] = 0x100000000000000000000000000000000000000000000000000000000000000 | uint248(STORAGE[v1 + 3]);\n    }\n    STORAGE[v1] = uint128(v0) | bytes16(STORAGE[v1]);\n    if (varg1) {\n        v2 = v3 = int128(STORAGE[v1] >> 128) - int128(varg7);\n        require(int128(varg7) >= 0 == v3 <= int128(STORAGE[v1] >> 128));\n        require(v3 == int128(v3));\n        // Unknown jump to Block 0x52f4. Refer to 3-address code (TAC);\n    } else {\n        v2 = int128(varg7) + int128(STORAGE[v1] >> 128);\n        require(int128(varg7) >= 0 == v2 >= int128(STORAGE[v1] >> 128));\n        require(v2 == int128(v2));\n    }\n    STORAGE[v1] = uint128(STORAGE[v1]) | uint128(int128(v2)) << 128;\n    return !uint128(STORAGE[v1]) != !uint128(v0);\n}\n\nfunction 0x5325(int24 varg0, int24 varg1, uint256 varg2) private { \n    assert(varg0);\n    require(!int24(int24(varg1) % int24(varg0)));\n    assert(varg0);\n    STORAGE[keccak256(int16(int24(int24(varg1) / int24(varg0)) >> 8), varg2)] = STORAGE[keccak256(int16(int24(int24(varg1) / int24(varg0)) >> 8), varg2)] ^ 1 << uint8(int24(int24(varg1) / int24(varg0)) % 256);\n    return ;\n}\n\nfunction positions(bytes32 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return uint128(_positions[varg0].field0), _positions[varg0].field1, _positions[varg0].field2, uint128(_positions[varg0].field3), uint128(_positions[varg0].field3 >> 128);\n}\n\nfunction () public payable { \n    revert();\n}\n\nfunction tickBitmap(int16 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return _tickBitmap[varg0];\n}\n\nfunction maxLiquidityPerTick() public payable { \n    return uint128(0x23746e6a58dcb13d4af821b93f062);\n}\n\nfunction setFeeProtocol(uint8 varg0, uint8 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(bool((address(0x1f98431c8ad98523631ae4a59f267346ea31f984)).code.size));\n    v0, /* address */ v1 = address(0x1f98431c8ad98523631ae4a59f267346ea31f984).owner().gas(msg.gas);\n    require(bool(v0), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(msg.sender == address(v1));\n    v2 = v3 = !varg0;\n    if (varg0) {\n        v2 = v4 = varg0 >= 4;\n        if (!bool(uint8(uint8(varg0)) < 4)) {\n            v2 = v5 = varg0 <= 10;\n        }\n    }\n    if (v2) {\n        v2 = v6 = !varg1;\n        if (varg1) {\n            v2 = v7 = varg1 >= 4;\n            if (!bool(uint8(uint8(varg1)) < 4)) {\n                v2 = v8 = varg1 <= 10;\n            }\n        }\n    }\n    require(v2);\n    _slot0 = _slot0 & 0xffff00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff | uint8(uint8(varg0) + (uint8(varg1) << 4 & 0xff0)) << 232;\n    emit SetFeeProtocol(uint8(uint8(_slot0 >> 232) % 16), bool(uint8(_slot0 >> 232) >> 4), varg0, varg1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n}\n\nfunction collectProtocol(address varg0, uint128 varg1, uint128 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    v0 = v1 = varg1;\n    v2 = v3 = varg2;\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    require(bool((address(0x1f98431c8ad98523631ae4a59f267346ea31f984)).code.size));\n    v4, /* address */ v5 = address(0x1f98431c8ad98523631ae4a59f267346ea31f984).owner().gas(msg.gas);\n    require(bool(v4), 0, RETURNDATASIZE()); // checks call status, propagates error data on error\n    require(RETURNDATASIZE() >= 32);\n    require(msg.sender == address(v5));\n    if (uint128(v1) > _protocolFees) {\n        v0 = v6 = _protocolFees;\n    }\n    if (uint128(v3) > stor_3_16_31) {\n        v2 = v7 = stor_3_16_31;\n    }\n    if (uint128(v0)) {\n        if (_protocolFees == uint128(v0)) {\n            v0 = v8 = v0 + ~0;\n        }\n        _protocolFees = _protocolFees - v0;\n        0x3b86(uint128(v0), varg0, 0xad7dbbdc3631ff6d736a5ac5999598d1dad440e0);\n    }\n    if (uint128(v2)) {\n        if (stor_3_16_31 == uint128(v2)) {\n            v2 = v9 = ~0 + v2;\n        }\n        stor_3_16_31 = stor_3_16_31 - v2;\n        0x3b86(uint128(v2), varg0, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n    }\n    emit CollectProtocol(msg.sender, varg0, uint128(v0), uint128(v2));\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return uint128(v0), uint128(v2);\n}\n\nfunction observe(uint32[] varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(varg0 <= 0x100000000);\n    require(varg0.data <= 4 + (msg.data.length - 4));\n    require(!((varg0.length > 0x100000000) | (varg0.data + (varg0.length << 5) > 4 + (msg.data.length - 4))));\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    v0 = new uint256[](varg0.length);\n    CALLDATACOPY(v0.data, varg0.data, varg0.length << 5);\n    v0[varg0.length] = 0;\n    require(uint16(_slot0 >> 200) > 0, Error(73));\n    require(v0.length <= uint64.max);\n    v1 = new uint256[](v0.length);\n    if (v0.length) {\n        CALLDATACOPY(v1.data, msg.data.length, v0.length << 5);\n    }\n    require(v0.length <= uint64.max);\n    v2 = new uint256[](v0.length);\n    if (v0.length) {\n        CALLDATACOPY(v2.data, msg.data.length, v0.length << 5);\n    }\n    v3 = v4 = 0;\n    while (v3 < v0.length) {\n        assert(v3 < v0.length);\n        if (uint32(v0[v3])) {\n            v5, v6 = 0x48d2(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), block.timestamp - v0[v3], block.timestamp, 8);\n            if (uint32(block.timestamp - v0[v3]) != uint32(v6.word0)) {\n                if (uint32(v5.word0) != uint32(block.timestamp - v0[v3])) {\n                    assert(uint32(v5.word0 - v6.word0));\n                    v7 = v6.word1 + int56(v5.word1 - v6.word1) / uint32(v5.word0 - v6.word0) * uint32(block.timestamp - v0[v3] - v6.word0);\n                    assert(uint32(v5.word0 - v6.word0));\n                    v8 = v6.word2 + address(v5.word2 - v6.word2) * uint32(block.timestamp - v0[v3] - v6.word0) / uint32(v5.word0 - v6.word0);\n                } else {\n                    v7 = v9 = v5.word1;\n                    v8 = v10 = v5.word2;\n                }\n            } else {\n                v7 = v11 = v6.word1;\n                v8 = v12 = v6.word2;\n            }\n        } else {\n            assert(uint16(_slot0 >> 184) < uint16.max);\n            v13 = v14 = new struct(4);\n            v14.word0 = uint32(STORAGE[8 + uint16(uint16(_slot0 >> 184))]);\n            v14.word1 = int56(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 32);\n            v14.word2 = address(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 88);\n            v14.word3 = bool(uint8(STORAGE[8 + uint16(uint16(_slot0 >> 184))] >> 248));\n            if (uint32(block.timestamp) != uint32(STORAGE[8 + uint16(uint16(_slot0 >> 184))])) {\n                v13 = v15 = 0x4822(_liquidity, int24(_slot0 >> 160), block.timestamp, v14);\n            }\n            v7 = v16 = MEM[32 + v13];\n            v8 = v17 = MEM[64 + v13];\n        }\n        assert(v3 < v1.length);\n        assert(v3 < v2.length);\n        v2[v3] = address(v8);\n        v1[v3] = int56(v7);\n        v3 += 1;\n    }\n    v18 = new uint256[](v1.length);\n    v19 = v20 = 0;\n    while (v19 < v1.length << 5) {\n        MEM[v19 + v18.data] = MEM[v19 + v1.data];\n        v19 += 32;\n    }\n    v21 = new uint256[](v2.length);\n    v18[v1.length] = v2.length;\n    v22 = v23 = 0;\n    while (v22 < v2.length << 5) {\n        MEM[v22 + v21.data] = MEM[v22 + v2.data];\n        v22 += 32;\n    }\n    return v18, v21;\n}\n\nfunction burn(int24 varg0, int24 varg1, uint128 varg2) public payable { \n    require(msg.data.length - 4 >= 96);\n    require(uint8(_slot0 >> 240), Error(0x4c4f4b));\n    _slot0 = ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    v0 = new struct(4);\n    v0.word0 = msg.sender;\n    v0.word1 = varg0;\n    v0.word2 = varg1;\n    require(varg2 == int128(uint128(uint128(varg2))));\n    v0.word3 = int128(0 - uint128(uint128(varg2)));\n    v1, v2, v3 = 0x3f69(v0);\n    v4 = v5 = 0 - v2 > 0;\n    if (0 - v2 <= 0) {\n        v4 = v6 = 0 - v1 > 0;\n    }\n    if (v4) {\n        STORAGE[v3 + 3] = bytes16(uint128(STORAGE[v3 + 3]) | uint128(0 - v1 + uint128(STORAGE[v3 + 3] >> 128)) << 128) | uint128(0 - v2 + uint128(STORAGE[v3 + 3]));\n    }\n    emit 0xc396cd989a39f4459b5fa1aed6a9a8dcdbc45908acfd67e028cd568da98982c(msg.sender, varg0, varg1, varg2, 0 - v2, 0 - v1);\n    _slot0 = 0x1000000000000000000000000000000000000000000000000000000000000 | ~0xff000000000000000000000000000000000000000000000000000000000000 & _slot0;\n    return 0 - v2, 0 - v1;\n}\n\nfunction snapshotCumulativesInside(int24 varg0, int24 varg1) public payable { \n    require(msg.data.length - 4 >= 64);\n    require(address(0x3935eaf11b29396f3067e45d7c68c400662be8b2) == this);\n    0x43a1(varg1, varg0);\n    require(uint8(_ticks[int24(int24(int24(varg0)))].field3 >> 248));\n    require(uint8(_ticks[int24(int24(int24(varg1)))].field3 >> 248));\n    MEM[MEM[64]] = address(_slot0);\n    MEM[MEM[64] + 128] = uint16(_slot0 >> 216);\n    MEM[MEM[64] + 160] = uint8(_slot0 >> 232);\n    MEM[MEM[64] + 192] = bool(uint8(_slot0 >> 240));\n    if (int24(_slot0 >> 160) >= varg0) {\n        if (int24(_slot0 >> 160) >= varg1) {\n            v0 = v1 = int56(_ticks[int24(int24(int24(varg1)))].field3) - int56(_ticks[int24(int24(int24(varg0)))].field3);\n            v2 = v3 = address(_ticks[int24(int24(int24(varg1)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg0)))].field3 >> 56);\n            v4 = v5 = uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216);\n        } else {\n            v6, v7 = 0x3389(uint16(_slot0 >> 200), _liquidity, uint16(_slot0 >> 184), int24(_slot0 >> 160), 0, block.timestamp, 8);\n            v0 = v8 = v7 - int56(_ticks[int24(int24(int24(varg0)))].field3) - int56(_ticks[int24(int24(int24(varg1)))].field3);\n            v2 = v9 = v6 - address(_ticks[int24(int24(int24(varg0)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg1)))].field3 >> 56);\n            v4 = v10 = block.timestamp - uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216);\n        }\n    } else {\n        v0 = v11 = int56(_ticks[int24(int24(int24(varg0)))].field3) - int56(_ticks[int24(int24(int24(varg1)))].field3);\n        v2 = v12 = address(_ticks[int24(int24(int24(varg0)))].field3 >> 56) - address(_ticks[int24(int24(int24(varg1)))].field3 >> 56);\n        v4 = v13 = uint32(_ticks[int24(int24(int24(varg0)))].field3 >> 216) - uint32(_ticks[int24(int24(int24(varg1)))].field3 >> 216);\n    }\n    return int56(v0), address(v2), uint32(v4);\n}\n\nfunction factory() public payable { \n    return address(0x1f98431c8ad98523631ae4a59f267346ea31f984);\n}\n\nfunction tickSpacing() public payable { \n    return int24(60);\n}\n\nfunction token1() public payable { \n    return address(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);\n}\n\nfunction fee() public payable { \n    return uint24(3000);\n}\n\nfunction feeGrowthGlobal0X128() public payable { \n    return _feeGrowthGlobal0X128;\n}\n\nfunction ticks(int24 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    return uint128(_ticks[int24(varg0)].field0), int128(_ticks[int24(varg0)].field0 >> 128), _ticks[varg0].field1, _ticks[varg0].field2, int56(_ticks[int24(varg0)].field3), address(_ticks[int24(varg0)].field3 >> 56), uint32(_ticks[int24(varg0)].field3 >> 216), bool(uint8(_ticks[int24(varg0)].field3 >> 248));\n}\n\nfunction initialize(uint160 varg0) public payable { \n    require(msg.data.length - 4 >= 32);\n    require(!address(_slot0), Error(16713));\n    v0 = 0x36a5(address(varg0));\n    MEM[MEM[64]] = uint32(block.timestamp);\n    MEM[MEM[64] + 32] = 0;\n    MEM[MEM[64] + 64] = 0;\n    MEM[MEM[64] + 96] = 1;\n    stor_8_0_3 = block.timestamp;\n    stor_8_31_31 = 1;\n    stor_8_4_30 = 0;\n    MEM[64] = MEM[64] + 224;\n    MEM[MEM[64]] = address(varg0);\n    MEM[MEM[64] + 32] = int24(v0);\n    MEM[64 + MEM[64]] = 0;\n    MEM[MEM[64] + 96] = uint16(1);\n    MEM[MEM[64] + 128] = uint16(1);\n    MEM[MEM[64] + 160] = 0;\n    MEM[MEM[64] + 192] = 1;\n    _slot0 = 0xff0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff & (0x1000000000000000000000000000000000000000000000000000000 | ~0xffff000000000000000000000000000000000000000000000000000000 & (0x100000000000000000000000000000000000000000000000000 | 0xffffffffff00000000ffffffffffffffffffffffffffffffffffffffffffffff & (uint24(int24(int24(v0))) << 160 | ~0xffffff0000000000000000000000000000000000000000 & (address(varg0) | bytes12(_slot0))))) | 0x1000000000000000000000000000000000000000000000000000000000000;\n    emit Initialize(address(varg0), int24(v0));\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(bytes4 function_selector) public payable { \n    MEM[64] = 128;\n    require(!msg.value);\n    if (msg.data.length < 4) {\n        ();\n    } else {\n        v0 = function_selector >> 224;\n        if (0x70cf754a > v0) {\n            if (0x3850c7bd > v0) {\n                if (0x1ad8b03b > v0) {\n                    if (0xdfe1681 == v0) {\n                        token0();\n                    } else if (0x128acb08 == v0) {\n                        swap(address,bool,int256,uint160,bytes);\n                    } else {\n                        require(0x1a686502 == v0);\n                        liquidity();\n                    }\n                } else if (0x1ad8b03b == v0) {\n                    protocolFees();\n                } else if (0x252c09d7 == v0) {\n                    observations(uint256);\n                } else {\n                    require(0x32148f67 == v0);\n                    increaseObservationCardinalityNext(uint16);\n                }\n            } else if (0x490e6cbc > v0) {\n                if (0x3850c7bd == v0) {\n                    slot0();\n                } else if (0x3c8a7d8d == v0) {\n                    mint(address,int24,int24,uint128,bytes);\n                } else {\n                    require(0x46141319 == v0);\n                    feeGrowthGlobal1X128();\n                }\n            } else if (0x490e6cbc == v0) {\n                flash(address,uint256,uint256,bytes);\n            } else if (0x4f1eb3d8 == v0) {\n                collect(address,int24,int24,uint128,uint128);\n            } else if (0x514ea4bf == v0) {\n                positions(bytes32);\n            } else {\n                require(0x5339c296 == v0);\n                tickBitmap(int16);\n            }\n        } else if (0xc45a0155 > v0) {\n            if (0x883bdbfd > v0) {\n                if (0x70cf754a == v0) {\n                    maxLiquidityPerTick();\n                } else if (0x8206a4d1 == v0) {\n                    setFeeProtocol(uint8,uint8);\n                } else {\n                    require(0x85b66729 == v0);\n                    collectProtocol(address,uint128,uint128);\n                }\n            } else if (0x883bdbfd == v0) {\n                observe(uint32[]);\n            } else if (0xa34123a7 == v0) {\n                burn(int24,int24,uint128);\n            } else {\n                require(0xa38807f2 == v0);\n                snapshotCumulativesInside(int24,int24);\n            }\n        } else if (0xddca3f43 > v0) {\n            if (0xc45a0155 == v0) {\n                factory();\n            } else if (0xd0c93a7c == v0) {\n                tickSpacing();\n            } else {\n                require(0xd21220a7 == v0);\n                token1();\n            }\n        } else if (0xddca3f43 == v0) {\n            fee();\n        } else if (0xf3058399 == v0) {\n            feeGrowthGlobal0X128();\n        } else if (0xf30dba93 == v0) {\n            ticks(int24);\n        } else {\n            require(0xf637731d == v0);\n            initialize(uint160);\n        }\n    }\n}\n.",
	"status": "1",
	"time_cost": 107.11872935295105,
	"usage": {
		"completion_tokens": 1035,
		"prompt_tokens": 24879,
		"total_tokens": 25914
	}
}