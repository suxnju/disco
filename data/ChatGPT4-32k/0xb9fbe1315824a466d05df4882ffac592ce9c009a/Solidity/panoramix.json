{
	"address": "0xb9fbe1315824a466d05df4882ffac592ce9c009a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code that could correspond to the decompiled code above:\n\n```solidity\npragma solidity ^0.8.0;\n\ncontract Contract {\n    address public owner;\n    uint256 public round;\n    address payable public beneficiaryAddress;\n    mapping (address => ProposalInfo) public proposals;\n    mapping (address => uint256) public contributions;\n    mapping (uint256 => uint256) public roundContribution;\n    mapping (address => uint256) public refundable;\n    uint256 public startTime;\n    uint256 public hardCap;\n    uint256 public duration;\n\n    struct ProposalInfo {\n        address tokenAddress;\n        string projectName;\n        string websiteUrl;\n        string logoUrl;\n        string whitepaperUrl;\n        string legalDocumentUrl;\n        uint256 icoStartDate;\n        uint256 icoEndDate;\n        uint256 icoRate;\n        uint256 totalRaised;\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event RoundFinalized(uint256 _round);\n    event TokenListingCancelled(address _tokenAddress);\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function kill() public onlyOwner {\n        selfdestruct(beneficiaryAddress);\n    }\n\n    function initialize(address payable sender) public onlyOwner {\n        beneficiaryAddress = sender;\n    }\n\n    function setRefundable(address _tokenAddress, uint256 endTime) public onlyOwner {\n        refundable[_tokenAddress] = endTime;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function reset(uint256 _startTime, uint256 _duration, uint256 _hardCap) public onlyOwner {\n        require(block.timestamp >= startTime + duration);\n        if (round > 0) {\n            (bool success,) = beneficiaryAddress.call{value: address(this).balance - roundContribution[round]}(\"\");\n            require(success);\n        }\n        startTime = _startTime;\n        duration = _duration;\n        hardCap = _hardCap;\n        emit RoundFinalized(round);\n        round++;\n    }\n\n    function propose(address _tokenAddress, string memory _projectName, string memory _websiteUrl, string memory _logoUrl, string memory _whitepaperUrl, string memory _legalDocumentUrl, uint256 _icoStartDate, uint256 _icoEndDate, uint256 _icoRate, uint256 _totalRaised) public payable {\n        require(proposals[_tokenAddress].tokenAddress == address(0));\n        require(block.timestamp < startTime + duration);\n        require(msg.value >= hardCap);\n        proposals[_tokenAddress] = ProposalInfo(_tokenAddress, _projectName, _websiteUrl, _logoUrl, _whitepaperUrl, _legalDocumentUrl, _icoStartDate, _icoEndDate, _icoRate, _totalRaised);\n    }\n\n    function refund(address payable investor) public {\n        require(refundable[investor] > 0);\n        require(block.timestamp < refundable[investor]);\n        contributions[investor] = 0;\n        require(contributions[investor] <= roundContribution[round]);\n        roundContribution[round] -= contributions[investor];\n        (bool success,) = investor.call{value: contributions[investor]}(\"\");\n        require(success);\n        emit TokenListingCancelled(investor);\n    }\n\n    fallback() external payable {\n        revert();\n    }\n}\n```\nPlease note that the propose function is incomplete in the provided decompiled code which may have led to some inaccuracies in the Solidity code. Also, the type of the proposals mapping has been assumed by me based on the limited information available.",
				"role": "assistant"
			}
		}
	],
	"created": 1700471483,
	"id": "chatcmpl-8MubLLiyH5a2RSSLbaENVSOhLr9e1",
	"input_format": "DecompiledCode",
	"ir": "# Palkeoramix decompiler. \n#\n#  I failed with these: \n#  - proposals(uint256 _param1, address _param2)\n#  All the rest is below.\n#\n\ndef storage:\n  owner is address at storage 0\n  round is uint256 at storage 1\n  beneficiaryAddress is address at storage 2\n  stor3 is mapping of struct at storage 3\n  contributions is mapping of struct at storage 4\n  roundContribution is mapping of uint256 at storage 5\n  refundable is mapping of uint256 at storage 6\n  startTime is uint256 at storage 7\n  hardCap is uint256 at storage 8\n  duration is uint256 at storage 9\n\ndef duration(): # not payable\n  return duration\n\ndef round(): # not payable\n  return round\n\ndef beneficiary(): # not payable\n  return beneficiaryAddress\n\ndef getContributions(address holder): # not payable\n  return contributions[address(holder)].field_0\n\ndef roundContribution(uint256 _param1): # not payable\n  return roundContribution[_param1]\n\ndef refundable(address _param1): # not payable\n  return refundable[_param1]\n\ndef startTime(): # not payable\n  return startTime\n\ndef owner(): # not payable\n  return owner\n\ndef proposalInfos(address _param1): # not payable\n  return contributions[_param1].field_0, contributions[_param1].field_256, contributions[_param1].field_512\n\ndef hardCap(): # not payable\n  return hardCap\n\n#\n#  Regular functions\n#\n\ndef kill(): # not payable\n  require caller == owner\n  selfdestruct(beneficiaryAddress)\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef initialize(address sender): # not payable\n  require caller == owner\n  beneficiaryAddress = sender\n\ndef setRefundable(address _tokenAddress, uint256 endTime): # not payable\n  require caller == owner\n  refundable[address(_tokenAddress)] = endTime\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef reset(uint256 _startTime, uint256 _duration, uint256 _hardCap): # not payable\n  require caller == owner\n  require block.timestamp >= startTime + duration\n  if round > 0:\n      call beneficiaryAddress with:\n         value eth.balance(this.address) - roundContribution[stor1] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n  startTime = _startTime\n  duration = _duration\n  hardCap = _hardCap\n  log RoundFinalized(uint256 _round=round)\n  round++\n\ndef propose(address _tokenAddress, string _projectName, string _websiteUrl, string _logoUrl, string _whitepaperUrl, string _legalDocumentUrl, uint256 _icoStartDate, uint256 _icoEndDate, uint256 _icoRate, uint256 _totalRaised) payable: \n  require not contributions[address(_tokenAddress)].field_0\n  require block.timestamp < startTime + duration\n  require call.value >= hardCap\n  stor3[stor1][address(_tokenAddress)].field_0 = _tokenAddress\n  stor3[stor1][address(_tokenAddress)].field_256 = (2 * _projectName.length) + 1\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef refund(address investor): # not payable\n  require refundable[address(investor)] > 0\n  require block.timestamp < refundable[address(investor)]\n  contributions[address(investor)].field_0 = 0\n  require contributions[address(investor)].field_0 <= roundContribution[stor4[address(investor)].field_512]\n  roundContribution[stor4[address(investor)].field_512] -= contributions[address(investor)].field_0\n  call contributions[address(investor)].field_256 with:\n     value contributions[address(investor)].field_0 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log TokenListingCancelled(address _tokenAddress=investor)\n\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: # Palkeoramix decompiler. \n#\n#  I failed with these: \n#  - proposals(uint256 _param1, address _param2)\n#  All the rest is below.\n#\n\ndef storage:\n  owner is address at storage 0\n  round is uint256 at storage 1\n  beneficiaryAddress is address at storage 2\n  stor3 is mapping of struct at storage 3\n  contributions is mapping of struct at storage 4\n  roundContribution is mapping of uint256 at storage 5\n  refundable is mapping of uint256 at storage 6\n  startTime is uint256 at storage 7\n  hardCap is uint256 at storage 8\n  duration is uint256 at storage 9\n\ndef duration(): # not payable\n  return duration\n\ndef round(): # not payable\n  return round\n\ndef beneficiary(): # not payable\n  return beneficiaryAddress\n\ndef getContributions(address holder): # not payable\n  return contributions[address(holder)].field_0\n\ndef roundContribution(uint256 _param1): # not payable\n  return roundContribution[_param1]\n\ndef refundable(address _param1): # not payable\n  return refundable[_param1]\n\ndef startTime(): # not payable\n  return startTime\n\ndef owner(): # not payable\n  return owner\n\ndef proposalInfos(address _param1): # not payable\n  return contributions[_param1].field_0, contributions[_param1].field_256, contributions[_param1].field_512\n\ndef hardCap(): # not payable\n  return hardCap\n\n#\n#  Regular functions\n#\n\ndef kill(): # not payable\n  require caller == owner\n  selfdestruct(beneficiaryAddress)\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef initialize(address sender): # not payable\n  require caller == owner\n  beneficiaryAddress = sender\n\ndef setRefundable(address _tokenAddress, uint256 endTime): # not payable\n  require caller == owner\n  refundable[address(_tokenAddress)] = endTime\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef reset(uint256 _startTime, uint256 _duration, uint256 _hardCap): # not payable\n  require caller == owner\n  require block.timestamp >= startTime + duration\n  if round > 0:\n      call beneficiaryAddress with:\n         value eth.balance(this.address) - roundContribution[stor1] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n  startTime = _startTime\n  duration = _duration\n  hardCap = _hardCap\n  log RoundFinalized(uint256 _round=round)\n  round++\n\ndef propose(address _tokenAddress, string _projectName, string _websiteUrl, string _logoUrl, string _whitepaperUrl, string _legalDocumentUrl, uint256 _icoStartDate, uint256 _icoEndDate, uint256 _icoRate, uint256 _totalRaised) payable: \n  require not contributions[address(_tokenAddress)].field_0\n  require block.timestamp < startTime + duration\n  require call.value >= hardCap\n  stor3[stor1][address(_tokenAddress)].field_0 = _tokenAddress\n  stor3[stor1][address(_tokenAddress)].field_256 = (2 * _projectName.length) + 1\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef refund(address investor): # not payable\n  require refundable[address(investor)] > 0\n  require block.timestamp < refundable[address(investor)]\n  contributions[address(investor)].field_0 = 0\n  require contributions[address(investor)].field_0 <= roundContribution[stor4[address(investor)].field_512]\n  roundContribution[stor4[address(investor)].field_512] -= contributions[address(investor)].field_0\n  call contributions[address(investor)].field_256 with:\n     value contributions[address(investor)].field_0 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log TokenListingCancelled(address _tokenAddress=investor)\n\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: # Palkeoramix decompiler. \n#\n#  I failed with these: \n#  - proposals(uint256 _param1, address _param2)\n#  All the rest is below.\n#\n\ndef storage:\n  owner is address at storage 0\n  round is uint256 at storage 1\n  beneficiaryAddress is address at storage 2\n  stor3 is mapping of struct at storage 3\n  contributions is mapping of struct at storage 4\n  roundContribution is mapping of uint256 at storage 5\n  refundable is mapping of uint256 at storage 6\n  startTime is uint256 at storage 7\n  hardCap is uint256 at storage 8\n  duration is uint256 at storage 9\n\ndef duration(): # not payable\n  return duration\n\ndef round(): # not payable\n  return round\n\ndef beneficiary(): # not payable\n  return beneficiaryAddress\n\ndef getContributions(address holder): # not payable\n  return contributions[address(holder)].field_0\n\ndef roundContribution(uint256 _param1): # not payable\n  return roundContribution[_param1]\n\ndef refundable(address _param1): # not payable\n  return refundable[_param1]\n\ndef startTime(): # not payable\n  return startTime\n\ndef owner(): # not payable\n  return owner\n\ndef proposalInfos(address _param1): # not payable\n  return contributions[_param1].field_0, contributions[_param1].field_256, contributions[_param1].field_512\n\ndef hardCap(): # not payable\n  return hardCap\n\n#\n#  Regular functions\n#\n\ndef kill(): # not payable\n  require caller == owner\n  selfdestruct(beneficiaryAddress)\n\ndef _fallback(?) payable: # default function\n  revert\n\ndef initialize(address sender): # not payable\n  require caller == owner\n  beneficiaryAddress = sender\n\ndef setRefundable(address _tokenAddress, uint256 endTime): # not payable\n  require caller == owner\n  refundable[address(_tokenAddress)] = endTime\n\ndef transferOwnership(address newOwner): # not payable\n  require caller == owner\n  require newOwner\n  log OwnershipTransferred(\n        address previousOwner=owner,\n        address newOwner=newOwner)\n  owner = newOwner\n\ndef reset(uint256 _startTime, uint256 _duration, uint256 _hardCap): # not payable\n  require caller == owner\n  require block.timestamp >= startTime + duration\n  if round > 0:\n      call beneficiaryAddress with:\n         value eth.balance(this.address) - roundContribution[stor1] wei\n           gas 2300 * is_zero(value) wei\n      if not ext_call.success:\n          revert with ext_call.return_data[0 len return_data.size]\n  startTime = _startTime\n  duration = _duration\n  hardCap = _hardCap\n  log RoundFinalized(uint256 _round=round)\n  round++\n\ndef propose(address _tokenAddress, string _projectName, string _websiteUrl, string _logoUrl, string _whitepaperUrl, string _legalDocumentUrl, uint256 _icoStartDate, uint256 _icoEndDate, uint256 _icoRate, uint256 _totalRaised) payable: \n  require not contributions[address(_tokenAddress)].field_0\n  require block.timestamp < startTime + duration\n  require call.value >= hardCap\n  stor3[stor1][address(_tokenAddress)].field_0 = _tokenAddress\n  stor3[stor1][address(_tokenAddress)].field_256 = (2 * _projectName.length) + 1\n  ...  # Decompilation aborted, sorry: (\"decompilation didn't finish\",)\n\ndef refund(address investor): # not payable\n  require refundable[address(investor)] > 0\n  require block.timestamp < refundable[address(investor)]\n  contributions[address(investor)].field_0 = 0\n  require contributions[address(investor)].field_0 <= roundContribution[stor4[address(investor)].field_512]\n  roundContribution[stor4[address(investor)].field_512] -= contributions[address(investor)].field_0\n  call contributions[address(investor)].field_256 with:\n     value contributions[address(investor)].field_0 wei\n       gas 2300 * is_zero(value) wei\n  if not ext_call.success:\n      revert with ext_call.return_data[0 len return_data.size]\n  log TokenListingCancelled(address _tokenAddress=investor)\n\n.",
	"status": "1",
	"time_cost": 39.13924598693848,
	"usage": {
		"completion_tokens": 779,
		"prompt_tokens": 1008,
		"total_tokens": 1787
	}
}