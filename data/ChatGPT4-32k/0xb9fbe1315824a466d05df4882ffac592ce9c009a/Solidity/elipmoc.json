{
	"address": "0xb9fbe1315824a466d05df4882ffac592ce9c009a",
	"choices": [
		{
			"finish_reason": "stop",
			"index": 0,
			"message": {
				"content": "Below is the Solidity contract code equivalent to the provided EVM decompiled code:\n\n```solidity\npragma solidity >=0.6.8;\n\ncontract Contract {\n    uint256 private _round;\n    mapping(uint256 => uint256[]) private _proposals;\n    mapping(address => uint256[]) private _getContributions;\n    mapping(uint256 => uint256) private _roundContribution;\n    mapping(address => uint256) private _refundable;\n    uint256 private _startTime;\n    uint256 private _hardCap;\n    uint256 private _duration;\n    address private _owner;\n    address private _beneficiary;\n    \n    event TokenListed(uint256 indexed round, address indexed tokenAddress);\n    event RoundFinalized(uint256 indexed round);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event TokenListingCancelled(address indexed tokenAddress);\n    \n    constructor() public {\n        _owner = msg.sender;\n    }\n\n    function propose(address varg0, string memory varg1, string memory varg2, string memory varg3, \n        string memory varg4, string memory varg5, uint256 varg6, uint256 varg7, \n        uint256 varg8, uint256 varg9) public payable {\n        // implementation of propose function\n    }\n\n    function duration() public view returns(uint256) {\n        return _duration;\n    }\n\n    function round() public view returns(uint256) {\n        return _round;\n    }\n\n    function beneficiary() public view returns(address) {\n        return _beneficiary;\n    }\n\n    function getContributions(address varg0) public view returns(uint256) {\n        return _getContributions[varg0][0];\n    }\n\n    function kill() public {\n        require(msg.sender == _owner);\n        selfdestruct(msg.sender);\n    }\n\n    function roundContribution(uint256 varg0) public view returns(uint256) {\n        return _roundContribution[varg0];\n    }\n\n    function refundable(address varg0) public view returns(uint256) {\n        return _refundable[varg0];\n    }\n\n    function proposals(uint256 varg0, address varg1) public view returns(uint256) {\n        // implementation of proposals function\n    }\n    \n    function startTime() public view returns(uint256) {\n        return _startTime;\n    }\n\n    function owner() public view returns(address) {\n        return _owner;\n    }\n\n    function reset(uint256 varg0, uint256 varg1, uint256 varg2) public {\n        // implementation of reset function\n    }\n\n    function initialize(address varg0) public {\n        // implementation of initialize function\n    }\n\n    function proposalInfos(address varg0) public view returns(uint256) {\n        // implementation of proposalInfos function\n    }\n\n    function transferOwnership(address varg0) public {\n        require(msg.sender == _owner);\n        _owner = varg0;\n        emit OwnershipTransferred(msg.sender, varg0);\n    }\n\n    function setRefundable(address varg0, uint256 varg1) public {\n        // implementation of setRefundable function\n    }\n\n    function refund(address varg0) public {\n        // implementation of refund function\n    }\n\n    function hardCap() public view returns(uint256) {\n        return _hardCap;\n    }\n}\n```\n\nPlease note that EVM decompiled code does not provide the full functionality of the original Solidity code. The functionalities inside the functions are assumed and will need to be implemented according to the requirements.",
				"role": "assistant"
			}
		}
	],
	"created": 1698039057,
	"id": "chatcmpl-8Chof9pmUV3s17vJTFQ2CKxN8Gmdb",
	"input_format": "DecompiledCode",
	"ir": "// Decompiled at www.contract-library.com\n// 2021.08.26 08:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _round; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _proposals; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _getContributions; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _roundContribution; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _refundable; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _hardCap; // STORAGE[0x8]\nuint256 _duration; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _beneficiary; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nTokenListed(uint256, address);\nRoundFinalized(uint256);\nOwnershipTransferred(address, address);\nTokenListingCancelled(address);\n\nfunction propose(address varg0, string varg1, string varg2, string varg3, string varg4, string varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) public payable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length);\n    v2 = new bytes[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg3, (?).length);\n    v3 = new bytes[]((?).length);\n    CALLDATACOPY(v3.data, 36 + varg4, (?).length);\n    v4 = new bytes[]((?).length);\n    CALLDATACOPY(v4.data, 36 + varg5, (?).length);\n    require(_getContributions[varg0][0] == 0);\n    require(block.timestamp < _startTime + _duration);\n    require(msg.value >= _hardCap);\n    v5 = varg0;\n    _proposals[v5][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _proposals[v5][0x0];\n    v6 = v7 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _proposals[v5][1] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v7 + MEM[v0] > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][1] = MEM[v0] + MEM[v0] | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + (((!(0x1 & _proposals[v5][0x1]) << 8) - 1 & _proposals[v5][0x1]) >> 1) >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    v10 = v11 = 32 + v1;\n    if (31 < MEM[v1]) {\n        _proposals[v5][2] = 1 + (MEM[v1] + MEM[v1]);\n        if (MEM[v1]) {\n            while (v11 + MEM[v1] > v10) {\n                STORAGE[v12] = MEM[v10];\n                v10 += 32;\n                v12 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][2] = MEM[v1] + MEM[v1] | ~0xff & MEM[v11];\n    }\n    while (v13 + (31 + (((!(0x1 & _proposals[v5][0x2]) << 8) - 1 & _proposals[v5][0x2]) >> 1) >> 5) > v12) {\n        STORAGE[v12] = 0;\n        v12 += 1;\n    }\n    v14 = v15 = 32 + v2;\n    if (31 < MEM[v2]) {\n        _proposals[v5][3] = 1 + (MEM[v2] + MEM[v2]);\n        if (MEM[v2]) {\n            while (v15 + MEM[v2] > v14) {\n                STORAGE[v16] = MEM[v14];\n                v14 += 32;\n                v16 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][3] = MEM[v2] + MEM[v2] | ~0xff & MEM[v15];\n    }\n    while (v17 + (31 + (((!(0x1 & _proposals[v5][0x3]) << 8) - 1 & _proposals[v5][0x3]) >> 1) >> 5) > v16) {\n        STORAGE[v16] = 0;\n        v16 += 1;\n    }\n    v18 = v19 = 32 + v3;\n    if (31 < MEM[v3]) {\n        _proposals[v5][4] = 1 + (MEM[v3] + MEM[v3]);\n        if (MEM[v3]) {\n            while (v19 + MEM[v3] > v18) {\n                STORAGE[v20] = MEM[v18];\n                v18 += 32;\n                v20 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][4] = MEM[v3] + MEM[v3] | ~0xff & MEM[v19];\n    }\n    while (v21 + (31 + (((!(0x1 & _proposals[v5][0x4]) << 8) - 1 & _proposals[v5][0x4]) >> 1) >> 5) > v20) {\n        STORAGE[v20] = 0;\n        v20 += 1;\n    }\n    v22 = v23 = 32 + v4;\n    if (31 < MEM[v4]) {\n        _proposals[v5][5] = 1 + (MEM[v4] + MEM[v4]);\n        if (MEM[v4]) {\n            while (v23 + MEM[v4] > v22) {\n                STORAGE[v24] = MEM[v22];\n                v22 += 32;\n                v24 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][5] = MEM[v4] + MEM[v4] | ~0xff & MEM[v23];\n    }\n    while (v25 + (31 + (((!(0x1 & _proposals[v5][0x5]) << 8) - 1 & _proposals[v5][0x5]) >> 1) >> 5) > v24) {\n        STORAGE[v24] = 0;\n        v24 += 1;\n    }\n    _proposals[v5][6] = varg6;\n    _proposals[v5][7] = varg7;\n    _proposals[v5][8] = varg8;\n    _proposals[v5][9] = varg9;\n    MEM[64] = MEM[64] + 96;\n    _getContributions[varg0][0] = msg.value;\n    _getContributions[varg0][1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getContributions[varg0][0x1];\n    _getContributions[varg0][2] = _round;\n    assert(_getContributions[_round] + msg.value >= _getContributions[_round]);\n    _roundContribution[_round] = _getContributions[_round] + msg.value;\n    emit TokenListed(_round, varg0);\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction round() public nonPayable { \n    return _round;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction getContributions(address varg0) public nonPayable { \n    return _getContributions[varg0][0];\n}\n\nfunction kill() public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(_beneficiary);\n}\n\nfunction roundContribution(uint256 varg0) public nonPayable { \n    return _roundContribution[varg0];\n}\n\nfunction refundable(address varg0) public nonPayable { \n    return _refundable[varg0];\n}\n\nfunction proposals(uint256 varg0, address varg1) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _proposals[varg1][1] >> 8 << 8;\n        }\n    }\n    v4 = new bytes[](((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1);\n    v5 = v6 = v4.data;\n    if (((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) {\n            do {\n                MEM[v5] = STORAGE[v7];\n                v7 += 1;\n                v5 += 32;\n            } while (v6 + (((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) <= v5);\n        } else {\n            MEM[v6] = _proposals[varg1][2] >> 8 << 8;\n        }\n    }\n    v8 = new bytes[](((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1);\n    v9 = v10 = v8.data;\n    if (((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) {\n            do {\n                MEM[v9] = STORAGE[v11];\n                v11 += 1;\n                v9 += 32;\n            } while (v10 + (((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) <= v9);\n        } else {\n            MEM[v10] = _proposals[varg1][3] >> 8 << 8;\n        }\n    }\n    v12 = new bytes[](((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1);\n    v13 = v14 = v12.data;\n    if (((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) {\n            do {\n                MEM[v13] = STORAGE[v15];\n                v15 += 1;\n                v13 += 32;\n            } while (v14 + (((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) <= v13);\n        } else {\n            MEM[v14] = _proposals[varg1][4] >> 8 << 8;\n        }\n    }\n    v16 = new bytes[](((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1);\n    v17 = v18 = v16.data;\n    if (((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) {\n            do {\n                MEM[v17] = STORAGE[v19];\n                v19 += 1;\n                v17 += 32;\n            } while (v18 + (((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) <= v17);\n        } else {\n            MEM[v18] = _proposals[varg1][5] >> 8 << 8;\n        }\n    }\n    v20 = new array[](v0.length);\n    v21 = v22 = 0;\n    while (v21 < v0.length) {\n        MEM[v20.data + v21] = MEM[v0.data + v21];\n        v21 = v21 + 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v20.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v20.data - (0x1f & v0.length)];\n    }\n    v23 = new array[](v4.length);\n    v24 = v25 = 0;\n    while (v24 < v4.length) {\n        MEM[v23.data + v24] = MEM[v4.data + v24];\n        v24 = v24 + 32;\n    }\n    if (0x1f & v4.length) {\n        MEM[v4.length + v23.data - (0x1f & v4.length)] = ~(256 ** (32 - (0x1f & v4.length)) - 1) & MEM[v4.length + v23.data - (0x1f & v4.length)];\n    }\n    v26 = new array[](v8.length);\n    v27 = v28 = 0;\n    while (v27 < v8.length) {\n        MEM[v26.data + v27] = MEM[v8.data + v27];\n        v27 = v27 + 32;\n    }\n    if (0x1f & v8.length) {\n        MEM[v8.length + v26.data - (0x1f & v8.length)] = ~(256 ** (32 - (0x1f & v8.length)) - 1) & MEM[v8.length + v26.data - (0x1f & v8.length)];\n    }\n    v29 = new array[](v12.length);\n    v30 = v31 = 0;\n    while (v30 < v12.length) {\n        MEM[v29.data + v30] = MEM[v12.data + v30];\n        v30 = v30 + 32;\n    }\n    if (0x1f & v12.length) {\n        MEM[v12.length + v29.data - (0x1f & v12.length)] = ~(256 ** (32 - (0x1f & v12.length)) - 1) & MEM[v12.length + v29.data - (0x1f & v12.length)];\n    }\n    v32 = new array[](v16.length);\n    v33 = v34 = 0;\n    while (v33 < v16.length) {\n        MEM[v32.data + v33] = MEM[v16.data + v33];\n        v33 = v33 + 32;\n    }\n    v35 = v36 = v16.length + v32.data;\n    if (0x1f & v16.length) {\n        MEM[v36 - (0x1f & v16.length)] = ~(256 ** (32 - (0x1f & v16.length)) - 1) & MEM[v36 - (0x1f & v16.length)];\n    }\n    return address(_proposals[varg1][0]), v20, v23, v26, v29, v32, _proposals[varg1][6], _proposals[varg1][7], _proposals[varg1][8], _proposals[varg1][9];\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction reset(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(block.timestamp >= _startTime + _duration);\n    if (_round > 0) {\n        v0 = _beneficiary.call().value((address(this)).balance - _roundContribution[_round]).gas(!((address(this)).balance - _roundContribution[_round]) * 2300);\n        require(v0); // checks call status, propagates error data on error\n    }\n    _startTime = varg0;\n    _duration = varg1;\n    _hardCap = varg2;\n    emit RoundFinalized(_round);\n    _round = _round + 1;\n}\n\nfunction initialize(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _beneficiary = varg0;\n}\n\nfunction proposalInfos(address varg0) public nonPayable { \n    return _getContributions[varg0][0], address(_getContributions[varg0][1]), _getContributions[varg0][2];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction setRefundable(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _refundable[varg0] = varg1;\n}\n\nfunction refund(address varg0) public nonPayable { \n    v0 = v1 = _refundable[varg0] > 0;\n    if (v1) {\n        v0 = v2 = block.timestamp < _refundable[varg0];\n    }\n    require(v0);\n    _getContributions[varg0][0] = 0;\n    assert(_getContributions[varg0][0] <= _getContributions[_getContributions[varg0][2]]);\n    _getContributions[_getContributions[varg0][2]] = _getContributions[_getContributions[varg0][2]] - _getContributions[varg0][0];\n    v3 = address(_getContributions[address(address(varg0))][1]).call().value(_getContributions[varg0][0]).gas(!_getContributions[varg0][0] * 2300);\n    require(v3); // checks call status, propagates error data on error\n    emit TokenListingCancelled(varg0);\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xef845df == function_selector) {\n            propose(address,string,string,string,string,string,uint256,uint256,uint256,uint256);\n        } else if (0xfb5a6b4 == function_selector) {\n            duration();\n        } else if (0x146ca531 == function_selector) {\n            round();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x3f19d043 == function_selector) {\n            getContributions(address);\n        } else if (0x41c0e1b5 == function_selector) {\n            kill();\n        } else if (0x51dc78df == function_selector) {\n            roundContribution(uint256);\n        } else if (0x68ec0d99 == function_selector) {\n            refundable(address);\n        } else if (0x752430df == function_selector) {\n            proposals(uint256,address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa6801cbd == function_selector) {\n            reset(uint256,uint256,uint256);\n        } else if (0xc4d66de8 == function_selector) {\n            initialize(address);\n        } else if (0xc50c0d78 == function_selector) {\n            proposalInfos(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf54a2ddc == function_selector) {\n            setRefundable(address,uint256);\n        } else if (0xfa89401a == function_selector) {\n            refund(address);\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        }\n    }\n    fallback();\n}\n",
	"language": "Solidity",
	"messages": [
		{
			"content": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.",
			"role": "system"
		},
		{
			"content": "The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 08:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _round; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _proposals; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _getContributions; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _roundContribution; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _refundable; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _hardCap; // STORAGE[0x8]\nuint256 _duration; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _beneficiary; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nTokenListed(uint256, address);\nRoundFinalized(uint256);\nOwnershipTransferred(address, address);\nTokenListingCancelled(address);\n\nfunction propose(address varg0, string varg1, string varg2, string varg3, string varg4, string varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) public payable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length);\n    v2 = new bytes[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg3, (?).length);\n    v3 = new bytes[]((?).length);\n    CALLDATACOPY(v3.data, 36 + varg4, (?).length);\n    v4 = new bytes[]((?).length);\n    CALLDATACOPY(v4.data, 36 + varg5, (?).length);\n    require(_getContributions[varg0][0] == 0);\n    require(block.timestamp < _startTime + _duration);\n    require(msg.value >= _hardCap);\n    v5 = varg0;\n    _proposals[v5][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _proposals[v5][0x0];\n    v6 = v7 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _proposals[v5][1] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v7 + MEM[v0] > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][1] = MEM[v0] + MEM[v0] | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + (((!(0x1 & _proposals[v5][0x1]) << 8) - 1 & _proposals[v5][0x1]) >> 1) >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    v10 = v11 = 32 + v1;\n    if (31 < MEM[v1]) {\n        _proposals[v5][2] = 1 + (MEM[v1] + MEM[v1]);\n        if (MEM[v1]) {\n            while (v11 + MEM[v1] > v10) {\n                STORAGE[v12] = MEM[v10];\n                v10 += 32;\n                v12 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][2] = MEM[v1] + MEM[v1] | ~0xff & MEM[v11];\n    }\n    while (v13 + (31 + (((!(0x1 & _proposals[v5][0x2]) << 8) - 1 & _proposals[v5][0x2]) >> 1) >> 5) > v12) {\n        STORAGE[v12] = 0;\n        v12 += 1;\n    }\n    v14 = v15 = 32 + v2;\n    if (31 < MEM[v2]) {\n        _proposals[v5][3] = 1 + (MEM[v2] + MEM[v2]);\n        if (MEM[v2]) {\n            while (v15 + MEM[v2] > v14) {\n                STORAGE[v16] = MEM[v14];\n                v14 += 32;\n                v16 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][3] = MEM[v2] + MEM[v2] | ~0xff & MEM[v15];\n    }\n    while (v17 + (31 + (((!(0x1 & _proposals[v5][0x3]) << 8) - 1 & _proposals[v5][0x3]) >> 1) >> 5) > v16) {\n        STORAGE[v16] = 0;\n        v16 += 1;\n    }\n    v18 = v19 = 32 + v3;\n    if (31 < MEM[v3]) {\n        _proposals[v5][4] = 1 + (MEM[v3] + MEM[v3]);\n        if (MEM[v3]) {\n            while (v19 + MEM[v3] > v18) {\n                STORAGE[v20] = MEM[v18];\n                v18 += 32;\n                v20 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][4] = MEM[v3] + MEM[v3] | ~0xff & MEM[v19];\n    }\n    while (v21 + (31 + (((!(0x1 & _proposals[v5][0x4]) << 8) - 1 & _proposals[v5][0x4]) >> 1) >> 5) > v20) {\n        STORAGE[v20] = 0;\n        v20 += 1;\n    }\n    v22 = v23 = 32 + v4;\n    if (31 < MEM[v4]) {\n        _proposals[v5][5] = 1 + (MEM[v4] + MEM[v4]);\n        if (MEM[v4]) {\n            while (v23 + MEM[v4] > v22) {\n                STORAGE[v24] = MEM[v22];\n                v22 += 32;\n                v24 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][5] = MEM[v4] + MEM[v4] | ~0xff & MEM[v23];\n    }\n    while (v25 + (31 + (((!(0x1 & _proposals[v5][0x5]) << 8) - 1 & _proposals[v5][0x5]) >> 1) >> 5) > v24) {\n        STORAGE[v24] = 0;\n        v24 += 1;\n    }\n    _proposals[v5][6] = varg6;\n    _proposals[v5][7] = varg7;\n    _proposals[v5][8] = varg8;\n    _proposals[v5][9] = varg9;\n    MEM[64] = MEM[64] + 96;\n    _getContributions[varg0][0] = msg.value;\n    _getContributions[varg0][1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getContributions[varg0][0x1];\n    _getContributions[varg0][2] = _round;\n    assert(_getContributions[_round] + msg.value >= _getContributions[_round]);\n    _roundContribution[_round] = _getContributions[_round] + msg.value;\n    emit TokenListed(_round, varg0);\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction round() public nonPayable { \n    return _round;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction getContributions(address varg0) public nonPayable { \n    return _getContributions[varg0][0];\n}\n\nfunction kill() public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(_beneficiary);\n}\n\nfunction roundContribution(uint256 varg0) public nonPayable { \n    return _roundContribution[varg0];\n}\n\nfunction refundable(address varg0) public nonPayable { \n    return _refundable[varg0];\n}\n\nfunction proposals(uint256 varg0, address varg1) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _proposals[varg1][1] >> 8 << 8;\n        }\n    }\n    v4 = new bytes[](((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1);\n    v5 = v6 = v4.data;\n    if (((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) {\n            do {\n                MEM[v5] = STORAGE[v7];\n                v7 += 1;\n                v5 += 32;\n            } while (v6 + (((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) <= v5);\n        } else {\n            MEM[v6] = _proposals[varg1][2] >> 8 << 8;\n        }\n    }\n    v8 = new bytes[](((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1);\n    v9 = v10 = v8.data;\n    if (((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) {\n            do {\n                MEM[v9] = STORAGE[v11];\n                v11 += 1;\n                v9 += 32;\n            } while (v10 + (((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) <= v9);\n        } else {\n            MEM[v10] = _proposals[varg1][3] >> 8 << 8;\n        }\n    }\n    v12 = new bytes[](((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1);\n    v13 = v14 = v12.data;\n    if (((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) {\n            do {\n                MEM[v13] = STORAGE[v15];\n                v15 += 1;\n                v13 += 32;\n            } while (v14 + (((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) <= v13);\n        } else {\n            MEM[v14] = _proposals[varg1][4] >> 8 << 8;\n        }\n    }\n    v16 = new bytes[](((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1);\n    v17 = v18 = v16.data;\n    if (((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) {\n            do {\n                MEM[v17] = STORAGE[v19];\n                v19 += 1;\n                v17 += 32;\n            } while (v18 + (((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) <= v17);\n        } else {\n            MEM[v18] = _proposals[varg1][5] >> 8 << 8;\n        }\n    }\n    v20 = new array[](v0.length);\n    v21 = v22 = 0;\n    while (v21 < v0.length) {\n        MEM[v20.data + v21] = MEM[v0.data + v21];\n        v21 = v21 + 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v20.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v20.data - (0x1f & v0.length)];\n    }\n    v23 = new array[](v4.length);\n    v24 = v25 = 0;\n    while (v24 < v4.length) {\n        MEM[v23.data + v24] = MEM[v4.data + v24];\n        v24 = v24 + 32;\n    }\n    if (0x1f & v4.length) {\n        MEM[v4.length + v23.data - (0x1f & v4.length)] = ~(256 ** (32 - (0x1f & v4.length)) - 1) & MEM[v4.length + v23.data - (0x1f & v4.length)];\n    }\n    v26 = new array[](v8.length);\n    v27 = v28 = 0;\n    while (v27 < v8.length) {\n        MEM[v26.data + v27] = MEM[v8.data + v27];\n        v27 = v27 + 32;\n    }\n    if (0x1f & v8.length) {\n        MEM[v8.length + v26.data - (0x1f & v8.length)] = ~(256 ** (32 - (0x1f & v8.length)) - 1) & MEM[v8.length + v26.data - (0x1f & v8.length)];\n    }\n    v29 = new array[](v12.length);\n    v30 = v31 = 0;\n    while (v30 < v12.length) {\n        MEM[v29.data + v30] = MEM[v12.data + v30];\n        v30 = v30 + 32;\n    }\n    if (0x1f & v12.length) {\n        MEM[v12.length + v29.data - (0x1f & v12.length)] = ~(256 ** (32 - (0x1f & v12.length)) - 1) & MEM[v12.length + v29.data - (0x1f & v12.length)];\n    }\n    v32 = new array[](v16.length);\n    v33 = v34 = 0;\n    while (v33 < v16.length) {\n        MEM[v32.data + v33] = MEM[v16.data + v33];\n        v33 = v33 + 32;\n    }\n    v35 = v36 = v16.length + v32.data;\n    if (0x1f & v16.length) {\n        MEM[v36 - (0x1f & v16.length)] = ~(256 ** (32 - (0x1f & v16.length)) - 1) & MEM[v36 - (0x1f & v16.length)];\n    }\n    return address(_proposals[varg1][0]), v20, v23, v26, v29, v32, _proposals[varg1][6], _proposals[varg1][7], _proposals[varg1][8], _proposals[varg1][9];\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction reset(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(block.timestamp >= _startTime + _duration);\n    if (_round > 0) {\n        v0 = _beneficiary.call().value((address(this)).balance - _roundContribution[_round]).gas(!((address(this)).balance - _roundContribution[_round]) * 2300);\n        require(v0); // checks call status, propagates error data on error\n    }\n    _startTime = varg0;\n    _duration = varg1;\n    _hardCap = varg2;\n    emit RoundFinalized(_round);\n    _round = _round + 1;\n}\n\nfunction initialize(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _beneficiary = varg0;\n}\n\nfunction proposalInfos(address varg0) public nonPayable { \n    return _getContributions[varg0][0], address(_getContributions[varg0][1]), _getContributions[varg0][2];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction setRefundable(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _refundable[varg0] = varg1;\n}\n\nfunction refund(address varg0) public nonPayable { \n    v0 = v1 = _refundable[varg0] > 0;\n    if (v1) {\n        v0 = v2 = block.timestamp < _refundable[varg0];\n    }\n    require(v0);\n    _getContributions[varg0][0] = 0;\n    assert(_getContributions[varg0][0] <= _getContributions[_getContributions[varg0][2]]);\n    _getContributions[_getContributions[varg0][2]] = _getContributions[_getContributions[varg0][2]] - _getContributions[varg0][0];\n    v3 = address(_getContributions[address(address(varg0))][1]).call().value(_getContributions[varg0][0]).gas(!_getContributions[varg0][0] * 2300);\n    require(v3); // checks call status, propagates error data on error\n    emit TokenListingCancelled(varg0);\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xef845df == function_selector) {\n            propose(address,string,string,string,string,string,uint256,uint256,uint256,uint256);\n        } else if (0xfb5a6b4 == function_selector) {\n            duration();\n        } else if (0x146ca531 == function_selector) {\n            round();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x3f19d043 == function_selector) {\n            getContributions(address);\n        } else if (0x41c0e1b5 == function_selector) {\n            kill();\n        } else if (0x51dc78df == function_selector) {\n            roundContribution(uint256);\n        } else if (0x68ec0d99 == function_selector) {\n            refundable(address);\n        } else if (0x752430df == function_selector) {\n            proposals(uint256,address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa6801cbd == function_selector) {\n            reset(uint256,uint256,uint256);\n        } else if (0xc4d66de8 == function_selector) {\n            initialize(address);\n        } else if (0xc50c0d78 == function_selector) {\n            proposalInfos(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf54a2ddc == function_selector) {\n            setRefundable(address,uint256);\n        } else if (0xfa89401a == function_selector) {\n            refund(address);\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        }\n    }\n    fallback();\n}\n.",
			"role": "user"
		}
	],
	"model": "gpt-4-32k",
	"object": "chat.completion",
	"prompts": "You are an experienced smart contract developer that excels at Solidity program languages. Please write a contract code by the following decompiled code lifted from EVM Bytecode.The following is the decompiled code: // Decompiled at www.contract-library.com\n// 2021.08.26 08:24 UTC\n\n// Data structures and variables inferred from the use of storage instructions\nuint256 _round; // STORAGE[0x1]\nmapping (uint256 => [uint256]) _proposals; // STORAGE[0x3]\nmapping (uint256 => [uint256]) _getContributions; // STORAGE[0x4]\nmapping (uint256 => [uint256]) _roundContribution; // STORAGE[0x5]\nmapping (uint256 => [uint256]) _refundable; // STORAGE[0x6]\nuint256 _startTime; // STORAGE[0x7]\nuint256 _hardCap; // STORAGE[0x8]\nuint256 _duration; // STORAGE[0x9]\naddress _owner; // STORAGE[0x0] bytes 0 to 19\naddress _beneficiary; // STORAGE[0x2] bytes 0 to 19\n\n// Events\nTokenListed(uint256, address);\nRoundFinalized(uint256);\nOwnershipTransferred(address, address);\nTokenListingCancelled(address);\n\nfunction propose(address varg0, string varg1, string varg2, string varg3, string varg4, string varg5, uint256 varg6, uint256 varg7, uint256 varg8, uint256 varg9) public payable { \n    v0 = new bytes[]((?).length);\n    CALLDATACOPY(v0.data, 36 + varg1, (?).length);\n    v1 = new bytes[]((?).length);\n    CALLDATACOPY(v1.data, 36 + varg2, (?).length);\n    v2 = new bytes[]((?).length);\n    CALLDATACOPY(v2.data, 36 + varg3, (?).length);\n    v3 = new bytes[]((?).length);\n    CALLDATACOPY(v3.data, 36 + varg4, (?).length);\n    v4 = new bytes[]((?).length);\n    CALLDATACOPY(v4.data, 36 + varg5, (?).length);\n    require(_getContributions[varg0][0] == 0);\n    require(block.timestamp < _startTime + _duration);\n    require(msg.value >= _hardCap);\n    v5 = varg0;\n    _proposals[v5][0] = varg0 | ~0xffffffffffffffffffffffffffffffffffffffff & _proposals[v5][0x0];\n    v6 = v7 = 32 + v0;\n    if (31 < MEM[v0]) {\n        _proposals[v5][1] = 1 + (MEM[v0] + MEM[v0]);\n        if (MEM[v0]) {\n            while (v7 + MEM[v0] > v6) {\n                STORAGE[v8] = MEM[v6];\n                v6 += 32;\n                v8 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][1] = MEM[v0] + MEM[v0] | ~0xff & MEM[v7];\n    }\n    while (v9 + (31 + (((!(0x1 & _proposals[v5][0x1]) << 8) - 1 & _proposals[v5][0x1]) >> 1) >> 5) > v8) {\n        STORAGE[v8] = 0;\n        v8 += 1;\n    }\n    v10 = v11 = 32 + v1;\n    if (31 < MEM[v1]) {\n        _proposals[v5][2] = 1 + (MEM[v1] + MEM[v1]);\n        if (MEM[v1]) {\n            while (v11 + MEM[v1] > v10) {\n                STORAGE[v12] = MEM[v10];\n                v10 += 32;\n                v12 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][2] = MEM[v1] + MEM[v1] | ~0xff & MEM[v11];\n    }\n    while (v13 + (31 + (((!(0x1 & _proposals[v5][0x2]) << 8) - 1 & _proposals[v5][0x2]) >> 1) >> 5) > v12) {\n        STORAGE[v12] = 0;\n        v12 += 1;\n    }\n    v14 = v15 = 32 + v2;\n    if (31 < MEM[v2]) {\n        _proposals[v5][3] = 1 + (MEM[v2] + MEM[v2]);\n        if (MEM[v2]) {\n            while (v15 + MEM[v2] > v14) {\n                STORAGE[v16] = MEM[v14];\n                v14 += 32;\n                v16 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][3] = MEM[v2] + MEM[v2] | ~0xff & MEM[v15];\n    }\n    while (v17 + (31 + (((!(0x1 & _proposals[v5][0x3]) << 8) - 1 & _proposals[v5][0x3]) >> 1) >> 5) > v16) {\n        STORAGE[v16] = 0;\n        v16 += 1;\n    }\n    v18 = v19 = 32 + v3;\n    if (31 < MEM[v3]) {\n        _proposals[v5][4] = 1 + (MEM[v3] + MEM[v3]);\n        if (MEM[v3]) {\n            while (v19 + MEM[v3] > v18) {\n                STORAGE[v20] = MEM[v18];\n                v18 += 32;\n                v20 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][4] = MEM[v3] + MEM[v3] | ~0xff & MEM[v19];\n    }\n    while (v21 + (31 + (((!(0x1 & _proposals[v5][0x4]) << 8) - 1 & _proposals[v5][0x4]) >> 1) >> 5) > v20) {\n        STORAGE[v20] = 0;\n        v20 += 1;\n    }\n    v22 = v23 = 32 + v4;\n    if (31 < MEM[v4]) {\n        _proposals[v5][5] = 1 + (MEM[v4] + MEM[v4]);\n        if (MEM[v4]) {\n            while (v23 + MEM[v4] > v22) {\n                STORAGE[v24] = MEM[v22];\n                v22 += 32;\n                v24 += 1;\n            }\n        }\n    } else {\n        _proposals[v5][5] = MEM[v4] + MEM[v4] | ~0xff & MEM[v23];\n    }\n    while (v25 + (31 + (((!(0x1 & _proposals[v5][0x5]) << 8) - 1 & _proposals[v5][0x5]) >> 1) >> 5) > v24) {\n        STORAGE[v24] = 0;\n        v24 += 1;\n    }\n    _proposals[v5][6] = varg6;\n    _proposals[v5][7] = varg7;\n    _proposals[v5][8] = varg8;\n    _proposals[v5][9] = varg9;\n    MEM[64] = MEM[64] + 96;\n    _getContributions[varg0][0] = msg.value;\n    _getContributions[varg0][1] = msg.sender | ~0xffffffffffffffffffffffffffffffffffffffff & _getContributions[varg0][0x1];\n    _getContributions[varg0][2] = _round;\n    assert(_getContributions[_round] + msg.value >= _getContributions[_round]);\n    _roundContribution[_round] = _getContributions[_round] + msg.value;\n    emit TokenListed(_round, varg0);\n}\n\nfunction duration() public nonPayable { \n    return _duration;\n}\n\nfunction round() public nonPayable { \n    return _round;\n}\n\nfunction beneficiary() public nonPayable { \n    return _beneficiary;\n}\n\nfunction getContributions(address varg0) public nonPayable { \n    return _getContributions[varg0][0];\n}\n\nfunction kill() public nonPayable { \n    require(msg.sender == _owner);\n    selfdestruct(_beneficiary);\n}\n\nfunction roundContribution(uint256 varg0) public nonPayable { \n    return _roundContribution[varg0];\n}\n\nfunction refundable(address varg0) public nonPayable { \n    return _refundable[varg0];\n}\n\nfunction proposals(uint256 varg0, address varg1) public nonPayable { \n    v0 = new bytes[](((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1);\n    v1 = v2 = v0.data;\n    if (((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) {\n            do {\n                MEM[v1] = STORAGE[v3];\n                v3 += 1;\n                v1 += 32;\n            } while (v2 + (((!(0x1 & _proposals[varg1][0x1]) << 8) - 1 & _proposals[varg1][0x1]) >> 1) <= v1);\n        } else {\n            MEM[v2] = _proposals[varg1][1] >> 8 << 8;\n        }\n    }\n    v4 = new bytes[](((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1);\n    v5 = v6 = v4.data;\n    if (((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) {\n            do {\n                MEM[v5] = STORAGE[v7];\n                v7 += 1;\n                v5 += 32;\n            } while (v6 + (((!(0x1 & _proposals[varg1][0x2]) << 8) - 1 & _proposals[varg1][0x2]) >> 1) <= v5);\n        } else {\n            MEM[v6] = _proposals[varg1][2] >> 8 << 8;\n        }\n    }\n    v8 = new bytes[](((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1);\n    v9 = v10 = v8.data;\n    if (((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) {\n            do {\n                MEM[v9] = STORAGE[v11];\n                v11 += 1;\n                v9 += 32;\n            } while (v10 + (((!(0x1 & _proposals[varg1][0x3]) << 8) - 1 & _proposals[varg1][0x3]) >> 1) <= v9);\n        } else {\n            MEM[v10] = _proposals[varg1][3] >> 8 << 8;\n        }\n    }\n    v12 = new bytes[](((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1);\n    v13 = v14 = v12.data;\n    if (((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) {\n            do {\n                MEM[v13] = STORAGE[v15];\n                v15 += 1;\n                v13 += 32;\n            } while (v14 + (((!(0x1 & _proposals[varg1][0x4]) << 8) - 1 & _proposals[varg1][0x4]) >> 1) <= v13);\n        } else {\n            MEM[v14] = _proposals[varg1][4] >> 8 << 8;\n        }\n    }\n    v16 = new bytes[](((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1);\n    v17 = v18 = v16.data;\n    if (((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) {\n        if (31 < ((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) {\n            do {\n                MEM[v17] = STORAGE[v19];\n                v19 += 1;\n                v17 += 32;\n            } while (v18 + (((!(0x1 & _proposals[varg1][0x5]) << 8) - 1 & _proposals[varg1][0x5]) >> 1) <= v17);\n        } else {\n            MEM[v18] = _proposals[varg1][5] >> 8 << 8;\n        }\n    }\n    v20 = new array[](v0.length);\n    v21 = v22 = 0;\n    while (v21 < v0.length) {\n        MEM[v20.data + v21] = MEM[v0.data + v21];\n        v21 = v21 + 32;\n    }\n    if (0x1f & v0.length) {\n        MEM[v0.length + v20.data - (0x1f & v0.length)] = ~(256 ** (32 - (0x1f & v0.length)) - 1) & MEM[v0.length + v20.data - (0x1f & v0.length)];\n    }\n    v23 = new array[](v4.length);\n    v24 = v25 = 0;\n    while (v24 < v4.length) {\n        MEM[v23.data + v24] = MEM[v4.data + v24];\n        v24 = v24 + 32;\n    }\n    if (0x1f & v4.length) {\n        MEM[v4.length + v23.data - (0x1f & v4.length)] = ~(256 ** (32 - (0x1f & v4.length)) - 1) & MEM[v4.length + v23.data - (0x1f & v4.length)];\n    }\n    v26 = new array[](v8.length);\n    v27 = v28 = 0;\n    while (v27 < v8.length) {\n        MEM[v26.data + v27] = MEM[v8.data + v27];\n        v27 = v27 + 32;\n    }\n    if (0x1f & v8.length) {\n        MEM[v8.length + v26.data - (0x1f & v8.length)] = ~(256 ** (32 - (0x1f & v8.length)) - 1) & MEM[v8.length + v26.data - (0x1f & v8.length)];\n    }\n    v29 = new array[](v12.length);\n    v30 = v31 = 0;\n    while (v30 < v12.length) {\n        MEM[v29.data + v30] = MEM[v12.data + v30];\n        v30 = v30 + 32;\n    }\n    if (0x1f & v12.length) {\n        MEM[v12.length + v29.data - (0x1f & v12.length)] = ~(256 ** (32 - (0x1f & v12.length)) - 1) & MEM[v12.length + v29.data - (0x1f & v12.length)];\n    }\n    v32 = new array[](v16.length);\n    v33 = v34 = 0;\n    while (v33 < v16.length) {\n        MEM[v32.data + v33] = MEM[v16.data + v33];\n        v33 = v33 + 32;\n    }\n    v35 = v36 = v16.length + v32.data;\n    if (0x1f & v16.length) {\n        MEM[v36 - (0x1f & v16.length)] = ~(256 ** (32 - (0x1f & v16.length)) - 1) & MEM[v36 - (0x1f & v16.length)];\n    }\n    return address(_proposals[varg1][0]), v20, v23, v26, v29, v32, _proposals[varg1][6], _proposals[varg1][7], _proposals[varg1][8], _proposals[varg1][9];\n}\n\nfunction startTime() public nonPayable { \n    return _startTime;\n}\n\nfunction owner() public nonPayable { \n    return _owner;\n}\n\nfunction reset(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { \n    require(msg.sender == _owner);\n    require(block.timestamp >= _startTime + _duration);\n    if (_round > 0) {\n        v0 = _beneficiary.call().value((address(this)).balance - _roundContribution[_round]).gas(!((address(this)).balance - _roundContribution[_round]) * 2300);\n        require(v0); // checks call status, propagates error data on error\n    }\n    _startTime = varg0;\n    _duration = varg1;\n    _hardCap = varg2;\n    emit RoundFinalized(_round);\n    _round = _round + 1;\n}\n\nfunction initialize(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    _beneficiary = varg0;\n}\n\nfunction proposalInfos(address varg0) public nonPayable { \n    return _getContributions[varg0][0], address(_getContributions[varg0][1]), _getContributions[varg0][2];\n}\n\nfunction transferOwnership(address varg0) public nonPayable { \n    require(msg.sender == _owner);\n    require(varg0 != 0);\n    emit OwnershipTransferred(_owner, varg0);\n    _owner = varg0;\n}\n\nfunction setRefundable(address varg0, uint256 varg1) public nonPayable { \n    require(msg.sender == _owner);\n    _refundable[varg0] = varg1;\n}\n\nfunction refund(address varg0) public nonPayable { \n    v0 = v1 = _refundable[varg0] > 0;\n    if (v1) {\n        v0 = v2 = block.timestamp < _refundable[varg0];\n    }\n    require(v0);\n    _getContributions[varg0][0] = 0;\n    assert(_getContributions[varg0][0] <= _getContributions[_getContributions[varg0][2]]);\n    _getContributions[_getContributions[varg0][2]] = _getContributions[_getContributions[varg0][2]] - _getContributions[varg0][0];\n    v3 = address(_getContributions[address(address(varg0))][1]).call().value(_getContributions[varg0][0]).gas(!_getContributions[varg0][0] * 2300);\n    require(v3); // checks call status, propagates error data on error\n    emit TokenListingCancelled(varg0);\n}\n\nfunction hardCap() public nonPayable { \n    return _hardCap;\n}\n\nfunction fallback() public payable { \n    revert();\n}\n\n// Note: The function selector is not present in the original solidity code.\n// However, we display it for the sake of completeness.\n\nfunction __function_selector__(uint32 function_selector) public payable { \n    MEM[64] = 128;\n    if (msg.data.length >= 4) {\n        if (0xef845df == function_selector) {\n            propose(address,string,string,string,string,string,uint256,uint256,uint256,uint256);\n        } else if (0xfb5a6b4 == function_selector) {\n            duration();\n        } else if (0x146ca531 == function_selector) {\n            round();\n        } else if (0x38af3eed == function_selector) {\n            beneficiary();\n        } else if (0x3f19d043 == function_selector) {\n            getContributions(address);\n        } else if (0x41c0e1b5 == function_selector) {\n            kill();\n        } else if (0x51dc78df == function_selector) {\n            roundContribution(uint256);\n        } else if (0x68ec0d99 == function_selector) {\n            refundable(address);\n        } else if (0x752430df == function_selector) {\n            proposals(uint256,address);\n        } else if (0x78e97925 == function_selector) {\n            startTime();\n        } else if (0x8da5cb5b == function_selector) {\n            owner();\n        } else if (0xa6801cbd == function_selector) {\n            reset(uint256,uint256,uint256);\n        } else if (0xc4d66de8 == function_selector) {\n            initialize(address);\n        } else if (0xc50c0d78 == function_selector) {\n            proposalInfos(address);\n        } else if (0xf2fde38b == function_selector) {\n            transferOwnership(address);\n        } else if (0xf54a2ddc == function_selector) {\n            setRefundable(address,uint256);\n        } else if (0xfa89401a == function_selector) {\n            refund(address);\n        } else if (0xfb86a404 == function_selector) {\n            hardCap();\n        }\n    }\n    fallback();\n}\n.",
	"status": "1",
	"time_cost": 48.40058922767639,
	"usage": {
		"completion_tokens": 732,
		"prompt_tokens": 5142,
		"total_tokens": 5874
	}
}